This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
App.css
App.jsx
assets/react.svg
components/auth/AuthScreen.jsx
components/auth/index.js
components/auth/Login.jsx
components/auth/Register.jsx
components/CommandBar.jsx
components/EmptyState.jsx
components/WindowManager.jsx
components/windows/AudioWindow.jsx
components/windows/EditorWindow.jsx
components/windows/ExplorerWindow.css
components/windows/ExplorerWindow.jsx
components/windows/imageWindow.jsx
components/windows/index.js
components/windows/PreviewWindow.jsx
components/windows/TerminalWindow.jsx
config/api.js
context/AuthContext.jsx
context/WindowStateContext.jsx
hocs/withCommandHandling.jsx
hocs/withWindowState.jsx
hooks/useForceUpdate.js
hooks/useKeyboardShortcuts.js
hooks/useWindowManager.js
index.html
main.jsx
models/Node.js
styles.css
styles/main.css
utils/constants.js
utils/treeUtils.js
utils/windowSizeConstants.js
utils/windowTypes.js
utils/windowUtils.js

================================================================
Files
================================================================

================
File: App.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

#root {
  width: 100%;
  height: 100%;
}

================
File: App.jsx
================
import React from 'react';
import { WindowManager } from './components/WindowManager';
import { CommandBar } from './components/CommandBar';
import { EmptyState } from './components/EmptyState';
import { AuthScreen } from './components/auth';
import { useWindowManager } from './hooks/useWindowManager';
import { useKeyboardShortcuts } from './hooks/useKeyboardShortcuts';
import { useAuth } from './context/AuthContext';
import { WINDOW_CONTENT } from './utils/windowTypes';

/**
 * Main application component that composes our window management system.
 * This component is intentionally kept simple, delegating most functionality
 * to specialized components and hooks.
 */
function App() {
  const { isAuthenticated, loading, user, logout } = useAuth();
  
  // Call all hooks at the top level, before any conditional returns
  const {
    rootNode,
    activeNodeId,
    setActiveNodeId,
    createNewWindow,
    splitWindow,
    closeWindow,
    transformWindow,
    handleCommand,
    handleResizeStart,
    handleResizeMove,
    handleResizeEnd,
    hasActiveWindow,
    hasRootNode,
    currentWorkspaceIndex,
    switchWorkspace,
    isResizeMode,
    setIsResizeMode,
    resizeActiveWindow
  } = useWindowManager();

  // Set up keyboard shortcuts - always call this hook, even if we'll return early
  useKeyboardShortcuts({
    onSplitVertical: () => splitWindow(activeNodeId, 'vertical'),
    onSplitHorizontal: () => splitWindow(activeNodeId, 'horizontal'),
    onClose: () => closeWindow(activeNodeId),
    createNewWindow,
    hasActiveWindow,
    hasRootNode,
    isResizeMode,
    setIsResizeMode,
    resizeActiveWindow
  });
  
  // If authentication is still loading, show a loading screen
  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-stone-900">
        <div className="text-teal-500 text-2xl font-mono">Loading...</div>
      </div>
    );
  }
  
  // If not authenticated, show the auth screen
  if (!isAuthenticated) {
    return <AuthScreen />;
  }

  // Define component to render based on whether we have a root node
  const renderContent = () => {
    if (!rootNode) {
      return <EmptyState />;
    }

    // Render the window tree with all necessary props
    return (
      <WindowTreeRenderer
        node={rootNode}
        activeNodeId={activeNodeId}
        setActiveNodeId={setActiveNodeId}
        transformWindow={transformWindow}
        onResizeStart={handleResizeStart}
        onResizeMove={handleResizeMove}
        onResizeEnd={handleResizeEnd}
        isResizeMode={isResizeMode} // Pass isResizeMode to WindowTreeRenderer
      />
    );
  };

  return (
    <div className="w-full h-screen flex flex-col">
      {/* Global command bar with user info */}
      <div className="flex items-center">
        <CommandBar 
          onCommand={handleCommand}
          currentWorkspaceIndex={currentWorkspaceIndex}
          switchWorkspace={switchWorkspace}
        />
        
        {/* User info and logout */}
        <div className="flex items-center border-l border-stone-600 ml-2 pl-2">
          <span className="text-white text-sm font-mono mr-2">
            {user?.username || 'User'}
          </span>
          <button 
            onClick={logout}
            className="bg-stone-700 hover:bg-stone-600 text-white text-sm px-2 py-1 rounded"
          >
            Logout
          </button>
        </div>
      </div>
      
      {/* Main content area */}
      <div className="flex-1 relative">
        {renderContent()}
      </div>
    </div>
  );
}

/**
 * Renders the window tree recursively. This component is kept within App.jsx
 * since it's tightly coupled with the WindowManager's functionality.
 */
const WindowTreeRenderer = ({
  node,
  depth = 0,
  available = { x: 0, y: 0, width: 100, height: 100 },
  activeNodeId,
  setActiveNodeId,
  transformWindow,
  onResizeStart,
  onResizeMove,
  onResizeEnd,
  isResizeMode // Add isResizeMode prop
}) => {
  if (node.type === 'window') {
    const windowContent = WINDOW_CONTENT[node.windowType];
    const Component = windowContent.component;
    const isActive = node.id === activeNodeId;

    return (
      <div
        className={`absolute overflow-hidden border-2 ${
          isActive 
            ? isResizeMode 
              ? 'border-yellow-500' 
              : 'border-teal-500'
            : 'border-stone-600'
        }`}
        style={{
          left: `${available.x}%`,
          top: `${available.y}%`,
          width: `${available.width}%`,
          height: `${available.height}%`,
        }}
        onClick={() => setActiveNodeId(node.id)}
      >
        <Component
          key={`window-${node.id}-${node.windowType}`}
          isActive={isActive}
          nodeId={node.id}
          transformWindow={transformWindow}
        />
      </div>
    );
  }

  // Handle split nodes...
  let firstDimensions, secondDimensions;
  if (node.direction === 'horizontal') {
    firstDimensions = {
      x: available.x,
      y: available.y,
      width: available.width * node.splitRatio,
      height: available.height
    };
    secondDimensions = {
      x: available.x + (available.width * node.splitRatio),
      y: available.y,
      width: available.width * (1 - node.splitRatio),
      height: available.height
    };
  } else {
    firstDimensions = {
      x: available.x,
      y: available.y,
      width: available.width,
      height: available.height * node.splitRatio
    };
    secondDimensions = {
      x: available.x,
      y: available.y + (available.height * node.splitRatio),
      width: available.width,
      height: available.height * (1 - node.splitRatio)
    };
  }

  return (
    <>
      <WindowTreeRenderer
        node={node.first}
        depth={depth + 1}
        available={firstDimensions}
        activeNodeId={activeNodeId}
        setActiveNodeId={setActiveNodeId}
        transformWindow={transformWindow}
        onResizeStart={onResizeStart}
        onResizeMove={onResizeMove}
        onResizeEnd={onResizeEnd}
        isResizeMode={isResizeMode} // Pass down isResizeMode
      />
      
      <div
        className={`absolute z-10 ${
          node.direction === 'horizontal' 
            ? 'w-1 cursor-col-resize hover:bg-teal-500' 
            : 'h-1 cursor-row-resize hover:bg-teal-500'
        }`}
        style={{
          left: node.direction === 'horizontal' ? `${available.x + (available.width * node.splitRatio)}%` : `${available.x}%`,
          top: node.direction === 'horizontal' ? `${available.y}%` : `${available.y + (available.height * node.splitRatio)}%`,
          height: node.direction === 'horizontal' ? `${available.height}%` : '2px',
          width: node.direction === 'horizontal' ? '2px' : `${available.width}%`,
        }}
        onMouseDown={(e) => onResizeStart(e, node)}
      />
      
      <WindowTreeRenderer
        node={node.second}
        depth={depth + 1}
        available={secondDimensions}
        activeNodeId={activeNodeId}
        setActiveNodeId={setActiveNodeId}
        transformWindow={transformWindow}
        onResizeStart={onResizeStart}
        onResizeMove={onResizeMove}
        onResizeEnd={onResizeEnd}
        isResizeMode={isResizeMode} // Pass down isResizeMode
      />
    </>
  );
};

export default App;

================
File: assets/react.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================
File: components/auth/AuthScreen.jsx
================
import React from 'react';
import { Login } from './Login';

export function AuthScreen() {
  return <Login />;
}

================
File: components/auth/index.js
================
export { AuthScreen } from './AuthScreen';
export { Login } from './Login';

================
File: components/auth/Login.jsx
================
import React, { useState } from 'react';
import { useAuth } from '../../context/AuthContext';

export function Login() {
  const { login, error, clearError, loading } = useAuth();
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = async (e) => {
    e.preventDefault();
    clearError();
    await login(username, password);
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-stone-900">
      <div className="bg-stone-800 p-8 rounded-lg shadow-lg w-full max-w-md">
        <h2 className="text-2xl font-bold text-teal-500 mb-6 text-center">Login to Window Manager</h2>
        
        {error && (
          <div className="bg-red-900 text-white p-3 rounded mb-4">
            {error}
          </div>
        )}
        
        
        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label className="block text-stone-300 mb-2 font-mono text-sm" htmlFor="username">
              Username
            </label>
            <input
              id="username"
              type="text"
              className="w-full p-2 rounded bg-stone-700 text-white border border-stone-600 focus:border-teal-500 focus:outline-none font-mono text-sm"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              required
            />
          </div>
          
          <div className="mb-6">
            <label className="block text-stone-300 mb-2 font-mono text-sm" htmlFor="password">
              Password
            </label>
            <input
              id="password"
              type="password"
              className="w-full p-2 rounded bg-stone-700 text-white border border-stone-600 focus:border-teal-500 focus:outline-none font-mono text-sm"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
          </div>
          
          <button
            type="submit"
            className="w-full bg-teal-600 hover:bg-teal-700 text-white font-mono text-sm py-2 px-4 rounded focus:outline-none focus:shadow-outline"
            disabled={loading}
          >
            {loading ? 'Logging in...' : 'Login'}
          </button>
        </form>
        
        <div className="mt-4 text-center">
          <p className="text-stone-400 text-sm font-mono">
            Contact administrator if you need an account
          </p>
        </div>
      </div>
    </div>
  );
}

================
File: components/auth/Register.jsx
================
import React, { useState } from 'react';
import { useAuth } from '../../context/AuthContext';

export function Register({ onSwitchToLogin }) {
  const { register, error, clearError, loading } = useAuth();
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [passwordError, setPasswordError] = useState('');
  const [success, setSuccess] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    clearError();
    setPasswordError('');
    
    // Validate passwords match
    if (password !== confirmPassword) {
      setPasswordError('Passwords do not match');
      return;
    }
    
    // Validate password strength
    if (password.length < 8) {
      setPasswordError('Password must be at least 8 characters long');
      return;
    }
    
    const result = await register(username, email, password);
    if (result.success) {
      setSuccess(true);
      // Reset form
      setUsername('');
      setEmail('');
      setPassword('');
      setConfirmPassword('');
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-900">
      <div className="bg-gray-800 p-8 rounded-lg shadow-lg w-full max-w-md">
        <h2 className="text-2xl font-bold text-teal-500 mb-6 text-center">Create an Account</h2>
        
        {error && (
          <div className="bg-red-900 text-white p-3 rounded mb-4">
            {error}
          </div>
        )}
        
        {passwordError && (
          <div className="bg-red-900 text-white p-3 rounded mb-4">
            {passwordError}
          </div>
        )}
        
        {success && (
          <div className="bg-green-900 text-white p-3 rounded mb-4">
            Registration successful! You can now login.
          </div>
        )}
        
        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label className="block text-gray-300 mb-2" htmlFor="username">
              Username
            </label>
            <input
              id="username"
              type="text"
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:border-teal-500 focus:outline-none"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              required
            />
          </div>
          
          <div className="mb-4">
            <label className="block text-gray-300 mb-2" htmlFor="email">
              Email
            </label>
            <input
              id="email"
              type="email"
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:border-teal-500 focus:outline-none"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
            />
          </div>
          
          <div className="mb-4">
            <label className="block text-gray-300 mb-2" htmlFor="password">
              Password
            </label>
            <input
              id="password"
              type="password"
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:border-teal-500 focus:outline-none"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
            <p className="text-gray-400 text-xs mt-1">Must be at least 8 characters long</p>
          </div>
          
          <div className="mb-6">
            <label className="block text-gray-300 mb-2" htmlFor="confirmPassword">
              Confirm Password
            </label>
            <input
              id="confirmPassword"
              type="password"
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:border-teal-500 focus:outline-none"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              required
            />
          </div>
          
          <button
            type="submit"
            className="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
            disabled={loading}
          >
            {loading ? 'Registering...' : 'Register'}
          </button>
        </form>
        
        <div className="mt-4 text-center">
          <button
            onClick={onSwitchToLogin}
            className="text-teal-400 hover:text-teal-300 text-sm"
          >
            Already have an account? Login
          </button>
        </div>
      </div>
    </div>
  );
}

================
File: components/CommandBar.jsx
================
import React, { useState, useEffect, useRef } from 'react';

export const CommandBar = ({ 
  onCommand, 
  currentWorkspaceIndex = 0,
  switchWorkspace
}) => {
  console.log('CommandBar render, currentWorkspaceIndex:', currentWorkspaceIndex);
  const [command, setCommand] = useState('');
  const inputRef = useRef(null);

  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && command.trim()) {
      onCommand(command.trim());
      setCommand('');
    }
  };

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.key === '/' && document.activeElement !== inputRef.current) {
        e.preventDefault();
        inputRef.current?.focus();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, []);

  return (
    <div className="w-full bg-stone-800 p-2 flex items-center gap-2">
      <div className="flex gap-2 items-center pr-2 border-r border-stone-600">
        <div className={`rounded-full cursor-pointer ${currentWorkspaceIndex === 0 ? 'w-3 h-3 bg-teal-400' : 'w-2 h-2 bg-stone-600 hover:bg-stone-500'}`} onClick={() => typeof switchWorkspace === 'function' && switchWorkspace(0)} />
        <div className={`rounded-full cursor-pointer ${currentWorkspaceIndex === 1 ? 'w-3 h-3 bg-teal-400' : 'w-2 h-2 bg-stone-600 hover:bg-stone-500'}`} onClick={() => typeof switchWorkspace === 'function' && switchWorkspace(1)} />
        <div className={`rounded-full cursor-pointer ${currentWorkspaceIndex === 2 ? 'w-3 h-3 bg-teal-400' : 'w-2 h-2 bg-stone-600 hover:bg-stone-500'}`} onClick={() => typeof switchWorkspace === 'function' && switchWorkspace(2)} />
        <div className={`rounded-full cursor-pointer ${currentWorkspaceIndex === 3 ? 'w-3 h-3 bg-teal-400' : 'w-2 h-2 bg-stone-600 hover:bg-stone-500'}`} onClick={() => typeof switchWorkspace === 'function' && switchWorkspace(3)} />
      </div>
      <span className="text-gray-400 text-sm font-mono">$</span>
      <input
        ref={inputRef}
        type="text"
        value={command}
        onChange={(e) => setCommand(e.target.value)} 
        onKeyDown={handleKeyDown}
        placeholder="Press '/' to focus"
        className="flex-1 bg-stone-700 text-white px-4 py-1 rounded text-sm font-mono focus:outline-none focus:ring-2 focus:ring-blue-500"
      />
    </div>
  );
};

export default CommandBar;

================
File: components/EmptyState.jsx
================
import React from 'react';

export const EmptyState = () => (
  <div className="absolute inset-0 flex items-center justify-center bg-stone-950">
    <div className="text-center">
      <h2 className="text-xl font-semibold text-teal-400 mb-4">SLUMNET</h2>
      <p className="text-teal-400 mb-4">Bub boils the seed!</p>
      <div className="text-teal-50 bg-stone-950 p-2 font-mono text-sm">
        <p>Keyboard shortcuts:</p>
        <p>Ctrl+Enter - Create/Split Vertical</p>
        <p>Ctrl+Shift+Enter - Split Horizontal</p>
        <p>Ctrl+Backspace - Close Window</p>
      </div>
    </div>
  </div>
);

export default EmptyState;

================
File: components/WindowManager.jsx
================
import React, { useState, useCallback, useEffect } from 'react';
import { WINDOW_CONTENT } from '../utils/windowTypes';
import { getWindowBounds } from '../utils/windowUtils';
import { useWindowManager } from '../hooks/useWindowManager';
import { useKeyboardShortcuts } from '../hooks/useKeyboardShortcuts';
import { CommandBar } from './CommandBar';
import EmptyState from './EmptyState';

export const WindowManager = ({ defaultLayout = null }) => {
  const [dragState, setDragState] = useState(null);
  const [notification, setNotification] = useState(null);
  const [flashingWindowIds, setFlashingWindowIds] = useState(new Set());
  
  // Function to flash a window's border red
  const flashWindowBorder = useCallback((windowId) => {
    setFlashingWindowIds(prev => {
      const newSet = new Set(prev);
      newSet.add(windowId);
      return newSet;
    });
    
    // Remove the window from flashing state after 500ms
    setTimeout(() => {
      setFlashingWindowIds(prev => {
        const newSet = new Set(prev);
        newSet.delete(windowId);
        return newSet;
      });
    }, 500);
  }, []);

  const {
    rootNode,
    activeNodeId,
    setActiveNodeId,
    terminalStates,
    updateTerminalState,
    splitWindow,
    createNewWindow,
    closeWindow,
    transformWindow,
    currentWorkspaceIndex,
    workspaceCount,
    switchWorkspace,
    isResizeMode,
    setIsResizeMode,
    resizeActiveWindow
  } = useWindowManager({ 
    defaultLayout,
    onFlashBorder: flashWindowBorder
  });
  
  // Override window.alert to use our notification system
  useEffect(() => {
    const originalAlert = window.alert;
    window.alert = (message) => {
      console.log('Alert:', message);
      
      // If the message is about splitting or creating windows, flash the active window border
      if (message.includes('split') || message.includes('create')) {
        if (activeNodeId) {
          flashWindowBorder(activeNodeId);
        }
      } else {
        // For other alerts, show the notification
        setNotification(message);
        setTimeout(() => setNotification(null), 3000); // Hide after 3 seconds
      }
    };
    
    return () => {
      window.alert = originalAlert;
    };
  }, [activeNodeId, flashWindowBorder]);

  // Add keyboard shortcuts
  useKeyboardShortcuts({
    onSplitVertical: () => splitWindow(activeNodeId, 'vertical'),
    onSplitHorizontal: () => splitWindow(activeNodeId, 'horizontal'),
    onClose: () => closeWindow(activeNodeId),
    createNewWindow,
    hasActiveWindow: Boolean(activeNodeId),
    hasRootNode: Boolean(rootNode),
    isResizeMode,
    setIsResizeMode: (mode) => setIsResizeMode(mode),
    resizeActiveWindow: (direction) => resizeActiveWindow(direction)
  });

  // Command handling for terminal
  const handleCommand = useCallback((command) => {
    const parts = command.split(' ');
    const cmd = parts[0].toLowerCase();

    switch (cmd) {
      case 'split':
        if (activeNodeId) {
          const direction = parts[1] === 'vertical' ? 'vertical' : 'horizontal';
          splitWindow(activeNodeId, direction);
        }
        break;
      case 'close':
        if (activeNodeId) {
          closeWindow(activeNodeId);
        }
        break;
    }
  }, [activeNodeId, splitWindow, closeWindow]);

  // Resize handling
  const handleResizeStart = useCallback((e, split) => {
    e.preventDefault();
    e.stopPropagation();
    const rect = e.currentTarget.getBoundingClientRect();
    setDragState({
      split,
      initialPos: {
        x: e.clientX,
        y: e.clientY
      },
      initialRatio: split.splitRatio
    });
  }, []);

  // Helper function to convert percentage-based bounds to pixel dimensions
  const calculatePixelDimensions = useCallback((bounds) => {
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    
    return {
      width: (bounds.width / 100) * windowWidth,
      height: (bounds.height / 100) * windowHeight
    };
  }, []);
  
  // Helper function to check if a window tree would have any windows smaller than the minimum size
  const hasWindowsBelowMinSize = useCallback((root) => {
    if (!root) return false;
    
    // Import constants directly here to avoid dependency issues
    const MIN_WINDOW_WIDTH_PX = 300;
    const MIN_WINDOW_HEIGHT_PX = 200;
    
    // Calculate the bounds of all windows
    const allWindows = getWindowBounds(root);
    
    // Check if any window would be smaller than the minimum size
    return allWindows.some(window => {
      const pixelDimensions = calculatePixelDimensions(window.bounds);
      const isTooSmall = pixelDimensions.width < MIN_WINDOW_WIDTH_PX || 
                         pixelDimensions.height < MIN_WINDOW_HEIGHT_PX;
      
      if (isTooSmall) {
        console.log('Window too small:', window.id);
        console.log('Dimensions:', pixelDimensions);
      }
      
      return isTooSmall;
    });
  }, [calculatePixelDimensions]);

  const handleResizeMove = useCallback((e) => {
    if (!dragState) return;

    const { split, initialPos, initialRatio } = dragState;
    const delta = split.direction === 'horizontal' 
      ? (e.clientX - initialPos.x) / window.innerWidth 
      : (e.clientY - initialPos.y) / window.innerHeight;

    const newRatio = Math.max(0.1, Math.min(0.9, initialRatio + delta));
    
    // Store the original ratio
    const originalRatio = split.splitRatio;
    
    // Apply the new ratio
    split.splitRatio = newRatio;
    
    // Check if this would result in windows that are too small, but don't block the resize
    if (hasWindowsBelowMinSize(rootNode)) {
      console.log('Windows are below minimum size, but resize is allowed');
    }
    
    // If we get here, the resize is allowed
    // Force a re-render
    setDragState(prev => ({ ...prev }));
  }, [dragState, rootNode, hasWindowsBelowMinSize, activeNodeId, flashWindowBorder]);

  const handleResizeEnd = useCallback(() => {
    setDragState(null);
  }, []);

  useEffect(() => {
    if (dragState) {
      window.addEventListener('mousemove', handleResizeMove);
      window.addEventListener('mouseup', handleResizeEnd);
      return () => {
        window.removeEventListener('mousemove', handleResizeMove);
        window.removeEventListener('mouseup', handleResizeEnd);
      };
    }
  }, [dragState, handleResizeMove, handleResizeEnd]);

  // Window tree renderer
  const WindowTreeRenderer = ({ node, depth = 0, available = { x: 0, y: 0, width: 100, height: 100 } }) => {
    if (!node) return null;

    if (node.type === 'window') {
      const windowContent = WINDOW_CONTENT[node.windowType];
      if (!windowContent) {
        console.error('No window content found for type:', node.windowType);
        return null;
      }
      const Component = windowContent.component;
      const isActive = node.id === activeNodeId;
  
      // Check if this window is currently flashing
      const isFlashing = flashingWindowIds.has(node.id);
      
      return (
        <div
          className={`absolute overflow-hidden border-2 ${
            isFlashing ? 'border-red-600' : 
            isActive ? (isResizeMode ? 'border-yellow-500' : 'border-teal-500') : 'border-stone-600'
          } ${isFlashing ? 'animate-pulse' : ''}`}
          style={{
            left: `${available.x}%`,
            top: `${available.y}%`,
            width: `${available.width}%`,
            height: `${available.height}%`,
            transition: 'border-color 0.2s ease-in-out'
          }}
          onClick={() => setActiveNodeId(node.id)}
        >
          <Component 
            key={`window-${node.id}-${node.windowType}`}
            onCommand={handleCommand} 
            isActive={isActive}
            nodeState={node.state}
            nodeId={node.id}
            transformWindow={transformWindow}
            onStateChange={(newState) => {
              updateTerminalState(node.id, newState);
            }}
          />
        </div>
      );
    }

    // Calculate split dimensions
    let firstDimensions, secondDimensions;
    if (node.direction === 'horizontal') {
      firstDimensions = {
        x: available.x,
        y: available.y,
        width: available.width * node.splitRatio,
        height: available.height
      };
      secondDimensions = {
        x: available.x + (available.width * node.splitRatio),
        y: available.y,
        width: available.width * (1 - node.splitRatio),
        height: available.height
      };
    } else {
      firstDimensions = {
        x: available.x,
        y: available.y,
        width: available.width,
        height: available.height * node.splitRatio
      };
      secondDimensions = {
        x: available.x,
        y: available.y + (available.height * node.splitRatio),
        width: available.width,
        height: available.height * (1 - node.splitRatio)
      };
    }

    return (
      <div className="absolute inset-0" style={{ pointerEvents: 'none' }}>
        <WindowTreeRenderer 
          node={node.first} 
          depth={depth + 1} 
          available={firstDimensions} 
        />
        <div
          className="absolute bg-stone-700 hover:bg-stone-500 transition-colors"
          style={{
            left: node.direction === 'horizontal' ? `${firstDimensions.width}%` : 0,
            top: node.direction === 'vertical' ? `${firstDimensions.height}%` : 0,
            width: node.direction === 'horizontal' ? '4px' : '100%',
            height: node.direction === 'vertical' ? '4px' : '100%',
            cursor: node.direction === 'horizontal' ? 'col-resize' : 'row-resize',
            pointerEvents: 'auto',
            zIndex: 10
          }}
          onMouseDown={(e) => handleResizeStart(e, node)}
        />
        <WindowTreeRenderer 
          node={node.second} 
          depth={depth + 1} 
          available={secondDimensions}
        />
      </div>
    );
  };

  return (
    <div className="w-full h-screen flex flex-col">
      <CommandBar
        onCommand={handleCommand}
        currentWorkspaceIndex={currentWorkspaceIndex}
        switchWorkspace={switchWorkspace}
      />
      <div className="flex-1 relative bg-stone-900">
        {rootNode ? (
          <WindowTreeRenderer
            node={rootNode}
            terminalStates={terminalStates}
            updateTerminalState={updateTerminalState}
          />
        ) : (
          <EmptyState />
        )}
        
        {/* Notification system */}
        {notification && (
          <div 
            className="absolute top-4 left-1/2 transform -translate-x-1/2 bg-red-500 text-white px-4 py-2 rounded shadow-lg z-50"
            style={{ maxWidth: '80%' }}
          >
            {notification}
          </div>
        )}
      </div>
    </div>
  );
};

export default WindowManager;

================
File: components/windows/AudioWindow.jsx
================
import React, { useRef, useState, useEffect, useCallback } from 'react';
import { Play, Pause, Volume2 } from 'lucide-react';

const AudioWindow = ({ nodeId, onCommand, windowState, updateWindowState }) => {
  const canvasRef = useRef(null);
  const audioRef = useRef(null);
  const audioContextRef = useRef(null);
  const analyserRef = useRef(null);
  const animationRef = useRef(null);
  const [isPlaying, setIsPlaying] = useState(windowState?.isPlaying || false);
  const [currentTime, setCurrentTime] = useState(windowState?.currentTime || 0);

  // Define draw function outside of other functions to avoid dependency issues
  const draw = useCallback(() => {
    if (!canvasRef.current || !analyserRef.current) {
      console.error('Cannot draw: canvas or analyser is null');
      return;
    }

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const analyser = analyserRef.current;
    
    // Make sure canvas dimensions are set correctly
    if (canvas.width === 0 || canvas.height === 0) {
      canvas.width = canvas.offsetWidth || 300;
      canvas.height = canvas.offsetHeight || 150;
    }
    
    // Use a smaller FFT size for better visualization
    analyser.fftSize = 512;
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    const drawFrame = () => {
      // Cancel any existing animation frame
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
      
      // Request next frame
      animationRef.current = requestAnimationFrame(drawFrame);
      
      // Get frequency data
      analyser.getByteFrequencyData(dataArray);

      // Clear canvas
      ctx.fillStyle = 'rgb(28, 25, 23)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw visualizer
      const barWidth = (canvas.width / bufferLength) * 2.5;
      let barHeight;
      let x = 0;

      for (let i = 0; i < bufferLength; i++) {
        barHeight = dataArray[i] * 1.5;
        
        // Make sure we have a minimum height for bars
        if (barHeight < 1) barHeight = 1;
        
        const gradient = ctx.createLinearGradient(0, canvas.height, 0, 0);
        gradient.addColorStop(0, '#14b8a6');
        gradient.addColorStop(1, '#2dd4bf');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);

        x += barWidth + 1;
      }
    };

    // Start the animation
    drawFrame();
    
    console.log('Visualization started');
    
    // Return a cleanup function
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
        animationRef.current = null;
      }
    };
  }, []);

  // Track if audio element has been connected to a source
  const sourceConnectedRef = useRef(false);

  // Setup audio with Web Audio API for visualization
  const setupAudio = useCallback(async () => {
    try {
      const audio = audioRef.current;
      if (!audio) {
        console.error('Audio element reference is null');
        return false;
      }
      
      // Force reset the sourceConnected flag if we're having issues
      if (audioContextRef.current?.state === 'closed') {
        sourceConnectedRef.current = false;
      }
      
      // Create new AudioContext if needed
      if (!audioContextRef.current || audioContextRef.current.state === 'closed') {
        console.log('Creating new AudioContext');
        
        // Create new AudioContext
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Create and configure analyser
        const analyser = audioContext.createAnalyser();
        analyser.fftSize = 256; // Smaller FFT size for better visualization
        analyser.smoothingTimeConstant = 0.8; // Add smoothing
        
        // Resume audio context (needed due to browser autoplay policies)
        await audioContext.resume();
        
        // Create a new MediaElementSource and connect it
        try {
          console.log('Creating new MediaElementSource');
          const source = audioContext.createMediaElementSource(audio);
          source.connect(analyser);
          analyser.connect(audioContext.destination);
          sourceConnectedRef.current = true;
          
          // Store references
          audioContextRef.current = audioContext;
          analyserRef.current = analyser;
          
          console.log('Audio setup complete with new AudioContext');
        } catch (sourceError) {
          console.error('Error creating MediaElementSource:', sourceError);
          return false;
        }
      } else {
        // If AudioContext exists but is suspended, resume it
        if (audioContextRef.current.state === 'suspended') {
          console.log('Resuming suspended AudioContext');
          await audioContextRef.current.resume();
        }
        
        console.log('Using existing AudioContext');
      }
      
      // Restore playback position from window state
      if (windowState?.currentTime) {
        audio.currentTime = windowState.currentTime;
      }
      
      return true;
    } catch (error) {
      console.error('Error setting up audio:', error);
      return false;
    }
  }, [windowState]);

  // Initialize audio on mount or when windowState changes
  useEffect(() => {
    const initializeAudio = async () => {
      // Set up the audio context
      const success = await setupAudio();
      
      // If setup was successful and we should be playing, start playback
      if (success && windowState?.isPlaying) {
        try {
          await audioRef.current.play();
          draw();
        } catch (error) {
          console.error('Error auto-playing audio:', error);
          setIsPlaying(false);
        }
      }
    };

    if (audioRef.current && 
        (!audioContextRef.current || audioContextRef.current.state === 'closed')) {
      initializeAudio();
    }

    return () => {
      if (audioContextRef.current && audioContextRef.current.state !== 'closed') {
        try {
          audioContextRef.current.close();
        } catch (error) {
          console.error('Error closing AudioContext:', error);
        }
      }
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [windowState, setupAudio, draw]);

  // Toggle play/pause
  const togglePlay = useCallback(async () => {
    if (!audioRef.current) return;

    try {
      console.log('Toggle play clicked, current state:', isPlaying);
      
      // Make sure audio context is initialized and running
      if (!audioContextRef.current || audioContextRef.current.state === 'closed') {
        console.log('Setting up audio again');
        const success = await setupAudio();
        if (!success) {
          console.error('Failed to set up audio');
          return;
        }
      } else if (audioContextRef.current.state === 'suspended') {
        console.log('Resuming suspended AudioContext');
        await audioContextRef.current.resume();
      }

      if (isPlaying) {
        console.log('Pausing audio');
        audioRef.current.pause();
        if (animationRef.current) {
          cancelAnimationFrame(animationRef.current);
          animationRef.current = null;
        }
      } else {
        console.log('Starting audio playback');
        try {
          // Start visualization before playing to ensure it's ready
          if (analyserRef.current && !animationRef.current) {
            console.log('Starting visualization');
            draw();
          }
          
          // Play the audio
          const playPromise = audioRef.current.play();
          if (playPromise) {
            await playPromise;
            console.log('Audio playback started successfully');
            
            // Make sure visualization is running
            if (!animationRef.current && analyserRef.current) {
              console.log('Starting visualization after successful play');
              draw();
            }
          }
        } catch (playError) {
          console.error('Error playing audio:', playError);
        }
      }
      
      setIsPlaying(!isPlaying);
    } catch (error) {
      console.error('Error in togglePlay:', error);
    }
  }, [isPlaying, setupAudio, draw]);

  // Handle canvas resize
  useEffect(() => {
    const resizeCanvas = () => {
      const canvas = canvasRef.current;
      if (!canvas) return;
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
    };

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    return () => window.removeEventListener('resize', resizeCanvas);
  }, []);

  // Update current time when playing
  useEffect(() => {
    if (!audioRef.current) return;
    
    const updateTime = () => {
      setCurrentTime(audioRef.current.currentTime);
    };
    
    audioRef.current.addEventListener('timeupdate', updateTime);
    return () => {
      audioRef.current?.removeEventListener('timeupdate', updateTime);
    };
  }, []);
  
  // Start visualization when audio is playing
  useEffect(() => {
    // If audio is playing but visualization is not running, start it
    if (isPlaying && audioRef.current && analyserRef.current && !animationRef.current) {
      console.log('Starting visualization due to isPlaying state change');
      draw();
    }
    
    // If audio is not playing but visualization is running, stop it
    if (!isPlaying && animationRef.current) {
      console.log('Stopping visualization due to isPlaying state change');
      cancelAnimationFrame(animationRef.current);
      animationRef.current = null;
    }
  }, [isPlaying, draw]);

  // Update window state when relevant state changes
  useEffect(() => {
    if (updateWindowState) {
      updateWindowState({
        isPlaying,
        currentTime
      });
    }
  }, [isPlaying, currentTime, updateWindowState]);

  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400">
      <div className="flex-1 relative">
        <canvas 
          ref={canvasRef}
          className="absolute inset-0 w-full h-full"
        />
      </div>

      <div className="border-t border-stone-700">
        <div className="flex items-center gap-4 mb-4">
          <button 
            onClick={togglePlay}
            className="p-2 hover:bg-stone-800 rounded-full transition-colors"
          >
            {isPlaying ? <Pause size={24} /> : <Play size={24} />}
          </button>
          <Volume2 size={24} />
        </div>

        <audio
          ref={audioRef}
          src="scamming-on-runescape.mp3"
          preload="auto"
          crossOrigin="anonymous"
          onPlay={() => setIsPlaying(true)}
          onPause={() => setIsPlaying(false)}
          onEnded={() => setIsPlaying(false)}
        />

        <div className="p-2 flex items-center gap-2 border-t border-stone-700">
          <span>$</span>
          <input
            type="text"
            className="flex-1 bg-stone-800 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
            onKeyDown={(e) => {
              if (e.key === 'Enter' && e.target.value.trim()) {
                onCommand(e.target.value.trim());
                e.target.value = '';
              }
            }}
          />
        </div>
      </div>
    </div>
  );
};

export default AudioWindow;

================
File: components/windows/EditorWindow.jsx
================
import React, { useState, useEffect } from 'react';

const EditorWindow = ({ nodeId, onCommand, windowState, updateWindowState }) => {
  // Use state from windowState or default value
  const [text, setText] = useState(windowState?.text || `function hello() {\n  console.log("Hello, World!");\n}\n\n// Call the function\nhello();`);
  const [command, setCommand] = useState('');
  
  // Sync with external state when it changes
  useEffect(() => {
    if (windowState && windowState.text !== undefined) {
      setText(windowState.text);
    }
  }, [windowState]);
  
  // Update window state when text changes
  useEffect(() => {
    if (updateWindowState) {
      updateWindowState({ text });
    }
  }, [text, updateWindowState]);
  
  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && command.trim()) {
      onCommand(command.trim());
      setCommand('');
    }
  };

  const handleTextChange = (e) => {
    setText(e.target.value);
  };

  return (
    <div className="p-4 font-mono text-sm h-full flex flex-col bg-white">
      <div className="flex-1">
        <textarea
          className="w-full h-full text-gray-800 resize-none focus:outline-none"
          value={text}
          onChange={handleTextChange}
          autoFocus
        />
      </div>

      {/* Command input */}
      <div className="mt-2 flex items-center gap-2">
        <span className="text-gray-400">$</span>
        <input
          type="text"
          value={command}
          onChange={(e) => setCommand(e.target.value)}
          onKeyDown={handleKeyDown}
          className="flex-1 bg-gray-100 px-2 py-1 rounded text-sm focus:outline-none"
          placeholder="Type a command..."
        />
      </div>
    </div>
  );
};

export default EditorWindow;

================
File: components/windows/ExplorerWindow.css
================
/* Markdown content styling */
.markdown-content {
    color: #f0f9ff; /* Light blue-white for readability */
    line-height: 1.6;
    font-family: 'Oxygen Mono', monospace;
    padding: 1rem;
  }
  
  /* Header styles with clear size differences */
  .markdown-content h1 {
    font-size: 2.5rem;
    font-weight: 700;
    margin-top: 1.5rem;
    margin-bottom: 1rem;
    color: #2dd4bf; /* Teal accent color */
    border-bottom: 1px solid #44403c;
    padding-bottom: 0.5rem;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content h2 {
    font-size: 2rem;
    font-weight: 600;
    margin-top: 1.5rem;
    margin-bottom: 0.75rem;
    color: #2dd4bf;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content h3 {
    font-size: 1.75rem;
    font-weight: 600;
    margin-top: 1.25rem;
    margin-bottom: 0.75rem;
    color: #2dd4bf;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content h4 {
    font-size: 1.5rem;
    font-weight: 600;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    color: #2dd4bf;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content h5 {
    font-size: 1.25rem;
    font-weight: 600;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    color: #2dd4bf;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content h6 {
    font-size: 1rem;
    font-weight: 600;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    color: #2dd4bf;
    font-family: 'Oxygen Mono', monospace;
  }
  
  /* Paragraph styling */
  .markdown-content p {
    margin-top: 0.5rem;
    margin-bottom: 0.5rem;
    font-family: 'Oxygen Mono', monospace;
  }
  
  /* Make sure the code blocks stand out */
  .markdown-content pre {
    background-color: #1c1917; /* Darker background for code */
    border-radius: 0.25rem;
    padding: 1rem;
    overflow-x: auto;
    margin: 1rem 0;
    font-family: 'Oxygen Mono', monospace;
    font-size: 0.875rem;
    line-height: 1.5;
  }
  
  .markdown-content code {
    font-family: 'Oxygen Mono', monospace;
    background-color: #1c1917;
    padding: 0.2rem 0.4rem;
    border-radius: 0.25rem;
    font-size: 0.875em;
  }
  
  /* Add some spacing between sections */
  .markdown-content br + h1,
  .markdown-content br + h2,
  .markdown-content br + h3,
  .markdown-content br + h4,
  .markdown-content br + h5,
  .markdown-content br + h6 {
    margin-top: 0.5rem;
  }
  
  /* Lists */
  .markdown-content ul, .markdown-content ol {
    margin-top: 0.5rem;
    margin-bottom: 0.5rem;
    padding-left: 2rem;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content li {
    margin-top: 0.25rem;
    margin-bottom: 0.25rem;
  }
  
  /* Links */
  .markdown-content a {
    color: #14b8a6;
    text-decoration: underline;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content a:hover {
    color: #2dd4bf;
  }

================
File: components/windows/ExplorerWindow.jsx
================
import React, { useState, useEffect } from 'react';
import { FolderOpen, FileText, ChevronRight, ChevronDown, File, Coffee, Code, BookOpen } from 'lucide-react';
import showdown from 'showdown';
import './ExplorerWindow.css';

const ExplorerWindow = ({ nodeId, onCommand, transformWindow, windowState, updateWindowState }) => {
  // Use state from windowState or initialize with defaults
  const [files, setFiles] = useState([]);
  const [currentPath, setCurrentPath] = useState(windowState?.currentPath || '/');
  const [selectedFile, setSelectedFile] = useState(windowState?.selectedFile || null);
  const [expandedFolders, setExpandedFolders] = useState(windowState?.expandedFolders || {});
  const [isLoading, setIsLoading] = useState(true);
  const [fileContent, setFileContent] = useState(windowState?.fileContent || '');
  const [errorMessage, setErrorMessage] = useState('');
  const [showPreview, setShowPreview] = useState(windowState?.showPreview || false);
  
  // Initialize Showdown converter for Markdown
  const converter = new showdown.Converter({
    tables: true,
    tasklists: true,
    strikethrough: true,
    emoji: true
  });

  // Function to fetch directory contents from the server
  const fetchDirectoryContents = async (path = '/') => {
    try {
      setIsLoading(true);
      setErrorMessage('');
      
      // In a real implementation, we would call an API endpoint
      // Since we can't do that directly in this example, I'll simulate a response
      
      // For development with Vite, we could use:
      // const response = await fetch(`/api/files?path=${encodeURIComponent(path)}`);
      // const data = await response.json();
      
      // Simulate server response with a directory structure
      setTimeout(() => {
        // This simulates the files in your project root
        // In a real implementation, this would come from your server
        const projectFiles = [
          {
            name: 'docs',
            type: 'directory',
            path: '/docs',
            children: [
              { name: 'introduction.md', type: 'file', path: '/docs/introduction.md' },
              { name: 'getting-started.md', type: 'file', path: '/docs/getting-started.md' },
              { name: 'api-reference.md', type: 'file', path: '/docs/api-reference.md' }
            ]
          },
          {
            name: 'src',
            type: 'directory',
            path: '/src',
            children: [
              { name: 'App.jsx', type: 'file', path: '/src/App.jsx' },
              { name: 'main.jsx', type: 'file', path: '/src/main.jsx' },
              { name: 'styles.css', type: 'file', path: '/src/styles.css' },
              { 
                name: 'components', 
                type: 'directory', 
                path: '/src/components',
                children: [
                  { name: 'WindowManager.jsx', type: 'file', path: '/src/components/WindowManager.jsx' },
                  { name: 'CommandBar.jsx', type: 'file', path: '/src/components/CommandBar.jsx' }
                ]
              }
            ]
          },
          { name: 'README.md', type: 'file', path: '/README.md' },
          { name: 'package.json', type: 'file', path: '/package.json' }
        ];
        
        setFiles(projectFiles);
        setCurrentPath(path);
        setIsLoading(false);
      }, 300);
    } catch (error) {
      console.error('Error fetching directory contents:', error);
      setErrorMessage('Failed to load files. Please try again.');
      setIsLoading(false);
    }
  };

  // Function to fetch file content
  const fetchFileContent = async (filePath) => {
    try {
      setIsLoading(true);
      setErrorMessage('');
      
      // In a real implementation, we would call an API endpoint
      // Since we can't do that directly in this example, I'll simulate content for markdown files
      
      setTimeout(() => {
        // Sample content for markdown files
        let content = '';
        
        if (filePath === '/README.md') {
          content = `# SLUMTERM
          
## Overview
i can render markdown now nerd

its over`;
        } 
        else if (filePath === '/docs/introduction.md') {
          content = `# Introduction to Window Manager
          
The Window Manager is a React-based system for creating flexible, multi-pane layouts.

## Core Concepts
- **Windows**: Individual content panes
- **Splits**: Divisions between windows
- **Workspaces**: Collections of window arrangements

## Architecture
The system uses a binary tree structure to represent the layout hierarchy.`;
        }
        else if (filePath === '/docs/getting-started.md') {
          content = `# Getting Started
          
## Installation
\`\`\`bash
npm install
npm run dev
\`\`\`

## Basic Usage
- **Ctrl+Enter**: Create new window or split vertically
- **Ctrl+Shift+Enter**: Split horizontally
- **Ctrl+Backspace**: Close window
- **Ctrl+Q**: Toggle resize mode`;
        }
        else if (filePath === '/docs/api-reference.md') {
          content = `# API Reference
          
## Components

### WindowManager
The main component that manages the window hierarchy.

\`\`\`jsx
<WindowManager defaultLayout={layout} />
\`\`\`

### CommandBar
Provides a command interface for controlling the window manager.

\`\`\`jsx
<CommandBar onCommand={handleCommand} />
\`\`\``;
        }
        else {
          // For non-markdown files, show a placeholder message
          content = `Content for ${filePath} would be displayed here.`;
        }
        
        setFileContent(content);
        setIsLoading(false);
      }, 300);
    } catch (error) {
      console.error('Error fetching file content:', error);
      setErrorMessage('Failed to load file content. Please try again.');
      setIsLoading(false);
    }
  };

  // Load initial directory contents
  useEffect(() => {
    fetchDirectoryContents();
  }, []);

  // Update window state when relevant state changes
  useEffect(() => {
    if (updateWindowState) {
      updateWindowState({
        currentPath,
        selectedFile,
        expandedFolders,
        fileContent,
        showPreview
      });
    }
  }, [currentPath, selectedFile, expandedFolders, fileContent, showPreview, updateWindowState]);

  // Toggle folder expansion
  const toggleFolder = (folderPath) => {
    setExpandedFolders(prev => ({
      ...prev,
      [folderPath]: !prev[folderPath]
    }));
  };

  // Handle file selection
  const handleFileSelect = (file) => {
    setSelectedFile(file);
    
    // If it's a markdown file, fetch its content and show preview
    if (file.name.endsWith('.md')) {
      fetchFileContent(file.path);
      setShowPreview(true);
    } else {
      setFileContent('');
      setShowPreview(false);
    }
  };

  // Get file icon based on file extension
  const getFileIcon = (fileName) => {
    if (fileName.endsWith('.md')) return <FileText size={16} className="mr-2" />;
    if (fileName.endsWith('.jsx') || fileName.endsWith('.js')) return <Code size={16} className="mr-2" />;
    if (fileName.endsWith('.json')) return <Coffee size={16} className="mr-2" />;
    if (fileName.endsWith('.css')) return <BookOpen size={16} className="mr-2" />;
    return <File size={16} className="mr-2" />;
  };
  
  // Render the file tree recursively
  const renderFileTree = (items) => {
    return items.map(item => {
      if (item.type === 'directory') {
        const isExpanded = expandedFolders[item.path];
        return (
          <div key={item.path} className="ml-2">
            <div 
              className={`flex items-center py-1 px-1 rounded hover:bg-stone-700 cursor-pointer ${isExpanded ? 'text-teal-300' : 'text-teal-400'}`}
              onClick={() => toggleFolder(item.path)}
            >
              {isExpanded ? <ChevronDown size={14} /> : <ChevronRight size={14} />}
              <FolderOpen size={16} className="ml-1 mr-2" />
              <span className="text-sm">{item.name}</span>
            </div>
            
            {isExpanded && item.children && (
              <div className="ml-2 border-l border-stone-700">
                {renderFileTree(item.children)}
              </div>
            )}
          </div>
        );
      } else {
        const isSelected = selectedFile && selectedFile.path === item.path;
        return (
          <div 
            key={item.path} 
            className={`flex items-center py-1 px-1 ml-4 rounded cursor-pointer hover:bg-stone-700 ${isSelected ? 'bg-stone-700 text-teal-300' : 'text-teal-50'}`}
            onClick={() => handleFileSelect(item)}
          >
            {getFileIcon(item.name)}
            <span className="text-sm">{item.name}</span>
          </div>
        );
      }
    });
  };

  // Handle command input
  const handleCommand = (e) => {
    if (e.key === 'Enter' && e.target.value.trim()) {
      const cmd = e.target.value.trim();
      onCommand(cmd);
      e.target.value = '';
      
      // Example commands:
      // - refresh: refresh file list
      // - preview: toggle markdown preview
      if (cmd === 'refresh') {
        fetchDirectoryContents(currentPath);
      } else if (cmd === 'preview' && selectedFile?.name.endsWith('.md')) {
        setShowPreview(!showPreview);
      }
    }
  };

  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400 overflow-hidden">
      <div className="flex flex-1 overflow-hidden">
        {/* File tree panel */}
        <div className="w-1/3 border-r border-stone-700 flex flex-col overflow-hidden">
          <div className="p-2 border-b border-stone-700 font-mono text-sm flex items-center">
            <span>PROJECT FILES</span>
          </div>
          
          <div className="flex-1 overflow-auto">
            {isLoading && !fileContent ? (
              <div className="flex items-center justify-center h-full">
                <span className="text-teal-300">Loading...</span>
              </div>
            ) : errorMessage ? (
              <div className="p-2 text-red-400">{errorMessage}</div>
            ) : (
              <div className="p-2 font-mono">
                {renderFileTree(files)}
              </div>
            )}
          </div>
          
          <div className="p-2 border-t border-stone-700 text-xs">
            {selectedFile ? selectedFile.path : currentPath}
          </div>
        </div>
        
        {/* File preview panel - only shown for markdown files */}
        <div className="flex-1 flex flex-col overflow-hidden">
          {selectedFile && showPreview ? (
            <>
              <div className="p-2 border-b border-stone-700 font-mono text-sm">
                <span>{selectedFile.name}</span>
              </div>
              
              <div className="flex-1 overflow-auto p-4">
                {isLoading ? (
                  <div className="flex items-center justify-center h-full">
                    <span className="text-teal-300">Loading content...</span>
                  </div>
                ) : (
                  <div className="markdown-preview text-teal-50">
                    {selectedFile.name.endsWith('.md') ? (
                      <div 
                        dangerouslySetInnerHTML={{ 
                          __html: converter.makeHtml(fileContent) 
                        }} 
                        className="markdown-content"
                      />
                    ) : (
                      <pre className="font-mono text-sm whitespace-pre-wrap">
                        {fileContent}
                      </pre>
                    )}
                  </div>
                )}
              </div>
            </>
          ) : (
            <div className="flex items-center justify-center h-full text-stone-600">
              <div className="text-center">
                <FileText size={48} className="mx-auto mb-4" />
                <p>Select a markdown file to preview</p>
                <p className="text-xs mt-2">Use the 'preview' command to toggle preview mode</p>
              </div>
            </div>
          )}
        </div>
      </div>
      
      {/* Command input */}
      <div className="p-2 flex items-center gap-2 border-t border-stone-700">
        <span className="text-teal-400">$</span>
        <input
          type="text"
          onKeyDown={handleCommand}
          className="flex-1 bg-stone-800 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none focus:ring-1 focus:ring-teal-500"
          autoFocus
        />
      </div>
    </div>
  );
};

export default ExplorerWindow;

================
File: components/windows/imageWindow.jsx
================
import React, { useState, useEffect } from 'react';
import { Image as ImageIcon } from 'lucide-react';
import dhakmir from '../../assets/dhakmir-01.png';  // Default image
import martell from '../../assets/Martell2.png';    // Alternative image

const ImageWindow = ({ nodeId, onCommand, windowState, updateWindowState }) => {
  // Use state from windowState or initialize with defaults
  const [imageSrc, setImageSrc] = useState(windowState?.imageSrc || dhakmir);
  const [imageAlt, setImageAlt] = useState(windowState?.imageAlt || 'dhakmir');

  // Update window state when image changes
  useEffect(() => {
    if (updateWindowState) {
      updateWindowState({
        imageSrc,
        imageAlt
      });
    }
  }, [imageSrc, imageAlt, updateWindowState]);

  // Handle image switching command
  const handleImageCommand = (command) => {
    if (command === 'switch') {
      if (imageSrc === dhakmir) {
        setImageSrc(martell);
        setImageAlt('martell');
      } else {
        setImageSrc(dhakmir);
        setImageAlt('dhakmir');
      }
      return true;
    }
    return false;
  };

  return (
    <div className="h-full w-full flex flex-col bg-stone-900">
      {/* Container div with relative positioning */}
      <div className="flex-1 relative">
        {/* Image absolutely positioned to fill space while staying centered */}
        <img 
          src={imageSrc} 
          alt={imageAlt} 
          className="absolute inset-0 w-full h-full object-contain m-auto"
        />
      </div>

      {/* Command input */}
      <div className="p-4 flex items-center gap-2">
        <span className="text-teal-400">$</span>
        <input
          type="text"
          className="flex-1 bg-transparent outline-none text-teal-400 font-mono"
          onKeyDown={(e) => {
            if (e.key === 'Enter' && e.target.value.trim()) {
              const command = e.target.value.trim();
              // First try our custom image commands
              const handled = handleImageCommand(command);
              // If not handled, pass to the general command handler
              if (!handled) {
                onCommand(command);
              }
              e.target.value = '';
            }
          }}
        />
      </div>
      <div className="p-2 text-xs text-teal-600 text-center">
        Type "switch" to toggle between images
      </div>
    </div>
  );
};

export default ImageWindow;

================
File: components/windows/index.js
================
import TerminalWindow from './TerminalWindow';
import ExplorerWindow from './ExplorerWindow';
import EditorWindow from './EditorWindow';
import PreviewWindow from './PreviewWindow';
import ImageWindow from './imageWindow';
import withCommandHandling from '../../hocs/withCommandHandling';
import withWindowState from '../../hocs/withWindowState';
import AudioWindow from './AudioWindow';
import { WINDOW_TYPES } from '../../utils/constants';

// Create enhanced versions of each window component by wrapping them with both HOCs
// First apply withCommandHandling, then withWindowState to provide state management
export const EnhancedTerminalWindow = withWindowState(withCommandHandling(TerminalWindow), WINDOW_TYPES.TERMINAL);
export const EnhancedExplorerWindow = withWindowState(withCommandHandling(ExplorerWindow), WINDOW_TYPES.EXPLORER);
export const EnhancedEditorWindow = withWindowState(withCommandHandling(EditorWindow), WINDOW_TYPES.EDITOR);
export const EnhancedPreviewWindow = withWindowState(withCommandHandling(PreviewWindow), WINDOW_TYPES.CHART);
export const EnhancedImageWindow = withWindowState(withCommandHandling(ImageWindow), WINDOW_TYPES.IMAGE);
export const EnhancedAudioWindow = withWindowState(withCommandHandling(AudioWindow), WINDOW_TYPES.AUDIO);

// Also export the base components in case they're needed
export { TerminalWindow, ExplorerWindow, EditorWindow, PreviewWindow };

================
File: components/windows/PreviewWindow.jsx
================
import React, { useState } from 'react';

const PreviewWindow = ({ nodeId, onCommand }) => {
  const [command, setCommand] = useState('');
  
  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && command.trim()) {
      onCommand(command.trim());
      setCommand('');
    }
  };

  return (
    <div className="p-4 h-full flex flex-col bg-stone-900">
      <div className="flex-1">
        <h1 className="text-2xl text-teal-400 font-mono">Pretend this is a chart</h1>
        <p className="mt-2 text-teal-400 font-mono text-sm">
          these would be the different components
        </p>
      </div>

      {/* Command input */}
      {/* <div className="mt-2 flex items-center gap-2">
        <span className="mr-2">$</span>
        <input
          type="text"
          value={command}
          onChange={(e) => setCommand(e.target.value)}
          onKeyDown={handleKeyDown}
          className="flex-1 bg-transparent outline-none text-teal-400"
          placeholder="Type a command..."
        />
      </div> */}
    </div>
  );
};

export default PreviewWindow;

================
File: components/windows/TerminalWindow.jsx
================
import React, { useState, useEffect, useRef } from 'react';
import { WINDOW_TYPES } from '../../utils/windowTypes';

const TerminalWindow = ({ onCommand, isActive, nodeId, transformWindow, windowState, updateWindowState }) => {
  // Refs for managing focus and scrolling
  const terminalRef = useRef(null);
  const inputRef = useRef(null);

  // Terminal state - use windowState if available
  const [history, setHistory] = useState(
    windowState?.history || ['SLUMNET TERMINAL - Type "help" for available commands.']
  );
  const [commandHistory, setCommandHistory] = useState(windowState?.commandHistory || []);
  const [currentInput, setCurrentInput] = useState(windowState?.currentInput || '');
  const [historyIndex, setHistoryIndex] = useState(windowState?.historyIndex || -1);

  // Auto-focus when terminal becomes active
  useEffect(() => {
    if (isActive) {
      inputRef.current?.focus();
    }
  }, [isActive]);

  // Auto-scroll to bottom when new output is added
  useEffect(() => {
    if (terminalRef.current) {
      terminalRef.current.scrollTop = terminalRef.current.scrollHeight;
    }
  }, [history]);

  // Update window state when terminal state changes
  useEffect(() => {
    if (updateWindowState) {
      updateWindowState({
        history,
        commandHistory,
        currentInput,
        historyIndex
      });
    }
  }, [history, commandHistory, currentInput, historyIndex, updateWindowState]);

  const handleTerminalClick = () => {
    inputRef.current?.focus();
  };

  const executeCommand = (command) => {
    setHistory(prev => [...prev, `$ ${command}`]);
    setCommandHistory(prev => [...prev, command]);
  
    const cmd = command.toLowerCase();
  
    if (Object.keys(WINDOW_TYPES).some(type => type.toLowerCase() === cmd)) {
      const requestedType = WINDOW_TYPES[cmd.toUpperCase()];
      transformWindow(nodeId, requestedType);
      return;
    }
  
    let response;
    switch (cmd) {
      case 'help':
        response = [
          'Available commands:',
          '  explorer     - Transform into file explorer',
          '  editor       - Transform into code editor',
          '  terminal     - Transform into terminal',
          '  preview      - Transform into preview window',
          '  help         - Show this help message',
          '  clear        - Clear terminal output',
          '',
          'Keyboard shortcuts:',
          '  Ctrl + Enter       - Split vertically',
          '  Ctrl + Shift + Enter - Split horizontally',
          '  Ctrl + Backspace   - Close window',
          '  /                  - Focus command bar'
        ].join('\n');
        break;
  
      case 'clear':
        setHistory(['Terminal cleared']);
        return;
  
      case 'version':
        response = 'SLUMNET Terminal v1.0.0';
        break;
  
      default:
        response = `Unknown command: ${command}`;
    }
  
    setHistory(prev => [...prev, response]);
  };

  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && currentInput.trim()) {
      executeCommand(currentInput.trim());
      setCurrentInput('');
      setHistoryIndex(-1);
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      if (historyIndex < commandHistory.length - 1) {
        const newIndex = historyIndex + 1;
        setHistoryIndex(newIndex);
        setCurrentInput(commandHistory[commandHistory.length - 1 - newIndex] || '');
      }
    } else if (e.key === 'ArrowDown') {
      e.preventDefault();
      if (historyIndex > -1) {
        const newIndex = historyIndex - 1;
        setHistoryIndex(newIndex);
        setCurrentInput(newIndex === -1 ? '' : commandHistory[commandHistory.length - 1 - newIndex] || '');
      }
    }
  };

  return (
    <div 
      className="bg-stone-900 text-teal-400 font-mono text-sm h-full flex flex-col"
      onClick={handleTerminalClick}
    >
      <div ref={terminalRef} className="p-2 flex-1 overflow-auto whitespace-pre-wrap">
        {history.map((line, i) => (
          <div key={i}>{line}</div>
        ))}
      </div>

      <div className="p-2 flex items-center gap-2 border-t border-stone-700">
        <span className="mr-2">$</span>
        <input
          ref={inputRef}
          type="text"
          value={currentInput}
          onChange={(e) => setCurrentInput(e.target.value)}
          onKeyDown={handleKeyDown}
          className="flex-1 bg-stone-800 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
          autoFocus
        />
      </div>
    </div>
  );
};

export default TerminalWindow;

================
File: config/api.js
================
// API configuration
const API_CONFIG = {
  // Replace with your actual server URL
  BASE_URL: 'http://45.45.239.125:3001/api',
  
  // Endpoints
  ENDPOINTS: {
    LOGIN: '/login',
    REGISTER: '/register',
    PROFILE: '/profile'
  }
};

export default API_CONFIG;

================
File: context/AuthContext.jsx
================
import React, { createContext, useContext, useState, useEffect } from 'react';
import axios from 'axios';
import API_CONFIG from '../config/api';

// Create the authentication context
const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Check if user is already logged in on component mount
  useEffect(() => {
    const token = localStorage.getItem('auth_token');
    if (token) {
      fetchUserProfile(token);
    } else {
      setLoading(false);
    }
  }, []);

  // Fetch user profile using the token
  const fetchUserProfile = async (token) => {
    try {
      const response = await axios.get(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PROFILE}`, {
        headers: { Authorization: `Bearer ${token}` }
      });
      setUser(response.data);
      setError(null);
    } catch (err) {
      console.error('Failed to fetch user profile:', err);
      localStorage.removeItem('auth_token');
      setError('Session expired. Please login again.');
    } finally {
      setLoading(false);
    }
  };

  // Login function
  const login = async (username, password) => {
    setLoading(true);
    try {
      const response = await axios.post(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.LOGIN}`, {
        username,
        password
      });
      
      const { token } = response.data;
      localStorage.setItem('auth_token', token);
      
      await fetchUserProfile(token);
      return { success: true };
    } catch (err) {
      setLoading(false);
      const message = err.response?.data?.message || 'Login failed';
      setError(message);
      return { success: false, message };
    }
  };

  // Logout function
  const logout = () => {
    localStorage.removeItem('auth_token');
    setUser(null);
    setError(null);
  };

  // Clear any authentication errors
  const clearError = () => {
    setError(null);
  };

  // Context value
  const value = {
    user,
    loading,
    error,
    login,
    logout,
    clearError,
    isAuthenticated: !!user
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

// Custom hook to use the auth context
export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

================
File: context/WindowStateContext.jsx
================
import React, { createContext, useContext, useState, useEffect, useCallback, useMemo, useRef } from 'react';

// Create context
const WindowStateContext = createContext();

// Initial state with different content types
const initialState = {
  windowStates: {}
};

// Context provider component
export function WindowStateProvider({ children }) {
  // Use a ref to store the state to avoid re-renders
  const stateRef = useRef(initialState);
  
  // Use useState just to trigger re-renders when needed
  const [, forceUpdate] = useState({});
  
  // Add a ref to track if we should update localStorage
  const isInitialMount = useRef(true);
  const saveTimeoutRef = useRef(null);

  // Load initial state from localStorage once on mount
  useEffect(() => {
    try {
      const savedState = localStorage.getItem('windowStates');
      if (savedState) {
        const parsedState = JSON.parse(savedState);
        if (parsedState && parsedState.windowStates) {
          // Update the state ref directly
          stateRef.current = parsedState;
          // Force a re-render
          forceUpdate({});
        }
      }
      // Mark initial load as complete
      isInitialMount.current = false;
    } catch (error) {
      console.error('Failed to load window states from localStorage:', error);
      isInitialMount.current = false;
    }
  }, []); // Empty dependency array means this runs once on mount

  // Save to localStorage with debounce
  const saveToLocalStorage = useCallback(() => {
    // Skip saving on initial load
    if (isInitialMount.current) {
      return;
    }
    
    // Clear any existing timeout
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
    }
    
    // Set a new timeout to save the state after a delay
    saveTimeoutRef.current = setTimeout(() => {
      try {
        localStorage.setItem('windowStates', JSON.stringify(stateRef.current));
      } catch (error) {
        console.error('Failed to save window states to localStorage:', error);
      }
    }, 500); // 500ms debounce
  }, []);

  // Action creators
  const setWindowState = useCallback((windowId, windowType, content) => {
    // Update the state ref directly
    stateRef.current = {
      ...stateRef.current,
      windowStates: {
        ...stateRef.current.windowStates,
        [windowId]: {
          type: windowType,
          content
        }
      }
    };
    
    // Save to localStorage
    saveToLocalStorage();
    
    // Force a re-render
    forceUpdate({});
  }, [saveToLocalStorage]);

  const removeWindowState = useCallback((windowId) => {
    // Create a new state object
    const newState = {
      ...stateRef.current,
      windowStates: { ...stateRef.current.windowStates }
    };
    
    // Delete the window state
    delete newState.windowStates[windowId];
    
    // Update the state ref
    stateRef.current = newState;
    
    // Save to localStorage
    saveToLocalStorage();
    
    // Force a re-render
    forceUpdate({});
  }, [saveToLocalStorage]);

  const getWindowState = useCallback((windowId) => {
    return stateRef.current.windowStates[windowId] || null;
  }, []);

  // Create a stable context value
  const contextValue = useMemo(() => ({
    windowStates: stateRef.current.windowStates,
    setWindowState,
    removeWindowState,
    getWindowState
  }), [setWindowState, removeWindowState, getWindowState]);

  return (
    <WindowStateContext.Provider value={contextValue}>
      {children}
    </WindowStateContext.Provider>
  );
}

// Custom hook to use the window state context
export function useWindowState() {
  const context = useContext(WindowStateContext);
  if (!context) {
    throw new Error('useWindowState must be used within a WindowStateProvider');
  }
  return context;
}

================
File: hocs/withCommandHandling.jsx
================
import React from 'react';
import { WINDOW_TYPES } from '../utils/windowTypes';

/**
 * Higher-Order Component that adds command handling capabilities to window components.
 * This HOC provides a standardized way to handle commands across different window types,
 * particularly focusing on window transformation commands.
 *
 * @param {React.Component} WrappedComponent - The window component to enhance with command handling
 * @returns {React.Component} - A new component with command handling capabilities
 */
const withCommandHandling = (WrappedComponent) => {
  // Return a new component that includes the command handling functionality
  return function WithCommandHandling({ 
    transformWindow, // Function to change window type
    nodeId,         // Unique identifier for the window
    ...props        // All other props passed to the window
  }) {
    /**
     * Handles commands entered in the window.
     * Currently supports window transformation commands (e.g., 'terminal', 'editor', etc.)
     * Can be extended to handle other command types in the future.
     *
     * @param {string} command - The command string to process
     * @returns {boolean} - Whether the command was handled
     */
    const handleCommand = (command) => {
      // Convert command to lowercase for case-insensitive comparison
      const cmd = command.toLowerCase();
      
      // Check if the command matches any window type
      // This allows commands like 'terminal', 'editor', 'explorer', 'preview'
      const isWindowTypeCommand = Object.keys(WINDOW_TYPES).some(
        type => type.toLowerCase() === cmd
      );

      if (isWindowTypeCommand) {
        // Get the actual window type constant from our types enum
        const requestedType = WINDOW_TYPES[cmd.toUpperCase()];
        
        // Log the transformation request for debugging
        console.log(`Transforming window ${nodeId} to ${requestedType}`);
        
        // Execute the transformation
        transformWindow(nodeId, requestedType);
        
        // Return true to indicate the command was handled
        return true;
      }
      
      // Return false if the command wasn't handled by this HOC
      // This allows the wrapped component to handle other commands if needed
      return false;
    };
    
    // Render the wrapped component with both the original props
    // and our new command handler
    return (
      <WrappedComponent 
        {...props} 
        transformWindow={transformWindow}
        nodeId={nodeId}
        onCommand={handleCommand}
      />
    );
  };
};

export default withCommandHandling;

================
File: hocs/withWindowState.jsx
================
import React, { useCallback, useMemo } from 'react';
import { useWindowState } from '../context/WindowStateContext';

/**
 * Higher-Order Component that adds state management capabilities to window components.
 * This HOC provides a standardized way to manage window state across different window types.
 *
 * @param {React.Component} WrappedComponent - The window component to enhance with state management
 * @param {string} windowType - The type of window from WINDOW_TYPES
 * @returns {React.Component} - A new component with state management capabilities
 */
const withWindowState = (WrappedComponent, windowType) => {
  return function WithWindowState({ 
    nodeId,
    ...props
  }) {
    // Access the window state context
    const { getWindowState, setWindowState } = useWindowState();
    
    // Get the current state or use an empty object if none exists
    // Use useMemo to avoid recreating the object on every render
    const currentState = useMemo(() => {
      return getWindowState(nodeId)?.content || {};
    }, [getWindowState, nodeId]);
    
    // Create an updater function for the component to use
    // Use useCallback to avoid recreating the function on every render
    const updateWindowState = useCallback((updates) => {
      // Get the latest state to ensure we're working with current data
      const latestState = getWindowState(nodeId)?.content || {};
      
      // Allow both object and function updaters
      const newContent = typeof updates === 'function'
        ? updates(latestState)
        : { ...latestState, ...updates };
        
      setWindowState(nodeId, windowType, newContent);
    }, [getWindowState, setWindowState, nodeId, windowType]);
    
    return (
      <WrappedComponent
        {...props}
        nodeId={nodeId}
        windowState={currentState}
        updateWindowState={updateWindowState}
      />
    );
  };
};

export default withWindowState;

================
File: hooks/useForceUpdate.js
================
import { useState } from 'react';

export function useForceUpdate() {
    const [state, setState] = useState(0);
    return () => setState((state) => state + 1);
  }

================
File: hooks/useKeyboardShortcuts.js
================
import { useEffect } from 'react';
import { WINDOW_TYPES } from '../utils/windowTypes';

/**
 * A custom hook that manages keyboard shortcuts for window operations.
 * This hook centralizes all keyboard-related logic for the window manager.
 * 
 * @param {Object} handlers - Object containing callback functions for various window operations
 * @param {Function} handlers.onSplitVertical - Handler for vertical split command
 * @param {Function} handlers.onSplitHorizontal - Handler for horizontal split command
 * @param {Function} handlers.onClose - Handler for window close command
 * @param {Function} handlers.createNewWindow - Handler for creating new windows
 * @param {boolean} hasActiveWindow - Whether there is currently an active window
 * @param {boolean} hasRootNode - Whether there is a root node in the tree
 */
export const useKeyboardShortcuts = ({
  onSplitVertical,
  onSplitHorizontal,
  onClose,
  createNewWindow,
  hasActiveWindow,
  hasRootNode,
  isResizeMode,
  setIsResizeMode,
  resizeActiveWindow
}) => {
  useEffect(() => {
    const handleKeyDown = (e) => {
      // Handle resize mode toggle
      if (e.ctrlKey && e.key === 'q') {
        e.preventDefault();
        setIsResizeMode(!isResizeMode);
        return;
      }

      // Handle resize mode arrow keys
      if (isResizeMode && !e.ctrlKey) {
        switch (e.key) {
          case 'ArrowLeft':
            e.preventDefault();
            resizeActiveWindow('left');
            break;
          case 'ArrowRight':
            e.preventDefault();
            resizeActiveWindow('right');
            break;
          case 'ArrowUp':
            e.preventDefault();
            resizeActiveWindow('up');
            break;
          case 'ArrowDown':
            e.preventDefault();
            resizeActiveWindow('down');
            break;
        }
        return;
      }

      // Handle other keyboard shortcuts...
      if (e.ctrlKey) {
        if (e.key === 'Enter') {
          e.preventDefault();
          if (e.shiftKey) {
            hasActiveWindow ? onSplitVertical() : createNewWindow();
          } else {
            hasActiveWindow ? onSplitHorizontal() : createNewWindow();
          }
        } else if ((e.key === 'Backspace' || e.key === 'Delete') && hasActiveWindow && hasRootNode) {
          e.preventDefault();
          onClose();
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [
    onSplitVertical,
    onSplitHorizontal,
    onClose,
    createNewWindow,
    hasActiveWindow,
    hasRootNode,
    isResizeMode,
    setIsResizeMode,
    resizeActiveWindow
  ]);
};

================
File: hooks/useWindowManager.js
================
import { useState, useCallback, useEffect, useRef } from 'react';
import { Node } from '../models/Node';
import { WINDOW_TYPES } from '../utils/windowTypes';
import { 
  splitNodeById, 
  removeNodeById, 
  findNodeById, 
  findAllWindowIds,
  updateSplitRatio,
} from '../utils/treeUtils';
import { getWindowBounds } from '../utils/windowUtils';
import { useWindowState } from '../context/WindowStateContext';
import { 
  MIN_WINDOW_WIDTH_PX, 
  MIN_WINDOW_HEIGHT_PX 
} from '../utils/windowSizeConstants';

export const useWindowManager = ({ defaultLayout = null, onFlashBorder = null } = {}) => {
  // Workspace state
  const [workspaces, setWorkspaces] = useState([
    { id: 1, name: 'Main', root: defaultLayout, activeNodeId: null, terminalStates: {} },
    { id: 2, name: 'Code', root: null, activeNodeId: null, terminalStates: {} },
    { id: 3, name: 'Terminal', root: null, activeNodeId: null, terminalStates: {} },
    { id: 4, name: 'Preview', root: null, activeNodeId: null, terminalStates: {} }
  ]);
  const [currentWorkspaceIndex, setCurrentWorkspaceIndex] = useState(0);
  const [isResizeMode, setIsResizeMode] = useState(false);
  const [isMoveMode, setIsMoveMode] = useState(false);

  // Get current workspace data directly from workspaces array
  const currentWorkspace = workspaces[currentWorkspaceIndex];
  const rootNode = currentWorkspace.root;
  const activeNodeId = currentWorkspace.activeNodeId;
  const terminalStates = currentWorkspace.terminalStates;

  // Create setActiveNodeId function that updates the workspace
  const setActiveNodeId = useCallback((nodeId) => {
    setWorkspaces(prev => {
      const updated = [...prev];
      updated[currentWorkspaceIndex] = {
        ...updated[currentWorkspaceIndex],
        activeNodeId: nodeId
      };
      return updated;
    });
  }, [currentWorkspaceIndex]);

  // Update workspace state
  const updateWorkspace = useCallback((updater) => {
    setWorkspaces(prev => {
      const updated = [...prev];
      if (typeof updater === 'function') {
        updated[currentWorkspaceIndex] = {
          ...updated[currentWorkspaceIndex],
          ...updater(updated[currentWorkspaceIndex])
        };
      } else {
        updated[currentWorkspaceIndex] = {
          ...updated[currentWorkspaceIndex],
          ...updater
        };
      }
      return updated;
    });
  }, [currentWorkspaceIndex]);

  const switchWorkspace = useCallback((target) => {
    console.log('Switching to:', target);
    if (typeof target === 'number' && target >= 0 && target < 4) {
      setCurrentWorkspaceIndex(target);
    } else if (target === 'right' || target === 'left') {
      setCurrentWorkspaceIndex(prev => {
        const newIndex = target === 'right' 
          ? (prev + 1) % 4 
          : prev - 1 < 0 ? 3 : prev - 1;
        console.log('New index:', newIndex);
        return newIndex;
      });
    }
  }, [setCurrentWorkspaceIndex]);

  useEffect(() => {
    const handleWorkspaceKeys = (e) => {
      if (e.ctrlKey && e.altKey) {
        switch (e.key) {
          case 'ArrowRight':
            e.preventDefault();
            switchWorkspace('right');
            break;
          case 'ArrowLeft':
            e.preventDefault();
            switchWorkspace('left');
            break;
          // Removed 'n' key handler for creating new workspaces
        }
      }
    };

    window.addEventListener('keydown', handleWorkspaceKeys);
    return () => window.removeEventListener('keydown', handleWorkspaceKeys);
  }, [switchWorkspace]);

  // Window navigation functions
  const navigateToWindow = useCallback((direction) => {
    if (!activeNodeId || !rootNode) return;
  
    const allWindows = getWindowBounds(rootNode);
    const activeWindow = allWindows.find(w => w.id === activeNodeId);
    if (!activeWindow) return;
  
    // Filter out the active window
    const otherWindows = allWindows.filter(w => w.id !== activeNodeId);
    
    // If no other windows, nothing to navigate to
    if (otherWindows.length === 0) return;
    
    // Calculate the active window's center
    const activeBounds = activeWindow.bounds;
    
    // Helper function to calculate overlap percentage between windows
    const calculateOverlap = (window1, window2, isHorizontal) => {
      if (isHorizontal) {
        // Calculate horizontal overlap
        const overlapStart = Math.max(window1.left, window2.left);
        const overlapEnd = Math.min(window1.right, window2.right);
        if (overlapEnd <= overlapStart) return 0; // No overlap
        
        const overlapWidth = overlapEnd - overlapStart;
        const window1Width = window1.right - window1.left;
        
        return overlapWidth / window1Width;
      } else {
        // Calculate vertical overlap
        const overlapStart = Math.max(window1.top, window2.top);
        const overlapEnd = Math.min(window1.bottom, window2.bottom);
        if (overlapEnd <= overlapStart) return 0; // No overlap
        
        const overlapHeight = overlapEnd - overlapStart;
        const window1Height = window1.bottom - window1.top;
        
        return overlapHeight / window1Height;
      }
    };
    
    // Find windows in the specified direction with a more relaxed approach
    let candidateWindows = [];
    const tolerance = 0.1; // 10% tolerance for adjacency
    
    switch (direction) {
      case 'up':
        // Windows that are above the active window
        candidateWindows = otherWindows.filter(w => {
          const bounds = w.bounds;
          // Window must be above the active window
          if (bounds.bottom > activeBounds.top) return false;
          
          // Calculate horizontal overlap
          const overlap = calculateOverlap(activeBounds, bounds, true);
          return overlap > 0; // Any overlap makes it a candidate
        });
        break;
        
      case 'down':
        // Windows that are below the active window
        candidateWindows = otherWindows.filter(w => {
          const bounds = w.bounds;
          // Window must be below the active window
          if (bounds.top < activeBounds.bottom) return false;
          
          // Calculate horizontal overlap
          const overlap = calculateOverlap(activeBounds, bounds, true);
          return overlap > 0; // Any overlap makes it a candidate
        });
        break;
        
      case 'left':
        // Windows that are to the left of the active window
        candidateWindows = otherWindows.filter(w => {
          const bounds = w.bounds;
          // Window must be to the left of the active window
          if (bounds.right > activeBounds.left) return false;
          
          // Calculate vertical overlap
          const overlap = calculateOverlap(activeBounds, bounds, false);
          return overlap > 0; // Any overlap makes it a candidate
        });
        break;
        
      case 'right':
        // Windows that are to the right of the active window
        candidateWindows = otherWindows.filter(w => {
          const bounds = w.bounds;
          // Window must be to the right of the active window
          if (bounds.left < activeBounds.right) return false;
          
          // Calculate vertical overlap
          const overlap = calculateOverlap(activeBounds, bounds, false);
          return overlap > 0; // Any overlap makes it a candidate
        });
        break;
    }
    
    // If no candidates found, return
    if (candidateWindows.length === 0) return;
    
    // Calculate scores for each candidate window based on:
    // 1. Overlap percentage (higher is better)
    // 2. Distance from active window (lower is better)
    const scoredWindows = candidateWindows.map(window => {
      const bounds = window.bounds;
      let overlapScore = 0;
      let distanceScore = 0;
      
      switch (direction) {
        case 'up':
          overlapScore = calculateOverlap(activeBounds, bounds, true);
          distanceScore = activeBounds.top - bounds.bottom;
          break;
          
        case 'down':
          overlapScore = calculateOverlap(activeBounds, bounds, true);
          distanceScore = bounds.top - activeBounds.bottom;
          break;
          
        case 'left':
          overlapScore = calculateOverlap(activeBounds, bounds, false);
          distanceScore = activeBounds.left - bounds.right;
          break;
          
        case 'right':
          overlapScore = calculateOverlap(activeBounds, bounds, false);
          distanceScore = bounds.left - activeBounds.right;
          break;
      }
      
      // Normalize distance score (closer is better)
      const normalizedDistanceScore = 1 / (1 + distanceScore);
      
      // Calculate final score with higher weight on overlap
      const finalScore = (overlapScore * 0.7) + (normalizedDistanceScore * 0.3);
      
      return {
        window,
        overlapScore,
        distanceScore,
        finalScore
      };
    });
    
    // Sort by final score (higher is better)
    scoredWindows.sort((a, b) => b.finalScore - a.finalScore);
    
    // Select the window with the highest score
    const nextWindow = scoredWindows[0].window;
    
    if (nextWindow) {
      setActiveNodeId(nextWindow.id);
    }
  }, [activeNodeId, rootNode, setActiveNodeId]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (!e.ctrlKey) return;
  
      switch (e.key) {
        case 'ArrowLeft':
          e.preventDefault();
          navigateToWindow('left');
          break;
        case 'ArrowRight':
          e.preventDefault();
          navigateToWindow('right');
          break;
        case 'ArrowUp':
          e.preventDefault();
          navigateToWindow('up');
          break;
        case 'ArrowDown':
          e.preventDefault();
          navigateToWindow('down');
          break;
      }
    };
  
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [navigateToWindow]);

  // Get window state management functions
  const { getWindowState, setWindowState, removeWindowState } = useWindowState();

  // Helper function to convert percentage-based bounds to pixel dimensions
  const calculatePixelDimensions = useCallback((bounds) => {
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    
    const pixelDimensions = {
      width: (bounds.width / 100) * windowWidth,
      height: (bounds.height / 100) * windowHeight
    };
    
    console.log('Window dimensions (percentage):', bounds);
    console.log('Window dimensions (pixels):', pixelDimensions);
    console.log('Minimum required:', MIN_WINDOW_WIDTH_PX, 'x', MIN_WINDOW_HEIGHT_PX);
    console.log('Is too small:', 
      pixelDimensions.width < MIN_WINDOW_WIDTH_PX || 
      pixelDimensions.height < MIN_WINDOW_HEIGHT_PX
    );
    
    return pixelDimensions;
  }, []);

  // Helper function to check if a resize operation would result in windows that are too small
  const wouldViolateMinSize = useCallback((root, direction, affectedSplits, resizeStep) => {
    console.log('Checking if resize would violate minimum size...');
    console.log('Direction:', direction);
    console.log('Affected splits:', affectedSplits.length);
    console.log('Browser window size:', window.innerWidth, 'x', window.innerHeight);
    
    // Create a deep copy of the root to simulate the resize
    const simulatedRoot = JSON.parse(JSON.stringify(root));
    
    // Apply the resize to the simulated root
    affectedSplits.forEach(({ node: originalNode, targetInFirst, isRightSide, isBottomSide }) => {
      // Find the corresponding node in the simulated root
      const simulatedNode = findNodeById(simulatedRoot, originalNode.id);
      if (!simulatedNode) return;
      
      console.log('Simulating resize on node:', simulatedNode.id);
      console.log('Original split ratio:', simulatedNode.splitRatio);
      
      // Determine effective direction
      let effectiveDirection = direction;
      if (isRightSide && (direction === 'left' || direction === 'right')) {
        effectiveDirection = direction === 'left' ? 'right' : 'left';
      }
      if (isBottomSide && (direction === 'up' || direction === 'down')) {
        effectiveDirection = direction === 'up' ? 'down' : 'up';
      }
      
      console.log('Effective direction:', effectiveDirection);
      
      // Apply the resize
      switch (effectiveDirection) {
        case 'left': // Shrink width
          if (targetInFirst) {
            simulatedNode.splitRatio = Math.max(0.1, simulatedNode.splitRatio - resizeStep);
          } else {
            simulatedNode.splitRatio = Math.min(0.9, simulatedNode.splitRatio + resizeStep);
          }
          break;
          
        case 'right': // Grow width
          if (targetInFirst) {
            simulatedNode.splitRatio = Math.min(0.9, simulatedNode.splitRatio + resizeStep);
          } else {
            simulatedNode.splitRatio = Math.max(0.1, simulatedNode.splitRatio - resizeStep);
          }
          break;
          
        case 'up': // Shrink height
          if (targetInFirst) {
            simulatedNode.splitRatio = Math.max(0.1, simulatedNode.splitRatio - resizeStep);
          } else {
            simulatedNode.splitRatio = Math.min(0.9, simulatedNode.splitRatio + resizeStep);
          }
          break;
          
        case 'down': // Grow height
          if (targetInFirst) {
            simulatedNode.splitRatio = Math.min(0.9, simulatedNode.splitRatio + resizeStep);
          } else {
            simulatedNode.splitRatio = Math.max(0.1, simulatedNode.splitRatio - resizeStep);
          }
          break;
      }
      
      console.log('New split ratio:', simulatedNode.splitRatio);
    });
    
    // Calculate the bounds of all windows after the simulated resize
    const simulatedWindows = getWindowBounds(simulatedRoot);
    console.log('Number of windows to check:', simulatedWindows.length);
    
    // Check if any window would be smaller than the minimum size
    const tooSmallWindows = simulatedWindows.filter(window => {
      const pixelDimensions = calculatePixelDimensions(window.bounds);
      return pixelDimensions.width < MIN_WINDOW_WIDTH_PX || 
             pixelDimensions.height < MIN_WINDOW_HEIGHT_PX;
    });
    
    const wouldViolate = tooSmallWindows.length > 0;
    console.log('Windows that would be too small:', tooSmallWindows.length);
    console.log('Would violate minimum size:', wouldViolate);
    
    return wouldViolate;
  }, [calculatePixelDimensions]);

  // Define splitWindow before createNewWindow since createNewWindow depends on it
  const splitWindow = useCallback((nodeId, direction, newWindow = null) => {
    // Get the original window's state if it exists
    const originalWindowState = getWindowState(nodeId);
    
    if (!newWindow) {
      newWindow = Node.createWindow(Date.now(), WINDOW_TYPES.TERMINAL);
    }
    
    // If the original window had state, copy it to the new window
    if (originalWindowState) {
      // Clone the content to avoid reference issues
      const clonedContent = JSON.parse(JSON.stringify(originalWindowState.content));
      setWindowState(newWindow.id, newWindow.windowType, clonedContent);
    }
    
    // Check if splitting would result in windows that are too small
    const simulatedRoot = JSON.parse(JSON.stringify(rootNode));
    const simulatedSplitRoot = splitNodeById(simulatedRoot, nodeId, direction, JSON.parse(JSON.stringify(newWindow)));
    
    // Calculate the bounds of all windows after the simulated split
    const simulatedWindows = getWindowBounds(simulatedSplitRoot);
    console.log('Simulating split - number of windows:', simulatedWindows.length);
    
    // Check if any window would be smaller than the minimum size
    const tooSmallWindows = simulatedWindows.filter(window => {
      const pixelDimensions = calculatePixelDimensions(window.bounds);
      return pixelDimensions.width < MIN_WINDOW_WIDTH_PX || 
             pixelDimensions.height < MIN_WINDOW_HEIGHT_PX;
    });
    
    const wouldViolate = tooSmallWindows.length > 0;
    console.log('Split would create windows that are too small:', wouldViolate);
    
    if (wouldViolate) {
      console.log('Split blocked: would result in windows smaller than minimum size');
      // Flash the active window border to indicate we've hit the minimum size
      if (onFlashBorder && activeNodeId) {
        onFlashBorder(activeNodeId);
      }
      return;
    }
  
    updateWorkspace(workspace => ({
      ...workspace,
      root: splitNodeById(workspace.root, nodeId, direction, newWindow)
    }));
  }, [updateWorkspace, getWindowState, setWindowState, rootNode, calculatePixelDimensions]);

  const createNewWindow = useCallback((windowType) => {
    const newNode = Node.createWindow(Date.now(), windowType || WINDOW_TYPES.TERMINAL);
    
    // Initialize window state based on window type
    const initialContent = {};
    
    if (windowType === WINDOW_TYPES.TERMINAL) {
      // Initialize terminal state
      initialContent.history = ['Welcome to the Terminal! Type "help" for available commands.'];
      initialContent.commandHistory = [];
      
      updateWorkspace(workspace => ({
        ...workspace,
        terminalStates: {
          ...workspace.terminalStates,
          [newNode.id]: {
            history: initialContent.history,
            commandHistory: initialContent.commandHistory
          }
        }
      }));
    } else if (windowType === WINDOW_TYPES.EDITOR) {
      // Initialize editor state with default content
      initialContent.text = `function hello() {\n  console.log("Hello, World!");\n}\n\n// Call the function\nhello();`;
    } else if (windowType === WINDOW_TYPES.EXPLORER) {
      // Initialize explorer state
      initialContent.currentPath = '/';
      initialContent.selectedItem = null;
    }
    
    // Set the initial window state
    setWindowState(newNode.id, newNode.windowType, initialContent);
    
    if (!rootNode) {
      // First window, always allowed
      updateWorkspace({
        root: newNode,
        activeNodeId: newNode.id
      });
      return;
    }
    
    if (!activeNodeId) {
      // No active window, but we have a root - this is unusual
      // Let's check if we can add a window without violating minimum size
      const simulatedRoot = JSON.parse(JSON.stringify(rootNode));
      const simulatedWindows = getWindowBounds(simulatedRoot);
      
      // Check if existing windows are already too small
      const tooSmallWindows = simulatedWindows.filter(window => {
        const pixelDimensions = calculatePixelDimensions(window.bounds);
        return pixelDimensions.width < MIN_WINDOW_WIDTH_PX || 
               pixelDimensions.height < MIN_WINDOW_HEIGHT_PX;
      });
      
      if (tooSmallWindows.length > 0) {
        console.log('Cannot create new window: existing windows are already too small');
        // Flash the active window border to indicate we've hit the minimum size
        if (onFlashBorder && activeNodeId) {
          onFlashBorder(activeNodeId);
        }
        return;
      }
      
      updateWorkspace({
        root: newNode,
        activeNodeId: newNode.id
      });
      return;
    }
    
    // Use splitWindow which already has minimum size checks
    splitWindow(activeNodeId, 'vertical', newNode);
    setActiveNodeId(newNode.id);
  }, [rootNode, activeNodeId, updateWorkspace, setActiveNodeId, setWindowState, calculatePixelDimensions, splitWindow]);

  const closeWindow = useCallback((nodeId) => {
    // Clean up window state when closing a window
    removeWindowState(nodeId);
    
    if (rootNode.type === 'window' && rootNode.id === nodeId) {
      updateWorkspace({
        root: null,
        activeNodeId: null
      });
      return;
    }

    const newRoot = JSON.parse(JSON.stringify(rootNode));
    const result = removeNodeById(newRoot, nodeId);
    
    if (activeNodeId === nodeId && result) {
      const nextWindowId = findAllWindowIds(result)[0] || null;
      updateWorkspace({
        root: result,
        activeNodeId: nextWindowId
      });
    } else {
      updateWorkspace({
        root: result
      });
    }
  }, [rootNode, activeNodeId, updateWorkspace, removeWindowState]);

  const transformWindow = useCallback((nodeId, newType) => {
    const newRoot = JSON.parse(JSON.stringify(rootNode));
    
    // Get the current window state before transformation
    const currentWindowState = getWindowState(nodeId);
    
    const updateNodeInTree = (node) => {
      if (!node) return null;
      
      if (node.type === 'window' && node.id === nodeId) {
        // Update the window type
        node.windowType = newType;
        
        // Update the window state with the new type but preserve content
        if (currentWindowState) {
          setWindowState(nodeId, newType, currentWindowState.content);
        }
        
        return true;
      }
      
      if (node.type === 'split') {
        return updateNodeInTree(node.first) || updateNodeInTree(node.second);
      }
      
      return false;
    };
    
    const updated = updateNodeInTree(newRoot);
    if (updated) {
      updateWorkspace({
        root: newRoot
      });
    }
  }, [rootNode, updateWorkspace, getWindowState, setWindowState]);

  const handleCommand = useCallback((command) => {
    const parts = command.split(' ');
    const cmd = parts[0].toLowerCase();

    switch (cmd) {
      case 'split':
        if (activeNodeId) {
          const direction = parts[1] === 'vertical' ? 'vertical' : 'horizontal';
          splitWindow(activeNodeId, direction);
        }
        break;
      case 'close':
        if (activeNodeId) {
          closeWindow(activeNodeId);
        }
        break;
    }
  }, [activeNodeId, splitWindow, closeWindow]);

  const resizeActiveWindow = useCallback((direction) => {
    if (!activeNodeId || !rootNode || !isResizeMode) return;
  
    updateWorkspace(workspace => {
      const newRoot = JSON.parse(JSON.stringify(workspace.root));
      
      // Helper function to find all affected splits and determine if window is in second child
      const findAffectedSplits = (node, targetId) => {
        if (!node) return [];
        
        const splits = [];
        if (node.type === 'split') {
          const targetInFirst = findNodeById(node.first, targetId);
          const targetInSecond = findNodeById(node.second, targetId);
          
          if (targetInFirst || targetInSecond) {
            // Add this split if it matches our resize direction
            if ((direction === 'left' || direction === 'right') && node.direction === 'horizontal') {
              splits.push({ 
                node, 
                targetInFirst: !!targetInFirst,
                // If this is a horizontal split and window is in second child, it's on the right side
                isRightSide: !!targetInSecond && node.direction === 'horizontal'
              });
            }
            if ((direction === 'up' || direction === 'down') && node.direction === 'vertical') {
              splits.push({ 
                node, 
                targetInFirst: !!targetInFirst,
                isRightSide: !!targetInSecond && node.direction === 'horizontal',
                isBottomSide: !!targetInSecond && node.direction === 'vertical'
              });
            }
          }
          
          splits.push(...findAffectedSplits(node.first, targetId));
          splits.push(...findAffectedSplits(node.second, targetId));
        }
        
        return splits;
      };
  
      const affectedSplits = findAffectedSplits(newRoot, activeNodeId);
      const resizeStep = 0.05;
      
      // We no longer block resize operations based on minimum size
      // Just log that windows will be below minimum size
      const willViolateMinSize = wouldViolateMinSize(newRoot, direction, affectedSplits, resizeStep);
      if (willViolateMinSize) {
        console.log('Windows will be below minimum size, but resize is allowed');
      }
  
      // Apply resize to all affected splits
      affectedSplits.forEach(({ node, targetInFirst, isRightSide, isBottomSide }) => {
        // Determine if we need to invert the direction based on window position
        let effectiveDirection = direction;
        if (isRightSide && (direction === 'left' || direction === 'right')) {
          effectiveDirection = direction === 'left' ? 'right' : 'left';
        }
        if (isBottomSide && (direction === 'up' || direction === 'down')) {
          effectiveDirection = direction === 'up' ? 'down' : 'up';
        }
        
        switch (effectiveDirection) {
          case 'left': // Shrink width
            if (targetInFirst) {
              node.splitRatio = Math.max(0.1, node.splitRatio - resizeStep);
            } else {
              node.splitRatio = Math.min(0.9, node.splitRatio + resizeStep);
            }
            break;
            
          case 'right': // Grow width
            if (targetInFirst) {
              node.splitRatio = Math.min(0.9, node.splitRatio + resizeStep);
            } else {
              node.splitRatio = Math.max(0.1, node.splitRatio - resizeStep);
            }
            break;
            
          case 'up': // Shrink height
            if (targetInFirst) {
              node.splitRatio = Math.max(0.1, node.splitRatio - resizeStep);
            } else {
              node.splitRatio = Math.min(0.9, node.splitRatio + resizeStep);
            }
            break;
            
          case 'down': // Grow height
            if (targetInFirst) {
              node.splitRatio = Math.min(0.9, node.splitRatio + resizeStep);
            } else {
              node.splitRatio = Math.max(0.1, node.splitRatio - resizeStep);
            }
            break;
        }
      });
  
      return { ...workspace, root: newRoot };
    });
  }, [activeNodeId, rootNode, isResizeMode, updateWorkspace, wouldViolateMinSize]);
  
  // Also add a debug check to see if the keyboard shortcut and resize mode are working
  useEffect(() => {
    console.log('Resize mode:', isResizeMode);
  }, [isResizeMode]);

  return {
    rootNode,
    activeNodeId,
    setActiveNodeId,
    terminalStates,
    createNewWindow,
    splitWindow,
    closeWindow,
    transformWindow,
    handleCommand,
    navigateToWindow,
    hasActiveWindow: Boolean(activeNodeId),
    hasRootNode: Boolean(rootNode),
    currentWorkspaceIndex,
    workspaceCount: 4,
    switchWorkspace,
    isResizeMode,
    setIsResizeMode,
    resizeActiveWindow
  };
};

================
File: index.html
================
// index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oxygen+Mono&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Window Manager</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

================
File: main.jsx
================
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './styles.css'
import './app.css'
import { WindowStateProvider } from './context/WindowStateContext'
import { AuthProvider } from './context/AuthContext'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <AuthProvider>
      <WindowStateProvider>
        <App />
      </WindowStateProvider>
    </AuthProvider>
  </React.StrictMode>,
)

================
File: models/Node.js
================
/**
 * Node class representing a window or split in the window management system.
 * Forms the foundation of our tree-based window layout structure.
 */
export class Node {
  constructor(id, type) {
    this.id = id;
    this.type = type;
    this.windowType = null;
    this.direction = null;
    this.first = null;
    this.second = null;
    this.splitRatio = 0.5;
    this.minimumSize = 20;
    this.state = null;
  }

  static createWindow(id, windowType, state = null) {
    const node = new Node(id, 'window');
    node.windowType = windowType;
    node.state = state;
    return node;
  }

  static createSplit(direction, first, second, ratio = 0.5) {
    const node = new Node(Date.now(), 'split');
    node.direction = direction;
    node.first = first;
    node.second = second;
    node.splitRatio = ratio;
    return node;
  }
}

================
File: styles.css
================
@import "tailwindcss";

@tailwind base;

@layer base {
  html {
    font-family: 'Oxygen Mono', monospace;
  }
}
@tailwind components;
@tailwind utilities;

html, body, #root {
  width: 100%;
  height: 100vh;
  margin: 0;
  padding: 0;
  overflow: hidden;
}

/* Custom scrollbar styling to match the application theme */
::-webkit-scrollbar {
  width: 8px;  /* for vertical scrollbars */
  height: 8px; /* for horizontal scrollbars */
}

::-webkit-scrollbar-track {
  background: #292524; /* stone-800 */
}

::-webkit-scrollbar-thumb {
  background: #44403c; /* stone-700 */
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #14b8a6; /* teal-500 */
}

/* Firefox scrollbar styling */
* {
  scrollbar-width: thin;
  scrollbar-color: #44403c #292524; /* thumb and track color */
}

.window-container {
  position: absolute;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.window-content {
  flex: 1;
  overflow: auto;
}

.resize-handle {
  position: absolute;
  z-index: 10;
  background-color: transparent;
  transition: background-color 0.2s;
}

.resize-handle:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

.resize-handle.horizontal {
  cursor: col-resize;
  width: 4px;
  height: 100%;
}

.resize-handle.vertical {
  cursor: row-resize;
  width: 100%;
  height: 4px;
}

================
File: styles/main.css
================
/* This imports all of Tailwind's utility classes */
@import "tailwindcss";

/* You can add any custom CSS below this line */

================
File: utils/constants.js
================
// src/utils/constants.js
export const WINDOW_TYPES = {
    EXPLORER: 'explorer',
    EDITOR: 'editor',
    TERMINAL: 'terminal',
    CHART: 'chart',
    IMAGE: 'image',
    AUDIO: 'audio'
  };

================
File: utils/treeUtils.js
================
import { Node } from '../models/Node';

/**
 * Splits a window by ID, ensuring only the target window is affected
 * @param {Node} node - Current node in the tree
 * @param {string} targetId - ID of the window to split
 * @param {string} direction - Split direction ('vertical' or 'horizontal')
 * @param {Node} newWindow - New window to insert
 * @returns {Node} Updated tree structure
 */
export const findFirstWindowId = (node) => {
  if (!node) return null;
  if (node.type === 'window') return node.id;
  return findFirstWindowId(node.first) || findFirstWindowId(node.second);
};

/**
 * Creates a new split by ID, inserting a new window at the specified location
 */
export const splitNodeById = (node, targetId, direction, newWindow) => {
    if (!node) return null;
  
    // If this is the node we want to split
    if (node.id === targetId && node.type === 'window') {
      // Create a new split with the current window and new window
      return Node.createSplit(direction, node, newWindow);
    }
  
    // If this is a split node, recursively check its children
    if (node.type === 'split') {
      // Check if target is in first child
      if (findNodeById(node.first, targetId)) {
        return {
          ...node,
          first: splitNodeById(node.first, targetId, direction, newWindow)
        };
      }
      
      // Check if target is in second child
      if (findNodeById(node.second, targetId)) {
        return {
          ...node,
          second: splitNodeById(node.second, targetId, direction, newWindow)
        };
      }
    }
  
    // If we haven't found the target node, return the original node unchanged
    return node;
  };

export const removeNodeById = (node, targetId) => {
  if (!node) return null;

  if (node.type === 'split') {
    // Only remove if the child is a window node with matching ID
    if (node.first.type === 'window' && node.first.id === targetId) {
      return node.second;
    }
    if (node.second.type === 'window' && node.second.id === targetId) {
      return node.first;
    }

    const firstResult = removeNodeById(node.first, targetId);
    if (firstResult !== node.first) {
      node.first = firstResult;
      return node;
    }

    const secondResult = removeNodeById(node.second, targetId);
    if (secondResult !== node.second) {
      node.second = secondResult;
      return node;
    }
  }

  return node;
};

export const findNodeById = (node, targetId) => {
  if (!node) return null;
  
  if (node.id === targetId && node.type === 'window') return node;
  
  if (node.type === 'split') {
    const firstResult = findNodeById(node.first, targetId);
    if (firstResult) return firstResult;
    
    const secondResult = findNodeById(node.second, targetId);
    if (secondResult) return secondResult;
  }
  
  return null;
};

export const findAllWindowIds = (node) => {
  if (!node) return [];
  if (node.type === 'window') return [node.id];
  return [...findAllWindowIds(node.first), ...findAllWindowIds(node.second)];
};

export const updateSplitRatio = (node, splitId, newRatio) => {
  if (!node) return;

  if (node.type === 'split' && node.id === splitId) {
    node.splitRatio = Math.max(0.2, Math.min(0.8, newRatio));
    return;
  }

  if (node.type === 'split') {
    updateSplitRatio(node.first, splitId, newRatio);
    updateSplitRatio(node.second, splitId, newRatio);
  }
};

================
File: utils/windowSizeConstants.js
================
/**
 * Constants for window size constraints
 * These values define the minimum sizes for windows to ensure they remain usable
 */

// Minimum window dimensions in percentage of screen size
export const MIN_WINDOW_WIDTH_PERCENT = 30; // 30% of screen width
export const MIN_WINDOW_HEIGHT_PERCENT = 30; // 30% of screen height

// Minimum window dimensions in pixels (used for absolute size checks)
export const MIN_WINDOW_WIDTH_PX = 300; // 300px minimum width
export const MIN_WINDOW_HEIGHT_PX = 200; // 200px minimum height

// Maximum number of windows total (regardless of arrangement)
export const MAX_HORIZONTAL_WINDOWS = 4; // Maximum windows total
export const MAX_VERTICAL_WINDOWS = 4;   // Maximum windows total

================
File: utils/windowTypes.js
================
// src/utils/windowTypes.js
import { FolderOpen, Code, Terminal as TerminalIcon, Eye } from 'lucide-react';
import { WINDOW_TYPES } from './constants';

// Import individually to avoid circular dependency
import { 
  EnhancedTerminalWindow,
  EnhancedEditorWindow,
  EnhancedExplorerWindow,
  EnhancedPreviewWindow,
  EnhancedImageWindow,
  EnhancedAudioWindow
} from '../components/windows';

export { WINDOW_TYPES };

export const WINDOW_CONTENT = {
  [WINDOW_TYPES.EXPLORER]: {
    title: 'File Explorer',
    icon: FolderOpen,
    component: EnhancedExplorerWindow
  },
  [WINDOW_TYPES.EDITOR]: {
    title: 'Code Editor',
    icon: Code,
    component: EnhancedEditorWindow
  },
  [WINDOW_TYPES.TERMINAL]: {
    title: 'Terminal',
    icon: TerminalIcon,
    component: EnhancedTerminalWindow
  },
  [WINDOW_TYPES.CHART]: {
    title: 'Chart',
    icon: Eye,
    component: EnhancedPreviewWindow
  },
  [WINDOW_TYPES.IMAGE]: {
    title: 'Image',
    icon: Eye,
    component: EnhancedImageWindow
  },
  [WINDOW_TYPES.AUDIO]: {
    title: 'Audio Player',
    icon: Eye,
    component: EnhancedAudioWindow
  }
};

================
File: utils/windowUtils.js
================
/**
 * Contains utility functions for window-specific calculations and operations.
 * These functions focus on spatial relationships and window bounds rather than
 * tree structure manipulation.
 */

/**
 * Calculates the bounds of windows in the tree. Each window gets its position
 * and size as percentages of the available space.
 * 
 * @param {Node} node - The node to calculate bounds for
 * @param {Object} available - The available space in percentages
 * @returns {Array} Array of objects containing window IDs and their bounds
 */
export const getWindowBounds = (node, available = { x: 0, y: 0, width: 100, height: 100 }) => {
    if (node.type === 'window') {
      return [{
        id: node.id,
        bounds: {
          left: available.x,
          top: available.y,
          right: available.x + available.width,
          bottom: available.y + available.height,
          width: available.width,
          height: available.height,
          centerX: available.x + (available.width / 2),
          centerY: available.y + (available.height / 2)
        }
      }];
    }
  
    // For split nodes, recursively get bounds of children
    const bounds = [];
    
    if (node.direction === 'horizontal') {
      const firstHalf = {
        x: available.x,
        y: available.y,
        width: available.width * node.splitRatio,
        height: available.height
      };
      const secondHalf = {
        x: available.x + (available.width * node.splitRatio),
        y: available.y,
        width: available.width * (1 - node.splitRatio),
        height: available.height
      };
      bounds.push(...getWindowBounds(node.first, firstHalf));
      bounds.push(...getWindowBounds(node.second, secondHalf));
    } else {
      const firstHalf = {
        x: available.x,
        y: available.y,
        width: available.width,
        height: available.height * node.splitRatio
      };
      const secondHalf = {
        x: available.x,
        y: available.y + (available.height * node.splitRatio),
        width: available.width,
        height: available.height * (1 - node.splitRatio)
      };
      bounds.push(...getWindowBounds(node.first, firstHalf));
      bounds.push(...getWindowBounds(node.second, secondHalf));
    }
  
    return bounds;
  };
  
  /**
   * Determines if two windows are adjacent in a specific direction.
   * Uses a small tolerance value to account for floating-point calculations.
   * 
   * @param {Object} window1 - First window with bounds
   * @param {Object} window2 - Second window with bounds
   * @param {string} direction - Direction to check ('left', 'right', 'up', 'down')
   * @returns {boolean} Whether the windows are adjacent
   */
  export const areWindowsAdjacent = (window1, window2, direction) => {
    const tolerance = 0.01; // 1% tolerance for floating point comparisons
    
    switch (direction) {
      case 'left':
        return Math.abs(window1.bounds.left - window2.bounds.right) < tolerance &&
               !(window1.bounds.bottom < window2.bounds.top || window1.bounds.top > window2.bounds.bottom);
      case 'right':
        return Math.abs(window1.bounds.right - window2.bounds.left) < tolerance &&
               !(window1.bounds.bottom < window2.bounds.top || window1.bounds.top > window2.bounds.bottom);
      case 'up':
        return Math.abs(window1.bounds.top - window2.bounds.bottom) < tolerance &&
               !(window1.bounds.right < window2.bounds.left || window1.bounds.left > window2.bounds.right);
      case 'down':
        return Math.abs(window1.bounds.bottom - window2.bounds.top) < tolerance &&
               !(window1.bounds.right < window2.bounds.left || window1.bounds.left > window2.bounds.right);
      default:
        return false;
    }
  };
  
  /**
   * Finds the next window in a specified direction from the active window.
   * 
   * @param {Node} rootNode - The root node of the window tree
   * @param {string} activeNodeId - ID of the currently active window
   * @param {string} direction - Direction to look for the next window
   * @returns {string|null} ID of the next window, or null if none found
   */
  export const findNextWindow = (rootNode, activeNodeId, direction) => {
    const allWindows = getWindowBounds(rootNode);
    const activeWindow = allWindows.find(w => w.id === activeNodeId);
    if (!activeWindow) return null;
  
    const adjacentWindows = allWindows.filter(w => 
      w.id !== activeNodeId && areWindowsAdjacent(activeWindow, w, direction)
    );
  
    if (adjacentWindows.length === 0) return null;
  
    // Sort adjacent windows based on position and direction
    let nextWindow;
    switch (direction) {
      case 'left':
        nextWindow = adjacentWindows.sort((a, b) => 
          a.bounds.centerX !== b.bounds.centerX
            ? b.bounds.centerX - a.bounds.centerX
            : a.bounds.centerY - b.bounds.centerY
        )[0];
        break;
      case 'right':
        nextWindow = adjacentWindows.sort((a, b) => 
          a.bounds.centerX !== b.bounds.centerX
            ? a.bounds.centerX - b.bounds.centerX
            : a.bounds.centerY - b.bounds.centerY
        )[0];
        break;
      case 'up':
        nextWindow = adjacentWindows.sort((a, b) => 
          a.bounds.centerY !== b.bounds.centerY
            ? b.bounds.centerY - a.bounds.centerY
            : a.bounds.centerX - b.bounds.centerX
        )[0];
        break;
      case 'down':
        nextWindow = adjacentWindows.sort((a, b) => 
          a.bounds.centerY !== b.bounds.centerY
            ? a.bounds.centerY - b.bounds.centerY
            : a.bounds.centerX - b.bounds.centerX
        )[0];
        break;
    }
  
    return nextWindow?.id || null;
  };



================================================================
End of Codebase
================================================================
