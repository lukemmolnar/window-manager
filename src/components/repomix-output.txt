This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
auth/AuthScreen.jsx
auth/index.js
auth/Login.jsx
auth/Register.jsx
CommandBar.jsx
EmptyState.jsx
WindowManager.jsx
windows/AdminWindow.jsx
windows/AudioWindow.jsx
windows/CanvasPreview.jsx
windows/CanvasWindow.jsx
windows/ChatWindow.jsx
windows/DiceRollGif.jsx
windows/explorer/api/fileOperations.js
windows/explorer/components/canvas/CanvasContainer.jsx
windows/explorer/components/canvas/CanvasEditor.jsx
windows/explorer/components/canvas/TextNode.jsx
windows/explorer/components/CanvasEditor.jsx
windows/explorer/components/CommandInput.jsx
windows/explorer/components/dialogs/FileDialogs.jsx
windows/explorer/components/FileContent.jsx
windows/explorer/components/FileTree.jsx
windows/explorer/components/MapEditor.jsx
windows/explorer/components/nodes/index.js
windows/explorer/components/nodes/TextNode.jsx
windows/explorer/components/StorageStats.jsx
windows/explorer/ExplorerWindow.jsx
windows/explorer/README.md
windows/explorer/state/useExplorerState.js
windows/explorer/utils/canvasUtils.js
windows/explorer/utils/fileUtils.js
windows/explorer/utils/markdownUtils.js
windows/ExplorerWindow-fix.jsx
windows/ExplorerWindow.css
windows/ExplorerWindow.jsx
windows/index.js
windows/mapeditor/components/OpacitySlider.jsx
windows/mapeditor/LayerPanel.jsx
windows/mapeditor/MapCanvas.jsx
windows/mapeditor/MapPropertiesPanel.jsx
windows/mapeditor/MapToolbar.jsx
windows/mapeditor/README.md
windows/mapeditor/styles/RangeSlider.css
windows/mapeditor/TilePalette.jsx
windows/mapeditor/TilePaletteWithMarketplace.jsx
windows/mapeditor/TilesetSelector.jsx
windows/mapeditor/utils/dynamicTileRegistry.js
windows/mapeditor/utils/mapUtils.js
windows/mapeditor/utils/tileRegistry.js
windows/MapEditorWindow.jsx
windows/MarketplaceWindow.jsx
windows/TerminalWindow.jsx

================================================================
Files
================================================================

================
File: auth/AuthScreen.jsx
================
import React from 'react';
import { Login } from './Login';

export function AuthScreen() {
  return <Login />;
}

================
File: auth/index.js
================
export { AuthScreen } from './AuthScreen';
export { Login } from './Login';

================
File: auth/Login.jsx
================
import React, { useState } from 'react';
import { useAuth } from '../../context/AuthContext';
import emptyStateSvg from '../../assets/SVG/emptyState.svg';

export function Login() {
  const { login, error, clearError, loading } = useAuth();
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = async (e) => {
    e.preventDefault();
    clearError();
    await login(username, password);
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-stone-950">
      <div className="bg-stone-950 p-8 rounded-lg w-full max-w-md">
      <div className="flex justify-center mb-4">
          <img 
            src={emptyStateSvg} 
            alt="Empty State" 
            className="h-auto"
          />
        </div>
        <h2 className="text-2xl font-bold text-teal-500 mb-6 text-center">SLUMNET</h2>
        
        {error && (
          <div className="bg-red-900 text-white p-3 rounded mb-4">
            {error}
          </div>
        )}
        
        
        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label className="block text-stone-300 mb-2 font-mono text-sm" htmlFor="username">
              Username
            </label>
            <input
              id="username"
              type="text"
              className="w-full p-2 rounded bg-stone-800 text-white border border-stone-600 focus:border-teal-500 focus:outline-none font-mono text-sm"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              required
            />
          </div>
          
          <div className="mb-6">
            <label className="block text-stone-300 mb-2 font-mono text-sm" htmlFor="password">
              Password
            </label>
            <input
              id="password"
              type="password"
              className="w-full p-2 rounded bg-stone-800 text-white border border-stone-600 focus:border-teal-500 focus:outline-none font-mono text-sm"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
          </div>
          
          <button
            type="submit"
            className="w-full bg-teal-600 hover:bg-teal-700 text-white font-mono text-sm py-2 px-4 rounded focus:outline-none focus:shadow-outline"
            disabled={loading}
          >
            {loading ? 'Logging in...' : 'Login'}
          </button>
        </form>
        
        <div className="mt-4 text-center">
          <p className="text-stone-400 text-sm font-mono">
            Are ya in the know?
          </p>
        </div>
      </div>
    </div>
  );
}

================
File: auth/Register.jsx
================
import React, { useState } from 'react';
import { useAuth } from '../../context/AuthContext';

export function Register({ onSwitchToLogin }) {
  const { register, error, clearError, loading } = useAuth();
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [passwordError, setPasswordError] = useState('');
  const [success, setSuccess] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    clearError();
    setPasswordError('');
    
    // Validate passwords match
    if (password !== confirmPassword) {
      setPasswordError('Passwords do not match');
      return;
    }
    
    // Validate password strength
    if (password.length < 8) {
      setPasswordError('Password must be at least 8 characters long');
      return;
    }
    
    const result = await register(username, email, password);
    if (result.success) {
      setSuccess(true);
      // Reset form
      setUsername('');
      setEmail('');
      setPassword('');
      setConfirmPassword('');
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-900">
      <div className="bg-gray-800 p-8 rounded-lg shadow-lg w-full max-w-md">
        <h2 className="text-2xl font-bold text-teal-500 mb-6 text-center">Create an Account</h2>
        
        {error && (
          <div className="bg-red-900 text-white p-3 rounded mb-4">
            {error}
          </div>
        )}
        
        {passwordError && (
          <div className="bg-red-900 text-white p-3 rounded mb-4">
            {passwordError}
          </div>
        )}
        
        {success && (
          <div className="bg-green-900 text-white p-3 rounded mb-4">
            Registration successful! You can now login.
          </div>
        )}
        
        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label className="block text-gray-300 mb-2" htmlFor="username">
              Username
            </label>
            <input
              id="username"
              type="text"
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:border-teal-500 focus:outline-none"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              required
            />
          </div>
          
          <div className="mb-4">
            <label className="block text-gray-300 mb-2" htmlFor="email">
              Email
            </label>
            <input
              id="email"
              type="email"
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:border-teal-500 focus:outline-none"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
            />
          </div>
          
          <div className="mb-4">
            <label className="block text-gray-300 mb-2" htmlFor="password">
              Password
            </label>
            <input
              id="password"
              type="password"
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:border-teal-500 focus:outline-none"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
            <p className="text-gray-400 text-xs mt-1">Must be at least 8 characters long</p>
          </div>
          
          <div className="mb-6">
            <label className="block text-gray-300 mb-2" htmlFor="confirmPassword">
              Confirm Password
            </label>
            <input
              id="confirmPassword"
              type="password"
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:border-teal-500 focus:outline-none"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              required
            />
          </div>
          
          <button
            type="submit"
            className="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
            disabled={loading}
          >
            {loading ? 'Registering...' : 'Register'}
          </button>
        </form>
        
        <div className="mt-4 text-center">
          <button
            onClick={onSwitchToLogin}
            className="text-teal-400 hover:text-teal-300 text-sm"
          >
            Already have an account? Login
          </button>
        </div>
      </div>
    </div>
  );
}

================
File: CommandBar.jsx
================
import React, { useEffect, useRef } from 'react';
import { useAnnouncement } from '../context/AnnouncementContext';
import { useActiveUsers } from '../context/ActiveUsersContext';

export const CommandBar = ({ 
  currentWorkspaceIndex = 0,
  switchWorkspace,
  user,
  onLogout
}) => {
  console.log('CommandBar render, currentWorkspaceIndex:', currentWorkspaceIndex);
  const { announcement } = useAnnouncement();
  const { activeUserCount } = useActiveUsers();
  const announcementRef = useRef(null);
  const containerRef = useRef(null);

  // Carousel effect for long announcements with consistent speed
  useEffect(() => {
    if (!announcement || !announcementRef.current || !containerRef.current) return;
    
    const textElement = announcementRef.current;
    const containerElement = containerRef.current;
    const isOverflowing = textElement.scrollWidth > containerElement.clientWidth;
    
    if (isOverflowing) {
      // Fixed animation duration of 15 seconds
      textElement.style.animation = 'scroll-text 40s linear infinite';
    } else {
      textElement.style.animation = 'none';
    }
  }, [announcement]);

  return (
    <div className="w-full bg-stone-800 p-2 flex items-center gap-2">
      <div className="flex gap-2 items-center pr-2 border-r border-stone-600">
        <div className={`rounded-full cursor-pointer ${currentWorkspaceIndex === 0 ? 'w-3 h-3 bg-teal-400' : 'w-2 h-2 bg-stone-600 hover:bg-stone-500'}`} onClick={() => typeof switchWorkspace === 'function' && switchWorkspace(0)} />
        <div className={`rounded-full cursor-pointer ${currentWorkspaceIndex === 1 ? 'w-3 h-3 bg-teal-400' : 'w-2 h-2 bg-stone-600 hover:bg-stone-500'}`} onClick={() => typeof switchWorkspace === 'function' && switchWorkspace(1)} />
        <div className={`rounded-full cursor-pointer ${currentWorkspaceIndex === 2 ? 'w-3 h-3 bg-teal-400' : 'w-2 h-2 bg-stone-600 hover:bg-stone-500'}`} onClick={() => typeof switchWorkspace === 'function' && switchWorkspace(2)} />
        <div className={`rounded-full cursor-pointer ${currentWorkspaceIndex === 3 ? 'w-3 h-3 bg-teal-400' : 'w-2 h-2 bg-stone-600 hover:bg-stone-500'}`} onClick={() => typeof switchWorkspace === 'function' && switchWorkspace(3)} />
      </div>
      
      {/* Announcement section with improved container */}
      <div ref={containerRef} className="flex-1 announcement-container">
        {announcement ? (
          <div 
            ref={announcementRef}
            className="announcement-text text-teal-300 text-sm font-mono"
          >
            {announcement}
          </div>
        ) : (
          <div className="text-gray-500 text-sm font-mono italic">No announcements</div>
        )}
      </div>
      
      {/* Command bar right section with active users and user info */}
      {user && (
        <>
          {/* Active users section */}
          <div className="flex items-center border-l border-stone-600 ml-2 pl-2">
            <div className="flex items-center text-teal-400 text-sm font-mono">
              <span className="leading-none">{activeUserCount}</span>
              <svg className="h-3 w-3 ml-0.5" viewBox="0 0 24 24" fill="currentColor"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z" /></svg>
            </div>
          </div>
          
          {/* Username and logout section */}
          <div className="flex items-center pl-2">
            <span className="text-white text-sm font-mono mr-2">
              {user?.username || 'User'} 
            </span>
            <button 
              onClick={onLogout}
              className="bg-stone-700 hover:bg-stone-600 text-white text-sm px-2 py-1 rounded"
            >
              Logout
            </button>
          </div>
        </>
      )}
    </div>
  );
};

export default CommandBar;

================
File: EmptyState.jsx
================
import React from 'react';
import emptyStateSvg from '../assets/SVG/emptyState.svg';

export const EmptyState = () => (
  <div className="absolute inset-0 flex flex-col items-center justify-center bg-stone-950">
    <img 
      src={emptyStateSvg} 
      alt="Empty State" 
      className="w-1/4 h-auto"
    />
    <h2 className="text-xl font-semibold text-teal-400 mt-4">SLUMNET</h2>
  </div>
);

export default EmptyState;

================
File: WindowManager.jsx
================
import React, { useState, useCallback, useEffect } from 'react';
import { WINDOW_CONTENT, WINDOW_TYPES } from '../utils/windowTypes';
import { getWindowBounds } from '../utils/windowUtils';
import { useWindowManager } from '../hooks/useWindowManager';
import { useKeyboardShortcuts } from '../hooks/useKeyboardShortcuts';
import { CommandBar } from './CommandBar';
import EmptyState from './EmptyState';

export const WindowManager = ({ defaultLayout = null }) => {
  const [dragState, setDragState] = useState(null);
  const [notification, setNotification] = useState(null);
  const [flashingWindowIds, setFlashingWindowIds] = useState(new Set());
  
  // Function to flash a window's border red
  const flashWindowBorder = useCallback((windowId) => {
    setFlashingWindowIds(prev => {
      const newSet = new Set(prev);
      newSet.add(windowId);
      return newSet;
    });
    
    // Remove the window from flashing state after 500ms
    setTimeout(() => {
      setFlashingWindowIds(prev => {
        const newSet = new Set(prev);
        newSet.delete(windowId);
        return newSet;
      });
    }, 200);
  }, []);

  const {
    rootNode,
    activeNodeId,
    setActiveNodeId,
    terminalStates,
    updateTerminalState,
    splitWindow,
    createNewWindow,
    closeWindow,
    transformWindow,
    currentWorkspaceIndex,
    workspaceCount,
    switchWorkspace,
    isResizeMode,
    setIsResizeMode,
    resizeActiveWindow,
    isMoveMode,
    setIsMoveMode,
    moveSourceWindowId,
    setMoveSourceWindowId,
    swapWindows
  } = useWindowManager({ 
    defaultLayout,
    onFlashBorder: flashWindowBorder
  });
  
  // Override window.alert to use our notification system
  useEffect(() => {
    const originalAlert = window.alert;
    window.alert = (message) => {
      console.log('Alert:', message);
      
      // If the message is about splitting or creating windows, flash the active window border
      if (message.includes('split') || message.includes('create')) {
        if (activeNodeId) {
          flashWindowBorder(activeNodeId);
        }
      } else {
        // For other alerts, show the notification
        setNotification(message);
        setTimeout(() => setNotification(null), 3000); // Hide after 3 seconds
      }
    };
    
    return () => {
      window.alert = originalAlert;
    };
  }, [activeNodeId, flashWindowBorder]);

  // Log when component mounts
  useEffect(() => {
    console.log('WindowManager component mounted');
    console.log('setIsMoveMode is a function:', typeof setIsMoveMode === 'function');
    console.log('Initial isMoveMode state:', isMoveMode);
  }, [isMoveMode]);
  
  // Log move mode state changes
  useEffect(() => {
    console.log('Move mode changed to:', isMoveMode);
  }, [isMoveMode]);

  // Add keyboard shortcuts
  useKeyboardShortcuts({
    onSplitVertical: () => splitWindow(activeNodeId, 'vertical'),
    onSplitHorizontal: () => splitWindow(activeNodeId, 'horizontal'),
    onClose: () => closeWindow(activeNodeId),
    createNewWindow,
    hasActiveWindow: Boolean(activeNodeId),
    hasRootNode: Boolean(rootNode),
    isResizeMode,
    setIsResizeMode,
    resizeActiveWindow,
    isMoveMode,
    setIsMoveMode,
    moveSourceWindowId,
    setMoveSourceWindowId,
    swapWindows,
    activeNodeId
  });

  // Command handling for terminal
  const handleCommand = useCallback((command) => {
    const parts = command.split(' ');
    const cmd = parts[0].toLowerCase();

    switch (cmd) {
      case 'split':
        if (activeNodeId) {
          const direction = parts[1] === 'vertical' ? 'vertical' : 'horizontal';
          splitWindow(activeNodeId, direction);
        }
        break;
      case 'close':
        if (activeNodeId) {
          closeWindow(activeNodeId);
        }
        break;
    }
  }, [activeNodeId, splitWindow, closeWindow]);

  // Resize handling
  const handleResizeStart = useCallback((e, split) => {
    e.preventDefault();
    e.stopPropagation();
    const rect = e.currentTarget.getBoundingClientRect();
    setDragState({
      split,
      initialPos: {
        x: e.clientX,
        y: e.clientY
      },
      initialRatio: split.splitRatio
    });
  }, []);

  // Helper function to convert percentage-based bounds to pixel dimensions
  const calculatePixelDimensions = useCallback((bounds) => {
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    
    return {
      width: (bounds.width / 100) * windowWidth,
      height: (bounds.height / 100) * windowHeight
    };
  }, []);
  
  // Helper function to check if a window tree would have any windows smaller than the minimum size
  const hasWindowsBelowMinSize = useCallback((root) => {
    if (!root) return false;
    
    // Import constants directly here to avoid dependency issues
    const MIN_WINDOW_WIDTH_PX = 300;
    const MIN_WINDOW_HEIGHT_PX = 200;
    
    // Calculate the bounds of all windows
    const allWindows = getWindowBounds(root);
    
    // Check if any window would be smaller than the minimum size
    return allWindows.some(window => {
      const pixelDimensions = calculatePixelDimensions(window.bounds);
      const isTooSmall = pixelDimensions.width < MIN_WINDOW_WIDTH_PX || 
                         pixelDimensions.height < MIN_WINDOW_HEIGHT_PX;
      
      if (isTooSmall) {
        console.log('Window too small:', window.id);
        console.log('Dimensions:', pixelDimensions);
      }
      
      return isTooSmall;
    });
  }, [calculatePixelDimensions]);

  const handleResizeMove = useCallback((e) => {
    if (!dragState) return;

    const { split, initialPos, initialRatio } = dragState;
    const delta = split.direction === 'horizontal' 
      ? (e.clientX - initialPos.x) / window.innerWidth 
      : (e.clientY - initialPos.y) / window.innerHeight;

    const newRatio = Math.max(0.1, Math.min(0.9, initialRatio + delta));
    
    // Store the original ratio
    const originalRatio = split.splitRatio;
    
    // Apply the new ratio
    split.splitRatio = newRatio;
    
    // Check if this would result in windows that are too small, but don't block the resize
    if (hasWindowsBelowMinSize(rootNode)) {
      console.log('Windows are below minimum size, but resize is allowed');
    }
    
    // If we get here, the resize is allowed
    // Force a re-render
    setDragState(prev => ({ ...prev }));
  }, [dragState, rootNode, hasWindowsBelowMinSize, activeNodeId, flashWindowBorder]);

  const handleResizeEnd = useCallback(() => {
    setDragState(null);
  }, []);

  useEffect(() => {
    if (dragState) {
      window.addEventListener('mousemove', handleResizeMove);
      window.addEventListener('mouseup', handleResizeEnd);
      return () => {
        window.removeEventListener('mousemove', handleResizeMove);
        window.removeEventListener('mouseup', handleResizeEnd);
      };
    }
  }, [dragState, handleResizeMove, handleResizeEnd]);

  // Window tree renderer
  const WindowTreeRenderer = ({ node, depth = 0, available = { x: 0, y: 0, width: 100, height: 100 } }) => {
    if (!node) return null;

    if (node.type === 'window') {
      const windowContent = WINDOW_CONTENT[node.windowType];
      if (!windowContent) {
        console.error('No window content found for type:', node.windowType);
        return null;
      }
      const Component = windowContent.component;
      const isActive = node.id === activeNodeId;
  
      // Check if this window is currently flashing
      const isFlashing = flashingWindowIds.has(node.id);
      
      // Check if this is the first selected window in move mode
      const isFirstSelectedWindow = isMoveMode && moveSourceWindowId === node.id;
      
      return (
        <div
          className={`absolute overflow-hidden border-1 ${
            isFlashing ? 'border-red-600' : 
            isFirstSelectedWindow ? 'border-blue-300' :
            isActive ? (
              isMoveMode ? 'border-green-500' : 
              isResizeMode ? 'border-yellow-500' : 
              'border-teal-500'
            ) : 'border-stone-600'
          } ${isFlashing ? 'animate-pulse' : ''}`}
          style={{
            left: `${available.x}%`,
            top: `${available.y}%`,
            width: `${available.width}%`,
            height: `${available.height}%`,
            transition: 'border-color 0.2s ease-in-out'
          }}
          onClick={() => setActiveNodeId(node.id)}
        >
          <Component 
            key={`window-${node.id}-${node.windowType}`}
            onCommand={handleCommand} 
            isActive={isActive}
            nodeState={node.state}
            nodeId={node.id}
            transformWindow={transformWindow}
            windowState={node.windowType === WINDOW_TYPES.TERMINAL ? terminalStates[node.id] : node.state}
            updateWindowState={(newState) => {
              updateTerminalState(node.id, newState);
            }}
          />
        </div>
      );
    }

    // Calculate split dimensions
    let firstDimensions, secondDimensions;
    if (node.direction === 'horizontal') {
      firstDimensions = {
        x: available.x,
        y: available.y,
        width: available.width * node.splitRatio,
        height: available.height
      };
      secondDimensions = {
        x: available.x + (available.width * node.splitRatio),
        y: available.y,
        width: available.width * (1 - node.splitRatio),
        height: available.height
      };
    } else {
      firstDimensions = {
        x: available.x,
        y: available.y,
        width: available.width,
        height: available.height * node.splitRatio
      };
      secondDimensions = {
        x: available.x,
        y: available.y + (available.height * node.splitRatio),
        width: available.width,
        height: available.height * (1 - node.splitRatio)
      };
    }

    return (
      <div className="absolute inset-0" style={{ pointerEvents: 'none' }}>
        <WindowTreeRenderer 
          node={node.first} 
          depth={depth + 1} 
          available={firstDimensions} 
        />
        <div
          className="absolute bg-stone-700 hover:bg-stone-500 transition-colors"
          style={{
            left: node.direction === 'horizontal' ? `${firstDimensions.width}%` : 0,
            top: node.direction === 'vertical' ? `${firstDimensions.height}%` : 0,
            width: node.direction === 'horizontal' ? '4px' : '100%',
            height: node.direction === 'vertical' ? '4px' : '100%',
            cursor: node.direction === 'horizontal' ? 'col-resize' : 'row-resize',
            pointerEvents: 'auto',
            zIndex: 10
          }}
          onMouseDown={(e) => handleResizeStart(e, node)}
        />
        <WindowTreeRenderer 
          node={node.second} 
          depth={depth + 1} 
          available={secondDimensions}
        />
      </div>
    );
  };

  return (
    <div className="w-full h-screen flex flex-col">
      <CommandBar
        onCommand={handleCommand}
        currentWorkspaceIndex={currentWorkspaceIndex}
        switchWorkspace={switchWorkspace}
      />
      <div className="flex-1 relative bg-stone-900">
        {rootNode ? (
          <WindowTreeRenderer
            node={rootNode}
            terminalStates={terminalStates}
            updateTerminalState={updateTerminalState}
          />
        ) : (
          <EmptyState />
        )}
        
        {/* Notification system */}
        {notification && (
          <div 
            className="absolute top-4 left-1/2 transform -translate-x-1/2 bg-red-500 text-white px-4 py-2 rounded shadow-lg z-50"
            style={{ maxWidth: '80%' }}
          >
            {notification}
          </div>
        )}
      </div>
    </div>
  );
};

export default WindowManager;

================
File: windows/AdminWindow.jsx
================
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import API_CONFIG from '../../config/api';
import { useAuth } from '../../context/AuthContext';
import { Trash } from 'lucide-react'; // Import Trash icon

const AdminWindow = ({ isActive }) => {
  const { user } = useAuth();
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [editingUser, setEditingUser] = useState(null);
  const [showCreateForm, setShowCreateForm] = useState(false);
  const [formData, setFormData] = useState({
    username: '',
    password: '',
    is_admin: false,
    has_file_access: false
  });
  const [createFormData, setCreateFormData] = useState({
    username: '',
    password: '',
    is_admin: false,
    has_file_access: false
  });
  
  // Chat channels state
  const [activeTab, setActiveTab] = useState('users'); // 'users' or 'channels'
  const [channels, setChannels] = useState([]);
  const [channelLoading, setChannelLoading] = useState(false);
  const [channelError, setChannelError] = useState(null);
  const [newChannelName, setNewChannelName] = useState('');
  const [showCreateChannelForm, setShowCreateChannelForm] = useState(false);

  // Fetch users when component mounts
  useEffect(() => {
    fetchUsers();
  }, []); // Empty dependency array means this runs once on mount
  
  // Load channels when tab changes to channels
  useEffect(() => {
    if (activeTab === 'channels') {
      fetchChannels();
    }
  }, [activeTab]);
  
  // Reset form visibility when switching tabs
  useEffect(() => {
    // Hide forms when switching tabs
    setShowCreateForm(false);
    setShowCreateChannelForm(false);
  }, [activeTab]);

  // Fetch all users from the API
  const fetchUsers = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem('auth_token');
      const response = await axios.get(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.USERS}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      setUsers(response.data);
      setError(null);
    } catch (err) {
      console.error('Failed to fetch users:', err);
      setError('Failed to load users. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Start editing a user
  const handleEdit = (user) => {
    setEditingUser(user.id);
    setFormData({
      username: user.username,
      password: '', // Don't populate password for security
      is_admin: user.is_admin === 1 || user.is_admin === true,
      has_file_access: user.has_file_access === 1 || user.has_file_access === true,
      storage_quota: user.storage_quota || 52428800 // Default to 50MB (52428800 bytes)
    });
  };

  // Cancel editing
  const handleCancel = () => {
    setEditingUser(null);
    setFormData({
      username: '',
      password: '',
      is_admin: false,
      has_file_access: false
    });
  };

  // Handle form input changes for editing
  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  // Handle form input changes for creating
  const handleCreateChange = (e) => {
    const { name, value, type, checked } = e.target;
    setCreateFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  // Save user changes
  const handleSave = async (userId) => {
    try {
      setLoading(true);
      const token = localStorage.getItem('auth_token');
      
      // Build user data object
      const userData = {
        username: formData.username,
        is_admin: formData.is_admin,
        has_file_access: formData.has_file_access,
        storage_quota: formData.storage_quota
      };
      
      // Only include password in the request if it was changed
      if (formData.password) {
        userData.password = formData.password;
      }
      
      await axios.put(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.USERS}/${userId}`,
        userData,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      // Refresh the user list
      await fetchUsers();
      setEditingUser(null);
      setFormData({
        username: '',
        password: '',
        is_admin: false,
        has_file_access: false
      });
    } catch (err) {
      console.error('Failed to update user:', err);
      setError('Failed to update user. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Create a new user
  const handleCreateUser = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem('auth_token');
      
      // Validate form data - only username and password are required
      if (!createFormData.username || !createFormData.password) {
        setError('Username and password are required.');
        setLoading(false);
        return;
      }
      
      // Use the register endpoint instead of users endpoint
      await axios.post(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.REGISTER}`,
        {
          username: createFormData.username,
          password: createFormData.password
        }
      );
      
      // If admin status or file access permissions need to be set, we need to do that in a separate request
      if (createFormData.is_admin || createFormData.has_file_access) {
        try {
          // Get the newly created user
          const usersResponse = await axios.get(
            `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.USERS}`,
            { headers: { Authorization: `Bearer ${token}` } }
          );
          
          const newUser = usersResponse.data.find(u => u.username === createFormData.username);
          
          if (newUser) {
            // Update the user with admin status and file access permissions
            await axios.put(
              `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.USERS}/${newUser.id}`,
              { 
                is_admin: createFormData.is_admin,
                has_file_access: createFormData.has_file_access,
                storage_quota: createFormData.storage_quota || 52428800 // Default to 50MB
              },
              { headers: { Authorization: `Bearer ${token}` } }
            );
          }
        } catch (adminErr) {
          console.error('Failed to set admin status:', adminErr);
          // Don't fail the whole operation if just the admin part fails
        }
      }
      
      // Refresh the user list
      await fetchUsers();
      
      // Reset form and hide it
      setCreateFormData({
        username: '',
        password: '',
        is_admin: false,
        has_file_access: false
      });
      setShowCreateForm(false);
      setError(null);
    } catch (err) {
      console.error('Failed to create user:', err);
      setError(err.response?.data?.message || 'Failed to create user. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Toggle create form visibility
  const toggleCreateForm = () => {
    setShowCreateForm(!showCreateForm);
    if (!showCreateForm) {
      // Reset form data when opening
      setCreateFormData({
        username: '',
        password: '',
        is_admin: false,
        has_file_access: false
      });
    }
  };
  
  // Toggle create channel form visibility
  const toggleCreateChannelForm = () => {
    setShowCreateChannelForm(!showCreateChannelForm);
    if (!showCreateChannelForm) {
      // Reset channel name when opening the form
      setNewChannelName('');
    }
  };

  // Render loading state
  if (loading && users.length === 0) {
    return (
      <div className="bg-stone-900 text-white p-4 h-full flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-teal-500 mx-auto mb-4"></div>
          <p>Loading users...</p>
        </div>
      </div>
    );
  }

  // Render error state
  if (error && users.length === 0) {
    return (
      <div className="bg-stone-900 text-white p-4 h-full flex items-center justify-center">
        <div className="text-center text-red-500">
          <p>{error}</p>
          <button 
            onClick={fetchUsers}
            className="mt-4 px-4 py-2 bg-stone-700 hover:bg-stone-600 rounded"
          >
            Try Again
          </button>
        </div>
      </div>
    );
  }

  // Fetch chat channels
  const fetchChannels = async () => {
    try {
      setChannelLoading(true);
      const token = localStorage.getItem('auth_token');
      const response = await axios.get(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.CHAT_ROOMS}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      setChannels(response.data);
      setChannelError(null);
    } catch (err) {
      console.error('Failed to fetch channels:', err);
      setChannelError('Failed to load chat channels. Please try again.');
    } finally {
      setChannelLoading(false);
    }
  };

  // Create a new chat channel
  const handleCreateChannel = async (e) => {
    e.preventDefault();
    if (!newChannelName.trim()) return;

    try {
      setChannelLoading(true);
      const token = localStorage.getItem('auth_token');
      await axios.post(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.CHAT_ROOMS}`,
        { name: newChannelName },
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      // Refresh the channel list
      await fetchChannels();
      
      // Reset form and hide it
      setNewChannelName('');
      setShowCreateChannelForm(false);
      setChannelError(null);
    } catch (err) {
      console.error('Failed to create channel:', err);
      setChannelError('Failed to create channel. Please try again.');
    } finally {
      setChannelLoading(false);
    }
  };

  // Delete a chat channel
  const handleDeleteChannel = async (channelId) => {
    try {
      setChannelLoading(true);
      const token = localStorage.getItem('auth_token');
      const endpoint = API_CONFIG.ENDPOINTS.CHAT_DELETE_ROOM.replace(':id', channelId);
      await axios.delete(
        `${API_CONFIG.BASE_URL}${endpoint}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      // Refresh the channel list
      await fetchChannels();
      setChannelError(null);
    } catch (err) {
      console.error('Failed to delete channel:', err);
      setChannelError('Failed to delete channel. Please try again.');
    } finally {
      setChannelLoading(false);
    }
  };
  
  // Delete a user
  const handleDeleteUser = async (userId) => {
    // Confirm deletion
    if (!window.confirm('Are you sure you want to delete this user? This action cannot be undone.')) {
      return;
    }
    
    try {
      setLoading(true);
      const token = localStorage.getItem('auth_token');
      
      // Use the DELETE endpoint
      await axios.delete(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.USERS}/${userId}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      // Refresh the user list
      await fetchUsers();
      setError(null);
    } catch (err) {
      console.error('Failed to delete user:', err);
      setError(err.response?.data?.message || 'Failed to delete user. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="bg-stone-900 text-white h-full overflow-auto flex flex-col">
      {/* Header Bar */}
      <div className="p-2 border-b border-stone-700 font-mono text-sm flex items-center justify-between">
        <h2 className="text-teal-400 font-medium">ADMIN PANEL</h2>
        
        {/* Tab Navigation */}
        <div className="flex">
          <button
            className={`px-3 py-1 rounded-t text-xs flex items-center ${
              activeTab === 'users'
                ? 'bg-stone-800 text-teal-300'
                : 'text-stone-400 hover:text-white'
            }`}
            onClick={() => setActiveTab('users')}
          >
            Users
          </button>
          <button
            className={`px-3 py-1 rounded-t text-xs flex items-center ml-1 ${
              activeTab === 'channels'
                ? 'bg-stone-800 text-teal-300'
                : 'text-stone-400 hover:text-white'
            }`}
            onClick={() => setActiveTab('channels')}
          >
            Chat Channels
          </button>
        </div>
      </div>
      
      {/* Create User/Channel Button - Only shown when respective tab is active */}
      {activeTab === 'users' && (
        <div className="p-2 flex justify-end">
          <button
            onClick={toggleCreateForm}
            className="px-3 py-1 bg-teal-600 hover:bg-teal-500 rounded text-sm"
          >
            {showCreateForm ? 'Cancel' : 'Create User'}
          </button>
        </div>
      )}
      
      {activeTab === 'channels' && (
        <div className="p-2 border-b border-stone-700 flex justify-end">
          <button
            onClick={toggleCreateChannelForm}
            className="px-3 py-1 bg-teal-600 hover:bg-teal-500 rounded text-sm"
          >
            {showCreateChannelForm ? 'Cancel' : 'Create Channel'}
          </button>
        </div>
      )}
      
      {/* Main Content Area */}
      <div className="p-4 flex-1 overflow-auto">
        {activeTab === 'users' && error && <p className="text-red-500 mb-4">{error}</p>}
        {activeTab === 'channels' && channelError && <p className="text-red-500 mb-4">{channelError}</p>}
        
        {/* Show users tab content */}
        {activeTab === 'users' && (
          <>
            {/* Create User Form */}
            {showCreateForm && (
              <div className="mb-6 p-4 bg-stone-800 rounded">
                <h3 className="text-lg mb-3 text-teal-400">Create New User</h3>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm text-gray-400 mb-1">Username: <span className="text-red-500">*</span></label>
                    <input
                      type="text"
                      name="username"
                      value={createFormData.username}
                      onChange={handleCreateChange}
                      className="bg-stone-700 text-white px-2 py-1 rounded w-full"
                      placeholder="Enter username"
                    />
                  </div>
                  <div>
                    <label className="block text-sm text-gray-400 mb-1">Password: <span className="text-red-500">*</span></label>
                    <input
                      type="password"
                      name="password"
                      value={createFormData.password}
                      onChange={handleCreateChange}
                      className="bg-stone-700 text-white px-2 py-1 rounded w-full"
                      placeholder="Enter password"
                    />
                  </div>
                  <div className="flex flex-col space-y-2">
                    <label className="flex items-center text-sm text-gray-400">
                      <input
                        type="checkbox"
                        name="is_admin"
                        checked={createFormData.is_admin}
                        onChange={handleCreateChange}
                        className="form-checkbox h-5 w-5 text-teal-500 mr-2"
                      />
                      Admin User
                    </label>
                    <label className="flex items-center text-sm text-gray-400">
                      <input
                        type="checkbox"
                        name="has_file_access"
                        checked={createFormData.has_file_access}
                        onChange={handleCreateChange}
                        className="form-checkbox h-5 w-5 text-teal-500 mr-2"
                      />
                      Private File Access
                    </label>
                  </div>
                  <div>
                    <label className="block text-sm text-gray-400 mb-1">Storage Quota:</label>
                    <div className="flex items-center">
                      <input
                        type="number"
                        name="storage_quota"
                        value={Math.round((createFormData.storage_quota || 52428800) / 1048576)}
                        onChange={(e) => {
                          const mbValue = parseInt(e.target.value) || 0;
                          handleCreateChange({
                            target: {
                              name: 'storage_quota',
                              value: mbValue * 1048576, // Convert MB to bytes
                              type: 'number'
                            }
                          });
                        }}
                        className="bg-stone-700 text-white px-2 py-1 rounded w-20 mr-2"
                        min="0"
                        step="1"
                        disabled={createFormData.is_admin}
                      />
                      <span className="text-sm text-gray-400">MB {createFormData.is_admin && "(Unlimited for admins)"}</span>
                    </div>
                  </div>
                </div>
                <div className="mt-4">
                  <button
                    onClick={handleCreateUser}
                    className="px-4 py-2 bg-teal-600 hover:bg-teal-500 rounded text-sm"
                    disabled={loading}
                  >
                    {loading ? 'Creating...' : 'Create User'}
                  </button>
                </div>
              </div>
            )}
            
            {/* Users Table */}
            <table className="w-full border-collapse">
              <thead>
                <tr className="border-b border-stone-700">
                  <th className="text-left p-2">User ID</th>
                  <th className="text-left p-2">Username</th>
                  <th className="text-left p-2">Admin</th>
                  <th className="text-left p-2">File Access</th>
                  <th className="text-left p-2">Storage Quota</th>
                  <th className="text-left p-2">Actions</th>
                </tr>
              </thead>
              <tbody>
                {users.map(userItem => (
                  <tr key={userItem.id} className="border-b border-stone-800 hover:bg-stone-800">
                    <td className="p-2">
                      {editingUser === userItem.id ? (
                        <span className="text-white px-2 py-1 rounded w-full">
                          {userItem.id}
                        </span>
                      ) : (
                        userItem.id
                      )}
                    </td>
                    <td className="p-2">
                      {editingUser === userItem.id ? (
                        <input
                          type="text"
                          name="username"
                          value={formData.username}
                          onChange={handleChange}
                          className="bg-stone-700 text-white px-2 py-1 rounded w-full"
                        />
                      ) : (
                        userItem.username
                      )}
                    </td>
                    <td className="p-2">
                      {editingUser === userItem.id ? (
                        <input
                          type="checkbox"
                          name="is_admin"
                          checked={formData.is_admin}
                          onChange={handleChange}
                          className="form-checkbox h-5 w-5 text-teal-500"
                        />
                      ) : (
                        userItem.is_admin === 1 || userItem.is_admin === true ? 'Yes' : 'No'
                      )}
                    </td>
                    <td className="p-2">
                      {editingUser === userItem.id ? (
                        <input
                          type="checkbox"
                          name="has_file_access"
                          checked={formData.has_file_access}
                          onChange={handleChange}
                          className="form-checkbox h-5 w-5 text-teal-500"
                        />
                      ) : (
                        userItem.has_file_access === 1 || userItem.has_file_access === true ? 'Yes' : 'No'
                      )}
                    </td>
                    <td className="p-2">
                      {editingUser === userItem.id ? (
                        <div className="flex items-center">
                          <input
                            type="number"
                            name="storage_quota"
                            value={Math.round((formData.storage_quota || 52428800) / 1048576)}
                            onChange={(e) => {
                              const mbValue = parseInt(e.target.value) || 0;
                              handleChange({
                                target: {
                                  name: 'storage_quota',
                                  value: mbValue * 1048576, // Convert MB to bytes
                                  type: 'number'
                                }
                              });
                            }}
                            className="bg-stone-700 text-white px-2 py-1 rounded w-20 mr-2"
                            min="0"
                            step="1"
                            disabled={formData.is_admin}
                          />
                          <span className="text-sm text-gray-400">MB {formData.is_admin && "(Unlimited for admins)"}</span>
                        </div>
                      ) : (
                        userItem.is_admin ? 'Unlimited' : 
                        `${Math.round((userItem.storage_quota || 52428800) / 1048576)} MB`
                      )}
                    </td>
                    <td className="p-2">
                      {editingUser === userItem.id ? (
                        <div className="flex flex-col space-y-2">
                          <div className="mb-2">
                            <label className="block text-sm text-gray-400">New Password:</label>
                            <input
                              type="password"
                              name="password"
                              value={formData.password}
                              onChange={handleChange}
                              placeholder="Leave blank to keep current"
                              className="bg-stone-700 text-white px-2 py-1 rounded w-full"
                            />
                          </div>
                          <div className="flex space-x-2">
                            <button
                              onClick={() => handleSave(userItem.id)}
                              className="px-3 py-1 bg-teal-600 hover:bg-teal-500 rounded text-sm"
                            >
                              Save
                            </button>
                            <button
                              onClick={handleCancel}
                              className="px-3 py-1 bg-stone-600 hover:bg-stone-500 rounded text-sm"
                            >
                              Cancel
                            </button>
                            <button
                              onClick={() => {
                                handleCancel();
                                handleDeleteUser(userItem.id);
                              }}
                              className="px-3 py-1 bg-stone-600 hover:bg-stone-500 rounded text-sm text-red-400 hover:text-red-300"
                            >
                              Delete
                            </button>
                          </div>
                        </div>
                      ) : (
                        <div className="flex space-x-2">
                          <button
                            onClick={() => handleEdit(userItem)}
                            className="px-3 py-1 bg-stone-700 hover:bg-stone-600 rounded text-sm"
                            disabled={loading}
                          >
                            Edit
                          </button>
                          <button
                            onClick={() => handleDeleteUser(userItem.id)}
                            className="px-3 py-1 focus:outline-none text-sm"
                            disabled={loading}
                            title="Delete user"
                          >
                            <Trash size={16} className="text-stone-400 hover:text-stone-300" />
                          </button>
                        </div>
                      )}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
            
            {loading && users.length > 0 && (
              <div className="mt-4 text-center">
                <div className="animate-spin rounded-full h-6 w-6 border-t-2 border-b-2 border-teal-500 mx-auto"></div>
              </div>
            )}
          </>
        )}
        
        {/* Show channels tab content */}
        {activeTab === 'channels' && (
          <>
            {/* Create Channel Form - Only shown when showCreateChannelForm is true */}
            {showCreateChannelForm && (
              <div className="mb-6 p-4 bg-stone-800 rounded">
                <h3 className="text-lg mb-3 text-teal-400">Create New Channel</h3>
                <form onSubmit={handleCreateChannel} className="flex items-end gap-4">
                  <div className="flex-1">
                    <label className="block text-sm text-gray-400 mb-1">Channel Name:</label>
                    <input
                      type="text"
                      value={newChannelName}
                      onChange={(e) => setNewChannelName(e.target.value)}
                      className="bg-stone-700 text-white px-2 py-1 rounded w-full"
                      placeholder="Enter channel name"
                    />
                  </div>
                  <button
                    type="submit"
                    className="px-4 py-1 bg-teal-600 hover:bg-teal-500 rounded text-sm"
                    disabled={channelLoading}
                  >
                    {channelLoading ? 'Creating...' : 'Create Channel'}
                  </button>
                </form>
              </div>
            )}
            
            {/* Channels Table */}
            <table className="w-full border-collapse">
              <thead>
                <tr className="border-b border-stone-700">
                  <th className="text-left p-2">Channel Name</th>
                  <th className="text-left p-2">Created By</th>
                  <th className="text-left p-2">Created At</th>
                  <th className="text-left p-2">Actions</th>
                </tr>
              </thead>
              <tbody>
                {channels.map(channel => (
                  <tr key={channel.id} className="border-b border-stone-800 hover:bg-stone-800">
                    <td className="p-2">{channel.name}</td>
                    <td className="p-2">{channel.created_by || '-'}</td>
                    <td className="p-2">
                      {new Date(channel.created_at).toLocaleString()}
                    </td>
                    <td className="p-2">
                      <button
                        onClick={() => handleDeleteChannel(channel.id)}
                        className="focus:outline-none"
                        title="Delete channel"
                        disabled={channelLoading}
                      >
                        <Trash size={16} className="text-stone-400 hover:text-stone-300" />
                      </button>
                    </td>
                  </tr>
                ))}
                {channels.length === 0 && !channelLoading && (
                  <tr>
                    <td colSpan="4" className="p-4 text-center text-stone-500">
                      No channels found. Create one above.
                    </td>
                  </tr>
                )}
              </tbody>
            </table>
            
            {channelLoading && (
              <div className="mt-4 text-center">
                <div className="animate-spin rounded-full h-6 w-6 border-t-2 border-b-2 border-teal-500 mx-auto"></div>
              </div>
            )}
          </>
        )}
      </div>
    </div>
  );
};

export default AdminWindow;

================
File: windows/AudioWindow.jsx
================
import React, { useRef, useState, useEffect, useCallback } from 'react';
import { Play, Pause, Volume2 } from 'lucide-react';

const AudioWindow = ({ nodeId, onCommand, windowState, updateWindowState }) => {
  const canvasRef = useRef(null);
  const audioRef = useRef(null);
  const audioContextRef = useRef(null);
  const analyserRef = useRef(null);
  const animationRef = useRef(null);
  const [isPlaying, setIsPlaying] = useState(windowState?.isPlaying || false);
  const [currentTime, setCurrentTime] = useState(windowState?.currentTime || 0);

  // Define draw function outside of other functions to avoid dependency issues
  const draw = useCallback(() => {
    if (!canvasRef.current || !analyserRef.current) {
      console.error('Cannot draw: canvas or analyser is null');
      return;
    }

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const analyser = analyserRef.current;
    
    // Make sure canvas dimensions are set correctly
    if (canvas.width === 0 || canvas.height === 0) {
      canvas.width = canvas.offsetWidth || 300;
      canvas.height = canvas.offsetHeight || 150;
    }
    
    // Use a smaller FFT size for better visualization
    analyser.fftSize = 512;
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    const drawFrame = () => {
      // Cancel any existing animation frame
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
      
      // Request next frame
      animationRef.current = requestAnimationFrame(drawFrame);
      
      // Get frequency data
      analyser.getByteFrequencyData(dataArray);

      // Clear canvas
      ctx.fillStyle = 'rgb(28, 25, 23)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw visualizer
      const barWidth = (canvas.width / bufferLength) * 2.5;
      let barHeight;
      let x = 0;

      for (let i = 0; i < bufferLength; i++) {
        barHeight = dataArray[i] * 1.5;
        
        // Make sure we have a minimum height for bars
        if (barHeight < 1) barHeight = 1;
        
        const gradient = ctx.createLinearGradient(0, canvas.height, 0, 0);
        gradient.addColorStop(0, '#14b8a6');
        gradient.addColorStop(1, '#2dd4bf');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);

        x += barWidth + 1;
      }
    };

    // Start the animation
    drawFrame();
    
    console.log('Visualization started');
    
    // Return a cleanup function
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
        animationRef.current = null;
      }
    };
  }, []);

  // Track if audio element has been connected to a source
  const sourceConnectedRef = useRef(false);

  // Setup audio with Web Audio API for visualization
  const setupAudio = useCallback(async () => {
    try {
      const audio = audioRef.current;
      if (!audio) {
        console.error('Audio element reference is null');
        return false;
      }
      
      // Force reset the sourceConnected flag if we're having issues
      if (audioContextRef.current?.state === 'closed') {
        sourceConnectedRef.current = false;
      }
      
      // Create new AudioContext if needed
      if (!audioContextRef.current || audioContextRef.current.state === 'closed') {
        console.log('Creating new AudioContext');
        
        // Create new AudioContext
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Create and configure analyser
        const analyser = audioContext.createAnalyser();
        analyser.fftSize = 256; // Smaller FFT size for better visualization
        analyser.smoothingTimeConstant = 0.8; // Add smoothing
        
        // Resume audio context (needed due to browser autoplay policies)
        await audioContext.resume();
        
        // Create a new MediaElementSource and connect it
        try {
          console.log('Creating new MediaElementSource');
          const source = audioContext.createMediaElementSource(audio);
          source.connect(analyser);
          analyser.connect(audioContext.destination);
          sourceConnectedRef.current = true;
          
          // Store references
          audioContextRef.current = audioContext;
          analyserRef.current = analyser;
          
          console.log('Audio setup complete with new AudioContext');
        } catch (sourceError) {
          console.error('Error creating MediaElementSource:', sourceError);
          return false;
        }
      } else {
        // If AudioContext exists but is suspended, resume it
        if (audioContextRef.current.state === 'suspended') {
          console.log('Resuming suspended AudioContext');
          await audioContextRef.current.resume();
        }
        
        console.log('Using existing AudioContext');
      }
      
      // Restore playback position from window state
      if (windowState?.currentTime) {
        audio.currentTime = windowState.currentTime;
      }
      
      return true;
    } catch (error) {
      console.error('Error setting up audio:', error);
      return false;
    }
  }, [windowState]);

  // Initialize audio on mount or when windowState changes
  useEffect(() => {
    const initializeAudio = async () => {
      // Set up the audio context
      const success = await setupAudio();
      
      // If setup was successful and we should be playing, start playback
      if (success && windowState?.isPlaying) {
        try {
          await audioRef.current.play();
          draw();
        } catch (error) {
          console.error('Error auto-playing audio:', error);
          setIsPlaying(false);
        }
      }
    };

    if (audioRef.current && 
        (!audioContextRef.current || audioContextRef.current.state === 'closed')) {
      initializeAudio();
    }

    return () => {
      if (audioContextRef.current && audioContextRef.current.state !== 'closed') {
        try {
          audioContextRef.current.close();
        } catch (error) {
          console.error('Error closing AudioContext:', error);
        }
      }
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [windowState, setupAudio, draw]);

  // Toggle play/pause
  const togglePlay = useCallback(async () => {
    if (!audioRef.current) return;

    try {
      console.log('Toggle play clicked, current state:', isPlaying);
      
      // Make sure audio context is initialized and running
      if (!audioContextRef.current || audioContextRef.current.state === 'closed') {
        console.log('Setting up audio again');
        const success = await setupAudio();
        if (!success) {
          console.error('Failed to set up audio');
          return;
        }
      } else if (audioContextRef.current.state === 'suspended') {
        console.log('Resuming suspended AudioContext');
        await audioContextRef.current.resume();
      }

      if (isPlaying) {
        console.log('Pausing audio');
        audioRef.current.pause();
        if (animationRef.current) {
          cancelAnimationFrame(animationRef.current);
          animationRef.current = null;
        }
      } else {
        console.log('Starting audio playback');
        try {
          // Start visualization before playing to ensure it's ready
          if (analyserRef.current && !animationRef.current) {
            console.log('Starting visualization');
            draw();
          }
          
          // Play the audio
          const playPromise = audioRef.current.play();
          if (playPromise) {
            await playPromise;
            console.log('Audio playback started successfully');
            
            // Make sure visualization is running
            if (!animationRef.current && analyserRef.current) {
              console.log('Starting visualization after successful play');
              draw();
            }
          }
        } catch (playError) {
          console.error('Error playing audio:', playError);
        }
      }
      
      setIsPlaying(!isPlaying);
    } catch (error) {
      console.error('Error in togglePlay:', error);
    }
  }, [isPlaying, setupAudio, draw]);

  // Handle canvas resize
  useEffect(() => {
    const resizeCanvas = () => {
      const canvas = canvasRef.current;
      if (!canvas) return;
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
    };

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    return () => window.removeEventListener('resize', resizeCanvas);
  }, []);

  // Update current time when playing
  useEffect(() => {
    if (!audioRef.current) return;
    
    const updateTime = () => {
      setCurrentTime(audioRef.current.currentTime);
    };
    
    audioRef.current.addEventListener('timeupdate', updateTime);
    return () => {
      audioRef.current?.removeEventListener('timeupdate', updateTime);
    };
  }, []);
  
  // Start visualization when audio is playing
  useEffect(() => {
    // If audio is playing but visualization is not running, start it
    if (isPlaying && audioRef.current && analyserRef.current && !animationRef.current) {
      console.log('Starting visualization due to isPlaying state change');
      draw();
    }
    
    // If audio is not playing but visualization is running, stop it
    if (!isPlaying && animationRef.current) {
      console.log('Stopping visualization due to isPlaying state change');
      cancelAnimationFrame(animationRef.current);
      animationRef.current = null;
    }
  }, [isPlaying, draw]);

  // Update window state when relevant state changes
  useEffect(() => {
    if (updateWindowState) {
      updateWindowState({
        isPlaying,
        currentTime
      });
    }
  }, [isPlaying, currentTime, updateWindowState]);

  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400">
      <div className="flex-1 relative">
        <canvas 
          ref={canvasRef}
          className="absolute inset-0 w-full h-full"
        />
      </div>

      <div className="border-t border-stone-700">
        <div className="flex items-center gap-4 mb-4">
          <button 
            onClick={togglePlay}
            className="p-2 hover:bg-stone-800 rounded-full transition-colors"
          >
            {isPlaying ? <Pause size={24} /> : <Play size={24} />}
          </button>
          <Volume2 size={24} />
        </div>

        <audio
          ref={audioRef}
          src="scamming-on-runescape.mp3"
          preload="auto"
          crossOrigin="anonymous"
          onPlay={() => setIsPlaying(true)}
          onPause={() => setIsPlaying(false)}
          onEnded={() => setIsPlaying(false)}
        />

        <div className="p-2 flex items-center gap-2 border-t border-stone-700">
          <span>$</span>
          <input
            type="text"
            className="flex-1 bg-stone-800 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
            onKeyDown={(e) => {
              if (e.key === 'Enter' && e.target.value.trim()) {
                onCommand(e.target.value.trim());
                e.target.value = '';
              }
            }}
          />
        </div>
      </div>
    </div>
  );
};

export default AudioWindow;

================
File: windows/CanvasPreview.jsx
================
import React, { useMemo } from 'react';
import ReactFlow, {
  Background,
  Controls,
  MiniMap,
  useNodesState,
  useEdgesState
} from 'reactflow';
import 'reactflow/dist/style.css';
import nodeTypes from '../../utils/canvasNodeTypes';

const CanvasPreview = ({ fileContent, nodeTypes: propNodeTypes }) => {
  // Parse the canvas data
  let canvasData;
  try {
    canvasData = JSON.parse(fileContent);
  } catch (error) {
    return (
      <div className="text-red-400 p-4">
        <p>Error parsing canvas file: {error.message}</p>
        <p className="mt-2">Raw content:</p>
        <pre className="font-mono text-sm whitespace-pre-wrap mt-2 bg-stone-800 p-2 rounded">
          {fileContent}
        </pre>
      </div>
    );
  }

  // Memoize the nodeTypes to prevent recreation on each render
  const memoizedNodeTypes = useMemo(() => propNodeTypes || nodeTypes, [propNodeTypes]);
  
  // Use React Flow hooks at the top level of the component
  const [nodes, setNodes] = useNodesState(canvasData.nodes || []);
  const [edges, setEdges] = useEdgesState(canvasData.edges || []);
  
  return (
    <div style={{ width: '100%', height: '100%', minHeight: '300px' }}>
      <ReactFlow
        nodes={nodes}
        edges={edges}
        nodeTypes={memoizedNodeTypes}
        fitView
        attributionPosition="bottom-right"
        minZoom={0.1}
        maxZoom={4}
        defaultViewport={{ x: 0, y: 0, zoom: 1 }}
      >
      <Background color="#44403c" gap={16} />
      <Controls showInteractive={false} />
      <MiniMap
        nodeColor={(node) => {
          switch (node.type) {
            case 'group':
              return node.data.color ? `rgba(${node.data.color}, 0.6)` : 'rgba(20, 184, 166, 0.6)';
            default:
              return '#14b8a6';
          }
        }}
        maskColor="rgba(0, 0, 0, 0.5)"
        style={{ backgroundColor: '#292524' }}
      />
      </ReactFlow>
    </div>
  );
};

export default CanvasPreview;

================
File: windows/CanvasWindow.jsx
================
import React, { useState, useEffect, useRef, useCallback } from 'react';
import ReactFlow, {
  Background,
  Controls,
  MiniMap,
  useNodesState,
  useEdgesState,
  addEdge,
  Panel
} from 'reactflow';
import 'reactflow/dist/style.css';
import { 
  Plus, 
  Minus, 
  Save, 
  FileText, 
  Trash2, 
  Edit, 
  Link as LinkIcon,
  Square,
  Type
} from 'lucide-react';
import API_CONFIG from '../../config/api';
import { useAuth } from '../../context/AuthContext';
import { useWindowState } from '../../context/WindowStateContext';
import { WINDOW_TYPES } from '../../utils/windowTypes';
import { saveCanvasState, getCanvasState } from '../../services/indexedDBService';

// Custom node types
const TextNode = ({ data }) => {
  return (
    <div className="p-2 bg-stone-800 border border-stone-700 rounded shadow-md">
      <div className="text-teal-400 text-sm whitespace-pre-wrap">{data.text}</div>
    </div>
  );
};

const GroupNode = ({ data }) => {
  return (
    <div 
      className="p-2 bg-stone-900 border border-stone-700 rounded shadow-md"
      style={{ backgroundColor: data.color ? `rgba(${data.color}, 0.2)` : 'rgba(20, 20, 20, 0.7)' }}
    >
      <div className="text-teal-300 font-bold mb-1">{data.label || 'Group'}</div>
      <div className="text-teal-400 text-sm">{data.children?.length || 0} items</div>
    </div>
  );
};

// Node types configuration
const nodeTypes = {
  text: TextNode,
  group: GroupNode
};

const CanvasWindow = ({ isActive, nodeId, onCommand, transformWindow, windowState, updateWindowState, focusRef }) => {
  // Get auth context to check if user is admin
  const { user } = useAuth();
  const isAdmin = user?.is_admin || false;
  
  // Get window state context for additional persistence
  const { setActiveWindow } = useWindowState();
  
  // Ref to track if state has been loaded from IndexedDB
  const stateLoadedRef = useRef(false);
  
  // Use state from windowState or initialize with defaults
  const [canvasName, setCanvasName] = useState(windowState?.canvasName || 'Untitled Canvas');
  const [currentCanvasPath, setCurrentCanvasPath] = useState(windowState?.currentCanvasPath || null);
  const [isLoading, setIsLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState('');
  const [saveStatus, setSaveStatus] = useState('saved'); // 'saved', 'saving', 'error'
  
  // ReactFlow states
  const [nodes, setNodes, onNodesChange] = useNodesState(windowState?.nodes || []);
  const [edges, setEdges, onEdgesChange] = useEdgesState(windowState?.edges || []);
  const [reactFlowInstance, setReactFlowInstance] = useState(null);
  
  // UI states
  const [selectedElements, setSelectedElements] = useState([]);
  const [showNodeCreator, setShowNodeCreator] = useState(false);
  const [newNodeType, setNewNodeType] = useState('text');
  const [newNodeText, setNewNodeText] = useState('');
  const [newNodeLabel, setNewNodeLabel] = useState('');
  const [newNodeColor, setNewNodeColor] = useState('');
  
  // For auto-save functionality
  const saveTimeoutRef = useRef(null);
  
  // Load canvas state from IndexedDB on mount
  useEffect(() => {
    const loadCanvasState = async () => {
      try {
        // Try to load canvas state from IndexedDB
        const savedState = await getCanvasState(nodeId);
        
        if (savedState && savedState.content && !stateLoadedRef.current) {
          console.log(`Loaded canvas state for window ${nodeId} from IndexedDB:`, savedState.content);
          
          // Update state with saved values
          if (savedState.content.nodes) {
            setNodes(savedState.content.nodes);
          }
          
          if (savedState.content.edges) {
            setEdges(savedState.content.edges);
          }
          
          if (savedState.content.canvasName) {
            setCanvasName(savedState.content.canvasName);
          }
          
          if (savedState.content.currentCanvasPath) {
            setCurrentCanvasPath(savedState.content.currentCanvasPath);
          }
          
          // Mark as loaded
          stateLoadedRef.current = true;
        }
      } catch (error) {
        console.error(`Failed to load canvas state for window ${nodeId} from IndexedDB:`, error);
      }
    };
    
    loadCanvasState();
  }, [nodeId, setNodes, setEdges]);
  
  // Handle window activation
  useEffect(() => {
    if (isActive) {
      // Save this as the active canvas window
      setActiveWindow(nodeId, WINDOW_TYPES.CANVAS);
    }
  }, [isActive, nodeId, setActiveWindow]);
  
  // Save canvas state to IndexedDB when it changes
  useEffect(() => {
    if (!stateLoadedRef.current) return;
    
    // Save the canvas state to IndexedDB
    saveCanvasState({
      id: nodeId,
      content: {
        nodes,
        edges,
        canvasName,
        currentCanvasPath
      }
    }).catch(error => {
      console.error(`Failed to save canvas state for window ${nodeId} to IndexedDB:`, error);
    });
    
  }, [nodes, edges, canvasName, currentCanvasPath, nodeId]);
  
  // Update window state when relevant state changes
  useEffect(() => {
    if (updateWindowState) {
      updateWindowState({
        nodes,
        edges,
        canvasName,
        currentCanvasPath,
        saveStatus
      });
    }
  }, [nodes, edges, canvasName, currentCanvasPath, saveStatus, updateWindowState]);
  
  // Auto-save functionality with debounce
  useEffect(() => {
    // Only auto-save if we have a path and user is admin
    if (currentCanvasPath && isAdmin) {
      // Clear any existing timeout
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
      
      // Set status to saving
      setSaveStatus('saving');
      
      // Set a new timeout for auto-save
      saveTimeoutRef.current = setTimeout(() => {
        saveCanvas();
      }, 2000); // 2 second debounce
    }
    
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, [nodes, edges, currentCanvasPath, isAdmin]);
  
  // Handle connection (edge) creation
  const onConnect = useCallback((params) => {
    setEdges((eds) => addEdge({
      ...params,
      id: `edge-${Date.now()}`,
      type: 'default',
      animated: false,
      style: { stroke: '#14b8a6' }
    }, eds));
  }, [setEdges]);
  
  // Handle node selection
  const onSelectionChange = useCallback(({ nodes, edges }) => {
    setSelectedElements([...nodes, ...edges]);
  }, []);
  
  // Handle drag over for node creation
  const onDragOver = useCallback((event) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);
  
  // Handle drop for node creation
  const onDrop = useCallback(
    (event) => {
      event.preventDefault();
      
      const type = event.dataTransfer.getData('application/reactflow/type');
      if (!type) return;
      
      const position = reactFlowInstance.screenToFlowPosition({
        x: event.clientX,
        y: event.clientY,
      });
      
      const newNode = {
        id: `node-${Date.now()}`,
        type,
        position,
        data: type === 'text' 
          ? { text: 'New text node' } 
          : { label: 'New Group', color: '20, 184, 166' },
        style: type === 'group' 
          ? { width: 400, height: 400, backgroundColor: 'rgba(20, 184, 166, 0.1)' } 
          : undefined
      };
      
      setNodes((nds) => nds.concat(newNode));
    },
    [reactFlowInstance, setNodes]
  );
  
  // Load canvas from file
  const loadCanvas = async (filePath) => {
    try {
      setIsLoading(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsLoading(false);
        return;
      }
      
      // Fetch file content from the server
      const response = await fetch(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_CONTENT}?path=${encodeURIComponent(filePath)}`,
        {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        }
      );
      
      if (!response.ok) {
        // If response is 403, it means the user doesn't have admin access
        if (response.status === 403) {
          setErrorMessage('Admin access required to view file content.');
        } else {
          setErrorMessage(`Failed to load canvas: ${response.statusText}`);
        }
        setIsLoading(false);
        return;
      }
      
      const data = await response.json();
      
      try {
        const canvasData = JSON.parse(data.content);
        
        if (canvasData.nodes && canvasData.edges) {
          setNodes(canvasData.nodes);
          setEdges(canvasData.edges);
          setCurrentCanvasPath(filePath);
          
          // Extract canvas name from file path
          const pathParts = filePath.split('/');
          const fileName = pathParts[pathParts.length - 1];
          setCanvasName(fileName.replace('.canvas', ''));
          
          setSaveStatus('saved');
        } else {
          setErrorMessage('Invalid canvas file format.');
        }
      } catch (parseError) {
        console.error('Error parsing canvas file:', parseError);
        setErrorMessage('Failed to parse canvas file. Invalid format.');
      }
      
      setIsLoading(false);
    } catch (error) {
      console.error('Error loading canvas:', error);
      setErrorMessage(`Error loading canvas: ${error.message}`);
      setSaveStatus('error');
      setIsLoading(false);
    }
  };
  
  // Save canvas to file
  const saveCanvas = async () => {
    try {
      // Check if we have a path
      if (!currentCanvasPath) {
        setErrorMessage('No file path specified. Please save as a new file first.');
        setSaveStatus('error');
        return;
      }
      
      setSaveStatus('saving');
      
      const canvasData = {
        nodes,
        edges
      };
      
      const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_SAVE}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
        },
        body: JSON.stringify({
          path: currentCanvasPath,
          content: JSON.stringify(canvasData, null, 2)
        })
      });
      
      if (!response.ok) {
        throw new Error(`Failed to save canvas: ${response.statusText}`);
      }
      
      setSaveStatus('saved');
      setErrorMessage('');
    } catch (error) {
      console.error('Error saving canvas:', error);
      setErrorMessage(`Error saving canvas: ${error.message}`);
      setSaveStatus('error');
    }
  };
  
  // Create a new node
  const createNode = (type) => {
    if (!reactFlowInstance) return;
    
    const position = {
      x: Math.random() * 400,
      y: Math.random() * 400
    };
    
    let newNode = {
      id: `node-${Date.now()}`,
      type,
      position,
      data: {}
    };
    
    if (type === 'text') {
      newNode.data = { text: newNodeText || 'New text node' };
    } else if (type === 'group') {
      newNode.data = { 
        label: newNodeLabel || 'New Group', 
        color: newNodeColor || '20, 184, 166' 
      };
      newNode.style = { 
        width: 400, 
        height: 400, 
        backgroundColor: `rgba(${newNodeColor || '20, 184, 166'}, 0.1)` 
      };
    }
    
    setNodes((nds) => nds.concat(newNode));
    setShowNodeCreator(false);
    setNewNodeText('');
    setNewNodeLabel('');
    setNewNodeColor('');
  };
  
  // Delete selected elements
  const deleteSelected = () => {
    const selectedNodeIds = selectedElements
      .filter(el => el.type !== 'default')
      .map(el => el.id);
    
    const selectedEdgeIds = selectedElements
      .filter(el => el.type === 'default')
      .map(el => el.id);
    
    setNodes(nodes.filter(node => !selectedNodeIds.includes(node.id)));
    setEdges(edges.filter(edge => !selectedEdgeIds.includes(edge.id)));
    setSelectedElements([]);
  };
  
  // Handle command input
  const handleCommand = (e) => {
    if (e.key === 'Enter' && e.target.value.trim()) {
      const cmd = e.target.value.trim();
      onCommand(cmd);
      e.target.value = '';
      
      // Commands:
      // - save: save the canvas
      // - load [path]: load a canvas from a file
      // - new-text: create a new text node
      // - new-group: create a new group node
      // - delete: delete selected elements
      if (cmd === 'save') {
        saveCanvas();
      } else if (cmd.startsWith('load ')) {
        const path = cmd.substring(5).trim();
        loadCanvas(path);
      } else if (cmd === 'new-text') {
        setNewNodeType('text');
        setShowNodeCreator(true);
      } else if (cmd === 'new-group') {
        setNewNodeType('group');
        setShowNodeCreator(true);
      } else if (cmd === 'delete') {
        deleteSelected();
      }
    }
  };
  
  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400 overflow-hidden">
      <div className="p-2 border-b border-stone-700 font-mono text-sm flex items-center justify-between">
        <div className="flex items-center">
          <span className="mr-2">{canvasName}</span>
          {saveStatus === 'saving' && <span className="text-yellow-400 text-xs ml-2">Saving...</span>}
          {saveStatus === 'saved' && <span className="text-green-400 text-xs ml-2">Saved</span>}
          {saveStatus === 'error' && <span className="text-red-400 text-xs ml-2">Error!</span>}
        </div>
        
        <div className="flex gap-2">
          <button 
            onClick={() => saveCanvas()}
            className="px-2 py-1 bg-stone-800 hover:bg-stone-700 rounded text-xs flex items-center gap-1"
            title="Save canvas"
          >
            <Save size={14} />
            Save
          </button>
          
          <button 
            onClick={() => {
              setNewNodeType('text');
              setShowNodeCreator(true);
            }}
            className="px-2 py-1 bg-stone-800 hover:bg-stone-700 rounded text-xs flex items-center gap-1"
            title="Add text node"
          >
            <Type size={14} />
            Text
          </button>
          
          <button 
            onClick={() => {
              setNewNodeType('group');
              setShowNodeCreator(true);
            }}
            className="px-2 py-1 bg-stone-800 hover:bg-stone-700 rounded text-xs flex items-center gap-1"
            title="Add group node"
          >
            <Square size={14} />
            Group
          </button>
          
          {selectedElements.length > 0 && (
            <button 
              onClick={deleteSelected}
              className="px-2 py-1 bg-stone-800 hover:bg-stone-700 rounded text-xs flex items-center gap-1"
              title="Delete selected"
            >
              <Trash2 size={14} />
              Delete
            </button>
          )}
        </div>
      </div>
      
      {/* Error message */}
      {errorMessage && (
        <div className="p-2 bg-red-900 text-red-200 text-sm">
          {errorMessage}
        </div>
      )}
      
      {/* Node creator dialog */}
      {showNodeCreator && (
        <div className="p-2 border-b border-stone-700 bg-stone-800">
          <div className="flex items-center justify-between mb-1">
            <span className="text-sm font-bold">
              {newNodeType === 'text' ? 'New Text Node' : 'New Group Node'}
            </span>
            <button
              onClick={() => setShowNodeCreator(false)}
              className="p-1 rounded hover:bg-stone-700 text-stone-400"
            >
              <Trash2 size={14} />
            </button>
          </div>
          
          {newNodeType === 'text' ? (
            <div className="flex flex-col gap-2">
              <textarea
                value={newNodeText}
                onChange={(e) => setNewNodeText(e.target.value)}
                placeholder="Enter text content"
                className="w-full bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
                rows={3}
              />
              <div className="flex justify-end">
                <button
                  onClick={() => createNode('text')}
                  className="px-2 py-1 bg-teal-700 text-teal-100 hover:bg-teal-600 rounded text-xs"
                >
                  Create
                </button>
              </div>
            </div>
          ) : (
            <div className="flex flex-col gap-2">
              <input
                type="text"
                value={newNodeLabel}
                onChange={(e) => setNewNodeLabel(e.target.value)}
                placeholder="Group label"
                className="w-full bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
              />
              <select
                value={newNodeColor}
                onChange={(e) => setNewNodeColor(e.target.value)}
                className="w-full bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
              >
                <option value="20, 184, 166">Teal</option>
                <option value="244, 63, 94">Red</option>
                <option value="234, 179, 8">Yellow</option>
                <option value="59, 130, 246">Blue</option>
                <option value="168, 85, 247">Purple</option>
                <option value="34, 197, 94">Green</option>
              </select>
              <div className="flex justify-end">
                <button
                  onClick={() => createNode('group')}
                  className="px-2 py-1 bg-teal-700 text-teal-100 hover:bg-teal-600 rounded text-xs"
                >
                  Create
                </button>
              </div>
            </div>
          )}
        </div>
      )}
      
      {/* Canvas area */}
      <div className="flex-1 overflow-hidden">
        {isLoading ? (
          <div className="flex items-center justify-center h-full">
            <span className="text-teal-300">Loading canvas...</span>
          </div>
        ) : (
          <ReactFlow
            nodes={nodes}
            edges={edges}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChange}
            onConnect={onConnect}
            onInit={setReactFlowInstance}
            onDrop={onDrop}
            onDragOver={onDragOver}
            onSelectionChange={onSelectionChange}
            nodeTypes={nodeTypes}
            fitView
            snapToGrid
            snapGrid={[15, 15]}
            defaultViewport={{ x: 0, y: 0, zoom: 1 }}
            minZoom={0.1}
            maxZoom={4}
            deleteKeyCode="Delete"
            multiSelectionKeyCode="Control"
            selectionKeyCode="Shift"
          >
            <Background color="#44403c" gap={16} />
            <Controls showInteractive={false} />
            <MiniMap
              nodeColor={(node) => {
                switch (node.type) {
                  case 'group':
                    return node.data.color ? `rgba(${node.data.color}, 0.6)` : 'rgba(20, 184, 166, 0.6)';
                  default:
                    return '#14b8a6';
                }
              }}
              maskColor="rgba(0, 0, 0, 0.5)"
              style={{ backgroundColor: '#292524' }}
            />
            
            <Panel position="top-left" className="bg-stone-800 p-2 rounded shadow-md">
              <div className="flex flex-col gap-1">
                <div className="text-xs text-stone-400">Drag to create:</div>
                <div 
                  className="flex items-center gap-1 p-1 bg-stone-700 rounded cursor-grab"
                  draggable
                  onDragStart={(event) => {
                    event.dataTransfer.setData('application/reactflow/type', 'text');
                    event.dataTransfer.effectAllowed = 'move';
                  }}
                >
                  <Type size={14} />
                  <span className="text-xs">Text Node</span>
                </div>
                <div 
                  className="flex items-center gap-1 p-1 bg-stone-700 rounded cursor-grab"
                  draggable
                  onDragStart={(event) => {
                    event.dataTransfer.setData('application/reactflow/type', 'group');
                    event.dataTransfer.effectAllowed = 'move';
                  }}
                >
                  <Square size={14} />
                  <span className="text-xs">Group Node</span>
                </div>
              </div>
            </Panel>
          </ReactFlow>
        )}
      </div>
      
      {/* Command input */}
      <div className="p-2 flex items-center gap-2 border-t border-stone-700">
        <span className="text-teal-400">$</span>
        <input
          ref={focusRef}
          type="text"
          onKeyDown={handleCommand}
          className="flex-1 bg-stone-800 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
          placeholder="Commands: save, load [path], new-text, new-group, delete"
        />
      </div>
    </div>
  );
};

export default CanvasWindow;

================
File: windows/ChatWindow.jsx
================
import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import { io } from 'socket.io-client';
import axios from 'axios';
import API_CONFIG from '../../config/api';
import { useAuth } from '../../context/AuthContext';
import { useWindowState } from '../../context/WindowStateContext';
import { WINDOW_TYPES } from '../../utils/windowTypes';
import { saveChatState, getChatState } from '../../services/indexedDBService';
import { MoreVertical, Trash, Mic, MicOff, Phone, PhoneOff, Plus } from 'lucide-react'; // Import additional icons
import SimplePeer from 'simple-peer';

// Helper function to safely destroy a peer connection
const safelyDestroyPeer = (peer, userId, destroyedPeersRef) => {
  if (!peer) return;
  
  try {
    // Stop any tracks in the peer's stream
    if (peer._localStream) {
      try {
        peer._localStream.getTracks().forEach(track => track.stop());
      } catch (err) {
        console.error('Error stopping local stream tracks:', err);
      }
    }
    
    // Destroy the peer
    if (peer.destroy) {
      peer.destroy();
      
      // Mark this peer as destroyed if we have a userId and ref
      if (userId && destroyedPeersRef?.current) {
        console.log(`Marking peer ${userId} as destroyed`);
        destroyedPeersRef.current.add(userId);
      }
    }
  } catch (err) {
    console.error('Error safely destroying peer:', err);
  }
};

// Parse a command input
const parseCommand = (input) => {
  // Check if this is a command (starts with /)
  if (!input.startsWith('/')) return null;
  
  // Split the input into command and arguments
  const parts = input.substring(1).trim().split(/\s+/);
  const command = parts[0].toLowerCase();
  const args = parts.slice(1);
  
  return { command, args };
};

const ChatWindow = ({ isActive, nodeId }) => {
  const { user } = useAuth();
  const { setActiveWindow } = useWindowState();
  const [rooms, setRooms] = useState([]);
  const [activeRoom, setActiveRoom] = useState(null);
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');
  const [charCount, setCharCount] = useState(0);
  const [newRoomName, setNewRoomName] = useState('');
  const [socket, setSocket] = useState(null);
  const messagesEndRef = useRef(null);
  // Refs to track loading state
  const stateLoadedRef = useRef(false);
  const roomsLoadedRef = useRef(false);
  
  // Voice chat state
  const [voiceChannels, setVoiceChannels] = useState([]);
  const [activeVoiceChannel, setActiveVoiceChannel] = useState(null);
  const [voiceParticipants, setVoiceParticipants] = useState([]);
  const [isMuted, setIsMuted] = useState(false);
  const [localStream, setLocalStream] = useState(null);
  const [peers, setPeers] = useState({});
  const [newVoiceChannelName, setNewVoiceChannelName] = useState('');
  const [speakingUsers, setSpeakingUsers] = useState(new Set());
  const audioContextRef = useRef(null);
  const analyserRef = useRef(null);
  const speakingTimeoutRef = useRef(null);
  const joinSoundRef = useRef(null);
  const leaveSoundRef = useRef(null);
  
  // Track destroyed peers to prevent signaling to them
  const destroyedPeersRef = useRef(new Set());
  
  // Helper function to create audio elements for remote streams
  const createAudioElement = (userId, stream) => {
    console.log('Creating audio element for user:', userId);
    const existingAudio = document.getElementById(`remote-audio-${userId}`);
    if (existingAudio) {
      console.log('Audio element already exists, removing it first');
      existingAudio.remove();
    }
    
    const audio = document.createElement('audio');
    audio.id = `remote-audio-${userId}`;
    audio.srcObject = stream;
    audio.autoplay = true;
    audio.controls = false; // Hide controls
    audio.volume = 1.0; // Full volume
    document.body.appendChild(audio);
    
    // Verify the audio element was created and is working
    console.log('Audio element created:', audio);
    console.log('Audio element autoplay:', audio.autoplay);
    console.log('Audio element srcObject:', audio.srcObject);
    
    return audio;
  };
  
  const MAX_CHARS = 500; // Maximum character limit

  // New state for tracking which message's menu is open
  const [activeMenu, setActiveMenu] = useState(null);

  // Initialize sound effects
  useEffect(() => {
    // Create the audio element for the join sound
    const joinSound = new Audio('/audio/vine-boom.mp3');
    joinSound.volume = 0.5; // Set volume to 50%
    joinSoundRef.current = joinSound;
    
    // Create the audio element for the leave sound
    const leaveSound = new Audio('/audio/vine-boom-leave.mp3');
    leaveSound.volume = 0.5; // Set volume to 50%
    leaveSoundRef.current = leaveSound;
    
    return () => {
      // Clean up
      if (joinSoundRef.current) {
        joinSoundRef.current.pause();
        joinSoundRef.current.src = '';
      }
      if (leaveSoundRef.current) {
        leaveSoundRef.current.pause();
        leaveSoundRef.current.src = '';
      }
    };
  }, []);
  
  // Connect to WebSocket server
  useEffect(() => {
    const socketInstance = io(API_CONFIG.BASE_URL.replace('/api', ''));
    setSocket(socketInstance);

    // Authenticate the socket connection
    const token = localStorage.getItem('auth_token');
    if (token) {
      socketInstance.emit('authenticate', token);
    }

    return () => {
      // Clean up voice chat if active
      if (localStream) {
        try {
          localStream.getTracks().forEach(track => track.stop());
        } catch (err) {
          console.error('Error stopping local stream tracks on unmount:', err);
        }
      }
      
      // Clean up peer connections safely using our helper function
      try {
        Object.values(peers).forEach(peer => {
          safelyDestroyPeer(peer);
        });
      } catch (err) {
        console.error('Error cleaning up peer connections on unmount:', err);
      }
      
      socketInstance.disconnect();
    };
  }, []);
  
  // Add effects to listen for message_deleted and room_deleted events
  useEffect(() => {
    if (!socket) return;
    
    const handleMessageDeleted = (data) => {
      setMessages(prev => prev.filter(msg => msg.id !== data.id));
    };
    
    const handleRoomDeleted = (data) => {
      // If the active room was deleted, set activeRoom to null
      if (activeRoom && activeRoom.id === data.id) {
        setActiveRoom(null);
      }
      
      // Remove the deleted room from the rooms list
      setRooms(prev => prev.filter(room => room.id !== data.id));
    };
    
    const handleVoiceChannelDeleted = (data) => {
      // If the active voice channel was deleted, leave it
      if (activeVoiceChannel && activeVoiceChannel.id === data.id) {
        leaveVoiceChannel();
      }
      
      // Remove the deleted voice channel from the list
      setVoiceChannels(prev => prev.filter(channel => channel.id !== data.id));
    };

    const handleMessagesCleared = (data) => {
      if (activeRoom && activeRoom.id === data.roomId) {
        // If this is for our current room, clear the messages
        if (data.count === 'all') {
          setMessages([]);
        } else {
          // Remove the most recent N messages
          const messageCount = parseInt(data.count, 10);
          if (!isNaN(messageCount)) {
            setMessages(prev => prev.slice(0, Math.max(0, prev.length - messageCount)));
          }
        }
        
        // Add a system message
        setMessages(prev => [...prev, {
          id: 'system-' + Date.now(),
          username: 'System',
          message: `Messages have been cleared by an admin.`,
          created_at: new Date().toISOString(),
          isSystem: true
        }]);
      }
    };
    
    socket.on('message_deleted', handleMessageDeleted);
    socket.on('room_deleted', handleRoomDeleted);
    socket.on('voice_channel_deleted', handleVoiceChannelDeleted);
    socket.on('messages_cleared', handleMessagesCleared);
    
    return () => {
      socket.off('message_deleted', handleMessageDeleted);
      socket.off('room_deleted', handleRoomDeleted);
      socket.off('voice_channel_deleted', handleVoiceChannelDeleted);
      socket.off('messages_cleared', handleMessagesCleared);
    };
  }, [socket, activeRoom, activeVoiceChannel]);

  // Load chat state from IndexedDB on mount
  useEffect(() => {
    const loadChatState = async () => {
      try {
        // Try to load chat state from IndexedDB
        const savedState = await getChatState(nodeId);
        
        if (savedState && savedState.content && !stateLoadedRef.current) {
          console.log(`Loaded chat state for window ${nodeId} from IndexedDB:`, savedState.content);
          
          // If we have a saved active room ID, we'll use it after fetching rooms
          stateLoadedRef.current = true;
          
          // Store the active room ID to use after fetching rooms
          if (savedState.content.activeRoomId) {
            // We'll set this after fetching rooms
            window.setTimeout(() => {
              if (rooms.length > 0) {
                const savedRoom = rooms.find(room => room.id === savedState.content.activeRoomId);
                if (savedRoom) {
                  setActiveRoom(savedRoom);
                  console.log(`Restored active room: ${savedRoom.name}`);
                }
              }
            }, 100);
          }
        }
      } catch (error) {
        console.error(`Failed to load chat state for window ${nodeId} from IndexedDB:`, error);
      }
    };
    
    loadChatState();
  }, [nodeId]);
  
  // Handle window activation
  useEffect(() => {
    if (isActive) {
      // Save this as the active chat window
      setActiveWindow(nodeId, WINDOW_TYPES.CHAT);
    }
  }, [isActive, nodeId, setActiveWindow]);

  // Fetch available rooms
  useEffect(() => {
    const fetchRooms = async () => {
      try {
        const token = localStorage.getItem('auth_token');
        const response = await axios.get(`${API_CONFIG.BASE_URL}/chat/rooms`, {
          headers: { Authorization: `Bearer ${token}` }
        });
        setRooms(response.data);
        roomsLoadedRef.current = true;
        
        // Get saved active room ID from sessionStorage
        const savedRoomId = sessionStorage.getItem(`chat_active_room_${nodeId}`);
        
        if (savedRoomId && response.data.length > 0) {
          // Try to find the saved room
          const savedRoom = response.data.find(room => 
            room.id === parseInt(savedRoomId, 10) || room.id === savedRoomId
          );
          
          if (savedRoom) {
            console.log(`Restoring saved room: ${savedRoom.name}`);
            setActiveRoom(savedRoom);
            
            // Load any saved draft message for this room
            const savedDraft = localStorage.getItem(`chat_draft_${nodeId}_${savedRoom.id}`);
            if (savedDraft) {
              setNewMessage(savedDraft);
              setCharCount(savedDraft.length);
            }
            
            return;
          }
        }
        
        // If no saved room was found or restored, and there are rooms but no active room,
        // set the first one as active
        if (response.data.length > 0 && !activeRoom) {
          setActiveRoom(response.data[0]);
        }
      } catch (error) {
        console.error('Failed to fetch rooms:', error);
      }
    };

    fetchRooms();
  }, []); // Only run once on mount

  // Save active room to IndexedDB and sessionStorage when it changes
  useEffect(() => {
    if (!activeRoom) return;
    
    // Save to sessionStorage for immediate persistence across refreshes
    sessionStorage.setItem(`chat_active_room_${nodeId}`, activeRoom.id);
    
    // Also save to IndexedDB for longer term storage if state is loaded
    if (stateLoadedRef.current) {
      saveChatState({
        id: nodeId,
        content: {
          activeRoomId: activeRoom.id
        }
      }).catch(error => {
        console.error(`Failed to save chat state for window ${nodeId} to IndexedDB:`, error);
      });
      
      console.log(`Saved active room ID ${activeRoom.id} to IndexedDB for window ${nodeId}`);
    }
    
    // Check for any saved draft message
    const savedDraft = localStorage.getItem(`chat_draft_${nodeId}_${activeRoom.id}`);
    if (savedDraft && newMessage !== savedDraft) {
      setNewMessage(savedDraft);
      setCharCount(savedDraft.length);
    }
  }, [activeRoom, nodeId, newMessage]);

  // Join room and fetch messages
  useEffect(() => {
    if (!activeRoom || !socket) return;

    // Join the room via WebSocket
    socket.emit('join_room', activeRoom.id);

    // Fetch messages for the room
    const fetchMessages = async () => {
      try {
        const token = localStorage.getItem('auth_token');
        const response = await axios.get(
          `${API_CONFIG.BASE_URL}/chat/rooms/${activeRoom.id}/messages`,
          { headers: { Authorization: `Bearer ${token}` } }
        );
        setMessages(response.data);
      } catch (error) {
        console.error('Failed to fetch messages:', error);
      }
    };

    // Fetch voice channels for the room
    const fetchVoiceChannels = async () => {
      try {
        const token = localStorage.getItem('auth_token');
        const response = await axios.get(
          `${API_CONFIG.BASE_URL}/chat/rooms/${activeRoom.id}/voice-channels`,
          { headers: { Authorization: `Bearer ${token}` } }
        );
        setVoiceChannels(response.data);
      } catch (error) {
        console.error('Failed to fetch voice channels:', error);
      }
    };

    fetchMessages();
    fetchVoiceChannels();

    // Listen for new messages
    const handleNewMessage = (message) => {
      setMessages((prev) => [...prev, message]);
    };

    socket.on('new_message', handleNewMessage);
//test
    return () => {
      // Leave the room when component unmounts or room changes
      socket.emit('leave_room', activeRoom.id);
      socket.off('new_message', handleNewMessage);
    };
  }, [activeRoom, socket]);

  // Set up voice activity detection
  useEffect(() => {
    if (!localStream || !socket || !activeVoiceChannel) return;
    
    // Create audio context and analyzer
    try {
      // Clean up any existing audio context
      if (audioContextRef.current) {
        audioContextRef.current.close();
      }
      
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      audioContextRef.current = audioContext;
      
      // Create analyzer node
      const analyser = audioContext.createAnalyser();
      analyser.fftSize = 256;
      analyser.smoothingTimeConstant = 0.8;
      analyserRef.current = analyser;
      
      // Connect the stream to the analyzer
      const source = audioContext.createMediaStreamSource(localStream);
      source.connect(analyser);
      
      // Set up the buffer for the analyzer
      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);
      
      // Function to check if user is speaking
      const checkSpeaking = () => {
        if (!analyser || !socket || !activeVoiceChannel || isMuted) return;
        
        analyser.getByteFrequencyData(dataArray);
        
        // Calculate average volume
        let sum = 0;
        for (let i = 0; i < bufferLength; i++) {
          sum += dataArray[i];
        }
        const average = sum / bufferLength;
        
        // Threshold for speaking detection
        const threshold = 20; // Adjust as needed
        
        // Check if speaking
        const isSpeaking = average > threshold;
        
        // If speaking state changed, emit event
        if (isSpeaking && !speakingUsers.has(user.id)) {
          // User started speaking
          socket.emit('voice_speaking_start', {
            channelId: activeVoiceChannel.id
          });
          
          // Update local state
          setSpeakingUsers(prev => {
            const newSet = new Set(prev);
            newSet.add(user.id);
            return newSet;
          });
          
          // Clear any existing timeout
          if (speakingTimeoutRef.current) {
            clearTimeout(speakingTimeoutRef.current);
          }
        } else if (!isSpeaking && speakingUsers.has(user.id)) {
          // Set a timeout to stop speaking status after a short delay
          // This prevents the speaking status from flickering
          if (!speakingTimeoutRef.current) {
            speakingTimeoutRef.current = setTimeout(() => {
              socket.emit('voice_speaking_stop', {
                channelId: activeVoiceChannel.id
              });
              
              // Update local state
              setSpeakingUsers(prev => {
                const newSet = new Set(prev);
                newSet.delete(user.id);
                return newSet;
              });
              
              speakingTimeoutRef.current = null;
            }, 300); // 300ms delay
          }
        }
      };
      
      // Set up interval to check speaking
      const intervalId = setInterval(checkSpeaking, 100); // Check every 100ms
      
      return () => {
        clearInterval(intervalId);
        if (speakingTimeoutRef.current) {
          clearTimeout(speakingTimeoutRef.current);
        }
        if (audioContextRef.current) {
          audioContextRef.current.close();
          audioContextRef.current = null;
        }
        analyserRef.current = null;
      };
    } catch (error) {
      console.error('Error setting up voice activity detection:', error);
    }
  }, [localStream, socket, activeVoiceChannel, isMuted, user.id, speakingUsers]);
  
  // Voice chat socket event handlers
  useEffect(() => {
    if (!socket) return;
    
    // Handle speaking events
    const handleUserSpeakingStart = (data) => {
      if (data.channelId === activeVoiceChannel?.id && data.userId !== user.id) {
        setSpeakingUsers(prev => {
          const newSet = new Set(prev);
          newSet.add(data.userId);
          return newSet;
        });
      }
    };
    
    const handleUserSpeakingStop = (data) => {
      if (data.channelId === activeVoiceChannel?.id && data.userId !== user.id) {
        setSpeakingUsers(prev => {
          const newSet = new Set(prev);
          newSet.delete(data.userId);
          return newSet;
        });
      }
    };
    
    socket.on('user_speaking_start', handleUserSpeakingStart);
    socket.on('user_speaking_stop', handleUserSpeakingStop);
    
    // Handle when a user joins a voice channel
    const handleUserJoinedVoice = (data) => {
      console.log('User joined voice:', data);
      
      // Add to participants list
      setVoiceParticipants(prev => {
        // Check if user is already in the list
        if (prev.some(p => p.user_id === data.userId)) {
          return prev;
        }
        
        // Play join sound if this is our active channel and we're not the one joining
        if (activeVoiceChannel && 
            activeVoiceChannel.id === data.channelId && 
            data.userId !== user.id &&
            joinSoundRef.current) {
          // Reset the audio to the beginning and play it
          joinSoundRef.current.currentTime = 0;
          joinSoundRef.current.play().catch(err => {
            console.error('Error playing join sound:', err);
          });
        }
        
        return [...prev, {
          user_id: data.userId,
          username: data.username,
          is_muted: data.isMuted,
          channel_id: data.channelId
        }];
      });
      
      // If this is our active voice channel and we have a local stream,
      // initiate a peer connection to the new user
      if (activeVoiceChannel && 
          activeVoiceChannel.id === data.channelId && 
          localStream && 
          localStream.active && // Check that stream is active
          data.userId !== user.id) {
        
        console.log('Creating new peer connection to user:', data.userId);
        
        // Create peer connection with optimized settings
        try {
          // Track connection start time for performance monitoring
          const connectionStartTime = performance.now();
          
          const peer = new SimplePeer({
            initiator: true,
            trickle: true, // Enable trickle ICE for faster connections
            stream: localStream,
            config: {
              iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' }
              ],
              iceCandidatePoolSize: 10 // Pre-gather some ICE candidates
            }
          });
            
            peer.on('signal', signal => {
              console.log('Generated signal for user:', data.userId, signal);
              console.time('signaling-' + data.userId);
              socket.emit('voice_signal', {
                channelId: activeVoiceChannel.id,
                targetUserId: data.userId,
                signal
              });
            });
            
            peer.on('stream', stream => {
              console.log('Received stream from user:', data.userId, stream);
              // Create audio element for the remote stream
              createAudioElement(data.userId, stream);
            });
            
            // Add error handling
            peer.on('error', err => {
              console.error('Peer connection error (initiator):', err);
            });
            
            // Monitor ICE connection state
            peer.on('iceStateChange', state => {
              console.log('ICE state change (initiator):', state);
            });
            
            // Monitor connection state with timing
            peer.on('connect', () => {
              console.timeEnd('signaling-' + data.userId);
              const connectionTime = performance.now() - connectionStartTime;
              console.log('Peer connection established (initiator) with user:', data.userId, 'in', connectionTime.toFixed(0), 'ms');
            });
            
            // Add to peers state
            setPeers(prev => ({
              ...prev,
              [data.userId]: peer
            }));
          } catch (err) {
            console.error('Error creating peer connection (initiator):', err);
          }
      }
    };

    
    
    // Handle when a user leaves a voice channel
    const handleUserLeftVoice = (data) => {
      console.log('User left voice:', data);
      
      // Play leave sound if this is our active channel and we're not the one leaving
      if (activeVoiceChannel && 
          activeVoiceChannel.id === data.channelId && 
          data.userId !== user.id &&
          leaveSoundRef.current) {
        // Reset the audio to the beginning and play it
        leaveSoundRef.current.currentTime = 0;
        leaveSoundRef.current.play().catch(err => {
          console.error('Error playing leave sound:', err);
        });
      }
      
      // Remove from participants list
      setVoiceParticipants(prev => 
        prev.filter(p => !(p.user_id === data.userId && p.channel_id === data.channelId))
      );
      
      // If we have a peer connection to this user, clean it up
      if (peers[data.userId]) {
        // Use our helper function to safely destroy the peer
        safelyDestroyPeer(peers[data.userId], data.userId, destroyedPeersRef);
        
        // Remove the audio element
        const audioElement = document.getElementById(`remote-audio-${data.userId}`);
        if (audioElement) {
          try {
            audioElement.remove();
          } catch (err) {
            console.error('Error removing audio element:', err);
          }
        }
        
        // Remove from peers state with a small delay to allow cleanup
        setTimeout(() => {
          setPeers(prev => {
            const newPeers = { ...prev };
            delete newPeers[data.userId];
            return newPeers;
          });
        }, 200);
      }
    };
    
    // Handle voice participants list
    const handleVoiceParticipants = (data) => {
      if (data.channelId === activeVoiceChannel?.id) {
        setVoiceParticipants(data.participants);
      }
    };
    
    // Handle WebRTC signaling
    const handleVoiceSignal = (data) => {
      console.log('Received voice signal:', data);
      
      // If the signal is for us and we're in the same channel
      if (data.channelId === activeVoiceChannel?.id && data.fromUserId !== user.id) {
        
        // If we already have a peer for this user and it's not in the destroyed list
        if (peers[data.fromUserId] && !destroyedPeersRef.current.has(data.fromUserId)) {
          console.log('Signaling existing peer for user:', data.fromUserId);
          try {
            peers[data.fromUserId].signal(data.signal);
          } catch (err) {
            console.error('Error signaling peer, it may have been destroyed:', err);
            // Mark this peer as destroyed to prevent future signaling attempts
            destroyedPeersRef.current.add(data.fromUserId);
          }
        } else {
          // Check if we have a valid stream
          if (!localStream || !localStream.active) {
            console.error('Cannot create peer connection: localStream is not available or not active');
            return;
          }
          
          // Create a new peer with optimized settings
          console.log('Creating new non-initiator peer for user:', data.fromUserId);
          
          try {
            // Track connection start time for performance monitoring
            const connectionStartTime = performance.now();
            
            const peer = new SimplePeer({
              initiator: false,
              trickle: true, // Enable trickle ICE for faster connections
              stream: localStream,
              config: {
                iceServers: [
                  { urls: 'stun:stun.l.google.com:19302' },
                  { urls: 'stun:stun1.l.google.com:19302' },
                  { urls: 'stun:stun2.l.google.com:19302' },
                  { urls: 'stun:stun3.l.google.com:19302' },
                  { urls: 'stun:stun4.l.google.com:19302' }
                ],
                iceCandidatePoolSize: 10 // Pre-gather some ICE candidates
              }
            });
              
              peer.on('signal', signal => {
                console.log('Generated response signal for user:', data.fromUserId, signal);
                console.time('signaling-' + data.fromUserId);
                socket.emit('voice_signal', {
                  channelId: activeVoiceChannel.id,
                  targetUserId: data.fromUserId,
                  signal
                });
              });
              
              peer.on('stream', stream => {
                console.log('Received stream from user:', data.fromUserId, stream);
                // Create audio element for the remote stream
                createAudioElement(data.fromUserId, stream);
              });
              
              // Add error handling
              peer.on('error', err => {
                console.error('Peer connection error (non-initiator):', err);
              });
              
              // Monitor ICE connection state
              peer.on('iceStateChange', state => {
                console.log('ICE state change (non-initiator):', state);
              });
              
              // Monitor connection state with timing
              peer.on('connect', () => {
                console.timeEnd('signaling-' + data.fromUserId);
                const connectionTime = performance.now() - connectionStartTime;
                console.log('Peer connection established (non-initiator) with user:', data.fromUserId, 'in', connectionTime.toFixed(0), 'ms');
              });
              
              // Signal with the received data
              peer.signal(data.signal);
              
              // Add to peers state
              setPeers(prev => ({
                ...prev,
                [data.fromUserId]: peer
              }));
            } catch (err) {
              console.error('Error creating peer connection (non-initiator):', err);
            }
        }
      }
    };
    
    // Handle mute status changes
    const handleUserMuteChanged = (data) => {
      setVoiceParticipants(prev => 
        prev.map(p => 
          p.user_id === data.userId && p.channel_id === data.channelId
            ? { ...p, is_muted: data.isMuted }
            : p
        )
      );
    };
    
    socket.on('user_joined_voice', handleUserJoinedVoice);
    socket.on('user_left_voice', handleUserLeftVoice);
    socket.on('voice_participants', handleVoiceParticipants);
    socket.on('voice_signal', handleVoiceSignal);
    socket.on('user_mute_changed', handleUserMuteChanged);
    
    return () => {
      socket.off('user_joined_voice', handleUserJoinedVoice);
      socket.off('user_left_voice', handleUserLeftVoice);
      socket.off('voice_participants', handleVoiceParticipants);
      socket.off('voice_signal', handleVoiceSignal);
      socket.off('user_mute_changed', handleUserMuteChanged);
    };
  }, [socket, activeVoiceChannel, localStream, peers, user]);

  // Scroll to bottom when messages change
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  const handleMessageChange = (e) => {
    const value = e.target.value;
    if (value.length <= MAX_CHARS) {
      setNewMessage(value);
      setCharCount(value.length);
      
      // Save draft message to localStorage
      if (activeRoom) {
        localStorage.setItem(`chat_draft_${nodeId}_${activeRoom.id}`, value);
      }
    }
  };

    // Command execution function
    const executeCommand = async (parsedCommand) => {
      const { command, args } = parsedCommand;
      
      // Handle different commands
      switch (command) {
        case 'clear':
        case 'delete':
          // Check if user is admin
          if (!user?.is_admin) {
            // Add system message that only admins can use this command
            setMessages(prev => [...prev, {
              id: 'system-' + Date.now(),
              username: 'System',
              message: 'Command failed: Admin privileges required',
              created_at: new Date().toISOString(),
              isSystem: true
            }]);
            return;
          }
          
          try {
            let count = 'all';
            if (args.length > 0) {
              count = args[0].toLowerCase() === 'all' ? 'all' : parseInt(args[0], 10);
              if (count !== 'all' && (isNaN(count) || count <= 0)) {
                setMessages(prev => [...prev, {
                  id: 'system-' + Date.now(),
                  username: 'System',
                  message: 'Invalid count. Usage: /clear [count|all]',
                  created_at: new Date().toISOString(),
                  isSystem: true
                }]);
                return;
              }
            }
            
            // Call the API to delete messages
            const token = localStorage.getItem('auth_token');
            const response = await axios.delete(
              `${API_CONFIG.BASE_URL}/chat/rooms/${activeRoom.id}/messages?count=${count}`,
              { headers: { Authorization: `Bearer ${token}` } }
            );
            
            // Add system message about successful deletion
            setMessages(prev => [...prev, {
              id: 'system-' + Date.now(),
              username: 'System',
              message: `${response.data.count} messages have been deleted from this channel.`,
              created_at: new Date().toISOString(),
              isSystem: true
            }]);
          } catch (error) {
            console.error('Failed to clear messages:', error);
            setMessages(prev => [...prev, {
              id: 'system-' + Date.now(),
              username: 'System',
              message: `Failed to clear messages: ${error.response?.data?.message || error.message}`,
              created_at: new Date().toISOString(),
              isSystem: true
            }]);
          }
          break;
          
        // Add other commands here in the future if needed
        
        default:
          // Unknown command
          setMessages(prev => [...prev, {
            id: 'system-' + Date.now(),
            username: 'System',
            message: `Unknown command: /${command}`,
            created_at: new Date().toISOString(),
            isSystem: true
          }]);
      }
    };

    const handleSendMessage = async (e) => {
      e.preventDefault();
      if (!newMessage.trim() || !activeRoom) return;
  
      // Check if this is a command
      const parsedCommand = parseCommand(newMessage);
      if (parsedCommand) {
        // This is a command, handle it with executeCommand
        await executeCommand(parsedCommand);
        setNewMessage('');
        setCharCount(0);
        // Clear the draft message from localStorage
        localStorage.removeItem(`chat_draft_${nodeId}_${activeRoom.id}`);
        return;
      }
  
      // This is a regular message, send it to the server
      try {
        const token = localStorage.getItem('auth_token');
        await axios.post(
          `${API_CONFIG.BASE_URL}/chat/rooms/${activeRoom.id}/messages`,
          { message: newMessage },
          { headers: { Authorization: `Bearer ${token}` } }
        );
        setNewMessage('');
        setCharCount(0);
        // Clear the draft message from localStorage
        localStorage.removeItem(`chat_draft_${nodeId}_${activeRoom.id}`);
      } catch (error) {
        console.error('Failed to send message:', error);
      }
    };

  const handleCreateRoom = async (e) => {
    e.preventDefault();
    if (!newRoomName.trim()) return;

    try {
      const token = localStorage.getItem('auth_token');
      const response = await axios.post(
        `${API_CONFIG.BASE_URL}/chat/rooms`,
        { name: newRoomName },
        { headers: { Authorization: `Bearer ${token}` } }
      );
      setRooms((prev) => [response.data, ...prev]);
      setNewRoomName('');
      setActiveRoom(response.data);
    } catch (error) {
      console.error('Failed to create room:', error);
    }
  };
  
  // Add new function to handle message deletion
  const handleDeleteMessage = async (messageId) => {
    try {
      const token = localStorage.getItem('auth_token');
      const endpoint = API_CONFIG.ENDPOINTS.CHAT_DELETE_MESSAGE.replace(':id', messageId);
      await axios.delete(
        `${API_CONFIG.BASE_URL}${endpoint}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      // The message will be removed from the UI when the socket event is received
      setActiveMenu(null); // Close the menu
    } catch (error) {
      console.error('Failed to delete message:', error);
    }
  };

  // Toggle menu function
  const toggleMenu = (messageId) => {
    setActiveMenu(activeMenu === messageId ? null : messageId);
  };

  const joinRoom = async (room) => {
    try {
      const token = localStorage.getItem('auth_token');
      await axios.post(
        `${API_CONFIG.BASE_URL}/chat/rooms/${room.id}/join`,
        {},
        { headers: { Authorization: `Bearer ${token}` } }
      );
      setActiveRoom(room);
    } catch (error) {
      console.error('Failed to join room:', error);
    }
  };
  
  // Voice chat functions
  const createVoiceChannel = async (e) => {
    e.preventDefault();
    if (!newVoiceChannelName.trim() || !activeRoom) return;
    
    try {
      const token = localStorage.getItem('auth_token');
      const response = await axios.post(
        `${API_CONFIG.BASE_URL}/chat/rooms/${activeRoom.id}/voice-channels`,
        { name: newVoiceChannelName },
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      setVoiceChannels(prev => [response.data, ...prev]);
      setNewVoiceChannelName('');
    } catch (error) {
      console.error('Failed to create voice channel:', error);
    }
  };
  
  const joinVoiceChannel = async (channel) => {
    // If already in a voice channel, leave it first
    if (activeVoiceChannel) {
      await leaveVoiceChannel();
    }
    
    try {
      // Request microphone access
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      
      // Verify we have an active stream with audio tracks
      if (!stream || !stream.active || stream.getAudioTracks().length === 0) {
        console.error('Failed to get active audio stream');
        alert('Could not access microphone. Please check your permissions.');
        return;
      }
      
      // Set initial mute state
      stream.getAudioTracks()[0].enabled = !isMuted;
      
      // Store the stream
      setLocalStream(stream);
      
      // Set the active voice channel
      setActiveVoiceChannel(channel);
      
      // Join the channel via socket
      socket.emit('join_voice', { 
        channelId: channel.id,
        isMuted
      });
      
      console.log(`Joined voice channel: ${channel.name}`);
    } catch (error) {
      console.error('Failed to join voice channel:', error);
      alert('Could not access microphone. Please check your permissions.');
    }
  };
  
  const leaveVoiceChannel = async () => {
    if (!activeVoiceChannel || !socket) return;
    
    // Notify server
    socket.emit('leave_voice', activeVoiceChannel.id);
    
    // Clean up peer connections safely using our helper function
    try {
      // Get keys (user IDs) from the peers object to use with safelyDestroyPeer
      Object.entries(peers).forEach(([userId, peer]) => {
        safelyDestroyPeer(peer, userId, destroyedPeersRef);
      });
    } catch (err) {
      console.error('Error cleaning up peer connections:', err);
    }
    
    // Clear the destroyed peers set when leaving a channel
    destroyedPeersRef.current = new Set();
    
    // Delay setting peers to empty to allow cleanup to complete
    setTimeout(() => {
      setPeers({});
    }, 300);
    
    // Remove remote audio elements
    document.querySelectorAll('[id^="remote-audio-"]').forEach(el => {
      try {
        el.remove();
      } catch (err) {
        console.error('Error removing audio element:', err);
      }
    });
    
    // Stop local stream
    if (localStream) {
      try {
        localStream.getTracks().forEach(track => track.stop());
      } catch (err) {
        console.error('Error stopping local stream tracks:', err);
      }
      setLocalStream(null);
    }
    
    // Clear active voice channel
    setActiveVoiceChannel(null);
    setVoiceParticipants([]);
    
    console.log('Left voice channel');
  };
  
  const toggleMute = () => {
    if (!localStream) return;
    
    // Toggle mute state
    const newMuteState = !isMuted;
    setIsMuted(newMuteState);
    
    // Update audio track
    localStream.getAudioTracks()[0].enabled = !newMuteState;
    
    // Notify others
    if (socket && activeVoiceChannel) {
      socket.emit('voice_mute_toggle', {
        channelId: activeVoiceChannel.id,
        isMuted: newMuteState
      });
    }
  };

  return (
    <div className="flex h-full">
      {/* Room sidebar */}
      <div className="w-1/9 max-w-[20%] min-w-[10%] bg-stone-900 border-r border-stone-700 flex flex-col">
        {/* Text channels */}
        <div className="p-2 border-b border-stone-700">
          <h3 className="text-teal-400 font-medium text-sm">Text Channels</h3>
        </div>
        <div className="flex-1 overflow-y-auto">
          {rooms.map((room) => (
            <div
              key={room.id}
              className={`text-sm p-2 cursor-pointer hover:bg-stone-700 ${
                activeRoom?.id === room.id ? 'bg-stone-800' : ''
              }`}
              onClick={() => joinRoom(room)}
            >
              <div className="text-white">{room.name}</div>
            </div>
          ))}
        </div>
        
        {/* Voice channels
        {activeRoom && (
          <>
            <div className="p-2 border-t border-b border-stone-700 flex justify-between items-center">
              <h3 className="text-teal-400 font-medium text-sm">Voice Channels</h3>
            </div>   
            <div className="overflow-y-auto">
              {voiceChannels.map((channel) => (
                <div
                  key={channel.id}
                  className={`text-sm p-2 cursor-pointer hover:bg-stone-700 ${
                    activeVoiceChannel?.id === channel.id ? 'bg-stone-800' : ''
                  }`}
                >
                  <div 
                    className="text-white flex items-center justify-between"
                    onClick={() => activeVoiceChannel?.id === channel.id ? leaveVoiceChannel() : joinVoiceChannel(channel)}
                  >
                    <span>{channel.name}</span>
                    {activeVoiceChannel?.id === channel.id ? (
                      <PhoneOff size={16} className="text-red-500" />
                    ) : (
                      <Phone size={16} className="text-teal-400" />
                    )}
                  </div> 
                  
                  {voiceParticipants.length > 0 && channel.id === activeVoiceChannel?.id && (
                    <div className="mt-1 pl-2 border-l border-stone-700">
                      {voiceParticipants.map(participant => (
                        <div key={participant.user_id} className="flex items-center text-xs text-stone-400 py-1">
                          {participant.is_muted ? (
                            <MicOff size={12} className="mr-1 text-red-500" />
                          ) : (
                            <Mic size={12} className={`mr-1 ${speakingUsers.has(participant.user_id) ? 'text-teal-400 animate-pulse' : 'text-green-500'}`} />
                          )}
                          <span 
                            className={`${speakingUsers.has(participant.user_id) && !participant.is_muted ? 'text-teal-400 font-medium animate-pulse' : ''}`}
                            style={{
                              textShadow: speakingUsers.has(participant.user_id) && !participant.is_muted ? '0 0 10px rgba(20, 184, 166, 0.5)' : 'none'
                            }}
                          >
                            {participant.username}
                          </span>
                          {participant.user_id === user.id && (
                            <button 
                              onClick={(e) => {
                                e.stopPropagation();
                                toggleMute();
                              }}
                              className="ml-2 text-stone-400 hover:text-teal-400"
                              title={isMuted ? "Unmute" : "Mute"}
                            >
                              {isMuted ? <MicOff size={12} /> : <Mic size={12} />}
                            </button>
                          )}
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              ))}
            </div>
          </>
        )}*/}
      </div>

      {/* Chat area */}
      <div className="flex-1 flex flex-col">
        {activeRoom ? (
          <>
            <div className="p-2 bg-stone-900 border-b border-stone-700 font-mono text-sm">
              <h3 className="text-teal-400 font-medium">{activeRoom.name}</h3>
            </div>
            <div className="flex-1 overflow-y-auto p-4 bg-stone-900">
              {messages.map((msg) => (
                <div
                  key={msg.id}
                  className="mb-1"
                >
                  <div
                    className="hover:bg-stone-800 inline-block rounded-lg px-4 py-2 w-[100%] break-all overflow-wrap break-word hyphens-auto overflow-hidden whitespace-pre-wrap relative text-white"
                    style={{ wordBreak: 'break-word', overflowWrap: 'break-word' }}
                  >
                    <div className="text-teal-400 flex font-medium text-s mb-1">
                      {msg.username}
                      <div className="text-xs text-white opacity-75 mt-1 ml-3">
                        {(() => {
                          // Ensure UTC interpretation by appending 'Z' if not already present
                          const timestamp = msg.created_at.endsWith('Z') ? 
                            msg.created_at : 
                            msg.created_at + 'Z';
                          
                          const msgDate = new Date(timestamp);
                          
                          return msgDate.toLocaleTimeString('en-US', {
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit',
                            hour: 'numeric',
                            minute: '2-digit',
                            timeZoneName: 'short',
                            hour12: false
                          });
                        })()}
                      </div>
                      
                      {/* Admin controls - only show if user is admin */}
                      {user?.is_admin && (
                        <div className="ml-auto">
                          <button 
                            onClick={(e) => {
                              e.stopPropagation();
                              handleDeleteMessage(msg.id);
                            }}
                            className="text-stone-400 hover:text-stone-300 focus:outline-none"
                            title="Delete message"
                          >
                            <Trash size={16} />
                          </button>
                        </div>
                      )}
                    </div>
                    <div>{msg.message}</div>
                  </div>
                </div>
              ))}
              <div ref={messagesEndRef} />
            </div>
            <form
              onSubmit={handleSendMessage}
              className="p-2 bg-stone-900 border-t border-stone-700 flex"
            >
              <div className="flex-1 flex flex-col">
                <input
                  type="text"
                  value={newMessage}
                  onChange={handleMessageChange}
                  className="flex-1 bg-stone-800 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none focus:ring-1 focus:ring-teal-400"
                  maxLength={MAX_CHARS}
                />
              </div>
            </form>
          </>
        ) : (
          <div className="flex-1 flex items-center justify-center bg-stone-900">
            <div className="text-stone-500">
              Select a channel to start chatting
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default ChatWindow;

================
File: windows/DiceRollGif.jsx
================
import React, { useEffect, useRef, useState } from 'react';

/**
 * Component to display dice roll GIF with animation completion detection
 */
const DiceRollGif = ({ src, onAnimationComplete }) => {
  const imgRef = useRef(null);
  const [isLoaded, setIsLoaded] = useState(false);
  
  // When the image loads, start tracking animation completion
  const handleImageLoad = () => {
    setIsLoaded(true);
  };
  
  // Effect to handle animation completion
  useEffect(() => {
    if (!isLoaded || !imgRef.current) return;
    
    // Create a temporary canvas to analyze the GIF
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    // Set a timeout that slightly exceeds typical GIF durations
    // This is a fallback in case we can't detect the exact animation end
    const timeoutId = setTimeout(() => {
      onAnimationComplete();
    }, 3000); // 3 seconds should be enough for most dice roll animations
    
    // For a more accurate approach (future improvement):
    // We could load the GIF via a GIF parsing library to get exact duration
    // Or track the animation via requestAnimationFrame and pixel comparison

    return () => {
      clearTimeout(timeoutId);
    };
  }, [isLoaded, onAnimationComplete]);
  
  return (
    <img 
      ref={imgRef}
      src={src} 
      alt="Rolling dice" 
      className="inline-block max-w-full h-32"
      onLoad={handleImageLoad}
    />
  );
};

export default DiceRollGif;

================
File: windows/explorer/api/fileOperations.js
================
import API_CONFIG from '../../../../config/api';

// Function to fetch public directory contents
export const fetchPublicDirectoryContents = async (publicPath = '/', refreshAll = false) => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // If refreshAll is true, start from the root
    const pathToFetch = refreshAll ? '/' : publicPath;
    
    // Fetch public directory contents from the server
    const response = await fetch(
      `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PUBLIC_FILES_LIST}?path=${encodeURIComponent(pathToFetch)}`,
      {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      }
    );
    
    if (!response.ok) {
      throw new Error(`Failed to load public files: ${response.statusText}`);
    }
    
    const data = await response.json();
    
    // Transform the data to match our expected format
    const transformedFiles = data.items.map(item => ({
      name: item.name,
      type: item.type,
      path: item.path,
      children: item.children || [],
      isPublic: true
    }));
    
    return {
      files: transformedFiles,
      error: null
    };
  } catch (error) {
    console.error('Error fetching public directory contents:', error);
    return {
      files: [],
      error: error.message || 'Failed to load public files. Please try again.'
    };
  }
};

// Function to fetch public file content
export const fetchPublicFileContent = async (filePath) => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // Fetch public file content from the server
    const url = `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PUBLIC_FILE_CONTENT}?path=${encodeURIComponent(filePath)}`;
    
    const response = await fetch(
      url,
      {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      }
    );
    
    const data = await response.json();
    console.log(`[DEBUG] Public file fetch - Content received length: ${data.content?.length || 0} characters`);
    
    return {
      content: data.content,
      error: null
    };
  } catch (error) {
    console.error('[DEBUG] Error fetching public file content:', error);
    return {
      content: '',
      error: error.message || 'Error loading file'
    };
  }
};

// Function to fetch private directory contents from the server (admin only)
export const fetchDirectoryContents = async (path = '/', refreshAll = false) => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // If refreshAll is true, start from the root
    const pathToFetch = refreshAll ? '/' : path;
    
    // Fetch directory contents from the server
    const response = await fetch(
      `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILES_LIST}?path=${encodeURIComponent(pathToFetch)}`,
      {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      }
    );
    
    if (!response.ok) {
      // If response is 403, it means the user doesn't have admin access
      if (response.status === 403) {
        throw new Error('Admin access required to view files.');
      } else {
        throw new Error(`Failed to load files: ${response.statusText}`);
      }
    }
    
    const data = await response.json();
    
    // Transform the data to match our expected format
    const transformedFiles = data.items.map(item => ({
      name: item.name,
      type: item.type,
      path: item.path,
      children: item.children || []
    }));
    
    return {
      files: transformedFiles,
      error: null
    };
  } catch (error) {
    return {
      files: [],
      error: error.message || 'Failed to load files. Please try again.'
    };
  }
};

// Function to fetch file content
export const fetchFileContent = async (filePath) => {
  console.log(`[DEBUG] fetchFileContent called with path: ${filePath}`);
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // Fetch file content from the server
    const url = `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_CONTENT}?path=${encodeURIComponent(filePath)}`;
    
    const response = await fetch(
      url,
      {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      }
    );
    
    
    if (!response.ok) {
      // If response is 403, it means the user doesn't have admin access
      if (response.status === 403) {
        throw new Error('Admin access required to view file content.');
      } else {
        const errorText = await response.text();
        throw new Error(`Failed to load file content: ${response.statusText}`);
      }
    }
    
    const data = await response.json();
    
    return {
      content: data.content,
      error: null
    };
  } catch (error) {
    return {
      content: '',
      error: error.message || 'Error loading file'
    };
  }
};

// Function to save file content
export const saveFileContent = async (filePath, content) => {

  
  try {
    // Check if filePath is valid
    if (!filePath || filePath.trim() === '') {
      throw new Error('No file selected. Please select a file first.');
    }
    
    // Special handling for .map files to ensure rotation is included
    let contentToSave = content;
    if (filePath?.endsWith('.map') && typeof content === 'string') {
      // For map files, parse the JSON, process it, and re-stringify it
      try {
        const mapData = JSON.parse(content);
        
        // Ensure all cells have rotation property
        if (mapData.layers && Array.isArray(mapData.layers)) {
          mapData.layers.forEach(layer => {
            if (layer.cells && Array.isArray(layer.cells)) {
              layer.cells = layer.cells.map(cell => {
                // If rotation doesn't exist, add it with default value of 0
                if (cell.rotation === undefined) {
                  return { ...cell, rotation: 0 };
                }
                // Ensure rotation is a number
                if (typeof cell.rotation !== 'number') {
                  return { ...cell, rotation: Number(cell.rotation) };
                }
                return cell;
              });
            }
          });
        }
        
        // Use a custom replacer to guarantee rotation values are included
        contentToSave = JSON.stringify(mapData, (key, value) => {
          if (key === 'rotation') {
            return value === undefined ? 0 : Number(value);
          }
          return value;
        }, 2);
        
      } catch (parseError) {
        // If we can't parse, just use the original content
        contentToSave = content;
      }
    }
    
    // Create request body
    const requestBody = JSON.stringify({
      path: filePath,
      content: contentToSave
    });
    
    
    // Make the API request
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_SAVE}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
      },
      body: requestBody
    });
    
    
    const responseData = await response.json();
    
    if (!response.ok) {
      throw new Error(responseData.message || `Failed to save file: ${response.statusText}`);
    }
    
    console.log(`[DEBUG] saveFileContent - Success!`);
    return { 
      error: null,
      size: responseData.size,
      modified: responseData.modified
    };
  } catch (error) {
    console.error('[DEBUG] Error saving file:', error);
    return { error: error.message || 'Error saving file' };
  }
};

// Simple path join function for browser environment
const joinPaths = (...parts) => {
  // Filter out empty parts and normalize
  const normalized = parts.map(part => {
    if (part === undefined || part === null) return '';
    // Remove leading/trailing slashes
    return part.toString().replace(/^\/+|\/+$/g, '');
  }).filter(Boolean);
  
  // Join with slashes and add leading slash
  return '/' + normalized.join('/');
};

// Function to create a new file or folder
export const createNewItem = async (activeTab, activeFolderPath, newItemName, createType) => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // Determine if we're creating in the public folder or private folder
    const isPublicFolder = activeTab === 'public';
    
    // Construct the full path for the new item
    let newItemPath;
    if (isPublicFolder) {
      // For public folder, prefix with /public if not already included
      const publicPrefix = activeFolderPath.startsWith('/public') ? '' : '/public';
      // Remove any leading slash from activeFolderPath if it exists and if using publicPrefix
      const folderPath = publicPrefix && activeFolderPath.startsWith('/') 
        ? activeFolderPath.substring(1) 
        : activeFolderPath;
      newItemPath = joinPaths(publicPrefix, folderPath, newItemName.trim());
    } else {
      // For private folder (admin only)
      newItemPath = joinPaths(activeFolderPath, newItemName.trim());
    }
    
    // Create the new file or folder
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_CREATE}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        path: newItemPath,
        type: createType,
        content: createType === 'file' ? '' : undefined
      })
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || `Failed to create ${createType}: ${response.statusText}`);
    }
    
    return { 
      success: true, 
      path: newItemPath,
      error: null
    };
  } catch (error) {
    console.error(`Error creating ${createType}:`, error);
    return { 
      success: false, 
      path: null,
      error: error.message || `Failed to create ${createType}` 
    };
  }
};

// Function to rename a file or folder
export const renameItem = async (itemPath, newName) => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // Rename the file or folder
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_RENAME}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        oldPath: itemPath,
        newName: newName.trim()
      })
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || `Failed to rename: ${response.statusText}`);
    }
    
    return { success: true, error: null };
  } catch (error) {
    console.error('Error renaming:', error);
    return { success: false, error: error.message || 'Failed to rename' };
  }
};

// Function to delete a file or folder
export const deleteItem = async (itemPath) => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // Delete the file or folder
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_DELETE}?path=${encodeURIComponent(itemPath)}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || `Failed to delete: ${response.statusText}`);
    }
    
    return { success: true, error: null };
  } catch (error) {
    console.error('Error deleting:', error);
    return { success: false, error: error.message || 'Failed to delete' };
  }
};

// Function to move a file or folder
// Function to get storage usage statistics
export const getStorageStats = async () => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // Fetch storage stats from the server
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.STORAGE_STATS}`, {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });
    
    if (!response.ok) {
      throw new Error(`Failed to load storage stats: ${response.statusText}`);
    }
    
    const data = await response.json();
    
    return {
      quota: data.quota,
      used: data.used,
      available: data.available,
      unlimited: data.unlimited,
      error: null
    };
  } catch (error) {
    console.error('Error fetching storage stats:', error);
    return {
      quota: 0,
      used: 0,
      available: 0,
      unlimited: false,
      error: error.message || 'Failed to load storage stats'
    };
  }
};

export const moveItem = async (sourcePath, destinationPath) => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // Call the API to move the file
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_MOVE}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        sourcePath,
        destinationPath
      })
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || `Failed to move: ${response.statusText}`);
    }
    
    return { success: true, error: null };
  } catch (error) {
    console.error('Error moving item:', error);
    return { success: false, error: error.message || 'Failed to move item' };
  }
};

================
File: windows/explorer/components/canvas/CanvasContainer.jsx
================
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { 
  generateId, 
  isPointInNode, 
  createTextNode, 
  createEdge,
  calculateBestConnectionSides,
  getConnectionPoints,
  drawConnection,
  getCanvasColor
} from '../../utils/canvasUtils';
import TextNode from './TextNode';

/**
 * CanvasContainer handles the infinite canvas, viewport, and interactions
 */
const CanvasContainer = ({ 
  canvasData, 
  onChange,
  readOnly = false
}) => {
  // State for viewport and interaction
  const [scale, setScale] = useState(1);
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  const [isPanning, setIsPanning] = useState(false);
  const [panStart, setPanStart] = useState({ x: 0, y: 0 });
  const [selectedNodeIds, setSelectedNodeIds] = useState([]);
  const [editingNodeId, setEditingNodeId] = useState(null);
  const [isConnecting, setIsConnecting] = useState(false);
  const [connectionStart, setConnectionStart] = useState(null);
  const [hoveredNodeId, setHoveredNodeId] = useState(null);
  const [isDragging, setIsDragging] = useState(false);
  const [draggedNodeIds, setDraggedNodeIds] = useState([]);

  // Refs for canvas elements
  const containerRef = useRef(null);
  const canvasRef = useRef(null);
  const interactionLayerRef = useRef(null);

  // Get the currently selected node
  const selectedNode = canvasData.nodes.find(node => node.id === selectedNodeIds[0]);

  // Draw the canvas with nodes and edges
  const drawCanvas = useCallback(() => {
    if (!canvasRef.current) return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const { width, height } = canvas;
    
    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    
    // Apply viewport transformation
    ctx.save();
    ctx.translate(offset.x, offset.y);
    ctx.scale(scale, scale);
    
    // Draw background grid (optional)
    ctx.strokeStyle = '#2a2a2a';
    ctx.lineWidth = 1 / scale;
    
    const gridSize = 20;
    const startX = Math.floor(-offset.x / scale / gridSize) * gridSize;
    const startY = Math.floor(-offset.y / scale / gridSize) * gridSize;
    const endX = Math.ceil((width - offset.x) / scale / gridSize) * gridSize;
    const endY = Math.ceil((height - offset.y) / scale / gridSize) * gridSize;
    
    // Draw vertical grid lines
    for (let x = startX; x <= endX; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, startY);
      ctx.lineTo(x, endY);
      ctx.stroke();
    }
    
    // Draw horizontal grid lines
    for (let y = startY; y <= endY; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(startX, y);
      ctx.lineTo(endX, y);
      ctx.stroke();
    }
    
    // Draw edges
    canvasData.edges.forEach(edge => {
      const sourceNode = canvasData.nodes.find(n => n.id === edge.fromNode);
      const targetNode = canvasData.nodes.find(n => n.id === edge.toNode);
      
      if (sourceNode && targetNode) {
        // Get connection points
        const points = getConnectionPoints(
          sourceNode, 
          targetNode, 
          edge.fromSide, 
          edge.toSide
        );
        
        // Draw the connection
        drawConnection(
          ctx, 
          points.source, 
          points.target, 
          getCanvasColor(edge.color),
          edge.fromEnd === 'arrow',
          edge.toEnd === 'arrow'
        );
      }
    });
    
    // Restore the context
    ctx.restore();
  }, [canvasData, offset, scale]);

  // Resize canvas to fit container
  const resizeCanvas = useCallback(() => {
    if (!containerRef.current || !canvasRef.current || !interactionLayerRef.current) return;
    
    const container = containerRef.current;
    const canvas = canvasRef.current;
    const interactionLayer = interactionLayerRef.current;
    
    // Set canvas size to match container
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    interactionLayer.width = container.clientWidth;
    interactionLayer.height = container.clientHeight;
    
    // Redraw canvas
    drawCanvas();
  }, [drawCanvas]);

  // Initialize and set up event listeners
  useEffect(() => {
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    return () => {
      window.removeEventListener('resize', resizeCanvas);
    };
  }, [resizeCanvas]);

  // Redraw canvas when data changes
  useEffect(() => {
    drawCanvas();
  }, [canvasData, drawCanvas, selectedNodeIds, scale, offset]);

  // Handle mouse wheel for zooming
  const handleWheel = (e) => {
    e.preventDefault();
    
    const { deltaY } = e;
    const direction = deltaY > 0 ? -1 : 1;
    
    // Calculate zoom
    const factor = 0.1;
    const newScale = Math.max(0.1, scale * (1 + direction * factor));
    
    // Get mouse position relative to canvas
    const rect = canvasRef.current.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Calculate new offset to zoom around mouse position
    const newOffsetX = mouseX - (mouseX - offset.x) * (newScale / scale);
    const newOffsetY = mouseY - (mouseY - offset.y) * (newScale / scale);
    
    setScale(newScale);
    setOffset({ x: newOffsetX, y: newOffsetY });
  };

  // Handle mouse down for panning and selection
  const handleMouseDown = (e) => {
    // Get mouse position relative to canvas
    const rect = canvasRef.current.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Convert to canvas coordinates
    const canvasX = (mouseX - offset.x) / scale;
    const canvasY = (mouseY - offset.y) / scale;
    
    // Check if clicked on a node
    const nodeUnderMouse = canvasData.nodes.find(node => 
      isPointInNode({ x: canvasX, y: canvasY }, node)
    );
    
    if (nodeUnderMouse) {
      // Select the node
      if (e.shiftKey) {
        // Add to selection if holding shift
        setSelectedNodeIds(prev => 
          prev.includes(nodeUnderMouse.id) 
            ? prev.filter(id => id !== nodeUnderMouse.id) 
            : [...prev, nodeUnderMouse.id]
        );
      } else if (!selectedNodeIds.includes(nodeUnderMouse.id)) {
        // Replace selection
        setSelectedNodeIds([nodeUnderMouse.id]);
      }
      
      // Prepare for dragging
      setIsDragging(true);
      setDraggedNodeIds(selectedNodeIds.includes(nodeUnderMouse.id) 
        ? selectedNodeIds 
        : [nodeUnderMouse.id]
      );
    } else {
      // Start panning
      setIsPanning(true);
      setPanStart({ x: mouseX, y: mouseY });
      
      // Clear selection unless shift is held
      if (!e.shiftKey) {
        setSelectedNodeIds([]);
      }
    }
  };

  // Handle mouse move for panning and dragging
  const handleMouseMove = (e) => {
    // Get mouse position relative to canvas
    const rect = canvasRef.current.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Convert to canvas coordinates
    const canvasX = (mouseX - offset.x) / scale;
    const canvasY = (mouseY - offset.y) / scale;
    
    // Handle panning
    if (isPanning) {
      const deltaX = mouseX - panStart.x;
      const deltaY = mouseY - panStart.y;
      
      setOffset(prev => ({
        x: prev.x + deltaX,
        y: prev.y + deltaY
      }));
      
      setPanStart({ x: mouseX, y: mouseY });
    }
    
    // Handle dragging
    if (isDragging && draggedNodeIds.length > 0 && !readOnly) {
      // Calculate the delta from last mouse position
      const lastMousePos = {
        x: (panStart.x - offset.x) / scale,
        y: (panStart.y - offset.y) / scale
      };
      
      const deltaX = canvasX - lastMousePos.x;
      const deltaY = canvasY - lastMousePos.y;
      
      // Update node positions
      const updatedNodes = canvasData.nodes.map(node => {
        if (draggedNodeIds.includes(node.id)) {
          return {
            ...node,
            x: node.x + deltaX,
            y: node.y + deltaY
          };
        }
        return node;
      });
      
      // Update canvas data
      onChange({
        ...canvasData,
        nodes: updatedNodes
      });
      
      // Update pan start
      setPanStart({ x: mouseX, y: mouseY });
    }
    
    // Check for node under mouse for hover effect
    const nodeUnderMouse = canvasData.nodes.find(node => 
      isPointInNode({ x: canvasX, y: canvasY }, node)
    );
    
    setHoveredNodeId(nodeUnderMouse?.id || null);
  };

  // Handle mouse up to stop panning and dragging
  const handleMouseUp = () => {
    setIsPanning(false);
    setIsDragging(false);
    setDraggedNodeIds([]);
  };

  // Handle node selection
  const handleNodeSelect = (nodeId) => {
    setSelectedNodeIds([nodeId]);
  };

  // Handle node text change
  const handleNodeTextChange = (nodeId, text) => {
    const updatedNodes = canvasData.nodes.map(node => {
      if (node.id === nodeId) {
        return {
          ...node,
          text
        };
      }
      return node;
    });
    
    onChange({
      ...canvasData,
      nodes: updatedNodes
    });
  };

  // Handle node resize
  const handleNodeResize = (nodeId, width, height) => {
    const updatedNodes = canvasData.nodes.map(node => {
      if (node.id === nodeId) {
        return {
          ...node,
          width,
          height
        };
      }
      return node;
    });
    
    onChange({
      ...canvasData,
      nodes: updatedNodes
    });
  };

  // Handle node move
  const handleNodeMove = (nodeId, x, y) => {
    const updatedNodes = canvasData.nodes.map(node => {
      if (node.id === nodeId) {
        return {
          ...node,
          x,
          y
        };
      }
      return node;
    });
    
    onChange({
      ...canvasData,
      nodes: updatedNodes
    });
  };

  // Add a new text node at a specific position
  const addTextNode = (x, y, text = 'New note') => {
    if (readOnly) return;
    
    // Convert screen coordinates to canvas coordinates
    const canvasX = (x - offset.x) / scale;
    const canvasY = (y - offset.y) / scale;
    
    // Create a new node
    const newNode = createTextNode(canvasX, canvasY, text);
    
    // Add to canvas data
    onChange({
      ...canvasData,
      nodes: [...canvasData.nodes, newNode]
    });
    
    // Select the new node
    setSelectedNodeIds([newNode.id]);
    
    // Start editing the new node
    setEditingNodeId(newNode.id);
    
    return newNode.id;
  };

  // Create a connection between two nodes
  const connectNodes = (sourceId, targetId) => {
    if (readOnly) return;
    
    // Find the nodes
    const sourceNode = canvasData.nodes.find(n => n.id === sourceId);
    const targetNode = canvasData.nodes.find(n => n.id === targetId);
    
    if (!sourceNode || !targetNode) return;
    
    // Calculate best connection sides
    const { fromSide, toSide } = calculateBestConnectionSides(sourceNode, targetNode);
    
    // Create a new edge
    const newEdge = createEdge(sourceId, targetId, fromSide, toSide);
    
    // Add to canvas data
    onChange({
      ...canvasData,
      edges: [...canvasData.edges, newEdge]
    });
    
    return newEdge.id;
  };

  // Delete selected nodes and their connections
  const deleteSelected = () => {
    if (readOnly || selectedNodeIds.length === 0) return;
    
    // Filter out selected nodes
    const updatedNodes = canvasData.nodes.filter(node => 
      !selectedNodeIds.includes(node.id)
    );
    
    // Filter out edges connected to deleted nodes
    const updatedEdges = canvasData.edges.filter(edge => 
      !selectedNodeIds.includes(edge.fromNode) && 
      !selectedNodeIds.includes(edge.toNode)
    );
    
    // Update canvas data
    onChange({
      ...canvasData,
      nodes: updatedNodes,
      edges: updatedEdges
    });
    
    // Clear selection
    setSelectedNodeIds([]);
  };

  // Start editing a node
  const startNodeEditing = (nodeId) => {
    setEditingNodeId(nodeId);
  };

  // Stop editing a node
  const stopNodeEditing = () => {
    setEditingNodeId(null);
  };

  return (
    <div 
      ref={containerRef}
      className="relative w-full h-full overflow-hidden bg-stone-900"
      tabIndex={0} // Make container focusable for keyboard shortcuts
      onKeyDown={(e) => {
        // Delete key to remove selected nodes
        if (e.key === 'Delete' && !readOnly) {
          deleteSelected();
        }
      }}
    >
      {/* Canvas for rendering edges */}
      <canvas 
        ref={canvasRef}
        className="absolute top-0 left-0 w-full h-full"
      />
      
      {/* Interaction layer */}
      <canvas 
        ref={interactionLayerRef}
        className="absolute top-0 left-0 w-full h-full"
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        onWheel={handleWheel}
        onDoubleClick={(e) => {
          if (readOnly) return;
          
          // Get mouse position
          const rect = canvasRef.current.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          
          // Add a new node at this position
          addTextNode(mouseX, mouseY);
        }}
      />
      
      {/* Node elements */}
      <div className="absolute top-0 left-0 w-full h-full pointer-events-none">
        {canvasData.nodes.map(node => (
          node.type === 'text' && (
            <TextNode
              key={node.id}
              node={node}
              selected={selectedNodeIds.includes(node.id)}
              onSelect={handleNodeSelect}
              onChange={handleNodeTextChange}
              onResize={handleNodeResize}
              onMove={handleNodeMove}
              scale={scale}
              isEditing={editingNodeId === node.id}
              onStartEditing={startNodeEditing}
              onStopEditing={stopNodeEditing}
            />
          )
        ))}
      </div>
      
      {/* Controls */}
      <div className="absolute bottom-4 right-4 flex flex-col gap-2 bg-stone-800 p-2 rounded shadow">
        <button 
          className="p-2 bg-stone-700 hover:bg-stone-600 rounded text-white"
          onClick={() => setScale(scale + 0.1)}
        >
          +
        </button>
        <button 
          className="p-2 bg-stone-700 hover:bg-stone-600 rounded text-white"
          onClick={() => setScale(Math.max(0.1, scale - 0.1))}
        >
          -
        </button>
        <button 
          className="p-2 bg-stone-700 hover:bg-stone-600 rounded text-white"
          onClick={() => {
            // Reset view
            setScale(1);
            setOffset({ x: 0, y: 0 });
          }}
        >
          Reset
        </button>
      </div>
    </div>
  );
};

export default CanvasContainer;

================
File: windows/explorer/components/canvas/CanvasEditor.jsx
================
import React, { useState, useEffect, useCallback } from 'react';
import { 
  createEmptyCanvas, 
  createTextNode, 
  createEdge, 
  generateId 
} from '../../utils/canvasUtils';
import CanvasContainer from './CanvasContainer';
import { 
  Plus, 
  Save, 
  Trash2, 
  Type,
  Link as LinkIcon,
  ArrowRight
} from 'lucide-react';

/**
 * Canvas Editor component that implements the JSONCanvas format
 * This is the main component for editing .canvas files
 */
const CanvasEditor = ({ fileContent, selectedFile, onSave }) => {
  const [canvasData, setCanvasData] = useState(createEmptyCanvas());
  const [canvasName, setCanvasName] = useState('Untitled Canvas');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [saveStatus, setSaveStatus] = useState('saved'); // 'saved', 'saving', 'error'
  const [showNodeCreator, setShowNodeCreator] = useState(false);
  const [newNodeText, setNewNodeText] = useState('');
  const [showConnectionCreator, setShowConnectionCreator] = useState(false);
  const [connectionNodes, setConnectionNodes] = useState({ source: '', target: '' });

  // Load canvas data when fileContent changes
  useEffect(() => {
    try {
      if (fileContent) {
        setIsLoading(true);
        
        // Parse the JSON canvas file
        const parsed = JSON.parse(fileContent);
        
        // Check if it has the basic JSONCanvas structure
        if (parsed.nodes || parsed.edges) {
          setCanvasData({
            nodes: parsed.nodes || [],
            edges: parsed.edges || []
          });
          
          // Extract canvas name from file path
          if (selectedFile) {
            const pathParts = selectedFile.path.split('/');
            const fileName = pathParts[pathParts.length - 1];
            setCanvasName(fileName.replace('.canvas', ''));
          }
          
          setSaveStatus('saved');
        } else {
          // Create a new canvas if the structure is invalid
          setCanvasData(createEmptyCanvas());
          console.warn('Invalid canvas format, creating new canvas');
        }
        
        setError(null);
      } else {
        // Create a new canvas if no content
        setCanvasData(createEmptyCanvas());
      }
    } catch (err) {
      console.error('Error parsing canvas file:', err);
      setError('Failed to parse canvas file. Creating a new canvas.');
      setCanvasData(createEmptyCanvas());
    } finally {
      setIsLoading(false);
    }
  }, [fileContent, selectedFile]);

  // Save canvas to file
  const handleSaveCanvas = useCallback(() => {
    if (!selectedFile) return;
    
    try {
      // Set status to saving
      setSaveStatus('saving');
      
      // Convert canvasData to proper format for saving
      // Make sure to remove any runtime-only properties
      const saveData = {
        nodes: canvasData.nodes.map(node => ({
          id: node.id,
          type: node.type,
          x: node.x,
          y: node.y,
          width: node.width,
          height: node.height,
          text: node.text,
          color: node.color
        })),
        edges: canvasData.edges.map(edge => ({
          id: edge.id,
          fromNode: edge.fromNode,
          toNode: edge.toNode,
          fromSide: edge.fromSide,
          toSide: edge.toSide,
          fromEnd: edge.fromEnd,
          toEnd: edge.toEnd,
          color: edge.color
        }))
      };
      
      // Serialize to JSON
      const jsonData = JSON.stringify(saveData, null, 2);
      
      // Call parent onSave function
      onSave(jsonData);
      
      // Update status
      setSaveStatus('saved');
    } catch (err) {
      console.error('Error saving canvas:', err);
      setError('Failed to save canvas file.');
      setSaveStatus('error');
    }
  }, [canvasData, selectedFile, onSave]);

  // Auto-save when canvas data changes
  useEffect(() => {
    if (canvasData.nodes.length > 0 || canvasData.edges.length > 0) {
      // Only trigger auto-save if we have content
      const timer = setTimeout(() => {
        handleSaveCanvas();
      }, 1000); // 1 second debounce
      
      return () => clearTimeout(timer);
    }
  }, [canvasData, handleSaveCanvas]);

  // Add a new node to the canvas
  const addNode = (type, text) => {
    // Create a node positioned in the center of the visible area
    const centerX = 100;
    const centerY = 100;
    
    let newNode;
    if (type === 'text') {
      newNode = createTextNode(centerX, centerY, text || 'New note');
    } else {
      // Default to text node
      newNode = createTextNode(centerX, centerY, text || 'New note');
    }
    
    // Add node to canvas data
    setCanvasData(prev => ({
      ...prev,
      nodes: [...prev.nodes, newNode]
    }));
    
    // Reset UI state
    setShowNodeCreator(false);
    setNewNodeText('');
    
    return newNode.id;
  };

  // Create a connection between two nodes
  const createConnection = (sourceId, targetId) => {
    // Find nodes to connect
    const sourceNode = canvasData.nodes.find(n => n.id === sourceId);
    const targetNode = canvasData.nodes.find(n => n.id === targetId);
    
    if (!sourceNode || !targetNode) {
      setError('Could not find one or both nodes to connect.');
      return;
    }
    
    // Create the edge and add it to canvas data
    const newEdge = createEdge(sourceId, targetId);
    
    setCanvasData(prev => ({
      ...prev,
      edges: [...prev.edges, newEdge]
    }));
    
    // Reset UI state
    setShowConnectionCreator(false);
    setConnectionNodes({ source: '', target: '' });
    
    return newEdge.id;
  };

  // Delete selected nodes
  const handleDeleteSelected = (nodeIds) => {
    if (!nodeIds || nodeIds.length === 0) return;
    
    // Remove nodes
    const updatedNodes = canvasData.nodes.filter(node => 
      !nodeIds.includes(node.id)
    );
    
    // Remove edges connected to those nodes
    const updatedEdges = canvasData.edges.filter(edge => 
      !nodeIds.includes(edge.fromNode) && 
      !nodeIds.includes(edge.toNode)
    );
    
    // Update canvas data
    setCanvasData({
      nodes: updatedNodes,
      edges: updatedEdges
    });
  };

  // Handle canvas data changes from CanvasContainer
  const handleCanvasChange = (newData) => {
    setCanvasData(newData);
    setSaveStatus('saving');
  };

  // If the canvas is still loading, show a loading state
  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-full">
        <span className="text-teal-300">Loading canvas editor...</span>
      </div>
    );
  }

  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400 overflow-hidden">
      {/* Toolbar */}
      <div className="p-2 border-b border-stone-700 flex justify-between items-center bg-stone-800">
        <h2 className="text-md font-semibold text-teal-400">{canvasName}</h2>
        
        <div className="flex gap-2">
          <button 
            onClick={handleSaveCanvas}
            className="px-2 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs flex items-center gap-1"
            title="Save canvas"
          >
            <Save size={14} />
            Save
          </button>
          
          <button 
            onClick={() => setShowNodeCreator(true)}
            className="px-2 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs flex items-center gap-1"
            title="Add text node"
          >
            <Type size={14} />
            Add Note
          </button>
          
          <button 
            onClick={() => setShowConnectionCreator(true)}
            className="px-2 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs flex items-center gap-1"
            title="Create connection"
          >
            <ArrowRight size={14} />
            Connect
          </button>
        </div>
      </div>
      
      {/* Error message */}
      {error && (
        <div className="p-2 bg-red-900 text-red-200 text-sm">
          {error}
        </div>
      )}
      
      {/* Node creator dialog */}
      {showNodeCreator && (
        <div className="p-2 border-b border-stone-700 bg-stone-800">
          <div className="flex items-center justify-between mb-1">
            <span className="text-sm font-bold">
              New Text Node
            </span>
            <button
              onClick={() => setShowNodeCreator(false)}
              className="p-1 rounded hover:bg-stone-700 text-stone-400"
            >
              <Trash2 size={14} />
            </button>
          </div>
          
          <div className="flex flex-col gap-2">
            <textarea
              value={newNodeText}
              onChange={(e) => setNewNodeText(e.target.value)}
              placeholder="Enter text content"
              className="w-full bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
              rows={3}
            />
            <div className="flex justify-end">
              <button
                onClick={() => addNode('text', newNodeText)}
                className="px-2 py-1 bg-teal-700 text-teal-100 hover:bg-teal-600 rounded text-xs"
              >
                Create
              </button>
            </div>
          </div>
        </div>
      )}
      
      {/* Connection creator dialog */}
      {showConnectionCreator && (
        <div className="p-2 border-b border-stone-700 bg-stone-800">
          <div className="flex items-center justify-between mb-1">
            <span className="text-sm font-bold">
              Create Connection
            </span>
            <button
              onClick={() => setShowConnectionCreator(false)}
              className="p-1 rounded hover:bg-stone-700 text-stone-400"
            >
              <Trash2 size={14} />
            </button>
          </div>
          
          <div className="flex flex-col gap-2">
            <div className="flex gap-2 items-center">
              <label className="text-xs w-20">From Node:</label>
              <select
                value={connectionNodes.source}
                onChange={(e) => setConnectionNodes(prev => ({ ...prev, source: e.target.value }))}
                className="flex-1 bg-stone-700 text-teal-400 px-2 py-1 rounded text-xs focus:outline-none"
              >
                <option value="">Select source node</option>
                {canvasData.nodes.map(node => (
                  <option key={node.id} value={node.id}>
                    {node.text ? node.text.substring(0, 20) + (node.text.length > 20 ? '...' : '') : node.id}
                  </option>
                ))}
              </select>
            </div>
            
            <div className="flex gap-2 items-center">
              <label className="text-xs w-20">To Node:</label>
              <select
                value={connectionNodes.target}
                onChange={(e) => setConnectionNodes(prev => ({ ...prev, target: e.target.value }))}
                className="flex-1 bg-stone-700 text-teal-400 px-2 py-1 rounded text-xs focus:outline-none"
              >
                <option value="">Select target node</option>
                {canvasData.nodes.map(node => (
                  <option key={node.id} value={node.id}>
                    {node.text ? node.text.substring(0, 20) + (node.text.length > 20 ? '...' : '') : node.id}
                  </option>
                ))}
              </select>
            </div>
            
            <div className="flex justify-end">
              <button
                onClick={() => createConnection(connectionNodes.source, connectionNodes.target)}
                disabled={!connectionNodes.source || !connectionNodes.target}
                className={`px-2 py-1 rounded text-xs ${
                  connectionNodes.source && connectionNodes.target
                    ? 'bg-teal-700 text-teal-100 hover:bg-teal-600'
                    : 'bg-stone-600 text-stone-400 cursor-not-allowed'
                }`}
              >
                Connect
              </button>
            </div>
          </div>
        </div>
      )}
      
      {/* Canvas container */}
      <div className="flex-1 overflow-hidden">
        <CanvasContainer 
          canvasData={canvasData}
          onChange={handleCanvasChange}
          onDeleteSelected={handleDeleteSelected}
        />
      </div>
      
      {/* Status indicator */}
      <div className="px-2 py-1 border-t border-stone-700 bg-stone-800 text-xs flex justify-between">
        <span>
          {canvasData.nodes.length} nodes, {canvasData.edges.length} connections
        </span>
        <span>
          {saveStatus === 'saving' && <span className="text-yellow-400">Saving...</span>}
          {saveStatus === 'saved' && <span className="text-green-400">Saved</span>}
          {saveStatus === 'error' && <span className="text-red-400">Error saving!</span>}
        </span>
      </div>
    </div>
  );
};

export default CanvasEditor;

================
File: windows/explorer/components/canvas/TextNode.jsx
================
import React, { useState, useRef, useEffect } from 'react';
import { getCanvasColor } from '../../utils/canvasUtils';

/**
 * TextNode component renders an individual text node in the canvas
 */
const TextNode = ({
  node,
  selected,
  onSelect,
  onChange,
  onResize,
  onMove,
  scale,
  isEditing,
  onStartEditing,
  onStopEditing
}) => {
  const [localText, setLocalText] = useState(node.text || '');
  const textareaRef = useRef(null);
  const nodeRef = useRef(null);
  const resizeHandleRef = useRef(null);
  const [isResizing, setIsResizing] = useState(false);
  const [initialSize, setInitialSize] = useState({ width: 0, height: 0 });
  const [initialPosition, setInitialPosition] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });

  // Update local text when node text changes
  useEffect(() => {
    setLocalText(node.text || '');
  }, [node.text]);

  // Focus the textarea when editing starts
  useEffect(() => {
    if (isEditing && textareaRef.current) {
      textareaRef.current.focus();
    }
  }, [isEditing]);

  // Handle mouse down for node selection and drag start
  const handleMouseDown = (e) => {
    e.stopPropagation();
    
    // Select this node
    onSelect(node.id);
    
    // If not already editing, prepare for dragging
    if (!isEditing) {
      setIsDragging(true);
      setInitialPosition({ x: node.x, y: node.y });
      setDragOffset({
        x: e.clientX / scale - node.x,
        y: e.clientY / scale - node.y
      });
    }
  };

  // Handle mouse down on resize handle
  const handleResizeMouseDown = (e) => {
    e.stopPropagation();
    
    // Start resizing
    setIsResizing(true);
    setInitialSize({ width: node.width, height: node.height });
    setInitialPosition({ x: e.clientX, y: e.clientY });
  };

  // Handle text change
  const handleTextChange = (e) => {
    const newText = e.target.value;
    setLocalText(newText);
    onChange(node.id, newText);
  };

  // Handle double click to start editing
  const handleDoubleClick = (e) => {
    e.stopPropagation();
    
    // Start editing
    if (!isEditing) {
      onStartEditing(node.id);
    }
  };

  // Handle blur to stop editing
  const handleBlur = () => {
    if (isEditing) {
      onStopEditing();
    }
  };

  // Get the background color
  const bgColor = getCanvasColor(node.color) || '#1e293b';
  const borderColor = selected ? '#14b8a6' : '#334155';

  return (
    <div
      ref={nodeRef}
      className="absolute select-none"
      style={{
        left: node.x,
        top: node.y,
        width: node.width,
        height: node.height,
        transform: `scale(${scale})`,
        transformOrigin: 'top left',
        zIndex: selected ? 10 : 1
      }}
      onMouseDown={handleMouseDown}
      onDoubleClick={handleDoubleClick}
    >
      <div
        className="w-full h-full rounded-md overflow-hidden flex flex-col"
        style={{
          backgroundColor: bgColor,
          border: `2px solid ${borderColor}`,
          boxShadow: selected ? '0 0 0 2px rgba(20, 184, 166, 0.5)' : 'none'
        }}
      >
        {isEditing ? (
          <textarea
            ref={textareaRef}
            className="w-full h-full p-2 bg-transparent text-white resize-none focus:outline-none"
            value={localText}
            onChange={handleTextChange}
            onBlur={handleBlur}
          />
        ) : (
          <div className="w-full h-full p-2 text-white overflow-auto whitespace-pre-wrap">
            {localText}
          </div>
        )}
        
        {/* Resize handle - only show when selected */}
        {selected && (
          <div
            ref={resizeHandleRef}
            className="absolute bottom-0 right-0 w-4 h-4 bg-teal-500 rounded-tl-md cursor-nwse-resize"
            onMouseDown={handleResizeMouseDown}
          />
        )}
      </div>
    </div>
  );
};

export default TextNode;

================
File: windows/explorer/components/CanvasEditor.jsx
================
import React, { useState, useEffect, useRef, useCallback } from 'react';
import ReactFlow, {
  Background,
  Controls,
  MiniMap,
  useNodesState,
  useEdgesState,
  addEdge,
  Panel
} from 'reactflow';
import 'reactflow/dist/style.css';
import { 
  Plus, 
  Save, 
  FileText, 
  Trash2, 
  Type,
  Square,
  Link as LinkIcon,
  Edit,
} from 'lucide-react';

// Import node types from the node registry
import nodeTypes from './nodes';

/**
 * Canvas Editor component for use within the FileContent area
 * This component handles the editing of .canvas files in the file explorer
 */
const CanvasEditor = ({ fileContent, selectedFile, onSave }) => {
  const [canvasName, setCanvasName] = useState('Untitled Canvas');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [saveStatus, setSaveStatus] = useState('saved'); // 'saved', 'saving', 'error'
  
  // ReactFlow states
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [reactFlowInstance, setReactFlowInstance] = useState(null);
  
  // UI states
  const [selectedElements, setSelectedElements] = useState([]);
  const [showNodeCreator, setShowNodeCreator] = useState(false);
  const [newNodeType, setNewNodeType] = useState('text');
  const [newNodeText, setNewNodeText] = useState('');
  const [editingNode, setEditingNode] = useState(null);
  
  // For auto-save functionality
  const saveTimeoutRef = useRef(null);
  
  // Setup custom node types with required props
  const customNodeTypes = {};
  
  // Add the TextNode and pass required props
  customNodeTypes.text = (props) => {
    // Create a handler for text updates
    const handleNodeTextChange = (nodeId, newText) => {
      setNodes((nds) => 
        nds.map((node) => {
          if (node.id === nodeId) {
            return {
              ...node,
              data: {
                ...node.data,
                text: newText
              }
            };
          }
          return node;
        })
      );
    };
    
    // Add the onChange handler to node data
    const nodeWithHandlers = {
      ...props,
      data: {
        ...props.data,
        onChange: handleNodeTextChange
      },
      editingNode: editingNode,
      setEditingNode: setEditingNode
    };
    
    // Use the TextNode component from the registry
    return React.createElement(nodeTypes.text, nodeWithHandlers);
  };
  
  // Load canvas data when fileContent changes
  useEffect(() => {
    try {
      if (fileContent) {
        setIsLoading(true);
        
        // Parse the JSON canvas file
        const canvasData = JSON.parse(fileContent);
        
        if (canvasData.nodes && canvasData.edges) {
          // Transform nodes from JSONCanvas format to ReactFlow format
          const transformedNodes = canvasData.nodes.map(node => {
            // Check if node has position as an object or direct x/y properties
            const nodeX = node.position?.x !== undefined ? node.position.x : (node.x || 0);
            const nodeY = node.position?.y !== undefined ? node.position.y : (node.y || 0);
            
            return {
              id: node.id,
              type: node.type,
              // For ReactFlow, use position property
              position: {
                x: nodeX,
                y: nodeY
              },
              // Preserve data, or create default data object with text if not present
              data: node.data || { text: node.text || "Text node" }
            };
          });
          
          console.log('[DEBUG] Transformed nodes:', transformedNodes.length);
          setNodes(transformedNodes);
          setEdges(canvasData.edges);
          
          // Extract canvas name from file path or use from canvas data
          if (canvasData.name) {
            setCanvasName(canvasData.name);
          } else if (selectedFile) {
            const pathParts = selectedFile.path.split('/');
            const fileName = pathParts[pathParts.length - 1];
            setCanvasName(fileName.replace('.canvas', ''));
          }
          
          setSaveStatus('saved');
        } else {
          // Create a new canvas if the structure is invalid
          createNewCanvas();
        }
        
        setIsLoading(false);
        setError(null);
      } else {
        // Create a new canvas if no content
        createNewCanvas();
      }
    } catch (err) {
      console.error('Error parsing canvas file:', err);
      setError('Failed to parse canvas file. Creating a new canvas.');
      createNewCanvas();
      setIsLoading(false);
    }
  }, [fileContent, selectedFile]);
  
  // Auto-save when node/edge data changes
  useEffect(() => {
    if (nodes.length > 0 || edges.length > 0) {
      // Only start auto-save if we have actual content
      
      // Clear any existing timeout
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
      
      // Set save status to 'saving'
      setSaveStatus('saving');
      
      // Set a new timeout for auto-save
      saveTimeoutRef.current = setTimeout(() => {
        handleSaveCanvas();
      }, 1000); // 1 second debounce
    }
    
    // Cleanup function to clear the timeout when component unmounts
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, [nodes, edges]);
  
  // Create a new canvas
  const createNewCanvas = () => {
    setNodes([]);
    setEdges([]);
    
    // Set canvas name from file if available
    if (selectedFile) {
      const pathParts = selectedFile.path.split('/');
      const fileName = pathParts[pathParts.length - 1];
      setCanvasName(fileName.replace('.canvas', ''));
    } else {
      setCanvasName('Untitled Canvas');
    }
    
    setSaveStatus('saved');
  };
  
  // Save canvas to file
  const handleSaveCanvas = () => {
    if (!selectedFile) return;
    
    try {
      // Transform nodes from ReactFlow format back to JSONCanvas format
      const transformedNodes = nodes.map(node => {
        // Extract position from ReactFlow format
        const nodePosition = node.position || { x: 0, y: 0 };
        
        return {
          id: node.id,
          type: node.type,
          // Store position in a position object for compatibility with JSONCanvas format
          position: {
            x: nodePosition.x,
            y: nodePosition.y
          },
          // Preserve the data object
          data: node.data
        };
      });
      
      // Create canvas data structure
      const canvasData = {
        name: canvasName,
        nodes: transformedNodes,
        edges,
        version: "1.0",
        metadata: {
          created: new Date().toISOString(),
          modified: new Date().toISOString()
        }
      };
      
      // Debug logs to track the data flow
      console.log('[DEBUG] Canvas Editor - Saving canvas data:', {
        nodesLength: transformedNodes.length,
        edgesLength: edges.length,
        selectedFile: selectedFile?.path
      });
      
      // Set status to saving
      setSaveStatus('saving');
      
      // Serialize to JSON string
      const canvasContent = JSON.stringify(canvasData, null, 2);
      
      // Call the parent onSave function
      onSave(canvasContent);
      
      // Update state
      setSaveStatus('saved');
      setError(null);
    } catch (err) {
      console.error('Error saving canvas:', err);
      setError('Failed to save canvas file.');
      setSaveStatus('error');
    }
  };
  
  // Handle connection (edge) creation
  const onConnect = useCallback((params) => {
    // Create a custom edge with styling and ID
    setEdges((eds) => addEdge({
      ...params,
      id: `edge-${Date.now()}`,
      type: 'default',
      animated: false,
      style: { stroke: '#14b8a6' }
    }, eds));
  }, [setEdges]);
  
  // Handle node selection
  const onSelectionChange = useCallback(({ nodes, edges }) => {
    setSelectedElements([...nodes, ...edges]);
  }, []);
  
  // Handle drag over for node creation
  const onDragOver = useCallback((event) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);
  
  // Handle drop for node creation
  const onDrop = useCallback(
    (event) => {
      event.preventDefault();
      
      const type = event.dataTransfer.getData('application/reactflow/type');
      if (!type || !reactFlowInstance) return;
      
      const position = reactFlowInstance.screenToFlowPosition({
        x: event.clientX,
        y: event.clientY,
      });
      
      const newNode = {
        id: `node-${Date.now()}`,
        type,
        position,
        data: { text: 'New text node' },
      };
      
      setNodes((nds) => nds.concat(newNode));
    },
    [reactFlowInstance, setNodes]
  );
  
  // Create a new node
  const createNode = (type) => {
    if (!reactFlowInstance) return;
    
    // If we have a viewport, center the node in the visible area
    const position = reactFlowInstance.project({
      x: window.innerWidth / 2,
      y: window.innerHeight / 2
    });
    
    const newNode = {
      id: `node-${Date.now()}`,
      type,
      position,
      data: { text: newNodeText || 'New text node' }
    };
    
    // Add the node and immediately set it to edit mode
    setNodes((nds) => {
      const updatedNodes = nds.concat(newNode);
      setTimeout(() => {
        setEditingNode(newNode.id);
      }, 100);
      return updatedNodes;
    });
    
    setShowNodeCreator(false);
    setNewNodeText('');
  };
  
  // Delete selected elements
  const deleteSelected = () => {
    const selectedNodeIds = selectedElements
      .filter(el => el.type !== 'default')
      .map(el => el.id);
    
    const selectedEdgeIds = selectedElements
      .filter(el => el.type === 'default')
      .map(el => el.id);
    
    setNodes(nodes.filter(node => !selectedNodeIds.includes(node.id)));
    setEdges(edges.filter(edge => !selectedEdgeIds.includes(edge.id)));
    setSelectedElements([]);
  };
  
  // If canvas data isn't loaded yet, show a loading state
  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-full">
        <span className="text-teal-300">Loading canvas editor...</span>
      </div>
    );
  }
  
  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400 overflow-hidden">
      {/* Toolbar */}
      <div className="p-2 border-b border-stone-700 flex justify-between items-center bg-stone-800">
        <h2 className="text-md font-semibold text-teal-400">{canvasName}</h2>
        
        <div className="flex gap-2">
          <button 
            onClick={handleSaveCanvas}
            className="px-2 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs flex items-center gap-1"
            title="Save canvas"
          >
            <Save size={14} />
            Save
          </button>
          
          <button 
            onClick={() => {
              setNewNodeType('text');
              setShowNodeCreator(true);
            }}
            className="px-2 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs flex items-center gap-1"
            title="Add text node"
          >
            <Type size={14} />
            Add Node
          </button>
          
          {/* Edit button - appears when a node is selected */}
          {selectedElements.length === 1 && selectedElements[0].type === 'text' && (
            <button 
              onClick={() => setEditingNode(selectedElements[0].id)}
              className="px-2 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs flex items-center gap-1"
              title="Edit selected node"
            >
              <Edit size={14} />
              Edit
            </button>
          )}
          
          {selectedElements.length > 0 && (
            <button 
              onClick={deleteSelected}
              className="px-2 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs flex items-center gap-1"
              title="Delete selected"
            >
              <Trash2 size={14} />
              Delete
            </button>
          )}
        </div>
      </div>
      
      {/* Error message */}
      {error && (
        <div className="p-2 bg-red-900 text-red-200 text-sm">
          {error}
        </div>
      )}
      
      {/* Node creator dialog */}
      {showNodeCreator && (
        <div className="p-2 border-b border-stone-700 bg-stone-800">
          <div className="flex items-center justify-between mb-1">
            <span className="text-sm font-bold">
              New Text Node
            </span>
            <button
              onClick={() => setShowNodeCreator(false)}
              className="p-1 rounded hover:bg-stone-700 text-stone-400"
            >
              <Trash2 size={14} />
            </button>
          </div>
          
          <div className="flex flex-col gap-2">
            <textarea
              value={newNodeText}
              onChange={(e) => setNewNodeText(e.target.value)}
              placeholder="Enter text content"
              className="w-full bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
              rows={3}
            />
            <div className="flex justify-end">
              <button
                onClick={() => createNode('text')}
                className="px-2 py-1 bg-teal-700 text-teal-100 hover:bg-teal-600 rounded text-xs"
              >
                Create
              </button>
            </div>
          </div>
        </div>
      )}
      
      {/* Canvas area */}
      <div className="flex-1 overflow-hidden">
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          connectionMode="loose"
          onConnect={onConnect}
          onInit={setReactFlowInstance}
          onDrop={onDrop}
          onDragOver={onDragOver}
          onSelectionChange={onSelectionChange}
          nodeTypes={customNodeTypes}
          fitView
          snapToGrid
          snapGrid={[15, 15]}
          defaultViewport={{ x: 0, y: 0, zoom: 1 }}
          minZoom={0.1}
          maxZoom={4}
          deleteKeyCode="Delete"
          multiSelectionKeyCode="Control"
          selectionKeyCode="Shift"
        >
          {/* Empty canvas help message */}
          {nodes.length === 0 && (
            <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
              <div className="bg-stone-800 bg-opacity-80 p-6 rounded-lg shadow-lg text-center max-w-md">
                <Type size={40} className="mx-auto mb-4 text-teal-500" />
                <h3 className="text-xl text-teal-400 mb-2 font-semibold">Canvas Editor</h3>
                <p className="text-stone-300 mb-4">
                  This is your canvas workspace. Create notes and connect them with arrows.
                </p>
                <ul className="text-left text-stone-300 space-y-2 mb-4">
                  <li>• Click "Add Node" to create a new text node</li>
                  <li>• Hover over a node and click the edit button to edit content</li>
                  <li>• Drag from a node's connection handle (teal dot) to another node to create a connection</li>
                  <li>• Select nodes and press Delete or use the Delete button</li>
                </ul>
                <p className="text-stone-400 text-sm">
                  See canvas-editor-documentation.md for more details
                </p>
              </div>
            </div>
          )}
          <Background color="#44403c" gap={16} />
          <Controls showInteractive={false} />
          <MiniMap
            nodeColor={(node) => '#14b8a6'}
            maskColor="rgba(0, 0, 0, 0.5)"
            style={{ backgroundColor: '#292524' }}
          />
          
          <Panel position="top-left" className="bg-stone-800 p-2 rounded shadow-md">
            <div className="flex flex-col gap-1">
              <div className="text-xs text-stone-400">Drag to create:</div>
              <div 
                className="flex items-center gap-1 p-1 bg-stone-700 rounded cursor-grab"
                draggable
                onDragStart={(event) => {
                  event.dataTransfer.setData('application/reactflow/type', 'text');
                  event.dataTransfer.effectAllowed = 'move';
                }}
              >
                <Type size={14} />
                <span className="text-xs">Text Node</span>
              </div>
            </div>
          </Panel>
        </ReactFlow>
      </div>
    </div>
  );
};

export default CanvasEditor;

================
File: windows/explorer/components/CommandInput.jsx
================
import React from 'react';

const CommandInput = ({ focusRef, isAdmin, handleCommand }) => {
  // Handle command input
  const onKeyDown = (e) => {
    if (e.key === 'Enter' && e.target.value.trim()) {
      const cmd = e.target.value.trim();
      handleCommand(cmd);
      e.target.value = '';
    }
  };

  return (
    <div className="p-2 flex items-center gap-2 border-t border-stone-700">
      <span className="text-teal-400">$</span>
      <input
        ref={focusRef}
        type="text"
        onKeyDown={onKeyDown}
        className="flex-1 bg-stone-800 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
      />
    </div>
  );
};

export default CommandInput;

================
File: windows/explorer/components/dialogs/FileDialogs.jsx
================
import React, { useRef, useEffect, useState } from 'react';
import { AVAILABLE_FILE_TYPES } from '../../utils/fileUtils';
import { 
  X, FileText, Code, Coffee, BookOpen, Globe, File, 
  Music, Image, Figma, Map 
} from 'lucide-react';

// Dialog for creating a new file or folder
export const CreateFileDialog = ({
  showCreateDialog,
  createType,
  newItemName,
  setNewItemName,
  isCreating,
  errorMessage,
  closeCreateDialog,
  createNewItem
}) => {
  const createInputRef = useRef(null);
  const [showAutocomplete, setShowAutocomplete] = useState(false);
  const [filteredTypes, setFilteredTypes] = useState([]);
  const [selectedTypeIndex, setSelectedTypeIndex] = useState(0);
  
  // Get file type icon for autocomplete menu
  const getFileTypeIcon = (fileType) => {
    const iconProps = { size: 16, className: "mr-2" };
    
    switch (fileType) {
      case 'md': return <FileText {...iconProps} />;
      case 'canvas': return <Figma {...iconProps} />;
      case 'map': return <Map {...iconProps} />;
      default: return <File {...iconProps} />;
    }
  };
  
  // Focus the input field when the dialog is shown
  useEffect(() => {
    if (showCreateDialog && createInputRef.current) {
      createInputRef.current.focus();
    }
  }, [showCreateDialog]);
  
  // Handle input change to detect periods and filter file types
  const handleInputChange = (e) => {
    const value = e.target.value;
    setNewItemName(value);
    
    // Only show autocomplete for files, not folders
    if (createType === 'file') {
      // Check if we should show autocomplete
      const lastPeriodIndex = value.lastIndexOf('.');
      if (lastPeriodIndex !== -1 && lastPeriodIndex < value.length) {
        const suffix = value.substring(lastPeriodIndex + 1);
        
        // Filter available types based on what user has typed after the period
        const filtered = AVAILABLE_FILE_TYPES.filter(type => 
          type.startsWith(suffix.toLowerCase())
        );
        
        setFilteredTypes(filtered);
        setShowAutocomplete(filtered.length > 0);
        setSelectedTypeIndex(0);
      } else {
        setShowAutocomplete(false);
      }
    }
  };
  
  // Function to select and apply a file type
  const selectFileType = (type) => {
    const lastPeriodIndex = newItemName.lastIndexOf('.');
    if (lastPeriodIndex !== -1) {
      // Replace everything after the period with the selected file type
      setNewItemName(newItemName.substring(0, lastPeriodIndex + 1) + type);
    }
    setShowAutocomplete(false);
  };
  
  // Handle key press in the create dialog
  const handleCreateKeyPress = (e) => {
    if (showAutocomplete) {
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        setSelectedTypeIndex(prev => 
          (prev + 1) % filteredTypes.length
        );
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        setSelectedTypeIndex(prev => 
          (prev - 1 + filteredTypes.length) % filteredTypes.length
        );
      } else if (e.key === 'Tab' || e.key === 'Enter') {
        e.preventDefault();
        selectFileType(filteredTypes[selectedTypeIndex]);
        if (e.key === 'Enter') {
          // If Enter was pressed and a type was selected, also create the item
          setTimeout(() => createNewItem(), 10);
        }
      } else if (e.key === 'Escape') {
        e.preventDefault();
        setShowAutocomplete(false);
      }
    } else if (e.key === 'Enter') {
      e.preventDefault();
      createNewItem();
    } else if (e.key === 'Escape') {
      closeCreateDialog();
    }
  };
  
  if (!showCreateDialog) return null;
  
  return (
    <div className="p-2 border-t border-stone-700 bg-stone-800">
      <div className="flex items-center justify-between mb-1">
        <span className="text-sm font-bold">
          {createType === 'file' ? 'New File' : 'New Folder'}
        </span>
        <button
          onClick={closeCreateDialog}
          className="p-1 rounded hover:bg-stone-700 text-stone-400"
        >
          <X size={14} />
        </button>
      </div>
      <div className="flex gap-2 relative">
        <div className="flex-1 relative">
          <input
            ref={createInputRef}
            type="text"
            value={newItemName}
            onChange={handleInputChange}
            onKeyDown={handleCreateKeyPress}
            placeholder={createType === 'file' ? 'filename.ext' : 'folder name'}
            className="w-full bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
            disabled={isCreating}
          />
          {showAutocomplete && (
            <div className="absolute bottom-full mb-1 w-full bg-stone-800 border border-stone-600 rounded shadow-lg z-50 max-h-32 overflow-y-auto">
              {filteredTypes.map((type, index) => (
                <div 
                  key={type}
                  onClick={() => selectFileType(type)}
                  className={`px-2 py-1 cursor-pointer text-sm flex items-center ${
                    index === selectedTypeIndex 
                      ? 'bg-stone-600 text-white' 
                      : 'hover:bg-stone-700 text-teal-400'
                  }`}
                >
                  {getFileTypeIcon(type)}
                  {type}
                </div>
              ))}
            </div>
          )}
        </div>
        <button
          onClick={createNewItem}
          disabled={isCreating || !newItemName.trim()}
          className={`px-2 py-1 rounded text-xs ${
            isCreating || !newItemName.trim()
              ? 'bg-stone-700 text-stone-500 cursor-not-allowed'
              : 'bg-teal-700 text-teal-100 hover:bg-teal-600'
          }`}
        >
          {isCreating ? 'Creating...' : 'Create'}
        </button>
      </div>
    </div>
  );
};

// Dialog for renaming a file or folder
export const RenameDialog = ({
  showRenameDialog,
  itemToRename,
  newName,
  setNewName,
  isRenaming,
  errorMessage,
  closeRenameDialog,
  renameItem
}) => {
  const renameInputRef = useRef(null);
  
  // Focus the input field when the dialog is shown
  useEffect(() => {
    if (showRenameDialog && renameInputRef.current) {
      renameInputRef.current.focus();
    }
  }, [showRenameDialog]);
  
  // Handle key press in the rename dialog
  const handleRenameKeyPress = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      renameItem();
    } else if (e.key === 'Escape') {
      closeRenameDialog();
    }
  };
  
  if (!showRenameDialog || !itemToRename) return null;
  
  return (
    <div className="p-2 border-t border-stone-700 bg-stone-800">
      <div className="flex items-center justify-between mb-1">
        <span className="text-sm font-bold">
          Rename {itemToRename.type === 'directory' ? 'Folder' : 'File'}
        </span>
        <button
          onClick={closeRenameDialog}
          className="p-1 rounded hover:bg-stone-700 text-stone-400"
        >
          <X size={14} />
        </button>
      </div>
      <div className="flex gap-2">
        <input
          ref={renameInputRef}
          type="text"
          value={newName}
          onChange={(e) => setNewName(e.target.value)}
          onKeyDown={handleRenameKeyPress}
          placeholder="New name"
          className="flex-1 bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
          disabled={isRenaming}
        />
        <button
          onClick={renameItem}
          disabled={isRenaming || !newName.trim() || newName === itemToRename.name}
          className={`px-2 py-1 rounded text-xs ${
            isRenaming || !newName.trim() || newName === itemToRename.name
              ? 'bg-stone-700 text-stone-500 cursor-not-allowed'
              : 'bg-teal-700 text-teal-100 hover:bg-teal-600'
          }`}
        >
          {isRenaming ? 'Renaming...' : 'Rename'}
        </button>
      </div>
    </div>
  );
};

// Dialog for deleting a file or folder
export const DeleteDialog = ({
  showDeleteDialog,
  itemToDelete,
  isDeleting,
  errorMessage,
  closeDeleteDialog,
  handleDeleteItem
}) => {
  if (!showDeleteDialog || !itemToDelete) return null;
  
  return (
    <div className="p-2 border-t border-stone-700 bg-stone-800">
      <div className="flex items-center justify-between mb-1">
        <span className="text-sm font-bold">
          Delete {itemToDelete.type === 'directory' ? 'Folder' : 'File'}
        </span>
        <button
          onClick={closeDeleteDialog}
          className="p-1 rounded hover:bg-stone-700 text-stone-400"
        >
          <X size={14} />
        </button>
      </div>
      <div className="mb-2 text-sm">
        <p>Are you sure you want to delete <span className="text-red-400 font-bold">{itemToDelete.name}</span>?</p>
        {itemToDelete.type === 'directory' && (
          <p className="text-red-400 text-xs mt-1">This will delete all files and folders inside it!</p>
        )}
      </div>
      <div className="flex gap-2 justify-end">
        <button
          onClick={closeDeleteDialog}
          className="px-2 py-1 rounded text-xs bg-stone-700 hover:bg-stone-600"
        >
          Cancel
        </button>
        <button
          onClick={handleDeleteItem}
          disabled={isDeleting}
          className={`px-2 py-1 rounded text-xs ${
            isDeleting
              ? 'bg-red-900 text-red-300 cursor-not-allowed'
              : 'bg-red-700 text-red-100 hover:bg-red-600'
          }`}
        >
          {isDeleting ? 'Deleting...' : 'Delete'}
        </button>
      </div>
    </div>
  );
};

================
File: windows/explorer/components/FileContent.jsx
================
import React, { useRef, useEffect } from 'react';
import { FileText, Edit, Eye, Bold, Italic, Code as CodeIcon, Link, Heading, List, ListOrdered, CheckSquare, Download, Map } from 'lucide-react';
import { handleEditorKeyDown, convertMarkdownToHtml } from '../utils/markdownUtils';
import MapEditor from './MapEditor';
import CanvasEditor from './CanvasEditor';

const FileContent = ({
  selectedFile,
  isContentLoading,
  fileContent,
  errorMessage,
  showPreview,
  editMode,
  saveStatus,
  converter,
  isAdmin,
  user,
  activeTab,
  setFileContent,
  toggleEditMode,
  handleMarkdownChange,
  handleSaveFileContent,
  handleExportFile
}) => {
  // Debug logging

  // Add an effect to log when file content changes
  useEffect(() => {
  }, [fileContent]);

  // Add an effect to log when selected file changes
  useEffect(() => {
  }, [selectedFile]);
  
  // Add debugging for save file content function
  const wrappedHandleSaveFileContent = (content) => {

    
    // Call the original function
    handleSaveFileContent(content);
  };

  const textareaRef = useRef(null);

  // Insert markdown syntax at cursor position
  const insertMarkdown = (prefix, suffix = '') => {
    const textarea = textareaRef.current;
    if (!textarea) return;
    
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const text = fileContent;
    
    // If text is selected, wrap it with prefix and suffix
    if (start !== end) {
      const selectedText = text.substring(start, end);
      const newContent = text.substring(0, start) + prefix + selectedText + suffix + text.substring(end);
      setFileContent(newContent);
      
      // Set cursor position after the inserted text
      setTimeout(() => {
        textarea.selectionStart = start + prefix.length;
        textarea.selectionEnd = end + prefix.length;
        textarea.focus();
      }, 0);
    } else {
      // No selection, just insert at cursor
      const newContent = text.substring(0, start) + prefix + suffix + text.substring(start);
      setFileContent(newContent);
      
      // Move cursor between prefix and suffix
      setTimeout(() => {
        textarea.selectionStart = textarea.selectionEnd = start + prefix.length;
        textarea.focus();
      }, 0);
    }
  };

  // Insert list items
  const insertList = (listPrefix) => {
    const textarea = textareaRef.current;
    if (!textarea) return;
    
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const text = fileContent;
    
    // If text is selected, apply list formatting to each line
    if (start !== end) {
      const selectedText = text.substring(start, end);
      const lines = selectedText.split('\n');
      
      // Format each line as a list item
      const formattedLines = lines.map(line => {
        // Skip empty lines
        if (line.trim() === '') return line;
        
        // For numbered lists, increment the number for each line
        if (listPrefix === '1. ') {
          const index = lines.indexOf(line) + 1;
          return `${index}. ${line}`;
        }
        
        return `${listPrefix}${line}`;
      });
      
      const newContent = text.substring(0, start) + formattedLines.join('\n') + text.substring(end);
      setFileContent(newContent);
      
      // Set cursor position after the inserted text
      setTimeout(() => {
        textarea.selectionStart = start;
        textarea.selectionEnd = start + formattedLines.join('\n').length;
        textarea.focus();
      }, 0);
    } else {
      // No selection, just insert at cursor
      const newContent = text.substring(0, start) + listPrefix + text.substring(start);
      setFileContent(newContent);
      
      // Move cursor after the inserted prefix
      setTimeout(() => {
        textarea.selectionStart = textarea.selectionEnd = start + listPrefix.length;
        textarea.focus();
      }, 0);
    }
  };

  // Handle editor keyboard events
  const onEditorKeyDown = (e) => {
    handleEditorKeyDown(e, textareaRef, fileContent, setFileContent);
  };

  return (
    <div className="flex-1 flex flex-col overflow-hidden">
      {selectedFile ? (
        <>
          {/* Header with file name, status, and controls */}
          <div className="p-2 border-b border-stone-700 font-mono text-sm flex items-center justify-between">
            <div className="flex items-center">
              <span className="mr-2">{selectedFile.name}</span>
              {saveStatus === 'saving' && <span className="text-yellow-400 text-xs ml-2">Saving...</span>}
              {saveStatus === 'saved' && <span className="text-green-400 text-xs ml-2">Saved</span>}
              {saveStatus === 'error' && <span className="text-red-400 text-xs ml-2">Error!</span>}
            </div>
            
            <div className="flex gap-2">
              {/* Export button - available for all file types */}
              <button 
                onClick={handleExportFile}
                className="px-2 py-1 bg-stone-800 hover:bg-stone-700 rounded text-xs flex items-center gap-1"
                title="Export file"
              >
                <Download size={14} />
                Export
              </button>
              
              {/* Show edit/preview toggle for markdown files to admins or users with file access (for private files) */}
              {selectedFile.name.endsWith('.md') && (isAdmin || (user && user.has_file_access && activeTab === 'private')) && (
                <>
                  {editMode && (
                    <button 
                      onClick={handleSaveFileContent}
                      className="px-2 py-1 bg-stone-800 hover:bg-stone-700 rounded text-xs"
                      title="Save file"
                    >
                      Save
                    </button>
                  )}
                  <button 
                    onClick={toggleEditMode}
                    className={`px-2 py-1 rounded text-xs flex items-center gap-1 ${editMode ? 'bg-teal-700 text-teal-100' : 'bg-stone-800 hover:bg-stone-700'}`}
                    title={editMode ? "Switch to preview mode" : "Switch to edit mode"}
                  >
                    {editMode ? <Eye size={14} /> : <Edit size={14} />}
                    {editMode ? 'Preview' : 'Edit'}
                  </button>
                </>
              )}
            </div>
          </div>
          
          {/* Error message */}
          {errorMessage && (
            <div className="p-2 bg-red-900 text-red-200 text-sm">
              {errorMessage}
            </div>
          )}
          
          {/* Content area - editor or preview based on file type */}
          {isContentLoading ? (
            <div className="flex-1 flex items-center justify-center">
              <span className="text-teal-300">Loading content...</span>
            </div>
          ) : selectedFile.name.endsWith('.canvas') && (isAdmin || (user && user.has_file_access && activeTab === 'private')) ? (
            // Canvas Editor for .canvas files - only for admin users and users with file access
            <CanvasEditor
              fileContent={fileContent}
              selectedFile={selectedFile}
              onSave={wrappedHandleSaveFileContent}
            />
          ) : selectedFile.name.endsWith('.map') && (isAdmin || (user && user.has_file_access && activeTab === 'private')) ? (
            // Map Editor for .map files - only for admin users and users with file access
            <MapEditor 
              fileContent={fileContent}
              selectedFile={selectedFile}
              onSave={wrappedHandleSaveFileContent}
            />
          ) : editMode && selectedFile.name.endsWith('.md') && (isAdmin || (user && user.has_file_access && activeTab === 'private')) ? (
            // Markdown Editor mode - only for markdown files and admin users
            <div className="flex-1 flex flex-col">
              {/* Markdown toolbar */}
              <div className="p-2 border-b border-stone-700 bg-stone-800 flex flex-wrap gap-2">
                <button 
                  onClick={() => insertMarkdown('### ')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Heading"
                >
                  <Heading size={16} />
                </button>
                <button 
                  onClick={() => insertMarkdown('**', '**')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Bold"
                >
                  <Bold size={16} />
                </button>
                <button 
                  onClick={() => insertMarkdown('*', '*')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Italic"
                >
                  <Italic size={16} />
                </button>
                <button 
                  onClick={() => insertMarkdown('`', '`')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Inline Code"
                >
                  <CodeIcon size={16} />
                </button>
                <button 
                  onClick={() => insertMarkdown('[', '](url)')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Link"
                >
                  <Link size={16} />
                </button>
                <span className="border-r border-stone-700 h-6"></span>
                <button 
                  onClick={() => insertList('- ')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Bullet List"
                >
                  <List size={16} />
                </button>
                <button 
                  onClick={() => insertList('1. ')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Numbered List"
                >
                  <ListOrdered size={16} />
                </button>
                <button 
                  onClick={() => insertList('- [ ] ')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Checklist"
                >
                  <CheckSquare size={16} />
                </button>
              </div>
              
              <div className="flex-1 p-2">
                <textarea
                  ref={textareaRef}
                  className="w-full h-full bg-stone-800 text-teal-50 p-4 resize-none focus:outline-none font-mono"
                  value={fileContent}
                  onChange={handleMarkdownChange}
                  onKeyDown={onEditorKeyDown}
                  placeholder="# Start typing your markdown here..."
                />
              </div>
            </div>
          ) : (
            // Preview mode
            <div className="flex-1 overflow-auto p-4">
              <div className="markdown-preview text-teal-50">
                {selectedFile.name.endsWith('.md') ? (
                  <div 
                    dangerouslySetInnerHTML={{ 
                      __html: convertMarkdownToHtml(converter, fileContent) 
                    }} 
                    className="markdown-content"
                  />
                ) : (
                  <pre className="font-mono text-sm whitespace-pre-wrap">
                    {fileContent}
                  </pre>
                )}
              </div>
            </div>
          )}
        </>
      ) : (
        // No file selected
        <div className="flex items-center justify-center h-full text-stone-600">
          <div className="text-center">
            <FileText size={48} className="mx-auto mb-4" />
            <p>Select a file to view</p>
            <p className="text-xs mt-2">All file types are supported for viewing</p>
            {isAdmin && (
              <p className="text-xs mt-1">
                Admin users can edit markdown (.md), map (.map), and canvas (.canvas) files
              </p>
            )}
            {!isAdmin && user && user.has_file_access && (
              <p className="text-xs mt-1">
                Users with file access can edit markdown (.md), map (.map), and canvas (.canvas) files in the Private section
              </p>
            )}
          </div>
        </div>
      )}
    </div>
  );
};

export default FileContent;

================
File: windows/explorer/components/FileTree.jsx
================
import React from 'react';
import { 
  FolderOpen, ChevronRight, ChevronDown, File, Coffee, Code, 
  BookOpen, FileText, Globe, Lock, FileEdit, Trash2, Music, Image, Figma,
  FolderPlus, Plus, Map
} from 'lucide-react';
import { getFileIconName } from '../utils/fileUtils';
import StorageStats from './StorageStats';
import { CreateFileDialog, RenameDialog, DeleteDialog } from './dialogs/FileDialogs';

const FileTree = ({ 
  files, 
  publicFiles, 
  activeTab,
  expandedFolders,
  currentPath,
  selectedFile,
  isTreeLoading,
  errorMessage,
  isAdmin,
  user,
  toggleFolder,
  handleFileSelect,
  openRenameDialog,
  openDeleteDialog,
  openCreateDialog,
  handleDragStart,
  handleDragOver,
  handleDragLeave,
  handleDrop,
  handleContainerDragOver,
  handleContainerDragLeave,
  handleContainerDrop,
  dropTarget,
  storageStats,
  // Dialog-related props
  showCreateDialog,
  createType,
  newItemName,
  setNewItemName,
  isCreating,
  closeCreateDialog,
  createNewItem,
  showRenameDialog,
  itemToRename,
  newName,
  setNewName,
  isRenaming,
  closeRenameDialog,
  renameItem,
  showDeleteDialog,
  itemToDelete,
  isDeleting,
  closeDeleteDialog,
  handleDeleteItem
}) => {
  
  // Get file icon based on file extension
  const getFileIcon = (fileName) => {
    const iconName = getFileIconName(fileName);
    const iconProps = { size: 16, className: "mr-2" };
    
    switch (iconName) {
      case 'FileText': return <FileText {...iconProps} />;
      case 'Code': return <Code {...iconProps} />;
      case 'Coffee': return <Coffee {...iconProps} />;
      case 'BookOpen': return <BookOpen {...iconProps} />;
      case 'Globe': return <Globe {...iconProps} />;
      case 'Music': return <Music {...iconProps} />;
      case 'Image': return <Image {...iconProps} />;
      case 'Figma': return <Figma {...iconProps} />;
      case 'Map': return <Map {...iconProps} />;
      default: return <File {...iconProps} />;
    }
  };
  
  // Render the file tree recursively
  const renderFileTree = (items) => {
    // Keep track of the path to the currently selected file to highlight its parent folder
    const selectedFilePath = selectedFile?.path || '';
    const selectedFileParentPath = selectedFile && selectedFile.type !== 'directory' ? 
      selectedFilePath.substring(0, selectedFilePath.lastIndexOf('/')) || '/' : '';
    
    return items.map(item => {
      if (item.type === 'directory') {
        const isExpanded = expandedFolders[item.path];
        // A folder is considered active if it's the current path OR if it's the parent of the selected file
        const isActive = currentPath === item.path || (selectedFileParentPath === item.path);
        return (
          <div key={item.path} className="ml-2">
            <div 
              className={`flex items-center justify-between py-1 px-1 rounded hover:bg-stone-700 cursor-pointer group ${
                isActive ? 'bg-stone-800 text-teal-300 font-bold' : 
                isExpanded ? 'text-teal-300' : 'text-teal-400'
              } ${dropTarget && dropTarget.path === item.path ? 'bg-teal-900 border border-teal-500' : ''}`}
              onClick={() => toggleFolder(item.path, item)}
              draggable={isAdmin || (user?.has_file_access && activeTab === 'private')}
              onDragStart={(e) => handleDragStart(e, item)}
              onDragOver={(e) => handleDragOver(e, item)}
              onDragLeave={(e) => handleDragLeave(e)}
              onDrop={(e) => handleDrop(e, item)}
            >
              <div className="flex items-center">
                {isExpanded ? <ChevronDown size={14} /> : <ChevronRight size={14} />}
                <FolderOpen size={16} className="ml-1 mr-2" />
                <span className="text-sm">{item.name}</span>
              </div>
              
              {/* File operation buttons */}
            {(isAdmin || (user && user.has_file_access && activeTab === 'private')) && (
                <div className="flex">
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      openRenameDialog(item);
                    }}
                    className="p-1 rounded hover:bg-stone-600 text-stone-400 hover:text-teal-300 opacity-0 group-hover:opacity-100"
                    title="Rename folder"
                  >
                    <FileEdit size={14} />
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      openDeleteDialog(item);
                    }}
                    className="p-1 rounded hover:bg-stone-600 text-stone-400 hover:text-red-400 opacity-0 group-hover:opacity-100"
                    title="Delete folder"
                  >
                    <Trash2 size={14} />
                  </button>
                </div>
              )}
            </div>
            
            {isExpanded && item.children && (
              <div className="ml-2 border-l border-stone-700">
                {renderFileTree(item.children)}
              </div>
            )}
          </div>
        );
      } else {
        const isSelected = selectedFile && selectedFile.path === item.path;
        return (
          <div 
            key={item.path} 
            className={`flex items-center justify-between py-1 px-1 ml-4 rounded cursor-pointer hover:bg-stone-700 group ${isSelected ? 'bg-stone-700 text-teal-300' : 'text-teal-50'}`}
            onClick={() => handleFileSelect(item)}
            draggable={isAdmin || (user?.has_file_access && activeTab === 'private')}
            onDragStart={(e) => handleDragStart(e, item)}
          >
            <div className="flex items-center">
              {getFileIcon(item.name)}
              <span className="text-sm">{item.name}</span>
            </div>
            
            {/* File operation buttons */}
            {(isAdmin || (user && user.has_file_access && activeTab === 'private')) && (
              <div className="flex">
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    openRenameDialog(item);
                  }}
                  className="p-1 rounded hover:bg-stone-600 text-stone-400 hover:text-teal-300 opacity-0 group-hover:opacity-100"
                  title="Rename file"
                >
                  <FileEdit size={14} />
                </button>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    openDeleteDialog(item);
                  }}
                  className="p-1 rounded hover:bg-stone-600 text-stone-400 hover:text-red-400 opacity-0 group-hover:opacity-100"
                  title="Delete file"
                >
                  <Trash2 size={14} />
                </button>
              </div>
            )}
          </div>
        );
      }
    });
  };

  return (
    <div className="w-1/4 border-r border-stone-700 flex flex-col overflow-hidden">
      <div className="p-2 border-b border-stone-700 font-mono text-sm flex items-center justify-between">
        <div className="flex items-center">
          <span>FILES</span>
          
          {/* Tabs for switching between public and private files */}
          <div className="flex ml-4">
            <button
              onClick={() => {
                if (activeTab !== 'public') {
                  // First set the active tab, then select the root folder
                  handleFileSelect({ 
                    path: '/', 
                    type: 'directory', 
                    name: 'Root', 
                    isPublic: true,
                    setTab: 'public' // Add flag to explicitly set the tab
                  });
                }
              }}
              className={`px-2 py-1 rounded-t text-xs flex items-center gap-1 ${
                activeTab === 'public' 
                  ? 'bg-stone-700 text-teal-300' 
                  : 'bg-stone-800 hover:bg-stone-700'
              }`}
              title="Public files (readable by all users)"
            >
              <Globe size={14} />
              <span>Public</span>
            </button>
            
            {(isAdmin || (user && user.has_file_access)) && (
              <button
                onClick={() => {
                  if (activeTab !== 'private') {
                    // First set the active tab, then select the root folder
                    handleFileSelect({ 
                      path: '/', 
                      type: 'directory', 
                      name: 'Root',
                      setTab: 'private' // Add flag to explicitly set the tab
                    });
                  }
                }}
                className={`px-2 py-1 rounded-t text-xs flex items-center gap-1 ml-1 ${
                  activeTab === 'private' 
                    ? 'bg-stone-700 text-teal-300' 
                    : 'bg-stone-800 hover:bg-stone-700'
                }`}
                title="Private files (admin only)"
              >
                <Lock size={14} />
                <span>Private</span>
              </button>
            )}
          </div>
        </div>
        
        {/* File creation buttons (admins for both tabs, users with file access only for private tab) */}
        {(isAdmin || (user && user.has_file_access && activeTab === 'private')) && (
          <div className="flex gap-2">
            <button
              onClick={() => openCreateDialog('file')}
              className="p-1 rounded hover:bg-stone-700 text-teal-400"
              title="Create new file"
            >
              <Plus size={16} />
            </button>
            <button
              onClick={() => openCreateDialog('directory')}
              className="p-1 rounded hover:bg-stone-700 text-teal-400"
              title="Create new folder"
            >
              <FolderPlus size={16} />
            </button>
          </div>
        )}
      </div>
      
      <div 
        className="flex-1 overflow-auto"
        onDragOver={handleContainerDragOver}
        onDragLeave={handleContainerDragLeave}
        onDrop={handleContainerDrop}
      >
        {isTreeLoading ? (
          <div className="flex items-center justify-center h-full">
            <span className="text-teal-300">Loading files...</span>
          </div>
        ) : errorMessage ? (
          <div className="p-2 text-red-400">{errorMessage}</div>
        ) : (
          <div className="p-2 font-mono">
            {activeTab === 'public' ? (
              // Show public files to all users
              <>
                <div className="flex items-center py-1 px-1 text-teal-300">
                  <Globe size={16} className="mr-2" />
                  <span className="text-sm font-bold">Public Files</span>
                </div>
                {publicFiles.length > 0 ? (
                  renderFileTree(publicFiles)
                ) : (
                  <div className="ml-4 text-stone-500 text-sm">No public files available</div>
                )}
              </>
            ) : (
              // Show private files to admin users
              <>
                <div className="flex items-center py-1 px-1 text-teal-300">
                  <Lock size={16} className="mr-2" />
                  <span className="text-sm font-bold">Private Files</span>
                </div>
                {files.length > 0 ? (
                  renderFileTree(files)
                ) : (
                  <div className="ml-4 text-stone-500 text-sm">No private files available</div>
                )}
              </>
            )}
          </div>
        )}
      </div>
      
      <div className="p-2 border-t border-stone-700 text-xs">
        {selectedFile ? selectedFile.path : currentPath}
      </div>
      
      {/* Storage statistics display */}
      {(isAdmin || (user && user.has_file_access)) && (
        <StorageStats stats={storageStats} />
      )}
      
      {/* File operation dialogs */}
      <CreateFileDialog
        showCreateDialog={showCreateDialog}
        createType={createType}
        newItemName={newItemName}
        setNewItemName={setNewItemName}
        isCreating={isCreating}
        errorMessage={errorMessage}
        closeCreateDialog={closeCreateDialog}
        createNewItem={createNewItem}
      />
        
      <RenameDialog
        showRenameDialog={showRenameDialog}
        itemToRename={itemToRename}
        newName={newName}
        setNewName={setNewName}
        isRenaming={isRenaming}
        errorMessage={errorMessage}
        closeRenameDialog={closeRenameDialog}
        renameItem={renameItem}
      />
        
      <DeleteDialog
        showDeleteDialog={showDeleteDialog}
        itemToDelete={itemToDelete}
        isDeleting={isDeleting}
        errorMessage={errorMessage}
        closeDeleteDialog={closeDeleteDialog}
        handleDeleteItem={handleDeleteItem}
      />
    </div>
  );
};

export default FileTree;

================
File: windows/explorer/components/MapEditor.jsx
================
import React, { useState, useRef, useEffect, useCallback } from 'react';
import { Map, Save, FileDown } from 'lucide-react';
import { 
  createEmptyMap, 
  serializeMap, 
  parseMapFile, 
  convertMapToAscii, 
  convertAsciiToMap 
} from '../../mapeditor/utils/mapUtils';

// Import sub-components
import MapToolbar from '../../mapeditor/MapToolbar';
import MapCanvas from '../../mapeditor/MapCanvas';
import LayerPanel from '../../mapeditor/LayerPanel';
import TilePalette from '../../mapeditor/TilePalette';

/**
 * Map Editor component for use within the FileContent area
 * This component handles the editing of .map files in the file explorer
 */
const MapEditor = ({ fileContent, selectedFile, onSave }) => {
  // State for map data
  const [mapData, setMapData] = useState(null);
  const [currentLayer, setCurrentLayer] = useState(0);
  const [currentTool, setCurrentTool] = useState('floor'); // Default to floor instead of select
  const [isDirty, setIsDirty] = useState(false);
  const [error, setError] = useState(null);
  const [saveStatus, setSaveStatus] = useState('saved'); // 'saved', 'saving', 'error'
  const [showAsciiModal, setShowAsciiModal] = useState(false);
  const [asciiContent, setAsciiContent] = useState('');
  const [asciiImportText, setAsciiImportText] = useState('');
  const [asciiModalMode, setAsciiModalMode] = useState('export'); // 'export' or 'import'
  const [selectedTileId, setSelectedTileId] = useState(0);
  const [selectedRotation, setSelectedRotation] = useState(0); // Add state for rotation
  const [showGrid, setShowGrid] = useState(true); // State for grid visibility
  const [brushSize, setBrushSize] = useState(1); // State for brush size
  
  // Use ref instead of state for the reset view function to avoid render-phase updates
  const resetViewFnRef = useRef(null);
  
  // References
  const autoSaveTimeoutRef = useRef(null);
  const isInitialLoadRef = useRef(true); // Track initial load to prevent layer reset during auto-save

  // Load map data when fileContent changes
  useEffect(() => {
    try {
      if (fileContent) {
        const parsedMap = parseMapFile(fileContent);
        setMapData(parsedMap);
        
        // Only reset currentLayer on initial load, not on auto-saves
        if (isInitialLoadRef.current) {
          setCurrentLayer(0);
          isInitialLoadRef.current = false;
        }
        
        setIsDirty(false);
        setError(null);
      } else {
        // Create a new map if no content
        setMapData(createEmptyMap());
        setIsDirty(true);
      }
    } catch (err) {
      console.error('Error parsing map file:', err);
      setError('Failed to parse map file. Creating a new map.');
      setMapData(createEmptyMap());
      setIsDirty(true);
    }
  }, [fileContent]);
  
  // Auto-save when map data changes
  useEffect(() => {
    // If the map is dirty (has unsaved changes), auto-save after a delay
    if (isDirty && mapData) {
      // Clear any existing timeout
      if (autoSaveTimeoutRef.current) {
        clearTimeout(autoSaveTimeoutRef.current);
      }
      
      // Set save status to 'saving'
      setSaveStatus('saving');
      
      // Set a new timeout for auto-save
      autoSaveTimeoutRef.current = setTimeout(() => {
        handleSaveMap();
      }, 1000); // 1 second debounce
    }
    
    // Cleanup function to clear the timeout when component unmounts
    return () => {
      if (autoSaveTimeoutRef.current) {
        clearTimeout(autoSaveTimeoutRef.current);
      }
    };
  }, [isDirty, mapData]);

  // Handler for saving the map
  const handleSaveMap = () => {
    if (!mapData) return;
    
    try {
      // Serialize the map data to JSON string
      const mapContent = serializeMap(mapData);
      
      // Debug logs to track the data flow
      console.log('[DEBUG] Map Editor - Saving map data:', {
        mapDataExists: !!mapData,
        serializedLength: mapContent?.length,
        serializedPreview: mapContent?.substring(0, 100) + '...',
        selectedFile: selectedFile?.path
      });
      
      // Set status to saving
      setSaveStatus('saving');
      
      // Call the parent onSave function
      onSave(mapContent);
      
      // Update state
      setIsDirty(false);
      setSaveStatus('saved');
    } catch (err) {
      console.error('Error saving map:', err);
      setError('Failed to save map file.');
      setSaveStatus('error');
    }
  };

  // Handler for map edits
  // Add 'rotation' parameter to accept the rotation value from MapCanvas
  const handleEdit = (x, y, tool, rotation) => {
    if (!mapData || !mapData.layers || !mapData.layers[currentLayer]) return;
    
    // Clone the current map data to avoid direct state mutation
    const newMapData = { ...mapData };
    const layerData = { ...newMapData.layers[currentLayer] };
    
    // Find if the cell already exists in this layer
    const existingCellIndex = layerData.cells.findIndex(cell => cell.x === x && cell.y === y);
    
    if (tool === 'erase') {
      // If erasing and the cell exists, remove it
      if (existingCellIndex !== -1) {
        layerData.cells = layerData.cells.filter((_, index) => index !== existingCellIndex);
      }
    } else {
      // Create the cell data based on the tool type
      // Include the received rotation value
      let cellData = { x, y, type: tool, rotation: rotation || 0 }; // Default to 0 if rotation is undefined/falsy
      
      // CRITICAL FIX: Include the selected tile ID for shadow tiles as well!
      if (tool === 'floor' || tool === 'wall' || tool === 'shadow') {
        cellData.tileId = selectedTileId;
        
        // For shadow tiles, add extra debug logging
        if (tool === 'shadow') {
          console.log(`MapEditor CRITICAL: Creating shadow tile at (${x}, ${y}) with tileId=${selectedTileId}`);
        }
      }
      
      // If a cell already exists at this position, update it immutably
      if (existingCellIndex !== -1) {
        // Create a new array with the updated cell
        layerData.cells = layerData.cells.map((cell, index) => 
          index === existingCellIndex ? cellData : cell
        );
      } else {
        // Otherwise, add a new cell (already immutable via push to a cloned array)
        layerData.cells.push(cellData);
      }
    }
    
    // Update the layer in the map data
    newMapData.layers[currentLayer] = layerData;
    
    // Update state
    setMapData(newMapData);
    setIsDirty(true);
  };

  // Handler for rotation changes from TilePalette
  const handleRotateTile = (newRotation) => {
    setSelectedRotation(newRotation);
    // Note: We don't mark as dirty here, as rotation is a tool setting, not map data change
  };

  // Layer management functions
  const handleToggleLayerVisibility = (layerIndex) => {
    if (!mapData || !mapData.layers || !mapData.layers[layerIndex]) return;
    
    const newMapData = { ...mapData };
    newMapData.layers[layerIndex] = {
      ...newMapData.layers[layerIndex],
      visible: !newMapData.layers[layerIndex].visible
    };
    
    setMapData(newMapData);
    setIsDirty(true);
  };

  const handleAddLayer = () => {
    if (!mapData) return;
    
    const newLayerName = `Layer ${mapData.layers.length + 1}`;
    const newLayer = {
      name: newLayerName,
      visible: true,
      cells: []
    };
    
    const newMapData = { 
      ...mapData,
      layers: [...mapData.layers, newLayer]
    };
    
    setMapData(newMapData);
    setCurrentLayer(newMapData.layers.length - 1);
    setIsDirty(true);
  };

  const handleRemoveLayer = (layerIndex) => {
    if (!mapData || !mapData.layers || mapData.layers.length <= 1) return;
    
    const newMapData = { ...mapData };
    newMapData.layers = newMapData.layers.filter((_, index) => index !== layerIndex);
    
    setMapData(newMapData);
    
    // Adjust current layer if necessary
    if (currentLayer >= newMapData.layers.length) {
      setCurrentLayer(newMapData.layers.length - 1);
    }
    
    setIsDirty(true);
  };

  const handleMoveLayerUp = (layerIndex) => {
    if (!mapData || !mapData.layers || layerIndex >= mapData.layers.length - 1) return;
    
    const newMapData = { ...mapData };
    const layers = [...newMapData.layers];
    
    // Swap layers
    [layers[layerIndex], layers[layerIndex + 1]] = [layers[layerIndex + 1], layers[layerIndex]];
    
    newMapData.layers = layers;
    setMapData(newMapData);
    
    // Update current layer if necessary
    if (currentLayer === layerIndex) {
      setCurrentLayer(layerIndex + 1);
    } else if (currentLayer === layerIndex + 1) {
      setCurrentLayer(layerIndex);
    }
    
    setIsDirty(true);
  };

  const handleMoveLayerDown = (layerIndex) => {
    if (!mapData || !mapData.layers || layerIndex <= 0) return;
    
    const newMapData = { ...mapData };
    const layers = [...newMapData.layers];
    
    // Swap layers
    [layers[layerIndex], layers[layerIndex - 1]] = [layers[layerIndex - 1], layers[layerIndex]];
    
    newMapData.layers = layers;
    setMapData(newMapData);
    
    // Update current layer if necessary
    if (currentLayer === layerIndex) {
      setCurrentLayer(layerIndex - 1);
    } else if (currentLayer === layerIndex - 1) {
      setCurrentLayer(layerIndex);
    }
    
    setIsDirty(true);
  };

  const handleRenameLayer = (layerIndex, newName) => {
    if (!mapData || !mapData.layers || !mapData.layers[layerIndex] || !newName) return;
    
    const newMapData = { ...mapData };
    newMapData.layers[layerIndex] = {
      ...newMapData.layers[layerIndex],
      name: newName
    };
    
    setMapData(newMapData);
    setIsDirty(true);
  };

  // Handler for exporting to ASCII
  const handleExportAscii = () => {
    if (!mapData) return;
    
    try {
      // Convert the map data to ASCII
      const ascii = convertMapToAscii(mapData);
      setAsciiContent(ascii);
      setAsciiModalMode('export');
      setShowAsciiModal(true);
    } catch (err) {
      console.error('Error exporting to ASCII:', err);
      setError('Failed to export map to ASCII format.');
    }
  };

  // Handler for importing from ASCII
  const handleImportAscii = () => {
    setAsciiImportText('');
    setAsciiModalMode('import');
    setShowAsciiModal(true);
  };

  // Handler for confirming ASCII import
  const handleConfirmAsciiImport = () => {
    if (!asciiImportText.trim()) {
      setError('No ASCII content to import.');
      return;
    }
    
    try {
      // Convert ASCII to map data
      const newMapData = convertAsciiToMap(asciiImportText, mapData.name);
      
      // Preserve metadata from existing map if possible
      if (mapData.metadata) {
        newMapData.metadata = {
          ...newMapData.metadata,
          author: mapData.metadata.author || 'user',
          modified: new Date().toISOString()
        };
      }
      
      // Update the map data
      setMapData(newMapData);
      setIsDirty(true);
      setShowAsciiModal(false);
    } catch (err) {
      console.error('Error importing from ASCII:', err);
      setError('Failed to import ASCII map. The format may be invalid.');
    }
  };

  // Handler for downloading the ASCII map
  const handleDownloadAscii = () => {
    if (!asciiContent) return;
    
    try {
      // Create a blob with the ASCII content
      const blob = new Blob([asciiContent], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      
      // Create a temporary anchor element to trigger the download
      const a = document.createElement('a');
      a.href = url;
      a.download = `${mapData.name || 'map'}.txt`;
      
      // Append the anchor to the document, click it, and remove it
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      // Clean up by revoking the object URL
      URL.revokeObjectURL(url);
    } catch (err) {
      console.error('Error downloading ASCII map:', err);
      setError('Failed to download ASCII map.');
    }
  };


  // Handler for applying map property changes
  const handleApplyProperties = (properties) => {
    if (!mapData) return;

    const newMapData = { 
      ...mapData,
      name: properties.name,
      width: properties.width,
      height: properties.height,
      gridSize: properties.gridSize
    };

    // Update map data
    setMapData(newMapData);
    setIsDirty(true);
  };
  
  // Handler for updating layer opacity
  const handleUpdateLayerOpacity = (layerIndex, opacity) => {
    if (!mapData || !mapData.layers || !mapData.layers[layerIndex]) return;
    
    const newMapData = { ...mapData };
    newMapData.layers[layerIndex] = {
      ...newMapData.layers[layerIndex],
      opacity: opacity
    };
    
    setMapData(newMapData);
    setIsDirty(true);
  };

  // If map data isn't loaded yet, show a loading state
  if (!mapData) {
    return (
      <div className="flex items-center justify-center h-full">
        <span className="text-teal-300">Loading map editor...</span>
      </div>
    );
  }

  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400 overflow-hidden">
      {/* Toolbar */}
      <MapToolbar 
        onSave={handleSaveMap}
        onUndo={() => console.log('Undo not implemented')}
        onRedo={() => console.log('Redo not implemented')}
        onClear={() => {
          // Create a new empty map but preserve properties like name, width, height, gridSize
          const newMap = createEmptyMap();
          newMap.name = mapData.name;
          newMap.width = mapData.width;
          newMap.height = mapData.height;
          newMap.gridSize = mapData.gridSize;
          // Preserve metadata if it exists
          if (mapData.metadata) {
            newMap.metadata = { ...mapData.metadata };
          }
          setMapData(newMap);
          setIsDirty(true);
        }}
        onExportAscii={handleExportAscii}
        onImportAscii={handleImportAscii}
        onToggleGrid={() => setShowGrid(!showGrid)}
        onResetView={() => {
          // Call the reset view function if it exists
          if (resetViewFnRef.current) {
            resetViewFnRef.current();
          }
        }}
        showGrid={showGrid}
        saveStatus={saveStatus}
        mapData={mapData}
        onApplyProperties={handleApplyProperties}
      />
      
      {/* Error message */}
      {error && (
        <div className="p-2 bg-red-900 text-red-200 text-sm">
          {error}
        </div>
      )}
      
      {/* Main content area */}
      <div className="flex-1 flex overflow-hidden">
        {/* Canvas for map editing */}
        <MapCanvas 
          mapData={mapData}
          currentLayer={currentLayer}
          currentTool={currentTool}
          selectedTileId={selectedTileId}
          selectedRotation={selectedRotation} // Pass rotation state to canvas
          onEdit={handleEdit}
          showGrid={showGrid}
          resetViewRef={resetViewFnRef} // Pass ref instead of setter function
          brushSize={brushSize}
        />
        
        {/* Layer panel with integrated tile palette */}
        <LayerPanel 
          layers={mapData.layers}
          currentLayer={currentLayer}
          setCurrentLayer={setCurrentLayer}
          onToggleLayerVisibility={handleToggleLayerVisibility}
          onAddLayer={handleAddLayer}
          onRemoveLayer={handleRemoveLayer}
          onMoveLayerUp={handleMoveLayerUp}
          onMoveLayerDown={handleMoveLayerDown}
          onRenameLayer={handleRenameLayer}
          onUpdateLayerOpacity={handleUpdateLayerOpacity}
          selectedTileId={selectedTileId}
          onSelectTile={setSelectedTileId}
          selectedRotation={selectedRotation} // Pass rotation state to LayerPanel
          onRotateTile={handleRotateTile} // Pass rotation handler to LayerPanel
          currentTool={currentTool}
          setCurrentTool={setCurrentTool}
          brushSize={brushSize}
          setBrushSize={setBrushSize}
        />
      </div>
      
      
      {/* ASCII Modal */}
      {showAsciiModal && (
        <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50">
          <div className="bg-stone-800 border border-stone-700 rounded-lg shadow-lg w-full max-w-3xl max-h-[80vh] flex flex-col">
            <div className="flex justify-between items-center p-4 border-b border-stone-700">
              <h2 className="text-lg font-semibold text-teal-300">
                {asciiModalMode === 'export' ? 'ASCII Map Export' : 'Import ASCII Map'}
              </h2>
              <button 
                onClick={() => setShowAsciiModal(false)}
                className="p-1 hover:bg-stone-700 rounded text-teal-400"
              >
                &times;
              </button>
            </div>
            
            <div className="p-4 flex-1 overflow-auto">
              {asciiModalMode === 'export' ? (
                <div className="flex flex-col h-full">
                  <p className="mb-4 text-sm text-stone-300">
                    This is the ASCII representation of your map. Each character represents a cell type:
                    <br />
                    <code className="bg-stone-900 px-1 rounded">
                      # = Wall, . = Floor, + = Door, " = Grass, ' = Ashes, &gt; = Stairs, @ = Spawn
                    </code>
                  </p>
                  <pre className="bg-stone-900 p-4 rounded font-mono text-teal-100 text-sm overflow-auto flex-1 whitespace-pre">
                    {asciiContent}
                  </pre>
                </div>
              ) : (
                <div className="flex flex-col h-full">
                  <p className="mb-4 text-sm text-stone-300">
                    Paste ASCII map content below. Each character represents a cell type:
                    <br />
                    <code className="bg-stone-900 px-1 rounded">
                      # = Wall, . = Floor, + = Door, " = Grass, ' = Ashes, &gt; = Stairs, @ = Spawn
                    </code>
                  </p>
                  <textarea 
                    className="bg-stone-900 p-4 rounded font-mono text-teal-100 text-sm overflow-auto flex-1 resize-none focus:outline-none focus:ring-1 focus:ring-teal-500"
                    value={asciiImportText}
                    onChange={e => setAsciiImportText(e.target.value)}
                    placeholder="Paste ASCII map here..."
                  />
                </div>
              )}
            </div>
            
            <div className="p-4 border-t border-stone-700 flex justify-end space-x-2">
              <button 
                onClick={() => setShowAsciiModal(false)}
                className="px-4 py-2 bg-stone-700 hover:bg-stone-600 rounded text-teal-100"
              >
                Cancel
              </button>
              
              {asciiModalMode === 'export' ? (
                <button 
                  onClick={handleDownloadAscii}
                  className="px-4 py-2 bg-teal-700 hover:bg-teal-600 rounded text-teal-100 flex items-center"
                >
                  <FileDown size={16} className="mr-2" />
                  Download ASCII
                </button>
              ) : (
                <button 
                  onClick={handleConfirmAsciiImport}
                  className="px-4 py-2 bg-teal-700 hover:bg-teal-600 rounded text-teal-100"
                >
                  Import
                </button>
              )}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default MapEditor;

================
File: windows/explorer/components/nodes/index.js
================
import TextNode from './TextNode';

/**
 * Node type registry
 * Export all node types from this file to easily import them elsewhere
 */

const nodeTypes = {
  // Add all node types here
  text: TextNode,
  // Additional node types can be added here in the future
};

export default nodeTypes;

================
File: windows/explorer/components/nodes/TextNode.jsx
================
import React, { useState } from 'react';
import { Edit } from 'lucide-react';
import { Handle, Position } from 'reactflow';

/**
 * TextNode component for displaying and editing text nodes in the canvas
 * This component is used in the Canvas Editor
 */
const TextNode = ({ id, data, isConnectable, setEditingNode, editingNode }) => {
  const isEditing = editingNode === id;
  const [isHovered, setIsHovered] = useState(false);
  
  const handleEditClick = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setEditingNode(id);
  };
  
  const handleEdit = (e) => {
    const updatedText = e.target.value;
    
    // Update the node data is handled by the parent component
    // through the setNodes function passed via data
    if (data.onChange) {
      data.onChange(id, updatedText);
    }
  };
  
  const handleBlur = () => {
    setEditingNode(null);
  };
  
  const handleKeyDown = (e) => {
    if (e.key === 'Escape') {
      setEditingNode(null);
    } else if (e.key === 'Enter' && e.ctrlKey) {
      setEditingNode(null);
    }
  };
  
  return (
    <div 
      className="p-2 bg-stone-800 border border-stone-700 rounded shadow-md relative"
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
    >
      <Handle 
        type="source" 
        position={Position.Top} 
        isConnectable={isConnectable} 
        style={{ 
          background: '#14b8a6', // teal-500 color
          width: '0.45rem',
          height: '0.45rem',
          borderRadius: '9999px',
          border: 'none'
        }}
      />

      {/* Bottom handle */}
      <Handle 
        type="source" 
        position={Position.Bottom} 
        isConnectable={isConnectable} 
        style={{ 
          background: '#14b8a6', // teal-500 color
          width: '0.45rem',
          height: '0.45rem',
          borderRadius: '9999px',
          border: 'none'
        }}
      />

      {/* Right handle */}
      <Handle 
        type="source" 
        position={Position.Right} 
        id="right"
        isConnectable={isConnectable} 
        style={{ 
          background: '#14b8a6', // teal-500 color
          width: '0.45rem',
          height: '0.45rem',
          borderRadius: '9999px',
          border: 'none'
        }}
      />

      {/* Left handle */}
      <Handle 
        type="source" 
        position={Position.Left} 
        id="left"
        isConnectable={isConnectable} 
        style={{ 
          background: '#14b8a6', // teal-500 color
          width: '0.45rem',
          height: '0.45rem',
          borderRadius: '9999px',
          border: 'none'
        }}
      />
      {isEditing ? (
        <textarea
          className="w-full h-full bg-stone-700 text-teal-400 p-2 rounded font-mono text-sm focus:outline-none resize-none min-h-[80px]"
          value={data.text}
          onChange={handleEdit}
          onBlur={handleBlur}
          onKeyDown={handleKeyDown}
          autoFocus
        />
      ) : (
        <>
          <div className="text-teal-400 text-sm whitespace-pre-wrap pr-6">{data.text}</div>
          {isHovered && (
            <button
              className="absolute top-1 right-1 bg-stone-700 p-1 rounded-sm hover:bg-stone-600 transition-colors"
              onClick={handleEditClick}
              title="Edit node"
            >
              <Edit size={14} className="text-teal-400" />
            </button>
          )}
        </>
      )}
    </div>
  );
};

export default TextNode;

================
File: windows/explorer/components/StorageStats.jsx
================
import React from 'react';

const StorageStats = ({ stats, isAdmin }) => {
  // If stats aren't available yet or the user doesn't have file access, don't show anything
  if (!stats || stats.isLoading) {
    return null;
  }

  // Format bytes to human-readable format
  const formatBytes = (bytes, decimals = 2) => {
    if (bytes === 0) return '0 Bytes';
    if (bytes === null || bytes === undefined) return 'Unlimited';
    
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
  };

  // Calculate percentage used
  const percentUsed = stats.unlimited ? 0 : Math.min(100, Math.round((stats.used / stats.quota) * 100)) || 0;
  
  return (
    <div className="px-2 py-1 bg-stone-800 text-xs border-t border-stone-700">
      <div className="flex justify-between items-center ${isAdmin ? 'mb-0' : 'mb-1'}">
        <span className="text-gray-400">Storage:</span>
        <span className="text-teal-400">
          {stats.unlimited 
            ? 'Unlimited (Admin)'
            : `${formatBytes(stats.used)} of ${formatBytes(stats.quota)}`
          }
        </span>
      </div>
      
      {!stats.unlimited && (
        <div className="w-full bg-stone-700 rounded-full h-1.5 mb-1">
          <div 
            className="bg-teal-600 h-1.5 rounded-full" 
            style={{ width: `${percentUsed}%` }}
          ></div>
        </div>
      )}
    </div>
  );
};

export default StorageStats;

================
File: windows/explorer/ExplorerWindow.jsx
================
import React from 'react';
import useExplorerState from './state/useExplorerState';
import { useAuth } from '../../../context/AuthContext';
import FileTree from './components/FileTree';
import FileContent from './components/FileContent';
import CommandInput from './components/CommandInput';
import StorageStats from './components/StorageStats';
import '../ExplorerWindow.css';

const ExplorerWindow = ({ isActive, nodeId, onCommand, transformWindow, windowState, updateWindowState, focusRef }) => {
  // Get auth context to check user permissions
  const { user } = useAuth();
  // Use the custom hook to manage state and operations
  const explorerState = useExplorerState(nodeId, windowState, updateWindowState);
  
  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400 overflow-hidden">
      <div className="flex flex-1 overflow-hidden relative">
        {/* File tree panel */}
        <FileTree 
          files={explorerState.files}
          publicFiles={explorerState.publicFiles}
          activeTab={explorerState.activeTab}
          expandedFolders={explorerState.expandedFolders}
          currentPath={explorerState.currentPath}
          selectedFile={explorerState.selectedFile}
          isTreeLoading={explorerState.isTreeLoading}
          errorMessage={explorerState.errorMessage}
          isAdmin={explorerState.isAdmin}
          user={user}
          toggleFolder={explorerState.toggleFolder}
          handleFileSelect={explorerState.handleFileSelect}
          openRenameDialog={explorerState.openRenameDialog}
          openDeleteDialog={explorerState.openDeleteDialog}
          openCreateDialog={explorerState.openCreateDialog}
          handleDragStart={explorerState.handleDragStart}
          handleDragOver={explorerState.handleDragOver}
          handleDragLeave={explorerState.handleDragLeave}
          handleDrop={explorerState.handleDrop}
          handleContainerDragOver={explorerState.handleContainerDragOver}
          handleContainerDragLeave={explorerState.handleContainerDragLeave}
          handleContainerDrop={explorerState.handleContainerDrop}
          dropTarget={explorerState.dropTarget}
          storageStats={explorerState.storageStats}
          // Dialog-related props
          showCreateDialog={explorerState.showCreateDialog}
          createType={explorerState.createType}
          newItemName={explorerState.newItemName}
          setNewItemName={explorerState.setNewItemName}
          isCreating={explorerState.isCreating}
          closeCreateDialog={explorerState.closeCreateDialog}
          createNewItem={explorerState.createNewItem}
          showRenameDialog={explorerState.showRenameDialog}
          itemToRename={explorerState.itemToRename}
          newName={explorerState.newName}
          setNewName={explorerState.setNewName}
          isRenaming={explorerState.isRenaming}
          closeRenameDialog={explorerState.closeRenameDialog}
          renameItem={explorerState.renameItem}
          showDeleteDialog={explorerState.showDeleteDialog}
          itemToDelete={explorerState.itemToDelete}
          isDeleting={explorerState.isDeleting}
          closeDeleteDialog={explorerState.closeDeleteDialog}
          handleDeleteItem={explorerState.handleDeleteItem}
        />
        
        
        {/* File content panel */}
        <FileContent
          selectedFile={explorerState.selectedFile}
          isContentLoading={explorerState.isContentLoading}
          fileContent={explorerState.fileContent}
          errorMessage={explorerState.errorMessage}
          showPreview={explorerState.showPreview}
          editMode={explorerState.editMode}
          saveStatus={explorerState.saveStatus}
          converter={explorerState.converter}
          isAdmin={explorerState.isAdmin}
          user={user}
          activeTab={explorerState.activeTab}
          setFileContent={explorerState.setFileContent}
          toggleEditMode={explorerState.toggleEditMode}
          handleMarkdownChange={explorerState.handleMarkdownChange}
          handleSaveFileContent={explorerState.handleSaveFileContent}
          handleExportFile={explorerState.handleExportFile}
        />
      </div>
      
      {/* Command input */}
      <CommandInput
        focusRef={focusRef}
        isAdmin={explorerState.isAdmin}
        handleCommand={explorerState.handleCommand}
      />
    </div>
  );
};

export default ExplorerWindow;

================
File: windows/explorer/README.md
================
# Explorer Window Component

This directory contains a modular implementation of the ExplorerWindow component. The code has been refactored to improve maintainability and make it easier to extend functionality.

## Architecture Overview

The ExplorerWindow has been split into several components and modules following a clean separation of concerns:

```
explorer/
├── ExplorerWindow.jsx              # Main component (orchestrator)
├── state/
│   └── useExplorerState.js         # Custom hook for state management
├── components/
│   ├── FileTree.jsx                # Tree view UI and navigation
│   ├── FileContent.jsx             # Content viewing/editing panel
│   ├── CommandInput.jsx            # Command input field
│   └── dialogs/
│       └── FileDialogs.jsx         # Dialog components for file operations
├── api/
│   └── fileOperations.js           # API calls and file operations
├── utils/
│   ├── fileUtils.js                # File-related utility functions
│   └── markdownUtils.js            # Markdown-specific utilities
└── README.md                       # This documentation file
```

## Component Responsibilities

### ExplorerWindow.jsx
- Acts as the main component that orchestrates all other components
- Retrieves state and operations from useExplorerState
- Passes down props to child components

### useExplorerState.js
- Centralizes all state management
- Handles state persistence and retrieval
- Implements business logic for all user interactions
- Provides functions for file operations

### FileTree.jsx
- Displays the directory structure
- Handles file/folder selection
- Manages UI for drag and drop operations

### FileContent.jsx
- Displays file content based on file type
- Provides editing interface for markdown files
- Renders markdown preview

### CommandInput.jsx
- Provides command input interface
- Handles command execution

### FileDialogs.jsx
- Contains dialog components for creating, renaming, and deleting files/folders

### fileOperations.js
- Encapsulates API calls to the server
- Handles error states and response parsing

### fileUtils.js and markdownUtils.js
- Provide utility functions for file and markdown operations

## Data Flow

1. User interactions in UI components trigger functions received from useExplorerState
2. useExplorerState processes these actions, updates state, and interacts with the API as needed
3. State changes flow back to UI components through props

## Adding Support for New File Types

To add support for new file types (e.g., canvas files, audio files, images):

1. Update `fileUtils.js` to recognize and provide appropriate icons for the new file types
2. Extend `FileContent.jsx` to render the new file types appropriately
3. If needed, add specific utility files (similar to markdownUtils.js) for the new file types
4. Update state in `useExplorerState.js` to handle any special behaviors for the new file types

## State Management

The component uses a custom hook approach for state management, which offers several advantages:

- Centralizes state logic in one place
- Makes the main component simpler and more declarative
- Allows for easier testing of business logic
- Simplifies adding new features or file type support

This approach is more maintainable than using a context provider for this specific use case, as the component tree is not deeply nested. If the component structure becomes more complex in the future, the code could be adapted to use a context provider instead.

================
File: windows/explorer/state/useExplorerState.js
================
import { useState, useEffect, useRef } from 'react';
import { useAuth } from '../../../../context/AuthContext';
import { useWindowState } from '../../../../context/WindowStateContext';
import { WINDOW_TYPES } from '../../../../utils/windowTypes';
import { saveExplorerState, getExplorerState } from '../../../../services/indexedDBService';
import { createMarkdownConverter } from '../utils/markdownUtils';
import { 
  fetchPublicDirectoryContents, 
  fetchDirectoryContents, 
  fetchPublicFileContent, 
  fetchFileContent,
  saveFileContent as apiSaveFileContent,
  createNewItem as apiCreateNewItem,
  renameItem as apiRenameItem,
  deleteItem as apiDeleteItem,
  moveItem as apiMoveItem,
  getStorageStats as apiGetStorageStats
} from '../api/fileOperations';
import { 
  getParentDirectoryPath, 
  expandParentFolders, 
  getActiveFolderPath 
} from '../utils/fileUtils';

const useExplorerState = (nodeId, windowState, updateWindowState) => {
  // Get auth context to check if user is admin
  const { user } = useAuth();
  const isAdmin = user?.is_admin || false;
  
  // Get window state context for additional persistence
  const { setActiveWindow } = useWindowState();
  
  // Refs to track state loading and saving
  const stateLoadedRef = useRef(false);
  const explorerSaveTimeoutRef = useRef(null); // New ref for debounced explorer state saving
  
  // Reference to store the saved state that needs to be restored after files are loaded
  const pendingStateRestoreRef = useRef(null);
  const fileLoadedRef = useRef(false);
  
  // Use state from windowState or initialize with defaults
  const [files, setFiles] = useState([]);
  const [publicFiles, setPublicFiles] = useState([]);
  const [currentPath, setCurrentPath] = useState(windowState?.currentPath || '/');
  const [selectedFile, setSelectedFile] = useState(windowState?.selectedFile || null);
  const [expandedFolders, setExpandedFolders] = useState(windowState?.expandedFolders || {});
  const [isTreeLoading, setIsTreeLoading] = useState(true);
  const [isContentLoading, setIsContentLoading] = useState(false);
  const [fileContent, setFileContent] = useState(windowState?.fileContent || '');
  const [errorMessage, setErrorMessage] = useState('');
  const [showPreview, setShowPreview] = useState(windowState?.showPreview || false);
  const [activeTab, setActiveTab] = useState(windowState?.activeTab || 'public'); // 'public' or 'private'
  
  // Additional state for markdown editing
  const [editMode, setEditMode] = useState(windowState?.editMode || false);
  const [saveStatus, setSaveStatus] = useState('saved'); // 'saved', 'saving', 'error'
  
  // State for file/folder creation
  const [showCreateDialog, setShowCreateDialog] = useState(false);
  const [createType, setCreateType] = useState('file'); // 'file' or 'directory'
  const [newItemName, setNewItemName] = useState('');
  const [isCreating, setIsCreating] = useState(false);
  
  // State for file/folder renaming
  const [showRenameDialog, setShowRenameDialog] = useState(false);
  const [itemToRename, setItemToRename] = useState(null);
  const [newName, setNewName] = useState('');
  const [isRenaming, setIsRenaming] = useState(false);
  
  // State for file/folder deletion
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [itemToDelete, setItemToDelete] = useState(null);
  const [isDeleting, setIsDeleting] = useState(false);
  
  // State for drag and drop
  const [draggedItem, setDraggedItem] = useState(null);
  const [dropTarget, setDropTarget] = useState(null);
  const [isMoving, setIsMoving] = useState(false);
  
  // For auto-save functionality and editor references
  const saveTimeoutRef = useRef(null);
  
  // Create markdown converter
  const converter = createMarkdownConverter();

  // Track previous node ID to detect window swaps
  const prevNodeIdRef = useRef(nodeId);

  // Load explorer state from IndexedDB on mount or when nodeId changes
  useEffect(() => {
    const loadExplorerState = async () => {
      console.log(`[DEBUG] Starting to load explorer state for window ${nodeId}`);
      
      // If nodeId changed but it's not the first load, it likely means a window swap occurred
      const isSwapDetected = prevNodeIdRef.current !== nodeId && prevNodeIdRef.current !== null;
      if (isSwapDetected) {
        console.log(`[DEBUG] Node ID changed from ${prevNodeIdRef.current} to ${nodeId}, possible window swap detected`);
        // Reset the state loaded flag to force a reload after a swap
        stateLoadedRef.current = false;
        // Clear any pending state
        pendingStateRestoreRef.current = null;
      }
      
      // Update prevNodeIdRef for future comparisons
      prevNodeIdRef.current = nodeId;
      
      try {
        // Try to load explorer state from IndexedDB
        const savedState = await getExplorerState(nodeId);
        console.log(`[DEBUG] Retrieved state from IndexedDB:`, savedState);
        
        if (savedState && savedState.content && !stateLoadedRef.current) {
          console.log(`[DEBUG] Valid saved state found for window ${nodeId}:`, savedState.content);
          
          // Store the saved state in the ref for later restoration after files are loaded
          pendingStateRestoreRef.current = savedState.content;
          
          // Restore expanded folders and active tab immediately
          if (savedState.content.expandedFolders) {
            console.log(`[DEBUG] Restoring expanded folders`);
            setExpandedFolders(savedState.content.expandedFolders);
          }
          
          if (savedState.content.activeTab) {
            console.log(`[DEBUG] Restoring active tab: ${savedState.content.activeTab}`);
            setActiveTab(savedState.content.activeTab);
          }
          
          if (savedState.content.editMode !== undefined && isAdmin) {
            console.log(`[DEBUG] Restoring edit mode: ${savedState.content.editMode}`);
            setEditMode(savedState.content.editMode);
          }
          
          // Mark as loaded
          stateLoadedRef.current = true;
        } else {
          console.log(`[DEBUG] No valid saved state found or state already loaded`);
          // Even if no state is loaded, mark as loaded to allow future saves
          stateLoadedRef.current = true;
        }
      } catch (error) {
        console.error(`[DEBUG] Failed to load explorer state:`, error);
        // Ensure we still mark state as loaded even if there's an error
        stateLoadedRef.current = true;
      }
    };
    
    loadExplorerState();
  }, [nodeId, isAdmin]);
  
  // Handle window activation
  useEffect(() => {
    if (windowState?.isActive) {
      // Save this as the active explorer window
      setActiveWindow(nodeId, WINDOW_TYPES.EXPLORER);
    }
  }, [windowState?.isActive, nodeId, setActiveWindow]);
  
  // Save explorer state to IndexedDB when it changes
  useEffect(() => {
    // Early return if state hasn't been loaded yet (prevents overwriting with default values)
    if (!stateLoadedRef.current) return;
    
    // Clear any existing timeout
    if (explorerSaveTimeoutRef.current) {
      clearTimeout(explorerSaveTimeoutRef.current);
    }
    
    // Save the explorer state to IndexedDB with debounce
    explorerSaveTimeoutRef.current = setTimeout(() => {
      console.log(`[DEBUG] Saving explorer state for window ${nodeId}:`, {
        selectedFile,
        expandedFolders,
        activeTab,
        editMode
      });
      
      saveExplorerState({
        id: nodeId,
        content: {
          selectedFile,
          expandedFolders,
          activeTab,
          editMode
        }
      }).catch(error => {
        console.error(`[DEBUG] Failed to save explorer state for window ${nodeId} to IndexedDB:`, error);
      });
    }, 300); // 300ms debounce
    
    // Clear timeout on cleanup
    return () => {
      if (explorerSaveTimeoutRef.current) {
        clearTimeout(explorerSaveTimeoutRef.current);
      }
    };
  }, [selectedFile, expandedFolders, activeTab, editMode, nodeId]);

  // Load initial directory contents and restore selected file afterward
  useEffect(() => {
    console.log('[DEBUG] Starting to load directory contents');
    
    // First, load the files
    const loadFilesAndRestoreSelection = async () => {
      try {
        // Load public files for all users
        await handleFetchPublicDirectoryContents('/', true);
        
      // Load private files for admin users or users with file access (if applicable)
      if (isAdmin || user?.has_file_access) {
        try {
          await handleFetchDirectoryContents('/', true);
        } catch (error) {
          console.error('Failed to load private files:', error);
          setFiles([]);
          if (activeTab === 'private') {
            setErrorMessage('Failed to load private files. Please ensure your directory exists.');
          }
        }
      }
        
        // Mark files as loaded
        fileLoadedRef.current = true;
        
        // Now that files are loaded, restore the selected file if we have one pending
        if (pendingStateRestoreRef.current && pendingStateRestoreRef.current.selectedFile) {
          const restoredFile = pendingStateRestoreRef.current.selectedFile;
          console.log(`[DEBUG] Now restoring selected file after files are loaded:`, restoredFile);
          
          // Set the selected file
          setSelectedFile(restoredFile);
          
          // Update the current path to ensure parent directories are visible
          if (restoredFile.type === 'file') {
            // For files, set the current path to the parent directory
            const parentPath = getParentDirectoryPath(restoredFile.path);
            setCurrentPath(parentPath);
          } else {
            // For directories, set the current path to the directory itself
            setCurrentPath(restoredFile.path);
          }
          
          // Ensure parent folders are expanded
          setExpandedFolders(prev => expandParentFolders(restoredFile.path, prev));
          
          // If it's a file, load its content
          if (restoredFile.type === 'file') {
            console.log(`[DEBUG] Loading content for restored file: ${restoredFile.path}`);
            
            // Set the preview mode for markdown files
            if (restoredFile.name.endsWith('.md')) {
              console.log(`[DEBUG] Setting preview mode for markdown file`);
              setShowPreview(true);
              
              // Also restore edit mode if it was saved
              if (pendingStateRestoreRef.current.editMode && isAdmin) {
                console.log(`[DEBUG] Restoring edit mode: ${pendingStateRestoreRef.current.editMode}`);
                setEditMode(pendingStateRestoreRef.current.editMode);
              }
            }
            
            // Use handleFileSelect to load the file content
            // Use setTimeout to ensure this happens after state updates
            setTimeout(() => {
              console.log(`[DEBUG] Executing delayed file selection for: ${restoredFile.path}`);
              handleFileSelect(restoredFile, true);
            }, 100);
          }
          
          // Clear the pending restore
          pendingStateRestoreRef.current = null;
        } else {
          console.log('[DEBUG] No file to restore or files not loaded yet');
        }
      } catch (error) {
        console.error('[DEBUG] Error in loadFilesAndRestoreSelection:', error);
      }
    };
    
    loadFilesAndRestoreSelection();
  }, [isAdmin, activeTab]);

  // State for storage statistics
  const [storageStats, setStorageStats] = useState({
    quota: 0,
    used: 0,
    available: 0,
    unlimited: false,
    isLoading: false
  });

  // Fetch storage statistics
  const fetchStorageStats = async () => {
    if (!user?.has_file_access && !isAdmin) return;
    
    setStorageStats(prev => ({ ...prev, isLoading: true }));
    
    try {
      const stats = await apiGetStorageStats();
      if (stats.error) {
        setErrorMessage(stats.error);
        setStorageStats(prev => ({
          ...prev,
          isLoading: false
        }));
      } else {
        setStorageStats({
          quota: stats.quota,
          used: stats.used,
          available: stats.available,
          unlimited: stats.unlimited,
          isLoading: false
        });
      }
    } catch (error) {
      console.error('Error fetching storage stats:', error);
      setStorageStats(prev => ({
        ...prev,
        isLoading: false
      }));
    }
  };

  // Fetch storage stats on mount and after file operations
  useEffect(() => {
    if (user?.has_file_access || isAdmin) {
      fetchStorageStats();
    }
  }, [user, isAdmin]);

  // Reset content states when switching tabs
  useEffect(() => {
    // Clear file content and reset view states when changing tabs
    setSelectedFile(null);
    setFileContent('');
    setShowPreview(false);
    setEditMode(false);
    setSaveStatus('saved');
    setErrorMessage('');
    
    // Reset current path to root for the selected tab
    setCurrentPath('/');
  }, [activeTab]);

  // Auto-save functionality with debounce
  useEffect(() => {
    // Auto-save if in edit mode, user has permission, and we have a markdown file selected
    // Allow for admins and users with file_access (for private files)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (editMode && hasEditPermission && selectedFile && selectedFile.name.endsWith('.md') && fileContent) {
      // Clear any existing timeout
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
      
      // Set status to saving
      setSaveStatus('saving');
      
      // Set a new timeout for auto-save
      saveTimeoutRef.current = setTimeout(() => {
        handleSaveFileContent();
      }, 1000); // 1 second debounce
    }
    
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, [fileContent, editMode, isAdmin, selectedFile]);

  // Update window state when relevant state changes
  useEffect(() => {
    if (updateWindowState) {
      updateWindowState({
        currentPath,
        selectedFile,
        expandedFolders,
        fileContent,
        showPreview,
        editMode,
        saveStatus,
        activeTab
      });
    }
  }, [currentPath, selectedFile, expandedFolders, fileContent, showPreview, editMode, saveStatus, activeTab, updateWindowState]);
  
  // Fetch public directory contents
  const handleFetchPublicDirectoryContents = async (publicPath = '/', refreshAll = false) => {
    setIsTreeLoading(true);
    setErrorMessage('');
    
    const result = await fetchPublicDirectoryContents(publicPath, refreshAll);
    
    if (result.error) {
      setErrorMessage(result.error);
    } else {
      setPublicFiles(result.files);
      
      // Only update the current path if we're not refreshing the entire tree
      if (!refreshAll) {
        setCurrentPath(publicPath);
      }
      
      // If we refreshed the entire tree, make sure the current path's parent folders are expanded
      if (refreshAll && currentPath !== '/') {
        setExpandedFolders(prev => expandParentFolders(currentPath, prev));
      }
    }
    
    setIsTreeLoading(false);
    return result; // Return result so we can chain promises
  };
  
  // Fetch public file content
  const handleFetchPublicFileContent = async (filePath) => {
    setIsContentLoading(true);
    setErrorMessage('');
    
    const result = await fetchPublicFileContent(filePath);
    
    if (result.error) {
      setErrorMessage(result.error);
      setSaveStatus('error');
    } else {
      setFileContent(result.content);
      setSaveStatus('saved');
    }
    
    setIsContentLoading(false);
  };
  
  // Fetch private directory contents
  const handleFetchDirectoryContents = async (path = '/', refreshAll = false) => {
    setIsTreeLoading(true);
    setErrorMessage('');
    
    const result = await fetchDirectoryContents(path, refreshAll);
    
    if (result.error) {
      setErrorMessage(result.error);
    } else {
      setFiles(result.files);
      
      // Only update the current path if we're not refreshing the entire tree
      if (!refreshAll) {
        setCurrentPath(path);
      }
      
      // If we refreshed the entire tree, make sure the current path's parent folders are expanded
      if (refreshAll && currentPath !== '/') {
        setExpandedFolders(prev => expandParentFolders(currentPath, prev));
      }
    }
    
    setIsTreeLoading(false);
    return result; // Return result so we can chain promises
  };
  
  // Fetch private file content
  const handleFetchFileContent = async (filePath) => {
    setIsContentLoading(true);
    setErrorMessage('');
    
    const result = await fetchFileContent(filePath);
    
    if (result.error) {
      setErrorMessage(result.error);
      setSaveStatus('error');
    } else {
      setFileContent(result.content);
      setSaveStatus('saved');
    }
    
    setIsContentLoading(false);
  };
  
  // Save file content
  const handleSaveFileContent = async (content) => {
    console.log('[DEBUG] useExplorerState - handleSaveFileContent called:', {
      selectedFilePath: selectedFile?.path,
      selectedFileName: selectedFile?.name,
      contentProvided: content !== undefined,
      // If content is provided, use it, otherwise use the state's fileContent
      contentToSaveType: typeof (content !== undefined ? content : fileContent),
      contentToSaveLength: (content !== undefined ? content : fileContent)?.length || 0,
      contentToSavePreview: typeof (content !== undefined ? content : fileContent) === 'string' 
        ? (content !== undefined ? content : fileContent).substring(0, 100) + '...' 
        : 'not a string'
    });
    
    // Check if filePath is valid
    if (!selectedFile || !selectedFile.path || selectedFile.path.trim() === '') {
      console.error('[DEBUG] handleSaveFileContent - No file selected');
      setErrorMessage('No file selected. Please select a file first.');
      setSaveStatus('error');
      return;
    }
    
    setSaveStatus('saving');
    
    // Use content parameter if provided, otherwise use state's fileContent
    const contentToSave = content !== undefined ? content : fileContent;
    
    console.log('[DEBUG] Sending to API:', {
      path: selectedFile.path,
      contentType: typeof contentToSave,
      contentLength: contentToSave?.length || 0
    });
    
    const result = await apiSaveFileContent(selectedFile.path, contentToSave);
    
    if (result.error) {
      console.error('[DEBUG] API Save Error:', result.error);
      setErrorMessage(result.error);
      setSaveStatus('error');
    } else {
      console.log('[DEBUG] API Save Success:', result);
      setErrorMessage('');
      setSaveStatus('saved');
      
      // If content parameter was provided, update the state's fileContent
      if (content !== undefined) {
        setFileContent(content);
      }
    }
  };
  
  // Toggle folder expansion
  const toggleFolder = (folderPath, folder) => {
    const isExpanding = !expandedFolders[folderPath];
    
    setExpandedFolders(prev => ({
      ...prev,
      [folderPath]: isExpanding
    }));
    
    // If we're expanding the folder, also set it as the current path
    if (isExpanding) {
      setCurrentPath(folderPath);
      setSelectedFile(folder);
    }
  };
  
  // Create a new file or folder
  const createNewItem = async () => {
    if (!newItemName.trim()) {
      setErrorMessage('Name cannot be empty');
      return;
    }
    
    setIsCreating(true);
    setErrorMessage('');
    
    // Get the active folder path where the new item should be created
    const activeFolderPath = getActiveFolderPath(selectedFile, currentPath);
    
    const result = await apiCreateNewItem(activeTab, activeFolderPath, newItemName, createType);
    
    if (result.error) {
      setErrorMessage(result.error);
    } else {
      // Close the dialog and reset the form
      setShowCreateDialog(false);
      setNewItemName('');
      
      // Refresh the entire file tree from the root
      if (activeTab === 'public') {
        handleFetchPublicDirectoryContents('/', true);
      } else {
        handleFetchDirectoryContents('/', true);
      }
      
      // If it's a directory, expand it
      if (createType === 'directory' && result.path) {
        setExpandedFolders(prev => ({
          ...prev,
          [result.path]: true
        }));
      }
    }
    
    setIsCreating(false);
  };
  
  // Open the create dialog
  const openCreateDialog = (type) => {
    setCreateType(type);
    setNewItemName('');
    setErrorMessage('');
    setShowCreateDialog(true);
  };
  
  // Close the create dialog
  const closeCreateDialog = () => {
    setShowCreateDialog(false);
    setNewItemName('');
    setErrorMessage('');
  };
  
  // Open the rename dialog
  const openRenameDialog = (item) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission) {
      setErrorMessage('Admin access required to rename files or file access permission for private files.');
      return;
    }
    
    setItemToRename(item);
    setNewName(item.name);
    setErrorMessage('');
    setShowRenameDialog(true);
  };
  
  // Close the rename dialog
  const closeRenameDialog = () => {
    setShowRenameDialog(false);
    setItemToRename(null);
    setNewName('');
    setErrorMessage('');
  };
  
  // Rename a file or folder
  const renameItem = async () => {
    if (!newName.trim()) {
      setErrorMessage('Name cannot be empty');
      return;
    }
    
    if (!itemToRename) {
      setErrorMessage('No item selected for renaming');
      return;
    }
    
    setIsRenaming(true);
    setErrorMessage('');
    
    const result = await apiRenameItem(itemToRename.path, newName);
    
    if (result.error) {
      setErrorMessage(result.error);
    } else {
      // Close the dialog and reset the form
      setShowRenameDialog(false);
      setItemToRename(null);
      setNewName('');
      
      // If the renamed item was selected, update the selected file
      if (selectedFile && selectedFile.path === itemToRename.path) {
        setSelectedFile(null);
      }
      
      // Refresh the appropriate file list
      if (itemToRename.isPublic) {
        handleFetchPublicDirectoryContents('/', true);
      } else {
        handleFetchDirectoryContents('/', true);
      }
    }
    
    setIsRenaming(false);
  };
  
  // Open the delete dialog
  const openDeleteDialog = (item) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission) {
      setErrorMessage('Admin access required to delete files or file access permission for private files.');
      return;
    }
    
    setItemToDelete(item);
    setErrorMessage('');
    setShowDeleteDialog(true);
  };
  
  // Close the delete dialog
  const closeDeleteDialog = () => {
    setShowDeleteDialog(false);
    setItemToDelete(null);
    setErrorMessage('');
  };
  
  // Delete a file or folder
  const handleDeleteItem = async () => {
    if (!itemToDelete) {
      setErrorMessage('No item selected for deletion');
      return;
    }
    
    setIsDeleting(true);
    setErrorMessage('');
    
    const result = await apiDeleteItem(itemToDelete.path);
    
    if (result.error) {
      setErrorMessage(result.error);
    } else {
      // Close the dialog
      setShowDeleteDialog(false);
      setItemToDelete(null);
      
      // If the deleted item was selected, clear the selection
      if (selectedFile && selectedFile.path === itemToDelete.path) {
        setSelectedFile(null);
        setFileContent('');
        setShowPreview(false);
        if (editMode) {
          setEditMode(false);
        }
      }
      
      // Refresh the appropriate file list
      if (itemToDelete.isPublic) {
        handleFetchPublicDirectoryContents('/', true);
      } else {
        handleFetchDirectoryContents('/', true);
      }
    }
    
    setIsDeleting(false);
  };
  
  // Handle drag start event
  const handleDragStart = (e, item) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission) return;
    
    setDraggedItem(item);
    e.dataTransfer.setData('text/plain', item.path);
    e.dataTransfer.effectAllowed = 'move';
    
    // Add dragging class to the element
    e.currentTarget.classList.add('dragging');
    
    // Remove the class after a short delay to ensure it's applied
    setTimeout(() => {
      if (e.currentTarget) {
        e.currentTarget.classList.remove('dragging');
      }
    }, 100);
  };
  
  // Handle drag over event
  const handleDragOver = (e, folder) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission || !draggedItem) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    // Only allow dropping into directories
    if (folder.type === 'directory') {
      setDropTarget(folder);
      e.dataTransfer.dropEffect = 'move';
      
      // Add drop-target class to the element
      e.currentTarget.classList.add('drop-target');
    }
  };
  
  // Handle drag over for the file tree container (to allow dropping to root)
  const handleContainerDragOver = (e) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission || !draggedItem) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    // Set root as the drop target
    const rootFolder = {
      type: 'directory',
      path: draggedItem.isPublic ? '/public' : '/',
      name: 'Root'
    };
    setDropTarget(rootFolder);
    e.dataTransfer.dropEffect = 'move';
  };
  
  // Handle drag leave event
  const handleDragLeave = (e) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission) return;
    
    e.preventDefault();
    e.stopPropagation();
    setDropTarget(null);
    
    // Remove drop-target class from the element
    e.currentTarget.classList.remove('drop-target');
  };
  
  // Handle drag leave for the container
  const handleContainerDragLeave = (e) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission) return;
    
    e.preventDefault();
    e.stopPropagation();
    setDropTarget(null);
  };
  
  // Handle drop event
  const handleDrop = async (e, targetFolder) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission || !draggedItem || !targetFolder) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    // Reset drop target
    setDropTarget(null);
    
    // Remove drop-target class from the element
    e.currentTarget.classList.remove('drop-target');
    
    // Only allow dropping into directories
    if (targetFolder.type !== 'directory') {
      return;
    }
    
    // Check if dropping on itself
    if (draggedItem.path === targetFolder.path) {
      return;
    }
    
    // Check if dropping in current location (parent folder is the same)
    const draggedParent = getParentDirectoryPath(draggedItem.path);
    if (draggedParent === targetFolder.path) {
      return;
    }
    
    setIsMoving(true);
    setErrorMessage('');
    
    const result = await apiMoveItem(draggedItem.path, targetFolder.path);
    
    if (result.error) {
      setErrorMessage(result.error);
    } else {
      // If the moved item was selected, clear the selection
      if (selectedFile && selectedFile.path === draggedItem.path) {
        setSelectedFile(null);
        setFileContent('');
        setShowPreview(false);
        if (editMode) {
          setEditMode(false);
        }
      }
      
      // Refresh the appropriate file list
      if (draggedItem.isPublic) {
        handleFetchPublicDirectoryContents('/', true);
      } else {
        handleFetchDirectoryContents('/', true);
      }
    }
    
    // Clear drag state
    setDraggedItem(null);
    setIsMoving(false);
  };
  
  // Handle drop event for the container (moving to root)
  const handleContainerDrop = async (e) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission || !draggedItem || !dropTarget) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    // Process the drop using the dropTarget which was set in handleContainerDragOver
    const targetFolder = dropTarget;
    
    // Reset drop target
    setDropTarget(null);
    
    // Check if dropping in current location (parent folder is the same)
    const draggedParent = getParentDirectoryPath(draggedItem.path);
    if (draggedParent === targetFolder.path) {
      return;
    }
    
    setIsMoving(true);
    setErrorMessage('');
    
    const result = await apiMoveItem(draggedItem.path, targetFolder.path);
    
    if (result.error) {
      setErrorMessage(result.error);
    } else {
      // If the moved item was selected, clear the selection
      if (selectedFile && selectedFile.path === draggedItem.path) {
        setSelectedFile(null);
        setFileContent('');
        setShowPreview(false);
        if (editMode) {
          setEditMode(false);
        }
      }
      
      // Refresh the appropriate file list
      if (draggedItem.isPublic) {
        handleFetchPublicDirectoryContents('/', true);
      } else {
        handleFetchDirectoryContents('/', true);
      }
    }
    
    // Clear drag state
    setDraggedItem(null);
    setIsMoving(false);
  };
  
  // Handle folder selection
  const handleFolderSelect = (folder) => {
    // Update the current path to the selected folder's path
    setCurrentPath(folder.path);
    
    // Set the selected folder
    setSelectedFile(folder);
    
    // Expand the folder
    setExpandedFolders(prev => ({
      ...prev,
      [folder.path]: true
    }));
    
    // Reset content and preview
    setFileContent('');
    setShowPreview(false);
    
    // Reset edit mode
    if (editMode) {
      setEditMode(false);
    }
  };
  
  // Handle file selection
  const handleFileSelect = (file, skipTabSwitch = false) => {
    // Check if this selection should change the active tab, but skip when restoring files
    if (!skipTabSwitch) {
      if (file.setTab) {
        setActiveTab(file.setTab);
      } else if (file.isPublic !== undefined) {
        // Update active tab based on file's isPublic property
        setActiveTab(file.isPublic ? 'public' : 'private');
      }
    }

    // If it's a directory, handle it differently
    if (file.type === 'directory') {
      handleFolderSelect(file);
      return;
    }
    
    setSelectedFile(file);
    
    // Make sure parent folders are expanded so the file is visible on reload
    setExpandedFolders(prev => expandParentFolders(file.path, prev));
    
    // Set current path to the parent directory for better context
    const parentPath = getParentDirectoryPath(file.path);
    setCurrentPath(parentPath);
    
    // Reset edit mode when selecting a new file
    if (editMode) {
      setEditMode(false);
    }
    
    // Fetch content for all file types
    if (file.isPublic) {
      // Fetch public file content
      handleFetchPublicFileContent(file.path);
    } else {
      // Fetch private file content (admin only)
      handleFetchFileContent(file.path);
    }
    
    // Only set preview mode for markdown files
    if (file.name.endsWith('.md')) {
      setShowPreview(true);
    } else {
      setShowPreview(false);
    }
  };
  
  // Toggle edit mode
  const toggleEditMode = () => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission) {
      setErrorMessage('Admin access required to edit files or file access permission for private files.');
      return;
    }
    
    if (!selectedFile || !selectedFile.name.endsWith('.md')) {
      setErrorMessage('Only markdown files can be edited.');
      return;
    }
    
    setEditMode(!editMode);
    // When switching to preview mode, ensure preview is shown
    if (editMode) {
      setShowPreview(true);
    }
  };
  
  // Handle markdown content change
  const handleMarkdownChange = (e) => {
    setFileContent(e.target.value);
  };
  
  // Handle commands (for the command input)
  const handleCommand = (cmd) => {
    // Commands:
    // - refresh: refresh file list
    // - preview: toggle markdown preview
    // - edit: toggle edit mode (users with permission)
    // - save: manually save the current file
    // - new-file: create a new file (users with permission)
    // - new-folder: create a new folder (users with permission)
    // - rename: rename selected file or folder (users with permission)
    // - delete: delete selected file or folder (users with permission)
    // - public: switch to public files tab
    // - private: switch to private files tab (users with permission)
    
    // Check permission for file operations
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    const canAccessPrivate = isAdmin || user?.has_file_access;
    
    if (cmd === 'refresh') {
      if (activeTab === 'public') {
        handleFetchPublicDirectoryContents('/', true);
      } else {
        handleFetchDirectoryContents('/', true);
      }
    } else if (cmd === 'preview' && selectedFile?.name.endsWith('.md')) {
      setShowPreview(!showPreview);
      if (editMode) {
        setEditMode(false);
      }
    } else if (cmd === 'edit' && selectedFile?.name.endsWith('.md')) {
      toggleEditMode();
    } else if (cmd === 'save' && editMode && selectedFile?.name.endsWith('.md')) {
      handleSaveFileContent();
    } else if (cmd === 'new-file' && hasEditPermission) {
      openCreateDialog('file');
    } else if (cmd === 'new-folder' && hasEditPermission) {
      openCreateDialog('directory');
    } else if (cmd === 'rename' && selectedFile && hasEditPermission) {
      openRenameDialog(selectedFile);
    } else if (cmd === 'delete' && selectedFile && hasEditPermission) {
      openDeleteDialog(selectedFile);
    } else if (cmd === 'public') {
      setActiveTab('public');
    } else if (cmd === 'private' && canAccessPrivate) {
      setActiveTab('private');
    } else {
      setErrorMessage(`Unknown command: ${cmd}`);
    }
  };

  // Handle file or folder export/download
  const handleExportFile = async () => {
    if (!selectedFile) {
      setErrorMessage('No file or folder selected');
      return;
    }
    
    try {
      // If it's a directory, create a zip file
      if (selectedFile.type === 'directory') {
        // Import JSZip dynamically 
        const JSZip = (await import('jszip')).default;
        const zip = new JSZip();
        
        setErrorMessage('Creating zip file...');
        
        // Function to recursively gather files from a folder
        const addFolderToZip = async (folderPath, zipFolder) => {
          // Determine which API to use based on whether the folder is public or private
          const fetchApi = selectedFile.isPublic ? fetchPublicDirectoryContents : fetchDirectoryContents;
          
          // Fetch directory contents
          const result = await fetchApi(folderPath, false);
          
          if (result.error) {
            throw new Error(`Failed to access folder: ${result.error}`);
          }
          
          // Process each item in the folder
          for (const item of result.files) {
            if (item.type === 'directory') {
              // Create a subfolder in the zip and process recursively
              const newFolder = zipFolder.folder(item.name);
              await addFolderToZip(item.path, newFolder);
            } else {
              // Fetch file content
              const contentApi = selectedFile.isPublic ? fetchPublicFileContent : fetchFileContent;
              const contentResult = await contentApi(item.path);
              
              if (contentResult.error) {
                console.error(`Error loading file content for ${item.path}: ${contentResult.error}`);
                continue;
              }
              
              // Add file to zip
              zipFolder.file(item.name, contentResult.content);
            }
          }
        };
        
        // Start the recursive process from the selected folder
        await addFolderToZip(selectedFile.path, zip);
        
        // Generate the zip file
        const content = await zip.generateAsync({type: 'blob'});
        
        // Create a filename for the zip file (folder name + .zip)
        const zipFileName = `${selectedFile.name}.zip`;
        
        // Create a temporary URL for the blob
        const url = URL.createObjectURL(content);
        
        // Create a temporary anchor element to trigger the download
        const a = document.createElement('a');
        a.href = url;
        a.download = zipFileName;
        
        // Append the anchor to the document, click it, and remove it
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        // Clean up by revoking the object URL
        URL.revokeObjectURL(url);
        
        // Clear the export message
        setErrorMessage('');
      } else {
        // For single file export, keep existing behavior
        if (!fileContent) {
          setErrorMessage('File has no content');
          return;
        }
        
        // Create a blob with the file content
        const blob = new Blob([fileContent], { type: 'text/plain' });
        
        // Create a temporary URL for the blob
        const url = URL.createObjectURL(blob);
        
        // Create a temporary anchor element to trigger the download
        const a = document.createElement('a');
        a.href = url;
        a.download = selectedFile.name;
        
        // Append the anchor to the document, click it, and remove it
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        // Clean up by revoking the object URL
        URL.revokeObjectURL(url);
      }
    } catch (error) {
      console.error('Error exporting:', error);
      setErrorMessage(`Failed to export: ${error.message}`);
    }
  };
  
  return {
    files,
    publicFiles,
    currentPath,
    selectedFile,
    expandedFolders,
    isTreeLoading,
    isContentLoading,
    fileContent,
    errorMessage,
    showPreview,
    activeTab,
    editMode,
    saveStatus,
    showCreateDialog,
    createType, 
    newItemName,
    isCreating,
    showRenameDialog,
    itemToRename,
    newName,
    isRenaming,
    showDeleteDialog,
    itemToDelete,
    isDeleting,
    draggedItem,
    dropTarget,
    isMoving,
    converter,
    isAdmin,
    storageStats,
    fetchStorageStats,
    handleFetchPublicDirectoryContents,
    handleFetchDirectoryContents,
    handleSaveFileContent,
    handleExportFile,
    toggleFolder,
    createNewItem,
    openCreateDialog,
    closeCreateDialog,
    openRenameDialog,
    closeRenameDialog,
    renameItem,
    openDeleteDialog,
    closeDeleteDialog,
    handleDeleteItem,
    handleDragStart,
    handleDragOver,
    handleContainerDragOver,
    handleDragLeave,
    handleContainerDragLeave,
    handleDrop,
    handleContainerDrop,
    handleFileSelect,
    toggleEditMode,
    handleMarkdownChange,
    handleCommand,
    setNewItemName,
    setNewName,
    setErrorMessage,
    setFileContent,
    setSelectedFile
  };
};

export default useExplorerState;

================
File: windows/explorer/utils/canvasUtils.js
================
/**
 * Utility functions for the canvas editor
 */

/**
 * Generate a unique ID for a node or edge
 * @param {string} prefix - Prefix for the ID (e.g., 'node' or 'edge')
 * @returns {string} Unique ID
 */
export const generateId = (prefix = 'node') => {
  return `${prefix}-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
};

/**
 * Calculate the distance between two points
 * @param {Object} point1 - First point {x, y}
 * @param {Object} point2 - Second point {x, y}
 * @returns {number} Distance
 */
export const distance = (point1, point2) => {
  return Math.sqrt(
    Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2)
  );
};

/**
 * Check if a point is inside a node
 * @param {Object} point - Point to check {x, y}
 * @param {Object} node - Node {x, y, width, height}
 * @returns {boolean} True if point is inside node
 */
export const isPointInNode = (point, node) => {
  return (
    point.x >= node.x &&
    point.x <= node.x + node.width &&
    point.y >= node.y &&
    point.y <= node.y + node.height
  );
};

/**
 * Get connection points for edges based on the fromSide and toSide
 * @param {Object} fromNode - Source node {x, y, width, height}
 * @param {Object} toNode - Target node {x, y, width, height}
 * @param {string} fromSide - Side of source node to connect from ('top', 'right', 'bottom', 'left')
 * @param {string} toSide - Side of target node to connect to ('top', 'right', 'bottom', 'left')
 * @returns {Object} Connection points {source: {x, y}, target: {x, y}}
 */
export const getConnectionPoints = (fromNode, toNode, fromSide = 'right', toSide = 'left') => {
  const source = { x: 0, y: 0 };
  const target = { x: 0, y: 0 };

  // Source node connection point
  switch (fromSide) {
    case 'top':
      source.x = fromNode.x + fromNode.width / 2;
      source.y = fromNode.y;
      break;
    case 'right':
      source.x = fromNode.x + fromNode.width;
      source.y = fromNode.y + fromNode.height / 2;
      break;
    case 'bottom':
      source.x = fromNode.x + fromNode.width / 2;
      source.y = fromNode.y + fromNode.height;
      break;
    case 'left':
      source.x = fromNode.x;
      source.y = fromNode.y + fromNode.height / 2;
      break;
    default:
      source.x = fromNode.x + fromNode.width;
      source.y = fromNode.y + fromNode.height / 2;
  }

  // Target node connection point
  switch (toSide) {
    case 'top':
      target.x = toNode.x + toNode.width / 2;
      target.y = toNode.y;
      break;
    case 'right':
      target.x = toNode.x + toNode.width;
      target.y = toNode.y + toNode.height / 2;
      break;
    case 'bottom':
      target.x = toNode.x + toNode.width / 2;
      target.y = toNode.y + toNode.height;
      break;
    case 'left':
      target.x = toNode.x;
      target.y = toNode.y + toNode.height / 2;
      break;
    default:
      target.x = toNode.x;
      target.y = toNode.y + toNode.height / 2;
  }

  return { source, target };
};

/**
 * Calculate the best connection sides for two nodes
 * @param {Object} fromNode - Source node {x, y, width, height}
 * @param {Object} toNode - Target node {x, y, width, height}
 * @returns {Object} Best sides {fromSide, toSide}
 */
export const calculateBestConnectionSides = (fromNode, toNode) => {
  // Calculate center points
  const fromCenter = {
    x: fromNode.x + fromNode.width / 2,
    y: fromNode.y + fromNode.height / 2
  };
  const toCenter = {
    x: toNode.x + toNode.width / 2,
    y: toNode.y + toNode.height / 2
  };

  // Calculate angle between centers
  const angle = Math.atan2(toCenter.y - fromCenter.y, toCenter.x - fromCenter.x);
  
  // Convert angle to degrees
  const degrees = (angle * 180) / Math.PI;
  
  // Determine from side based on angle
  let fromSide;
  if (degrees >= -45 && degrees < 45) {
    fromSide = 'right';
  } else if (degrees >= 45 && degrees < 135) {
    fromSide = 'bottom';
  } else if (degrees >= 135 || degrees < -135) {
    fromSide = 'left';
  } else {
    fromSide = 'top';
  }
  
  // Calculate opposite side for target
  let toSide;
  switch (fromSide) {
    case 'right': toSide = 'left'; break;
    case 'bottom': toSide = 'top'; break;
    case 'left': toSide = 'right'; break;
    case 'top': toSide = 'bottom'; break;
    default: toSide = 'left';
  }
  
  return { fromSide, toSide };
};

/**
 * Draw an arrow at the end of a line
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {number} x - X coordinate of arrow tip
 * @param {number} y - Y coordinate of arrow tip
 * @param {number} angle - Angle of the line in radians
 * @param {number} size - Size of the arrow
 */
export const drawArrow = (ctx, x, y, angle, size = 10) => {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(-size, -size / 2);
  ctx.lineTo(-size, size / 2);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
};

/**
 * Draw a connection line between two points with optional arrow
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {Object} source - Source point {x, y}
 * @param {Object} target - Target point {x, y}
 * @param {string} color - Line color
 * @param {boolean} showSourceArrow - Whether to show an arrow at the source
 * @param {boolean} showTargetArrow - Whether to show an arrow at the target
 */
export const drawConnection = (ctx, source, target, color = '#14b8a6', showSourceArrow = false, showTargetArrow = true) => {
  const angle = Math.atan2(target.y - source.y, target.x - source.x);
  
  // Draw line
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(source.x, source.y);
  ctx.lineTo(target.x, target.y);
  ctx.stroke();
  
  // Draw arrows
  ctx.fillStyle = color;
  if (showSourceArrow) {
    drawArrow(ctx, source.x, source.y, angle + Math.PI);
  }
  if (showTargetArrow) {
    drawArrow(ctx, target.x, target.y, angle);
  }
};

/**
 * Convert a canvas color code to an actual color
 * @param {string} colorCode - Color code (e.g., '1', '2', '#FF0000')
 * @returns {string} CSS color value
 */
export const getCanvasColor = (colorCode) => {
  // Map of preset colors
  const colorMap = {
    '1': '#ef4444', // red
    '2': '#f97316', // orange
    '3': '#eab308', // yellow
    '4': '#22c55e', // green
    '5': '#06b6d4', // cyan
    '6': '#a855f7'  // purple
  };
  
  // If colorCode is a preset, return the mapped color
  if (colorMap[colorCode]) {
    return colorMap[colorCode];
  }
  
  // Otherwise, return the color code as is (assuming it's a valid CSS color)
  return colorCode || '#14b8a6'; // Default to teal if no color provided
};

/**
 * Create a new empty canvas with the JSONCanvas format
 * @returns {Object} Empty canvas data
 */
export const createEmptyCanvas = () => {
  return {
    nodes: [],
    edges: []
  };
};

/**
 * Create a new text node with default properties
 * @param {number} x - X position
 * @param {number} y - Y position
 * @param {string} text - Node text content
 * @returns {Object} New text node
 */
export const createTextNode = (x, y, text = 'New note') => {
  return {
    id: generateId('node'),
    type: 'text',
    x,
    y,
    width: 200,
    height: 100,
    text
  };
};

/**
 * Create a new edge connecting two nodes
 * @param {string} fromNode - ID of source node
 * @param {string} toNode - ID of target node
 * @param {string} fromSide - Side of source node ('top', 'right', 'bottom', 'left')
 * @param {string} toSide - Side of target node ('top', 'right', 'bottom', 'left')
 * @returns {Object} New edge
 */
export const createEdge = (fromNode, toNode, fromSide = 'right', toSide = 'left') => {
  return {
    id: generateId('edge'),
    fromNode,
    toNode,
    fromSide,
    toSide,
    fromEnd: 'none',
    toEnd: 'arrow'
  };
};

================
File: windows/explorer/utils/fileUtils.js
================
// List of available file types for autocomplete
export const AVAILABLE_FILE_TYPES = [
  'md',
  'canvas',
  'map'
];

// Helper function to get parent directory path from a file path
export const getParentDirectoryPath = (filePath) => {
  // Remove trailing slash if present
  const normalizedPath = filePath.endsWith('/') ? filePath.slice(0, -1) : filePath;
  // Find the last slash in the path
  const lastSlashIndex = normalizedPath.lastIndexOf('/');
  
  if (lastSlashIndex === -1) {
    // No slash found, return root
    return '/';
  }
  
  // Return everything up to the last slash
  return normalizedPath.substring(0, lastSlashIndex) || '/';
};

// Helper function to expand all parent folders of a path
export const expandParentFolders = (filePath, currentExpandedFolders) => {
  const parts = filePath.split('/').filter(Boolean);
  let currentPath = '';
  
  // Create a new expanded folders object
  const newExpandedFolders = { ...currentExpandedFolders };
  
  // Expand each parent folder
  for (let i = 0; i < parts.length; i++) {
    currentPath += '/' + parts[i];
    newExpandedFolders[currentPath] = true;
  }
  
  return newExpandedFolders;
};

// Get file icon based on file extension
export const getFileIconName = (fileName) => {
  if (fileName.endsWith('.md')) return 'FileText';
  if (fileName.endsWith('.jsx') || fileName.endsWith('.js')) return 'Code';
  if (fileName.endsWith('.json')) return 'Coffee';
  if (fileName.endsWith('.css')) return 'BookOpen';
  if (fileName.endsWith('.html')) return 'Globe';
  if (fileName.endsWith('.svg') || fileName.endsWith('.png') || fileName.endsWith('.jpg') || fileName.endsWith('.jpeg') || fileName.endsWith('.gif')) return 'Image';
  if (fileName.endsWith('.mp3') || fileName.endsWith('.wav') || fileName.endsWith('.ogg')) return 'Music';
  if (fileName.endsWith('.canvas')) return 'Figma';
  if (fileName.endsWith('.map')) return 'Map';
  return 'File';
};

// Helper function to get the active folder path based on selected item and current path
export const getActiveFolderPath = (selectedFile, currentPath) => {
  if (selectedFile) {
    // If selected item is a directory, use its path
    if (selectedFile.type === 'directory') {
      return selectedFile.path;
    }
    // If selected item is a file, use its parent directory
    return getParentDirectoryPath(selectedFile.path);
  }
  // Fall back to current path if no file is selected
  return currentPath;
};

================
File: windows/explorer/utils/markdownUtils.js
================
import showdown from 'showdown';

// Initialize Showdown converter for Markdown with enhanced options
export const createMarkdownConverter = () => {
  const converter = new showdown.Converter({
    tables: true,
    tasklists: true,
    strikethrough: true,
    emoji: true,
    breaks: true,  // Enable line breaks to be rendered as <br> tags
    simpleLineBreaks: true,
    openLinksInNewWindow: true,
    backslashEscapesHTMLTags: true,
    ghCodeBlocks: true,
    ghCompatibleHeaderId: true,
    ghMentions: true,
    smoothLivePreview: true
  });
  
  // Enable additional extensions
  converter.setFlavor('github');
  
  return converter;
};

// Insert markdown syntax at cursor position
export const insertMarkdown = (textareaRef, fileContent, setFileContent, prefix, suffix = '') => {
  const textarea = textareaRef.current;
  if (!textarea) return;
  
  const start = textarea.selectionStart;
  const end = textarea.selectionEnd;
  const text = fileContent;
  
  // If text is selected, wrap it with prefix and suffix
  if (start !== end) {
    const selectedText = text.substring(start, end);
    const newContent = text.substring(0, start) + prefix + selectedText + suffix + text.substring(end);
    setFileContent(newContent);
    
    // Set cursor position after the inserted text
    setTimeout(() => {
      textarea.selectionStart = start + prefix.length;
      textarea.selectionEnd = end + prefix.length;
      textarea.focus();
    }, 0);
  } else {
    // No selection, just insert at cursor
    const newContent = text.substring(0, start) + prefix + suffix + text.substring(start);
    setFileContent(newContent);
    
    // Move cursor between prefix and suffix
    setTimeout(() => {
      textarea.selectionStart = textarea.selectionEnd = start + prefix.length;
      textarea.focus();
    }, 0);
  }
};

// Insert list items
export const insertList = (textareaRef, fileContent, setFileContent, listPrefix) => {
  const textarea = textareaRef.current;
  if (!textarea) return;
  
  const start = textarea.selectionStart;
  const end = textarea.selectionEnd;
  const text = fileContent;
  
  // If text is selected, apply list formatting to each line
  if (start !== end) {
    const selectedText = text.substring(start, end);
    const lines = selectedText.split('\n');
    
    // Format each line as a list item
    const formattedLines = lines.map(line => {
      // Skip empty lines
      if (line.trim() === '') return line;
      
      // For numbered lists, increment the number for each line
      if (listPrefix === '1. ') {
        const index = lines.indexOf(line) + 1;
        return `${index}. ${line}`;
      }
      
      return `${listPrefix}${line}`;
    });
    
    const newContent = text.substring(0, start) + formattedLines.join('\n') + text.substring(end);
    setFileContent(newContent);
    
    // Set cursor position after the inserted text
    setTimeout(() => {
      textarea.selectionStart = start;
      textarea.selectionEnd = start + formattedLines.join('\n').length;
      textarea.focus();
    }, 0);
  } else {
    // No selection, just insert at cursor
    const newContent = text.substring(0, start) + listPrefix + text.substring(start);
    setFileContent(newContent);
    
    // Move cursor after the inserted prefix
    setTimeout(() => {
      textarea.selectionStart = textarea.selectionEnd = start + listPrefix.length;
      textarea.focus();
    }, 0);
  }
};

// Get the current line of text at cursor position
export const getCurrentLine = (text, cursorPos) => {
  const textBeforeCursor = text.substring(0, cursorPos);
  const lineStartPos = textBeforeCursor.lastIndexOf('\n') + 1;
  const lineEndPos = text.indexOf('\n', cursorPos);
  const actualLineEndPos = lineEndPos !== -1 ? lineEndPos : text.length;
  return text.substring(lineStartPos, actualLineEndPos);
};

// Handle keyboard events in the editor
export const handleEditorKeyDown = (e, textareaRef, fileContent, setFileContent) => {
  // Handle keyboard shortcuts
  if (e.ctrlKey || e.metaKey) {
    // Ctrl+B or Cmd+B for bold
    if (e.key === 'b') {
      e.preventDefault();
      insertMarkdown(textareaRef, fileContent, setFileContent, '**', '**');
      return;
    }
    
    // Ctrl+I or Cmd+I for italic
    if (e.key === 'i') {
      e.preventDefault();
      insertMarkdown(textareaRef, fileContent, setFileContent, '*', '*');
      return;
    }
    
    // Ctrl+Shift+L for unordered list
    if (e.shiftKey && e.key === 'L') {
      e.preventDefault();
      insertList(textareaRef, fileContent, setFileContent, '- ');
      return;
    }
    
    // Ctrl+Shift+O for ordered list
    if (e.shiftKey && e.key === 'O') {
      e.preventDefault();
      insertList(textareaRef, fileContent, setFileContent, '1. ');
      return;
    }
    
    // Ctrl+Shift+C for checklist
    if (e.shiftKey && e.key === 'C') {
      e.preventDefault();
      insertList(textareaRef, fileContent, setFileContent, '- [ ] ');
      return;
    }
  }
  
  // Auto-continue lists on Enter
  if (e.key === 'Enter' && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
    const textarea = textareaRef.current;
    if (!textarea) return;
    
    const cursorPos = textarea.selectionStart;
    const text = fileContent;
    const currentLine = getCurrentLine(text, cursorPos);
    
    // Check for list patterns
    const bulletListMatch = currentLine.match(/^(\s*)(-|\*|\+)\s+(.*)/);
    const numberedListMatch = currentLine.match(/^(\s*)(\d+)\.?\s+(.*)/);
    const checklistMatch = currentLine.match(/^(\s*)(-|\*|\+)\s+\[([ xX])\]\s+(.*)/);
    
    if (bulletListMatch || numberedListMatch || checklistMatch) {
      // Get the indentation and list marker
      let indentation, marker, content;
      
      if (checklistMatch) {
        indentation = checklistMatch[1];
        marker = checklistMatch[2];
        const checkState = checklistMatch[3];
        content = checklistMatch[4];
        
        // If the checklist item is empty, remove the list marker
        if (content.trim() === '') {
          e.preventDefault();
          const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
          const newContent = text.substring(0, lineStart) + text.substring(cursorPos);
          setFileContent(newContent);
          setTimeout(() => {
            textarea.selectionStart = textarea.selectionEnd = lineStart;
            textarea.focus();
          }, 0);
          return;
        }
        
        // Continue the checklist with an unchecked box
        e.preventDefault();
        const newListItem = `\n${indentation}${marker} [ ] `;
        insertMarkdown(textareaRef, fileContent, setFileContent, newListItem);
        return;
      } else if (bulletListMatch) {
        indentation = bulletListMatch[1];
        marker = bulletListMatch[2];
        content = bulletListMatch[3];
        
        // If the list item is empty, remove the list marker
        if (content.trim() === '') {
          e.preventDefault();
          const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
          const newContent = text.substring(0, lineStart) + text.substring(cursorPos);
          setFileContent(newContent);
          setTimeout(() => {
            textarea.selectionStart = textarea.selectionEnd = lineStart;
            textarea.focus();
          }, 0);
          return;
        }
        
        // Continue the bullet list
        e.preventDefault();
        const newListItem = `\n${indentation}${marker} `;
        insertMarkdown(textareaRef, fileContent, setFileContent, newListItem);
        return;
      } else if (numberedListMatch) {
        indentation = numberedListMatch[1];
        const number = parseInt(numberedListMatch[2], 10);
        content = numberedListMatch[3];
        
        // If the list item is empty, remove the list marker
        if (content.trim() === '') {
          e.preventDefault();
          const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
          const newContent = text.substring(0, lineStart) + text.substring(cursorPos);
          setFileContent(newContent);
          setTimeout(() => {
            textarea.selectionStart = textarea.selectionEnd = lineStart;
            textarea.focus();
          }, 0);
          return;
        }
        
        // Continue the numbered list with incremented number
        e.preventDefault();
        const newListItem = `\n${indentation}${number + 1}. `;
        insertMarkdown(textareaRef, fileContent, setFileContent, newListItem);
        return;
      }
    }
  }
  
  // Handle tab for indentation in lists
  if (e.key === 'Tab') {
    const textarea = textareaRef.current;
    if (!textarea) return;
    
    const cursorPos = textarea.selectionStart;
    const text = fileContent;
    const currentLine = getCurrentLine(text, cursorPos);
    
    // Check if we're in a list item
    const listMatch = currentLine.match(/^(\s*)(-|\*|\+|\d+\.|\[[ xX]\])\s+/);
    if (listMatch) {
      e.preventDefault();
      
      // Add or remove indentation based on shift key
      if (e.shiftKey) {
        // Outdent: remove 2 spaces from the beginning if they exist
        if (currentLine.startsWith('  ')) {
          const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
          const lineEnd = text.indexOf('\n', cursorPos);
          const actualLineEnd = lineEnd !== -1 ? lineEnd : text.length;
          
          const newContent = text.substring(0, lineStart) + currentLine.substring(2) + text.substring(actualLineEnd);
          setFileContent(newContent);
          
          // Adjust cursor position
          const newCursorPos = cursorPos - 2;
          setTimeout(() => {
            textarea.selectionStart = textarea.selectionEnd = newCursorPos > lineStart ? newCursorPos : lineStart;
            textarea.focus();
          }, 0);
        }
      } else {
        // Indent: add 2 spaces at the beginning
        const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
        const lineEnd = text.indexOf('\n', cursorPos);
        const actualLineEnd = lineEnd !== -1 ? lineEnd : text.length;
        
        const newContent = text.substring(0, lineStart) + '  ' + currentLine + text.substring(actualLineEnd);
        setFileContent(newContent);
        
        // Adjust cursor position
        const newCursorPos = cursorPos + 2;
        setTimeout(() => {
          textarea.selectionStart = textarea.selectionEnd = newCursorPos;
          textarea.focus();
        }, 0);
      }
    }
  }
};

// Convert markdown to HTML
export const convertMarkdownToHtml = (converter, markdown) => {
  return converter.makeHtml(markdown);
};

================
File: windows/ExplorerWindow-fix.jsx
================
// This is a patch file that contains only important modifications to fix the file persistence issue
// You should compare this with your existing ExplorerWindow.jsx and integrate these changes

// KEY CHANGES:

// 1. In handleFileSelect function, add this line AFTER setting the selected file:
/*
    // Make sure parent folders are expanded so the file is visible on reload
    expandParentFolders(file.path);
*/

// 2. In loadExplorerState function, when restoring a file, add this code to ensure proper path setting:
/*
    // Important: Update the currentPath to ensure parent directories are visible
    if (restoredFile.type === 'file') {
      // For files, set the current path to the parent directory
      const parentPath = getParentDirectoryPath(restoredFile.path);
      setCurrentPath(parentPath);
    } else {
      // For directories, set the current path to the directory itself
      setCurrentPath(restoredFile.path);
    }
*/

// 3. Add a debounce for explorer state saving by adding a new ref:
/*
    const explorerSaveTimeoutRef = useRef(null); // New ref for debounced explorer state saving
*/

// 4. Modify the useEffect that saves explorer state to add debounce:
/*
  // Save explorer state to IndexedDB when it changes
  useEffect(() => {
    // Early return if state hasn't been loaded yet (prevents overwriting with default values)
    if (!stateLoadedRef.current) return;
    
    // Clear any existing timeout
    if (explorerSaveTimeoutRef.current) {
      clearTimeout(explorerSaveTimeoutRef.current);
    }
    
    // Save the explorer state to IndexedDB with debounce
    explorerSaveTimeoutRef.current = setTimeout(() => {
      console.log(`Saving explorer state for window ${nodeId}:`, {
        selectedFile,
        expandedFolders,
        activeTab
      });
      
      saveExplorerState({
        id: nodeId,
        content: {
          selectedFile,
          expandedFolders,
          activeTab
        }
      }).catch(error => {
        console.error(`Failed to save explorer state for window ${nodeId} to IndexedDB:`, error);
      });
    }, 300); // 300ms debounce
    
    // Clear timeout on cleanup
    return () => {
      if (explorerSaveTimeoutRef.current) {
        clearTimeout(explorerSaveTimeoutRef.current);
      }
    };
  }, [selectedFile, expandedFolders, activeTab, nodeId]);
*/

// 5. Modify the initial directory loading code to ensure selected files have their parent folders expanded:
/*
  // Load initial directory contents
  useEffect(() => {
    // Load public files for all users
    fetchPublicDirectoryContents('/', true).then(() => {
      // After files are loaded, try to restore expanded state for the selected file
      if (selectedFile) {
        console.log('Ensuring parent folders for selected file are expanded:', selectedFile.path);
        expandParentFolders(selectedFile.path);
      }
    });
    
    // Load private files for admin users
    if (isAdmin) {
      fetchDirectoryContents('/', true).catch(error => {
        console.error('Failed to load private files:', error);
        // Set a specific error message for private files without affecting public files
        setFiles([]);
        if (activeTab === 'private') {
          setErrorMessage('Failed to load private files. Please ensure your admin directory exists.');
        }
      });
    }
  }, [isAdmin, activeTab]);
*/

// 6. Always set stateLoaded to true in loadExplorerState even if no state is found:
/*
  if (savedState && savedState.content) {
    // ... existing code ...
  } else {
    // Even if no state is loaded, mark as loaded to allow future saves
    stateLoadedRef.current = true;
  }
*/

================
File: windows/ExplorerWindow.css
================
/* Markdown content styling */
.markdown-content {
    color: #f0f9ff; /* Light blue-white for readability */
    line-height: 1;
    font-family: 'Oxygen Mono', monospace;
    padding: 1rem;
    white-space: pre-wrap; /* Preserve line breaks */
  }

  /* Bold text styling */
  .markdown-content strong {
    font-weight: 700;
    color: #2dd4bf; /* Teal accent color to make bold text stand out */
  }
  
  /* Italic text styling */
  .markdown-content em {
    font-style: italic;
    color: #a5f3fc; /* Light cyan for emphasis */
  }
  
  /* Header styles with clear size differences */
  .markdown-content h1 {
    font-size: 2.5rem;
    font-weight: 700;
    margin-top: 1.5rem;
    margin-bottom: 1rem;
    color: #2dd4bf; /* Teal accent color */
    border-bottom: 1px solid #44403c;
    padding-bottom: 0.5rem;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content h2 {
    font-size: 2rem;
    font-weight: 600;
    margin-top: 1.5rem;
    margin-bottom: 0.75rem;
    color: #2dd4bf;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content h3 {
    font-size: 1.75rem;
    font-weight: 600;
    margin-top: 1.25rem;
    margin-bottom: 0.75rem;
    color: #2dd4bf;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content h4 {
    font-size: 1.5rem;
    font-weight: 600;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    color: #2dd4bf;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content h5 {
    font-size: 1.25rem;
    font-weight: 600;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    color: #2dd4bf;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content h6 {
    font-size: 1rem;
    font-weight: 600;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    color: #2dd4bf;
    font-family: 'Oxygen Mono', monospace;
  }
  
  /* Paragraph styling */
  .markdown-content p {
    margin-top: 0.5rem;
    margin-bottom: 0.5rem;
    font-family: 'Oxygen Mono', monospace;
  }
  
  /* Make sure the code blocks stand out */
  .markdown-content pre {
    background-color: #1c1917; /* Darker background for code */
    border-radius: 0.25rem;
    padding: 1rem;
    overflow-x: auto;
    margin: 1rem 0;
    font-family: 'Oxygen Mono', monospace;
    font-size: 0.875rem;
    line-height: 1;
  }
  
  .markdown-content code {
    font-family: 'Oxygen Mono', monospace;
    background-color: #1c1917;
    padding: 0.2rem 0.4rem;
    border-radius: 0.25rem;
    font-size: 0.875em;
  }
  
  /* Add some spacing between sections */
  .markdown-content br + h1,
  .markdown-content br + h2,
  .markdown-content br + h3,
  .markdown-content br + h4,
  .markdown-content br + h5,
  .markdown-content br + h6 {
    margin-top: 0.5rem;
  }
  
/* Lists */
.markdown-content ul, .markdown-content ol {
  margin-top: 0.5rem;
  margin-bottom: 1rem;
  padding-left: 2rem;
  font-family: 'Oxygen Mono', monospace;
  list-style-position: outside;
}

/* Bullet points */
.markdown-content ul {
  list-style-type: disc;
}

/* Numbered lists */
.markdown-content ol {
  list-style-type: decimal;
}

.markdown-content li {
  margin-top: 0.25rem;
  margin-bottom: 0.25rem;
  padding-left: 0.5rem;
  display: list-item;
}

/* Make sure list items are clearly visible */
.markdown-content ul > li::marker {
  color: #2dd4bf; /* Teal color for bullet points */
}

.markdown-content ol > li::marker {
  color: #2dd4bf; /* Teal color for numbers */
  font-weight: bold;
}

/* Task lists (checkboxes) */
.markdown-content .task-list {
  list-style-type: none;
  padding-left: 0.5rem;
}

.markdown-content .task-list-item {
  display: flex;
  align-items: flex-start;
  margin-bottom: 0.5rem;
}

.markdown-content .task-list-item-checkbox {
  margin-right: 0.5rem;
  margin-top: 0.25rem;
  appearance: none;
  -webkit-appearance: none;
  width: 1rem;
  height: 1rem;
  border: 1px solid #2dd4bf;
  border-radius: 0.25rem;
  background-color: #1c1917;
  cursor: pointer;
  position: relative;
}

.markdown-content .task-list-item-checkbox:checked {
  background-color: #2dd4bf;
}

.markdown-content .task-list-item-checkbox:checked::after {
  content: '✓';
  position: absolute;
  color: #1c1917;
  font-size: 0.75rem;
  top: -0.125rem;
  left: 0.125rem;
}

/* Alternative styling for checklists as rendered by Showdown */
.markdown-content ul li input[type="checkbox"] {
  margin-right: 0.5rem;
  margin-top: 0.25rem;
  appearance: none;
  -webkit-appearance: none;
  width: 1rem;
  height: 1rem;
  border: 1px solid #2dd4bf;
  border-radius: 0.25rem;
  background-color: #1c1917;
  cursor: pointer;
  position: relative;
  vertical-align: middle;
}

.markdown-content ul li input[type="checkbox"]:checked {
  background-color: #2dd4bf;
}

.markdown-content ul li input[type="checkbox"]:checked::after {
  content: '✓';
  position: absolute;
  color: #1c1917;
  font-size: 0.75rem;
  top: -0.125rem;
  left: 0.125rem;
}

/* Remove default bullets for checklist items */
.markdown-content ul li:has(input[type="checkbox"]) {
  list-style-type: none;
  margin-left: -1.5rem;
}

/* Specific styling for Showdown's task list output */
.markdown-content ul.contains-task-list {
  list-style-type: none;
  padding-left: 1rem;
}

.markdown-content ul.contains-task-list li.task-list-item {
  list-style-type: none;
  padding-left: 0;
  display: flex;
  align-items: center;
}

/* Nested lists */
.markdown-content ul ul,
.markdown-content ol ol,
.markdown-content ul ol,
.markdown-content ol ul {
  margin-top: 0.25rem;
  margin-bottom: 0.25rem;
}
  
  /* Links */
  .markdown-content a {
    color: #14b8a6;
    text-decoration: underline;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content a:hover {
    color: #2dd4bf;
  }

/* Drag and drop styles */
[draggable] {
  cursor: grab;
}

[draggable]:active {
  cursor: grabbing;
}

/* Style for the drop target when dragging over */
.drop-target {
  background-color: rgba(20, 184, 166, 0.2) !important;
  border: 2px dashed rgb(20, 184, 166) !important;
  border-radius: 0.25rem;
}

/* Style for the item being dragged */
.dragging {
  opacity: 0.5;
  background-color: rgba(20, 184, 166, 0.1);
}

================
File: windows/ExplorerWindow.jsx
================
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { 
  FolderOpen, FileText, ChevronRight, ChevronDown, File, Coffee, Code, 
  BookOpen, Edit, Eye, Plus, FolderPlus, X, Globe, Lock, FileEdit, Trash2,
  List, ListOrdered, CheckSquare, Bold, Italic, Code as CodeIcon, Link, Heading
} from 'lucide-react';
import showdown from 'showdown';
import path from 'path-browserify';
import API_CONFIG from '../../config/api';
import { useAuth } from '../../context/AuthContext';
import { useWindowState } from '../../context/WindowStateContext';
import { WINDOW_TYPES } from '../../utils/windowTypes';
import { saveExplorerState, getExplorerState } from '../../services/indexedDBService';
import './ExplorerWindow.css';

const ExplorerWindow = ({ isActive, nodeId, onCommand, transformWindow, windowState, updateWindowState, focusRef }) => {
  // Get auth context to check if user is admin
  const { user } = useAuth();
  const isAdmin = user?.is_admin || false;
  
  // Get window state context for additional persistence
  const { setActiveWindow } = useWindowState();
  
  // Ref to track if state has been loaded from IndexedDB
  const stateLoadedRef = useRef(false);
  
  // Use state from windowState or initialize with defaults
  const [files, setFiles] = useState([]);
  const [publicFiles, setPublicFiles] = useState([]);
  const [currentPath, setCurrentPath] = useState(windowState?.currentPath || '/');
  const [selectedFile, setSelectedFile] = useState(windowState?.selectedFile || null);
  const [expandedFolders, setExpandedFolders] = useState(windowState?.expandedFolders || {});
  const [isTreeLoading, setIsTreeLoading] = useState(true);
  const [isContentLoading, setIsContentLoading] = useState(false);
  const [fileContent, setFileContent] = useState(windowState?.fileContent || '');
  const [errorMessage, setErrorMessage] = useState('');
  const [showPreview, setShowPreview] = useState(windowState?.showPreview || false);
  const [activeTab, setActiveTab] = useState(windowState?.activeTab || 'public'); // 'public' or 'private'
  
  // Additional state for markdown editing
  const [editMode, setEditMode] = useState(windowState?.editMode || false);
  const [saveStatus, setSaveStatus] = useState('saved'); // 'saved', 'saving', 'error'
  
  // State for file/folder creation
  const [showCreateDialog, setShowCreateDialog] = useState(false);
  const [createType, setCreateType] = useState('file'); // 'file' or 'directory'
  const [newItemName, setNewItemName] = useState('');
  const [isCreating, setIsCreating] = useState(false);
  
  // State for file/folder renaming
  const [showRenameDialog, setShowRenameDialog] = useState(false);
  const [itemToRename, setItemToRename] = useState(null);
  const [newName, setNewName] = useState('');
  const [isRenaming, setIsRenaming] = useState(false);
  
  // State for file/folder deletion
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [itemToDelete, setItemToDelete] = useState(null);
  const [isDeleting, setIsDeleting] = useState(false);
  
  // State for drag and drop
  const [draggedItem, setDraggedItem] = useState(null);
  const [dropTarget, setDropTarget] = useState(null);
  const [isMoving, setIsMoving] = useState(false);
  
  // For auto-save functionality and editor references
  const saveTimeoutRef = useRef(null);
  const createInputRef = useRef(null);
  const renameInputRef = useRef(null);
  const textareaRef = useRef(null);
  
  // Initialize Showdown converter for Markdown with enhanced options
  const converter = new showdown.Converter({
    tables: true,
    tasklists: true,
    strikethrough: true,
    emoji: true,
    breaks: true,  // Enable line breaks to be rendered as <br> tags
    simpleLineBreaks: true,
    openLinksInNewWindow: true,
    backslashEscapesHTMLTags: true,
    ghCodeBlocks: true,
    ghCompatibleHeaderId: true,
    ghMentions: true,
    smoothLivePreview: true
  });
  
  // Enable additional extensions
  converter.setFlavor('github');

  // Helper function to expand all parent folders of a path
  const expandParentFolders = (filePath) => {
    const parts = filePath.split('/').filter(Boolean);
    let currentPath = '';
    
    // Create a new expanded folders object
    const newExpandedFolders = { ...expandedFolders };
    
    // Expand each parent folder
    for (let i = 0; i < parts.length; i++) {
      currentPath += '/' + parts[i];
      newExpandedFolders[currentPath] = true;
    }
    
    setExpandedFolders(newExpandedFolders);
  };

  // Function to fetch public directory contents
  const fetchPublicDirectoryContents = async (publicPath = '/', refreshAll = false) => {
    try {
      setIsTreeLoading(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsTreeLoading(false);
        return;
      }
      
      // If refreshAll is true, start from the root
      const pathToFetch = refreshAll ? '/' : publicPath;
      
      // Fetch public directory contents from the server
      const response = await fetch(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PUBLIC_FILES_LIST}?path=${encodeURIComponent(pathToFetch)}`,
        {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        }
      );
      
      if (!response.ok) {
        setErrorMessage(`Failed to load public files: ${response.statusText}`);
        setIsTreeLoading(false);
        return;
      }
      
      const data = await response.json();
      
      // Transform the data to match our expected format
      const transformedFiles = data.items.map(item => ({
        name: item.name,
        type: item.type,
        path: item.path,
        children: item.children || [],
        isPublic: true
      }));
      
      setPublicFiles(transformedFiles);
      
      // Only update the current path if we're not refreshing the entire tree
      if (!refreshAll) {
        setCurrentPath(publicPath);
      }
      
      setIsTreeLoading(false);
      
      // If we refreshed the entire tree, make sure the current path's parent folders are expanded
      if (refreshAll && currentPath !== '/') {
        expandParentFolders(currentPath);
      }
    } catch (error) {
      console.error('Error fetching public directory contents:', error);
      setErrorMessage('Failed to load public files. Please try again.');
      setIsTreeLoading(false);
    }
  };

  // Function to fetch public file content
  const fetchPublicFileContent = async (filePath) => {
    try {
      setIsContentLoading(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsContentLoading(false);
        return;
      }
      
      // Fetch public file content from the server
      const response = await fetch(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PUBLIC_FILE_CONTENT}?path=${encodeURIComponent(filePath)}`,
        {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        }
      );
      
      if (!response.ok) {
        setErrorMessage(`Failed to load file content: ${response.statusText}`);
        setIsContentLoading(false);
        return;
      }
      
      const data = await response.json();
      setFileContent(data.content);
      setIsContentLoading(false);
      setSaveStatus('saved');
    } catch (error) {
      console.error('Error fetching public file content:', error);
      setErrorMessage(`Error loading file: ${error.message}`);
      setSaveStatus('error');
      setIsContentLoading(false);
    }
  };

  // Function to fetch private directory contents from the server (admin only)
  const fetchDirectoryContents = async (path = '/', refreshAll = false) => {
    try {
      setIsTreeLoading(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsTreeLoading(false);
        return;
      }
      
      // If refreshAll is true, start from the root
      const pathToFetch = refreshAll ? '/' : path;
      
      // Fetch directory contents from the server
      const response = await fetch(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILES_LIST}?path=${encodeURIComponent(pathToFetch)}`,
        {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        }
      );
      
      if (!response.ok) {
        // If response is 403, it means the user doesn't have admin access
        if (response.status === 403) {
          setErrorMessage('Admin access required to view files.');
        } else {
          setErrorMessage(`Failed to load files: ${response.statusText}`);
        }
        setIsTreeLoading(false);
        return;
      }
      
      const data = await response.json();
      
      // Transform the data to match our expected format
      const transformedFiles = data.items.map(item => ({
        name: item.name,
        type: item.type,
        path: item.path,
        children: item.children || []
      }));
      
      setFiles(transformedFiles);
      
      // Only update the current path if we're not refreshing the entire tree
      if (!refreshAll) {
        setCurrentPath(path);
      }
      
      setIsTreeLoading(false);
      
      // If we refreshed the entire tree, make sure the current path's parent folders are expanded
      if (refreshAll && currentPath !== '/') {
        expandParentFolders(currentPath);
      }
    } catch (error) {
      console.error('Error fetching directory contents:', error);
      setErrorMessage('Failed to load files. Please try again.');
      setIsTreeLoading(false);
    }
  };

  // Function to fetch file content
  const fetchFileContent = async (filePath) => {
    try {
      setIsContentLoading(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsContentLoading(false);
        return;
      }
      
      // Fetch file content from the server
      const response = await fetch(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_CONTENT}?path=${encodeURIComponent(filePath)}`,
        {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        }
      );
      
      if (!response.ok) {
        // If response is 403, it means the user doesn't have admin access
        if (response.status === 403) {
          setErrorMessage('Admin access required to view file content.');
        } else {
          setErrorMessage(`Failed to load file content: ${response.statusText}`);
        }
        setIsContentLoading(false);
        return;
      }
      
      const data = await response.json();
      setFileContent(data.content);
      setIsContentLoading(false);
      setSaveStatus('saved');
    } catch (error) {
      console.error('Error fetching file content:', error);
      setErrorMessage(`Error loading file: ${error.message}`);
      setSaveStatus('error');
      setIsContentLoading(false);
    }
  };
  
  // Function to save file content
  const saveFileContent = async () => {
    try {
      // Check if filePath is valid
      if (!selectedFile || !selectedFile.path || selectedFile.path.trim() === '') {
        setErrorMessage('No file selected. Please select a file first.');
        setSaveStatus('error');
        return;
      }
      
      setSaveStatus('saving');
      
      const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_SAVE}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
        },
        body: JSON.stringify({
          path: selectedFile.path,
          content: fileContent
        })
      });
      
      if (!response.ok) {
        throw new Error(`Failed to save file: ${response.statusText}`);
      }
      
      setSaveStatus('saved');
      setErrorMessage('');
    } catch (error) {
      console.error('Error saving file:', error);
      setErrorMessage(`Error saving file: ${error.message}`);
      setSaveStatus('error');
    }
  };
  
  // Insert markdown syntax at cursor position
  const insertMarkdown = (prefix, suffix = '') => {
    const textarea = textareaRef.current;
    if (!textarea) return;
    
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const text = fileContent;
    
    // If text is selected, wrap it with prefix and suffix
    if (start !== end) {
      const selectedText = text.substring(start, end);
      const newContent = text.substring(0, start) + prefix + selectedText + suffix + text.substring(end);
      setFileContent(newContent);
      
      // Set cursor position after the inserted text
      setTimeout(() => {
        textarea.selectionStart = start + prefix.length;
        textarea.selectionEnd = end + prefix.length;
        textarea.focus();
      }, 0);
    } else {
      // No selection, just insert at cursor
      const newContent = text.substring(0, start) + prefix + suffix + text.substring(start);
      setFileContent(newContent);
      
      // Move cursor between prefix and suffix
      setTimeout(() => {
        textarea.selectionStart = textarea.selectionEnd = start + prefix.length;
        textarea.focus();
      }, 0);
    }
  };
  
  // Insert list items
  const insertList = (listPrefix) => {
    const textarea = textareaRef.current;
    if (!textarea) return;
    
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const text = fileContent;
    
    // If text is selected, apply list formatting to each line
    if (start !== end) {
      const selectedText = text.substring(start, end);
      const lines = selectedText.split('\n');
      
      // Format each line as a list item
      const formattedLines = lines.map(line => {
        // Skip empty lines
        if (line.trim() === '') return line;
        
        // For numbered lists, increment the number for each line
        if (listPrefix === '1. ') {
          const index = lines.indexOf(line) + 1;
          return `${index}. ${line}`;
        }
        
        return `${listPrefix}${line}`;
      });
      
      const newContent = text.substring(0, start) + formattedLines.join('\n') + text.substring(end);
      setFileContent(newContent);
      
      // Set cursor position after the inserted text
      setTimeout(() => {
        textarea.selectionStart = start;
        textarea.selectionEnd = start + formattedLines.join('\n').length;
        textarea.focus();
      }, 0);
    } else {
      // No selection, just insert at cursor
      const newContent = text.substring(0, start) + listPrefix + text.substring(start);
      setFileContent(newContent);
      
      // Move cursor after the inserted prefix
      setTimeout(() => {
        textarea.selectionStart = textarea.selectionEnd = start + listPrefix.length;
        textarea.focus();
      }, 0);
    }
  };
  
  // Get the current line of text at cursor position
  const getCurrentLine = (text, cursorPos) => {
    const textBeforeCursor = text.substring(0, cursorPos);
    const lineStartPos = textBeforeCursor.lastIndexOf('\n') + 1;
    const lineEndPos = text.indexOf('\n', cursorPos);
    const actualLineEndPos = lineEndPos !== -1 ? lineEndPos : text.length;
    return text.substring(lineStartPos, actualLineEndPos);
  };
  
  // Handle keyboard events in the editor
  const handleEditorKeyDown = (e) => {
    // Handle keyboard shortcuts
    if (e.ctrlKey || e.metaKey) {
      // Ctrl+B or Cmd+B for bold
      if (e.key === 'b') {
        e.preventDefault();
        insertMarkdown('**', '**');
        return;
      }
      
      // Ctrl+I or Cmd+I for italic
      if (e.key === 'i') {
        e.preventDefault();
        insertMarkdown('*', '*');
        return;
      }
      
      // Ctrl+Shift+L for unordered list
      if (e.shiftKey && e.key === 'L') {
        e.preventDefault();
        insertList('- ');
        return;
      }
      
      // Ctrl+Shift+O for ordered list
      if (e.shiftKey && e.key === 'O') {
        e.preventDefault();
        insertList('1. ');
        return;
      }
      
      // Ctrl+Shift+C for checklist
      if (e.shiftKey && e.key === 'C') {
        e.preventDefault();
        insertList('- [ ] ');
        return;
      }
    }
    
    // Auto-continue lists on Enter
    if (e.key === 'Enter' && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
      const textarea = textareaRef.current;
      if (!textarea) return;
      
      const cursorPos = textarea.selectionStart;
      const text = fileContent;
      const currentLine = getCurrentLine(text, cursorPos);
      
      // Check for list patterns
      const bulletListMatch = currentLine.match(/^(\s*)(-|\*|\+)\s+(.*)/);
      const numberedListMatch = currentLine.match(/^(\s*)(\d+)\.?\s+(.*)/);
      const checklistMatch = currentLine.match(/^(\s*)(-|\*|\+)\s+\[([ xX])\]\s+(.*)/);
      
      if (bulletListMatch || numberedListMatch || checklistMatch) {
        // Get the indentation and list marker
        let indentation, marker, content;
        
        if (checklistMatch) {
          indentation = checklistMatch[1];
          marker = checklistMatch[2];
          const checkState = checklistMatch[3];
          content = checklistMatch[4];
          
          // If the checklist item is empty, remove the list marker
          if (content.trim() === '') {
            e.preventDefault();
            const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
            const newContent = text.substring(0, lineStart) + text.substring(cursorPos);
            setFileContent(newContent);
            setTimeout(() => {
              textarea.selectionStart = textarea.selectionEnd = lineStart;
              textarea.focus();
            }, 0);
            return;
          }
          
          // Continue the checklist with an unchecked box
          e.preventDefault();
          const newListItem = `\n${indentation}${marker} [ ] `;
          insertMarkdown(newListItem);
          return;
        } else if (bulletListMatch) {
          indentation = bulletListMatch[1];
          marker = bulletListMatch[2];
          content = bulletListMatch[3];
          
          // If the list item is empty, remove the list marker
          if (content.trim() === '') {
            e.preventDefault();
            const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
            const newContent = text.substring(0, lineStart) + text.substring(cursorPos);
            setFileContent(newContent);
            setTimeout(() => {
              textarea.selectionStart = textarea.selectionEnd = lineStart;
              textarea.focus();
            }, 0);
            return;
          }
          
          // Continue the bullet list
          e.preventDefault();
          const newListItem = `\n${indentation}${marker} `;
          insertMarkdown(newListItem);
          return;
        } else if (numberedListMatch) {
          indentation = numberedListMatch[1];
          const number = parseInt(numberedListMatch[2], 10);
          content = numberedListMatch[3];
          
          // If the list item is empty, remove the list marker
          if (content.trim() === '') {
            e.preventDefault();
            const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
            const newContent = text.substring(0, lineStart) + text.substring(cursorPos);
            setFileContent(newContent);
            setTimeout(() => {
              textarea.selectionStart = textarea.selectionEnd = lineStart;
              textarea.focus();
            }, 0);
            return;
          }
          
          // Continue the numbered list with incremented number
          e.preventDefault();
          const newListItem = `\n${indentation}${number + 1}. `;
          insertMarkdown(newListItem);
          return;
        }
      }
    }
    
    // Handle tab for indentation in lists
    if (e.key === 'Tab') {
      const textarea = textareaRef.current;
      if (!textarea) return;
      
      const cursorPos = textarea.selectionStart;
      const text = fileContent;
      const currentLine = getCurrentLine(text, cursorPos);
      
      // Check if we're in a list item
      const listMatch = currentLine.match(/^(\s*)(-|\*|\+|\d+\.|\[[ xX]\])\s+/);
      if (listMatch) {
        e.preventDefault();
        
        // Add or remove indentation based on shift key
        if (e.shiftKey) {
          // Outdent: remove 2 spaces from the beginning if they exist
          if (currentLine.startsWith('  ')) {
            const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
            const lineEnd = text.indexOf('\n', cursorPos);
            const actualLineEnd = lineEnd !== -1 ? lineEnd : text.length;
            
            const newContent = text.substring(0, lineStart) + currentLine.substring(2) + text.substring(actualLineEnd);
            setFileContent(newContent);
            
            // Adjust cursor position
            const newCursorPos = cursorPos - 2;
            setTimeout(() => {
              textarea.selectionStart = textarea.selectionEnd = newCursorPos > lineStart ? newCursorPos : lineStart;
              textarea.focus();
            }, 0);
          }
        } else {
          // Indent: add 2 spaces at the beginning
          const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
          const lineEnd = text.indexOf('\n', cursorPos);
          const actualLineEnd = lineEnd !== -1 ? lineEnd : text.length;
          
          const newContent = text.substring(0, lineStart) + '  ' + currentLine + text.substring(actualLineEnd);
          setFileContent(newContent);
          
          // Adjust cursor position
          const newCursorPos = cursorPos + 2;
          setTimeout(() => {
            textarea.selectionStart = textarea.selectionEnd = newCursorPos;
            textarea.focus();
          }, 0);
        }
      }
    }
  };
  
  // Handle markdown content change
  const handleMarkdownChange = (e) => {
    setFileContent(e.target.value);
  };

  // Load explorer state from IndexedDB on mount
  useEffect(() => {
    const loadExplorerState = async () => {
      try {
        // Try to load explorer state from IndexedDB
        const savedState = await getExplorerState(nodeId);
        
        if (savedState && savedState.content && !stateLoadedRef.current) {
          console.log(`Loaded explorer state for window ${nodeId} from IndexedDB:`, savedState.content);
          
          let restoredFile = null;
          
          // Update state with saved values
          if (savedState.content.selectedFile) {
            restoredFile = savedState.content.selectedFile;
            setSelectedFile(restoredFile);
          }
          
          if (savedState.content.expandedFolders) {
            setExpandedFolders(savedState.content.expandedFolders);
          }
          
          if (savedState.content.activeTab) {
            setActiveTab(savedState.content.activeTab);
          }
          
          // Mark as loaded
          stateLoadedRef.current = true;
          
          // If a file was restored and it's a markdown file, load its content
          if (restoredFile && restoredFile.type === 'file' && restoredFile.name.endsWith('.md')) {
            // Set the preview mode for markdown files
            setShowPreview(true);
            
            // Load the file content based on whether it's a public or private file
            if (restoredFile.isPublic) {
              // Fetch public file content
              fetchPublicFileContent(restoredFile.path);
            } else if (isAdmin) {
              // Fetch private file content (admin only)
              fetchFileContent(restoredFile.path);
            }
          }
        }
      } catch (error) {
        console.error(`Failed to load explorer state for window ${nodeId} from IndexedDB:`, error);
      }
    };
    
    loadExplorerState();
  }, [nodeId, isAdmin]);
  
  // Handle window activation
  useEffect(() => {
    if (isActive) {
      // Save this as the active explorer window
      setActiveWindow(nodeId, WINDOW_TYPES.EXPLORER);
    }
  }, [isActive, nodeId, setActiveWindow]);
  
  // Save explorer state to IndexedDB when it changes
  useEffect(() => {
    if (!stateLoadedRef.current) return;
    
    // Save the explorer state to IndexedDB
    saveExplorerState({
      id: nodeId,
      content: {
        selectedFile,
        expandedFolders,
        activeTab
      }
    }).catch(error => {
      console.error(`Failed to save explorer state for window ${nodeId} to IndexedDB:`, error);
    });
    
  }, [selectedFile, expandedFolders, activeTab, nodeId]);

  // Load initial directory contents
  useEffect(() => {
    // Load public files for all users
    fetchPublicDirectoryContents();
    
    // Load private files for admin users
    if (isAdmin) {
      fetchDirectoryContents().catch(error => {
        console.error('Failed to load private files:', error);
        // Set a specific error message for private files without affecting public files
        setFiles([]);
        if (activeTab === 'private') {
          setErrorMessage('Failed to load private files. Please ensure your admin directory exists.');
        }
      });
    }
  }, [isAdmin]);

  // Reset content states when switching tabs
  useEffect(() => {
    // Clear file content and reset view states when changing tabs
    setSelectedFile(null);
    setFileContent('');
    setShowPreview(false);
    setEditMode(false);
    setSaveStatus('saved');
    setErrorMessage('');
    
    // Reset current path to root for the selected tab
    setCurrentPath('/');
  }, [activeTab]);

  // Auto-save functionality with debounce
  useEffect(() => {
    // Only auto-save if in edit mode, user is admin, and we have a markdown file selected
    if (editMode && isAdmin && selectedFile && selectedFile.name.endsWith('.md') && fileContent) {
      // Clear any existing timeout
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
      
      // Set status to saving
      setSaveStatus('saving');
      
      // Set a new timeout for auto-save
      saveTimeoutRef.current = setTimeout(() => {
        saveFileContent();
      }, 1000); // 1 second debounce
    }
    
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, [fileContent, editMode, isAdmin, selectedFile]);

  // Update window state when relevant state changes
  useEffect(() => {
    if (updateWindowState) {
      updateWindowState({
        currentPath,
        selectedFile,
        expandedFolders,
        fileContent,
        showPreview,
        editMode,
        saveStatus,
        activeTab
      });
    }
  }, [currentPath, selectedFile, expandedFolders, fileContent, showPreview, editMode, saveStatus, activeTab, updateWindowState]);
  
  // Focus the input field when the create or rename dialog is shown
  useEffect(() => {
    if (showCreateDialog && createInputRef.current) {
      createInputRef.current.focus();
    }
    if (showRenameDialog && renameInputRef.current) {
      renameInputRef.current.focus();
    }
  }, [showCreateDialog, showRenameDialog]);

  // Toggle folder expansion
  const toggleFolder = (folderPath, folder) => {
    const isExpanding = !expandedFolders[folderPath];
    
    setExpandedFolders(prev => ({
      ...prev,
      [folderPath]: isExpanding
    }));
    
    // If we're expanding the folder, also set it as the current path
    if (isExpanding) {
      setCurrentPath(folderPath);
      setSelectedFile(folder);
    }
  };
  
  // Helper function to get the active folder path based on selected item and current path
  const getActiveFolderPath = () => {
    if (selectedFile) {
      // If selected item is a directory, use its path
      if (selectedFile.type === 'directory') {
        return selectedFile.path;
      }
      // If selected item is a file, use its parent directory
      return getParentDirectoryPath(selectedFile.path);
    }
    // Fall back to current path if no file is selected
    return currentPath;
  };
  
  // Create a new file or folder
  const createNewItem = async () => {
    if (!newItemName.trim()) {
      setErrorMessage('Name cannot be empty');
      return;
    }
    
    try {
      setIsCreating(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsCreating(false);
        return;
      }
      
      // Determine if we're creating in the public folder or private folder
      const isPublicFolder = activeTab === 'public';
      
      // Get the active folder path where the new item should be created
      const activeFolderPath = getActiveFolderPath();
      
      // Construct the full path for the new item
      let newItemPath;
      if (isPublicFolder) {
        // For public folder, prefix with /public if not already included
        const publicPrefix = activeFolderPath.startsWith('/public') ? '' : '/public';
        newItemPath = path.join(publicPrefix, activeFolderPath, newItemName.trim()).replace(/\\/g, '/');
      } else {
        // For private folder (admin only)
        newItemPath = path.join(activeFolderPath, newItemName.trim()).replace(/\\/g, '/');
      }
      
      // Create the new file or folder
      const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_CREATE}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          path: newItemPath,
          type: createType,
          content: createType === 'file' ? '' : undefined
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || `Failed to create ${createType}: ${response.statusText}`);
      }
      
      // Close the dialog and reset the form
      setShowCreateDialog(false);
      setNewItemName('');
      
      // Refresh the entire file tree from the root
      if (isPublicFolder) {
        fetchPublicDirectoryContents('/', true);
      } else {
        fetchDirectoryContents('/', true);
      }
      
      // If it's a directory, expand it
      if (createType === 'directory') {
        setExpandedFolders(prev => ({
          ...prev,
          [newItemPath]: true
        }));
      }
      
      setIsCreating(false);
    } catch (error) {
      console.error(`Error creating ${createType}:`, error);
      setErrorMessage(`Failed to create ${createType}: ${error.message}`);
      setIsCreating(false);
    }
  };
  
  // Open the create dialog
  const openCreateDialog = (type) => {
    setCreateType(type);
    setNewItemName('');
    setErrorMessage('');
    setShowCreateDialog(true);
  };
  
  // Close the create dialog
  const closeCreateDialog = () => {
    setShowCreateDialog(false);
    setNewItemName('');
    setErrorMessage('');
  };
  
  // Handle key press in the create dialog
  const handleCreateKeyPress = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      createNewItem();
    } else if (e.key === 'Escape') {
      closeCreateDialog();
    }
  };

  // Open the rename dialog for a file or folder
  const openRenameDialog = (item) => {
    if (!isAdmin) {
      setErrorMessage('Admin access required to rename files.');
      return;
    }
    
    setItemToRename(item);
    setNewName(item.name);
    setErrorMessage('');
    setShowRenameDialog(true);
  };
  
  // Close the rename dialog
  const closeRenameDialog = () => {
    setShowRenameDialog(false);
    setItemToRename(null);
    setNewName('');
    setErrorMessage('');
  };
  
  // Open the delete dialog for a file or folder
  const openDeleteDialog = (item) => {
    if (!isAdmin) {
      setErrorMessage('Admin access required to delete files.');
      return;
    }
    
    setItemToDelete(item);
    setErrorMessage('');
    setShowDeleteDialog(true);
  };
  
  // Close the delete dialog
  const closeDeleteDialog = () => {
    setShowDeleteDialog(false);
    setItemToDelete(null);
    setErrorMessage('');
  };
  
  // Handle drag start event
  const handleDragStart = (e, item) => {
    if (!isAdmin) return;
    
    setDraggedItem(item);
    e.dataTransfer.setData('text/plain', item.path);
    e.dataTransfer.effectAllowed = 'move';
    
    // Add dragging class to the element
    e.currentTarget.classList.add('dragging');
    
    // Remove the class after a short delay to ensure it's applied
    setTimeout(() => {
      if (e.currentTarget) {
        e.currentTarget.classList.remove('dragging');
      }
    }, 100);
  };
  
  // Handle drag over event
  const handleDragOver = (e, folder) => {
    if (!isAdmin || !draggedItem) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    // Only allow dropping into directories
    if (folder.type === 'directory') {
      setDropTarget(folder);
      e.dataTransfer.dropEffect = 'move';
      
      // Add drop-target class to the element
      e.currentTarget.classList.add('drop-target');
    }
  };
  
  // Handle drag over for the file tree container (to allow dropping to root)
  const handleContainerDragOver = (e) => {
    if (!isAdmin || !draggedItem) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    // Set root as the drop target
    const rootFolder = {
      type: 'directory',
      path: draggedItem.isPublic ? '/public' : '/',
      name: 'Root'
    };
    setDropTarget(rootFolder);
    e.dataTransfer.dropEffect = 'move';
  };
  
  // Handle drag leave event
  const handleDragLeave = (e) => {
    if (!isAdmin) return;
    
    e.preventDefault();
    e.stopPropagation();
    setDropTarget(null);
    
    // Remove drop-target class from the element
    e.currentTarget.classList.remove('drop-target');
  };
  
  // Handle drag leave for the container
  const handleContainerDragLeave = (e) => {
    if (!isAdmin) return;
    
    e.preventDefault();
    e.stopPropagation();
    setDropTarget(null);
  };
  
  // Handle drop event
  const handleDrop = async (e, targetFolder) => {
    if (!isAdmin || !draggedItem || !targetFolder) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    // Reset drop target
    setDropTarget(null);
    
    // Remove drop-target class from the element
    e.currentTarget.classList.remove('drop-target');
    
    // Only allow dropping into directories
    if (targetFolder.type !== 'directory') {
      return;
    }
    
    // Check if dropping on itself
    if (draggedItem.path === targetFolder.path) {
      return;
    }
    
    // Check if dropping in current location (parent folder is the same)
    const draggedParent = getParentDirectoryPath(draggedItem.path);
    if (draggedParent === targetFolder.path) {
      return;
    }
    
    try {
      setIsMoving(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsMoving(false);
        return;
      }
      
      // Call the API to move the file
      const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_MOVE}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          sourcePath: draggedItem.path,
          destinationPath: targetFolder.path
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || `Failed to move ${draggedItem.type}: ${response.statusText}`);
      }
      
      // If the moved item was selected, clear the selection
      if (selectedFile && selectedFile.path === draggedItem.path) {
        setSelectedFile(null);
        setFileContent('');
        setShowPreview(false);
        if (editMode) {
          setEditMode(false);
        }
      }
      
      // Refresh the appropriate file list
      if (draggedItem.isPublic) {
        fetchPublicDirectoryContents('/', true);
      } else {
        fetchDirectoryContents('/', true);
      }
      
      // Clear drag state
      setDraggedItem(null);
      setIsMoving(false);
    } catch (error) {
      console.error(`Error moving ${draggedItem.type}:`, error);
      setErrorMessage(`Failed to move ${draggedItem.type}: ${error.message}`);
      setDraggedItem(null);
      setIsMoving(false);
    }
  };
  
  // Handle drop event for the container (moving to root)
  const handleContainerDrop = async (e) => {
    if (!isAdmin || !draggedItem || !dropTarget) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    // Process the drop using the dropTarget which was set in handleContainerDragOver
    const targetFolder = dropTarget;
    
    // Reset drop target
    setDropTarget(null);
    
    // Check if dropping in current location (parent folder is the same)
    const draggedParent = getParentDirectoryPath(draggedItem.path);
    if (draggedParent === targetFolder.path) {
      return;
    }
    
    try {
      setIsMoving(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsMoving(false);
        return;
      }
      
      // Call the API to move the file
      const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_MOVE}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          sourcePath: draggedItem.path,
          destinationPath: targetFolder.path
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || `Failed to move ${draggedItem.type}: ${response.statusText}`);
      }
      
      // If the moved item was selected, clear the selection
      if (selectedFile && selectedFile.path === draggedItem.path) {
        setSelectedFile(null);
        setFileContent('');
        setShowPreview(false);
        if (editMode) {
          setEditMode(false);
        }
      }
      
      // Refresh the appropriate file list
      if (draggedItem.isPublic) {
        fetchPublicDirectoryContents('/', true);
      } else {
        fetchDirectoryContents('/', true);
      }
      
      // Clear drag state
      setDraggedItem(null);
      setIsMoving(false);
    } catch (error) {
      console.error(`Error moving ${draggedItem.type} to root:`, error);
      setErrorMessage(`Failed to move ${draggedItem.type} to root: ${error.message}`);
      setDraggedItem(null);
      setIsMoving(false);
    }
  };
  
  // Delete a file or folder
  const deleteItem = async () => {
    if (!itemToDelete) {
      setErrorMessage('No item selected for deletion');
      return;
    }
    
    try {
      setIsDeleting(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsDeleting(false);
        return;
      }
      
      // Delete the file or folder
      const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_DELETE}?path=${encodeURIComponent(itemToDelete.path)}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || `Failed to delete ${itemToDelete.type}: ${response.statusText}`);
      }
      
      // Close the dialog
      setShowDeleteDialog(false);
      setItemToDelete(null);
      
      // If the deleted item was selected, clear the selection
      if (selectedFile && selectedFile.path === itemToDelete.path) {
        setSelectedFile(null);
        setFileContent('');
        setShowPreview(false);
        if (editMode) {
          setEditMode(false);
        }
      }
      
      // Refresh the appropriate file list
      if (itemToDelete.isPublic) {
        fetchPublicDirectoryContents('/', true);
      } else {
        fetchDirectoryContents('/', true);
      }
      
      setIsDeleting(false);
    } catch (error) {
      console.error(`Error deleting ${itemToDelete.type}:`, error);
      setErrorMessage(`Failed to delete ${itemToDelete.type}: ${error.message}`);
      setIsDeleting(false);
    }
  };
  
  // Handle key press in the rename dialog
  const handleRenameKeyPress = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      renameItem();
    } else if (e.key === 'Escape') {
      closeRenameDialog();
    }
  };
  
  // Rename a file or folder
  const renameItem = async () => {
    if (!newName.trim()) {
      setErrorMessage('Name cannot be empty');
      return;
    }
    
    if (!itemToRename) {
      setErrorMessage('No item selected for renaming');
      return;
    }
    
    try {
      setIsRenaming(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsRenaming(false);
        return;
      }
      
      // Rename the file or folder
      const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_RENAME}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          oldPath: itemToRename.path,
          newName: newName.trim()
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || `Failed to rename ${itemToRename.type}: ${response.statusText}`);
      }
      
      // Close the dialog and reset the form
      setShowRenameDialog(false);
      setItemToRename(null);
      setNewName('');
      
      // If the renamed item was selected, update the selected file
      if (selectedFile && selectedFile.path === itemToRename.path) {
        setSelectedFile(null);
      }
      
      // Refresh the appropriate file list
      if (itemToRename.isPublic) {
        fetchPublicDirectoryContents('/', true);
      } else {
        fetchDirectoryContents('/', true);
      }
      
      setIsRenaming(false);
    } catch (error) {
      console.error(`Error renaming ${itemToRename.type}:`, error);
      setErrorMessage(`Failed to rename ${itemToRename.type}: ${error.message}`);
      setIsRenaming(false);
    }
  };
  
  // Handle folder selection
  const handleFolderSelect = (folder) => {
    // Update the current path to the selected folder's path
    setCurrentPath(folder.path);
    
    // Set the selected folder
    setSelectedFile(folder);
    
    // Expand the folder
    setExpandedFolders(prev => ({
      ...prev,
      [folder.path]: true
    }));
    
    // Reset content and preview
    setFileContent('');
    setShowPreview(false);
    
    // Reset edit mode
    if (editMode) {
      setEditMode(false);
    }
  };
  
  // Helper function to get parent directory path
  const getParentDirectoryPath = (filePath) => {
    // Remove trailing slash if present
    const normalizedPath = filePath.endsWith('/') ? filePath.slice(0, -1) : filePath;
    // Find the last slash in the path
    const lastSlashIndex = normalizedPath.lastIndexOf('/');
    
    if (lastSlashIndex === -1) {
      // No slash found, return root
      return '/';
    }
    
    // Return everything up to the last slash
    return normalizedPath.substring(0, lastSlashIndex) || '/';
  };
  
  // Handle file selection
  const handleFileSelect = (file) => {
    // If it's a directory, handle it differently
    if (file.type === 'directory') {
      handleFolderSelect(file);
      return;
    }
    
    setSelectedFile(file);
    
    // We don't change the current path when selecting a file
    // This prevents the file tree from reloading unnecessarily
    
    // Reset edit mode when selecting a new file
    if (editMode) {
      setEditMode(false);
    }
    
    // If it's a markdown file, fetch its content and show preview
    if (file.name.endsWith('.md')) {
      if (file.isPublic) {
        // Fetch public file content
        fetchPublicFileContent(file.path);
      } else {
        // Fetch private file content (admin only)
        fetchFileContent(file.path);
      }
      setShowPreview(true);
    } else {
      setFileContent('');
      setShowPreview(false);
    }
  };

  // Get file icon based on file extension
  const getFileIcon = (fileName) => {
    if (fileName.endsWith('.md')) return <FileText size={16} className="mr-2" />;
    if (fileName.endsWith('.jsx') || fileName.endsWith('.js')) return <Code size={16} className="mr-2" />;
    if (fileName.endsWith('.json')) return <Coffee size={16} className="mr-2" />;
    if (fileName.endsWith('.css')) return <BookOpen size={16} className="mr-2" />;
    return <File size={16} className="mr-2" />;
  };
  
  // Render the file tree recursively
  const renderFileTree = (items) => {
    // Keep track of the path to the currently selected file to highlight its parent folder
    const selectedFilePath = selectedFile?.path || '';
    const selectedFileParentPath = selectedFile && selectedFile.type !== 'directory' ? 
      getParentDirectoryPath(selectedFilePath) : '';
    
    return items.map(item => {
      if (item.type === 'directory') {
        const isExpanded = expandedFolders[item.path];
        // A folder is considered active if it's the current path OR if it's the parent of the selected file
        const isActive = currentPath === item.path || (selectedFileParentPath === item.path);
        return (
          <div key={item.path} className="ml-2">
            <div 
              className={`flex items-center justify-between py-1 px-1 rounded hover:bg-stone-700 cursor-pointer group ${
                isActive ? 'bg-stone-800 text-teal-300 font-bold' : 
                isExpanded ? 'text-teal-300' : 'text-teal-400'
              } ${dropTarget && dropTarget.path === item.path ? 'bg-teal-900 border border-teal-500' : ''}`}
              onClick={() => toggleFolder(item.path, item)}
              draggable={isAdmin}
              onDragStart={(e) => handleDragStart(e, item)}
              onDragOver={(e) => handleDragOver(e, item)}
              onDragLeave={(e) => handleDragLeave(e)}
              onDrop={(e) => handleDrop(e, item)}
            >
              <div className="flex items-center">
                {isExpanded ? <ChevronDown size={14} /> : <ChevronRight size={14} />}
                <FolderOpen size={16} className="ml-1 mr-2" />
                <span className="text-sm">{item.name}</span>
              </div>
              
              {/* Admin-only buttons */}
              {isAdmin && (
                <div className="flex">
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      openRenameDialog(item);
                    }}
                    className="p-1 rounded hover:bg-stone-600 text-stone-400 hover:text-teal-300 opacity-0 group-hover:opacity-100"
                    title="Rename folder"
                  >
                    <FileEdit size={14} />
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      openDeleteDialog(item);
                    }}
                    className="p-1 rounded hover:bg-stone-600 text-stone-400 hover:text-red-400 opacity-0 group-hover:opacity-100"
                    title="Delete folder"
                  >
                    <Trash2 size={14} />
                  </button>
                </div>
              )}
            </div>
            
            {isExpanded && item.children && (
              <div className="ml-2 border-l border-stone-700">
                {renderFileTree(item.children)}
              </div>
            )}
          </div>
        );
      } else {
        const isSelected = selectedFile && selectedFile.path === item.path;
        return (
          <div 
            key={item.path} 
            className={`flex items-center justify-between py-1 px-1 ml-4 rounded cursor-pointer hover:bg-stone-700 group ${isSelected ? 'bg-stone-700 text-teal-300' : 'text-teal-50'}`}
            onClick={() => handleFileSelect(item)}
            draggable={isAdmin}
            onDragStart={(e) => handleDragStart(e, item)}
          >
            <div className="flex items-center">
              {getFileIcon(item.name)}
              <span className="text-sm">{item.name}</span>
            </div>
            
            {/* Admin-only buttons */}
            {isAdmin && (
              <div className="flex">
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    openRenameDialog(item);
                  }}
                  className="p-1 rounded hover:bg-stone-600 text-stone-400 hover:text-teal-300 opacity-0 group-hover:opacity-100"
                  title="Rename file"
                >
                  <FileEdit size={14} />
                </button>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    openDeleteDialog(item);
                  }}
                  className="p-1 rounded hover:bg-stone-600 text-stone-400 hover:text-red-400 opacity-0 group-hover:opacity-100"
                  title="Delete file"
                >
                  <Trash2 size={14} />
                </button>
              </div>
            )}
          </div>
        );
      }
    });
  };

  // Toggle edit mode
  const toggleEditMode = () => {
    if (!isAdmin) {
      setErrorMessage('Admin access required to edit files.');
      return;
    }
    
    if (!selectedFile || !selectedFile.name.endsWith('.md')) {
      setErrorMessage('Only markdown files can be edited.');
      return;
    }
    
    setEditMode(!editMode);
    // When switching to preview mode, ensure preview is shown
    if (editMode) {
      setShowPreview(true);
    }
  };

  // Handle command input
  const handleCommand = (e) => {
    if (e.key === 'Enter' && e.target.value.trim()) {
      const cmd = e.target.value.trim();
      onCommand(cmd);
      e.target.value = '';
      
      // Commands:
      // - refresh: refresh file list
      // - preview: toggle markdown preview
      // - edit: toggle edit mode (admin only)
      // - save: manually save the current file
      // - new-file: create a new file (admin only)
      // - new-folder: create a new folder (admin only)
      // - rename: rename selected file or folder (admin only)
      // - delete: delete selected file or folder (admin only)
      // - public: switch to public files tab
      // - private: switch to private files tab (admin only)
      if (cmd === 'refresh') {
        // Refresh the appropriate file list based on the active tab
        if (activeTab === 'public') {
          fetchPublicDirectoryContents('/', true);
        } else {
          fetchDirectoryContents('/', true);
        }
      } else if (cmd === 'preview' && selectedFile?.name.endsWith('.md')) {
        setShowPreview(!showPreview);
        if (editMode) {
          setEditMode(false); // Exit edit mode when switching to preview
        }
      } else if (cmd === 'edit' && selectedFile?.name.endsWith('.md')) {
        toggleEditMode();
      } else if (cmd === 'save' && editMode && selectedFile?.name.endsWith('.md')) {
        saveFileContent();
      } else if (cmd === 'new-file' && isAdmin) {
        openCreateDialog('file');
      } else if (cmd === 'new-folder' && isAdmin) {
        openCreateDialog('directory');
      } else if (cmd === 'rename' && isAdmin && selectedFile) {
        openRenameDialog(selectedFile);
      } else if (cmd === 'delete' && isAdmin && selectedFile) {
        openDeleteDialog(selectedFile);
      } else if (cmd === 'public') {
        setActiveTab('public');
      } else if (cmd === 'private' && isAdmin) {
        setActiveTab('private');
      }
    }
  };

  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400 overflow-hidden">
      <div className="flex flex-1 overflow-hidden">
        {/* File tree panel */}
        <div className="w-1/3 border-r border-stone-700 flex flex-col overflow-hidden">
          <div className="p-2 border-b border-stone-700 font-mono text-sm flex items-center justify-between">
            <div className="flex items-center">
              <span>FILES</span>
              
              {/* Tabs for switching between public and private files */}
              <div className="flex ml-4">
                <button
                  onClick={() => setActiveTab('public')}
                  className={`px-2 py-1 rounded-t text-xs flex items-center gap-1 ${
                    activeTab === 'public' 
                      ? 'bg-stone-700 text-teal-300' 
                      : 'bg-stone-800 hover:bg-stone-700'
                  }`}
                  title="Public files (readable by all users)"
                >
                  <Globe size={14} />
                  <span>Public</span>
                </button>
                
                {isAdmin && (
                  <button
                    onClick={() => setActiveTab('private')}
                    className={`px-2 py-1 rounded-t text-xs flex items-center gap-1 ml-1 ${
                      activeTab === 'private' 
                        ? 'bg-stone-700 text-teal-300' 
                        : 'bg-stone-800 hover:bg-stone-700'
                    }`}
                    title="Private files (admin only)"
                  >
                    <Lock size={14} />
                    <span>Private</span>
                  </button>
                )}
              </div>
            </div>
            
            {/* Admin-only file creation buttons */}
            {isAdmin && (
              <div className="flex gap-2">
                <button
                  onClick={() => openCreateDialog('file')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Create new file"
                >
                  <Plus size={16} />
                </button>
                <button
                  onClick={() => openCreateDialog('directory')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Create new folder"
                >
                  <FolderPlus size={16} />
                </button>
              </div>
            )}
          </div>
          
          <div 
            className="flex-1 overflow-auto"
            onDragOver={handleContainerDragOver}
            onDragLeave={handleContainerDragLeave}
            onDrop={handleContainerDrop}
          >
            {isTreeLoading ? (
              <div className="flex items-center justify-center h-full">
                <span className="text-teal-300">Loading files...</span>
              </div>
            ) : errorMessage ? (
              <div className="p-2 text-red-400">{errorMessage}</div>
            ) : (
              <div className="p-2 font-mono">
                {activeTab === 'public' ? (
                  // Show public files to all users
                  <>
                    <div className="flex items-center py-1 px-1 text-teal-300">
                      <Globe size={16} className="mr-2" />
                      <span className="text-sm font-bold">Public Files</span>
                    </div>
                    {publicFiles.length > 0 ? (
                      renderFileTree(publicFiles)
                    ) : (
                      <div className="ml-4 text-stone-500 text-sm">No public files available</div>
                    )}
                  </>
                ) : (
                  // Show private files to admin users
                  <>
                    <div className="flex items-center py-1 px-1 text-teal-300">
                      <Lock size={16} className="mr-2" />
                      <span className="text-sm font-bold">Private Files (Admin Only)</span>
                    </div>
                    {files.length > 0 ? (
                      renderFileTree(files)
                    ) : (
                      <div className="ml-4 text-stone-500 text-sm">No private files available</div>
                    )}
                  </>
                )}
              </div>
            )}
          </div>
          
          {/* Create file/folder dialog */}
          {showCreateDialog && (
            <div className="p-2 border-t border-stone-700 bg-stone-800">
              <div className="flex items-center justify-between mb-1">
                <span className="text-sm font-bold">
                  {createType === 'file' ? 'New File' : 'New Folder'}
                </span>
                <button
                  onClick={closeCreateDialog}
                  className="p-1 rounded hover:bg-stone-700 text-stone-400"
                >
                  <X size={14} />
                </button>
              </div>
              <div className="flex gap-2">
                <input
                  ref={createInputRef}
                  type="text"
                  value={newItemName}
                  onChange={(e) => setNewItemName(e.target.value)}
                  onKeyDown={handleCreateKeyPress}
                  placeholder={createType === 'file' ? 'filename.ext' : 'folder name'}
                  className="flex-1 bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
                  disabled={isCreating}
                />
                <button
                  onClick={createNewItem}
                  disabled={isCreating || !newItemName.trim()}
                  className={`px-2 py-1 rounded text-xs ${
                    isCreating || !newItemName.trim()
                      ? 'bg-stone-700 text-stone-500 cursor-not-allowed'
                      : 'bg-teal-700 text-teal-100 hover:bg-teal-600'
                  }`}
                >
                  {isCreating ? 'Creating...' : 'Create'}
                </button>
              </div>
            </div>
          )}
          
          {/* Rename file/folder dialog */}
          {showRenameDialog && itemToRename && (
            <div className="p-2 border-t border-stone-700 bg-stone-800">
              <div className="flex items-center justify-between mb-1">
                <span className="text-sm font-bold">
                  Rename {itemToRename.type === 'directory' ? 'Folder' : 'File'}
                </span>
                <button
                  onClick={closeRenameDialog}
                  className="p-1 rounded hover:bg-stone-700 text-stone-400"
                >
                  <X size={14} />
                </button>
              </div>
              <div className="flex gap-2">
                <input
                  ref={renameInputRef}
                  type="text"
                  value={newName}
                  onChange={(e) => setNewName(e.target.value)}
                  onKeyDown={handleRenameKeyPress}
                  placeholder="New name"
                  className="flex-1 bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
                  disabled={isRenaming}
                />
                <button
                  onClick={renameItem}
                  disabled={isRenaming || !newName.trim() || newName === itemToRename.name}
                  className={`px-2 py-1 rounded text-xs ${
                    isRenaming || !newName.trim() || newName === itemToRename.name
                      ? 'bg-stone-700 text-stone-500 cursor-not-allowed'
                      : 'bg-teal-700 text-teal-100 hover:bg-teal-600'
                  }`}
                >
                  {isRenaming ? 'Renaming...' : 'Rename'}
                </button>
              </div>
            </div>
          )}
          
          {/* Delete file/folder confirmation dialog */}
          {showDeleteDialog && itemToDelete && (
            <div className="p-2 border-t border-stone-700 bg-stone-800">
              <div className="flex items-center justify-between mb-1">
                <span className="text-sm font-bold">
                  Delete {itemToDelete.type === 'directory' ? 'Folder' : 'File'}
                </span>
                <button
                  onClick={closeDeleteDialog}
                  className="p-1 rounded hover:bg-stone-700 text-stone-400"
                >
                  <X size={14} />
                </button>
              </div>
              <div className="mb-2 text-sm">
                <p>Are you sure you want to delete <span className="text-red-400 font-bold">{itemToDelete.name}</span>?</p>
                {itemToDelete.type === 'directory' && (
                  <p className="text-red-400 text-xs mt-1">This will delete all files and folders inside it!</p>
                )}
              </div>
              <div className="flex gap-2 justify-end">
                <button
                  onClick={closeDeleteDialog}
                  className="px-2 py-1 rounded text-xs bg-stone-700 hover:bg-stone-600"
                >
                  Cancel
                </button>
                <button
                  onClick={deleteItem}
                  disabled={isDeleting}
                  className={`px-2 py-1 rounded text-xs ${
                    isDeleting
                      ? 'bg-red-900 text-red-300 cursor-not-allowed'
                      : 'bg-red-700 text-red-100 hover:bg-red-600'
                  }`}
                >
                  {isDeleting ? 'Deleting...' : 'Delete'}
                </button>
              </div>
            </div>
          )}
          
          <div className="p-2 border-t border-stone-700 text-xs">
            {selectedFile ? selectedFile.path : currentPath}
          </div>
        </div>
        
        {/* File content panel (preview or edit) */}
        <div className="flex-1 flex flex-col overflow-hidden">
          {selectedFile ? (
            <>
              {/* Header with file name, status, and controls */}
              <div className="p-2 border-b border-stone-700 font-mono text-sm flex items-center justify-between">
                <div className="flex items-center">
                  <span className="mr-2">{selectedFile.name}</span>
                  {saveStatus === 'saving' && <span className="text-yellow-400 text-xs ml-2">Saving...</span>}
                  {saveStatus === 'saved' && <span className="text-green-400 text-xs ml-2">Saved</span>}
                  {saveStatus === 'error' && <span className="text-red-400 text-xs ml-2">Error!</span>}
                </div>
                
                {/* Only show edit/preview toggle for markdown files and admin users */}
                {selectedFile.name.endsWith('.md') && isAdmin && (
                  <div className="flex gap-2">
                    <button 
                      onClick={toggleEditMode}
                      className={`px-2 py-1 rounded text-xs flex items-center gap-1 ${editMode ? 'bg-teal-700 text-teal-100' : 'bg-stone-800 hover:bg-stone-700'}`}
                      title={editMode ? "Switch to preview mode" : "Switch to edit mode"}
                    >
                      {editMode ? <Eye size={14} /> : <Edit size={14} />}
                      {editMode ? 'Preview' : 'Edit'}
                    </button>
                    
                    {editMode && (
                      <button 
                        onClick={saveFileContent}
                        className="px-2 py-1 bg-stone-800 hover:bg-stone-700 rounded text-xs"
                        title="Save file"
                      >
                        Save
                      </button>
                    )}
                  </div>
                )}
              </div>
              
              {/* Error message */}
              {errorMessage && (
                <div className="p-2 bg-red-900 text-red-200 text-sm">
                  {errorMessage}
                </div>
              )}
              
              {/* Content area - either editor or preview */}
              {isContentLoading ? (
                <div className="flex-1 flex items-center justify-center">
                  <span className="text-teal-300">Loading content...</span>
                </div>
              ) : editMode && selectedFile.name.endsWith('.md') && isAdmin ? (
                // Editor mode - only for markdown files and admin users
                <div className="flex-1 flex flex-col">
                  {/* Markdown toolbar */}
                  <div className="p-2 border-b border-stone-700 bg-stone-800 flex flex-wrap gap-2">
                    <button 
                      onClick={() => insertMarkdown('### ')}
                      className="p-1 rounded hover:bg-stone-700 text-teal-400"
                      title="Heading"
                    >
                      <Heading size={16} />
                    </button>
                    <button 
                      onClick={() => insertMarkdown('**', '**')}
                      className="p-1 rounded hover:bg-stone-700 text-teal-400"
                      title="Bold"
                    >
                      <Bold size={16} />
                    </button>
                    <button 
                      onClick={() => insertMarkdown('*', '*')}
                      className="p-1 rounded hover:bg-stone-700 text-teal-400"
                      title="Italic"
                    >
                      <Italic size={16} />
                    </button>
                    <button 
                      onClick={() => insertMarkdown('`', '`')}
                      className="p-1 rounded hover:bg-stone-700 text-teal-400"
                      title="Inline Code"
                    >
                      <CodeIcon size={16} />
                    </button>
                    <button 
                      onClick={() => insertMarkdown('[', '](url)')}
                      className="p-1 rounded hover:bg-stone-700 text-teal-400"
                      title="Link"
                    >
                      <Link size={16} />
                    </button>
                    <span className="border-r border-stone-700 h-6"></span>
                    <button 
                      onClick={() => insertList('- ')}
                      className="p-1 rounded hover:bg-stone-700 text-teal-400"
                      title="Bullet List"
                    >
                      <List size={16} />
                    </button>
                    <button 
                      onClick={() => insertList('1. ')}
                      className="p-1 rounded hover:bg-stone-700 text-teal-400"
                      title="Numbered List"
                    >
                      <ListOrdered size={16} />
                    </button>
                    <button 
                      onClick={() => insertList('- [ ] ')}
                      className="p-1 rounded hover:bg-stone-700 text-teal-400"
                      title="Checklist"
                    >
                      <CheckSquare size={16} />
                    </button>
                  </div>
                  
                  <div className="flex-1 p-2">
                    <textarea
                      ref={textareaRef}
                      className="w-full h-full bg-stone-800 text-teal-50 p-4 resize-none focus:outline-none font-mono"
                      value={fileContent}
                      onChange={handleMarkdownChange}
                      onKeyDown={handleEditorKeyDown}
                      placeholder="# Start typing your markdown here..."
                    />
                  </div>
                </div>
              ) : showPreview ? (
                // Preview mode
                <div className="flex-1 overflow-auto p-4">
                  <div className="markdown-preview text-teal-50">
                    {selectedFile.name.endsWith('.md') ? (
                      <div 
                        dangerouslySetInnerHTML={{ 
                          __html: converter.makeHtml(fileContent) 
                        }} 
                        className="markdown-content"
                      />
                    ) : (
                      <pre className="font-mono text-sm whitespace-pre-wrap">
                        {fileContent}
                      </pre>
                    )}
                  </div>
                </div>
              ) : null}
            </>
          ) : (
            // No file selected
            <div className="flex items-center justify-center h-full text-stone-600">
              <div className="text-center">
                <FileText size={48} className="mx-auto mb-4" />
                <p>Select a markdown file to preview</p>
                <p className="text-xs mt-2">Use the 'preview' command to toggle preview mode</p>
                {isAdmin && <p className="text-xs mt-1">Admin users can use the 'edit' command to edit markdown files</p>}
              </div>
            </div>
          )}
        </div>
      </div>
      
      {/* Command input */}
      <div className="p-2 flex items-center gap-2 border-t border-stone-700">
        <span className="text-teal-400">$</span>
        <input
          ref={focusRef}
          type="text"
          onKeyDown={handleCommand}
          className="flex-1 bg-stone-800 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
        />
      </div>
    </div>
  );
};

export default ExplorerWindow;

================
File: windows/index.js
================
import TerminalWindow from './TerminalWindow';
import ExplorerWindow from './explorer/ExplorerWindow';
import withCommandHandling from '../../hocs/withCommandHandling';
import withWindowState from '../../hocs/withWindowState';
import withCommandInput from '../../hocs/withCommandInput';
import AudioWindow from './AudioWindow';
import ChatWindow from './ChatWindow';
import AdminWindow from './AdminWindow';
import CanvasWindow from './CanvasWindow';
import MarketplaceWindow from './MarketplaceWindow';
import { WINDOW_TYPES } from '../../utils/constants';

// Create enhanced versions of each window component by wrapping them with HOCs
// Terminal and Explorer already have command inputs, so we don't need to add them
export const EnhancedTerminalWindow = withWindowState(withCommandHandling(TerminalWindow), WINDOW_TYPES.TERMINAL);
export const EnhancedExplorerWindow = withWindowState(withCommandHandling(ExplorerWindow), WINDOW_TYPES.EXPLORER);

// For other windows, add the command input
export const EnhancedAudioWindow = withWindowState(withCommandHandling(withCommandInput(AudioWindow)), WINDOW_TYPES.AUDIO);
export const EnhancedChatWindow = withWindowState(withCommandHandling(withCommandInput(ChatWindow)), WINDOW_TYPES.CHAT);
export const EnhancedAdminWindow = withWindowState(withCommandHandling(withCommandInput(AdminWindow)), WINDOW_TYPES.ADMIN);
export const EnhancedCanvasWindow = withWindowState(withCommandHandling(CanvasWindow), WINDOW_TYPES.CANVAS);
export const EnhancedMarketplaceWindow = withWindowState(withCommandHandling(withCommandInput(MarketplaceWindow)), WINDOW_TYPES.MARKETPLACE);

// Also export the base components in case they're needed
export { TerminalWindow, ExplorerWindow, ChatWindow, AdminWindow, CanvasWindow, MarketplaceWindow };

================
File: windows/mapeditor/components/OpacitySlider.jsx
================
import React, { useState, useRef, useEffect } from 'react';
import '../styles/RangeSlider.css';

/**
 * Custom OpacitySlider component that provides better interaction handling
 * than the standard HTML range input in complex UI scenarios.
 */
const OpacitySlider = ({ value, onChange, className = '' }) => {
  // Refs for DOM elements
  const trackRef = useRef(null);
  const thumbRef = useRef(null);
  const containerRef = useRef(null);
  
  // State to track dragging status
  const [isDragging, setIsDragging] = useState(false);
  const [displayValue, setDisplayValue] = useState(value || 1.0);
  
  // Update display value when prop changes
  useEffect(() => {
    setDisplayValue(value || 1.0);
  }, [value]);
  
  // Calculate position based on value (0-1)
  const getThumbPosition = (val) => {
    return `${val * 100}%`;
  };
  
  // Calculate value from mouse/touch position
  const calculateValueFromPosition = (clientX) => {
    if (!trackRef.current) return 0;
    
    const rect = trackRef.current.getBoundingClientRect();
    const trackWidth = rect.width;
    const offset = clientX - rect.left;
    
    // Calculate value (0-1) based on position
    let newValue = offset / trackWidth;
    
    // Clamp value between 0 and 1
    newValue = Math.max(0, Math.min(1, newValue));
    
    // Round to nearest 0.05
    return Math.round(newValue * 20) / 20;
  };
  
  // Handle mouse/touch down
  const handleStart = (clientX) => {
    setIsDragging(true);
    const newValue = calculateValueFromPosition(clientX);
    setDisplayValue(newValue);
    if (onChange) onChange(newValue);
    
    // Add document-level event listeners
    document.addEventListener('mousemove', handleMove);
    document.addEventListener('mouseup', handleEnd);
    document.addEventListener('touchmove', handleTouchMove);
    document.addEventListener('touchend', handleEnd);
  };
  
  // Handle mouse/touch move
  const handleMove = (e) => {
    if (!isDragging) return;
    const newValue = calculateValueFromPosition(e.clientX);
    setDisplayValue(newValue);
    if (onChange) onChange(newValue);
  };
  
  // Handle touch move with proper event handling
  const handleTouchMove = (e) => {
    if (!isDragging || !e.touches[0]) return;
    const newValue = calculateValueFromPosition(e.touches[0].clientX);
    setDisplayValue(newValue);
    if (onChange) onChange(newValue);
  };
  
  // Handle mouse/touch up - end dragging
  const handleEnd = () => {
    setIsDragging(false);
    
    // Remove document-level event listeners
    document.removeEventListener('mousemove', handleMove);
    document.removeEventListener('mouseup', handleEnd);
    document.removeEventListener('touchmove', handleTouchMove);
    document.removeEventListener('touchend', handleEnd);
  };
  
  // Handle mouse down on track/thumb
  const handleMouseDown = (e) => {
    e.stopPropagation();
    e.preventDefault();
    handleStart(e.clientX);
  };
  
  // Handle touch start on track/thumb
  const handleTouchStart = (e) => {
    e.stopPropagation();
    if (e.touches[0]) {
      handleStart(e.touches[0].clientX);
    }
  };

  return (
    <div 
      className={`custom-slider-container ${className}`}
      ref={containerRef}
      onClick={e => e.stopPropagation()}
    >
      {/* Display percentage value */}
      <div className="flex items-center justify-between mb-2">
        <span className="text-xs text-stone-400" title="Adjust layer transparency">
          Opacity:
        </span>
        <span className="text-xs font-medium text-teal-300">
          {Math.round(displayValue * 100)}%
        </span>
      </div>
      
      {/* Slider track and thumb */}
      <div 
        className="custom-slider-track"
        ref={trackRef}
        onMouseDown={handleMouseDown}
        onTouchStart={handleTouchStart}
        onClick={e => e.stopPropagation()}
        style={{
          background: `linear-gradient(to right, #14b8a6 0%, #14b8a6 ${displayValue * 100}%, #44403c ${displayValue * 100}%, #44403c 100%)`
        }}
      >
        {/* Draggable thumb */}
        <div
          className="custom-slider-thumb"
          ref={thumbRef}
          style={{ left: getThumbPosition(displayValue) }}
          onMouseDown={handleMouseDown}
          onTouchStart={handleTouchStart}
        />
      </div>
    </div>
  );
};

export default OpacitySlider;

================
File: windows/mapeditor/LayerPanel.jsx
================
import React, { useState, useEffect, useRef } from 'react';
import { Eye, EyeOff, Layers, Plus, Trash2, ArrowUp, ArrowDown, Edit2, ChevronDown, ChevronUp } from 'lucide-react';
import TilePalette from './TilePalette';
import OpacitySlider from './components/OpacitySlider';

/**
 * Layer panel component for the Map Editor
 * Allows for managing layers (visibility, order, etc) and selecting tiles
 */
const LayerPanel = ({ 
  layers, 
  currentLayer, 
  setCurrentLayer, 
  onToggleLayerVisibility, 
  onAddLayer, 
  onRemoveLayer, 
  onMoveLayerUp, 
  onMoveLayerDown, 
  onRenameLayer,
  onUpdateLayerOpacity,
  selectedTileId = 0,
  onSelectTile,
  selectedRotation, // Add prop for receiving rotation state
  onRotateTile,     // Add prop for passing rotation handler
  currentTool,
  setCurrentTool,
  brushSize = 1,
  setBrushSize
}) => {
  // State for tracking which layer is being edited and the current edited name
  const [editingLayerIndex, setEditingLayerIndex] = useState(null);
  const [editedLayerName, setEditedLayerName] = useState('');
  const [expandedOpacityLayers, setExpandedOpacityLayers] = useState({});
  const layerNameInputRef = useRef(null);
  
  // Toggle opacity controls for a layer
  const toggleOpacityControls = (layerIndex, e) => {
    e.stopPropagation();
    setExpandedOpacityLayers(prev => ({
      ...prev,
      [layerIndex]: !prev[layerIndex]
    }));
  };
  
  // Focus input when editing starts
  useEffect(() => {
    if (editingLayerIndex !== null && layerNameInputRef.current) {
      layerNameInputRef.current.focus();
    }
  }, [editingLayerIndex]);
  
  // Handle starting the edit process
  const handleStartEditing = (e, layerIndex) => {
    e.stopPropagation();
    setEditingLayerIndex(layerIndex);
    setEditedLayerName(layers[layerIndex].name);
  };
  
  // Handle saving the edited name
  const handleSaveLayerName = (layerIndex) => {
    if (editedLayerName.trim()) {
      onRenameLayer(layerIndex, editedLayerName);
    }
    setEditingLayerIndex(null);
  };
  
  // Handle keydown events in the input field
  const handleInputKeyDown = (e, layerIndex) => {
    if (e.key === 'Enter') {
      handleSaveLayerName(layerIndex);
    } else if (e.key === 'Escape') {
      setEditingLayerIndex(null);
    }
  };

  return (
    <div className="w-64 bg-stone-800 border-l border-stone-700 flex flex-col overflow-hidden">
      {/* Brush Size Control */}
      <div className="p-2 border-b border-stone-700">
        <div className="flex items-center justify-between">
          <span className="text-sm text-teal-400">BRUSH SIZE:</span>
          <div className="flex items-center">
            <button
              onClick={() => setBrushSize(Math.max(1, brushSize - 1))}
              className="px-2 py-0.5 bg-stone-700 hover:bg-stone-600 rounded-l text-teal-300 text-xs focus:outline-none"
            >
              -
            </button>
            <input
                type="number"
                value={brushSize}
                onChange={(e) => {
                  const value = parseInt(e.target.value, 10);
                  if (!isNaN(value) && value > 0) setBrushSize(value);
                }}
                className="w-10 bg-stone-700 text-xs text-teal-100 px-1 py-0.5 border-x-0 focus:outline-none text-center
                          [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                min="1"
                max="10"
              />
            <button
              onClick={() => setBrushSize(Math.min(10, brushSize + 1))}
              className="px-2 py-0.5 bg-stone-700 hover:bg-stone-600 rounded-r text-teal-300 text-xs focus:outline-none"
            >
              +
            </button>
          </div>
        </div>
        <div className="text-xs text-stone-400 mt-1">
          {brushSize}×{brushSize}
        </div>
      </div>
      
      {/* Tile Type and Palette Section */}
      <div className="border-b border-stone-700">
        <TilePalette 
          selectedTileId={selectedTileId}
          onSelectTile={onSelectTile}
          selectedRotation={selectedRotation} // Pass rotation state down
          onRotateTile={onRotateTile}         // Pass rotation handler down
          tileType={currentTool}
          onChangeTileType={setCurrentTool}
        />
      </div>
      <div className="p-2 border-b border-stone-700 font-mono text-sm flex items-center justify-between">
        <div className="flex items-center">
          <Layers size={14} className="mr-2" />
          <span>LAYERS</span>
        </div>
        <button
          onClick={onAddLayer}
          className="p-1 rounded hover:bg-stone-700 text-teal-400"
          title="Add new layer"
        >
          <Plus size={16} />
        </button>
      </div>
      
      <div className="flex-1 overflow-auto">
        {layers && layers.length > 0 ? (
          <div className="p-2">
            {/* Show layers in reverse order so top layer is shown first */}
            {[...layers].reverse().map((layer, idx) => {
              // Calculate the actual index
              const actualIndex = layers.length - 1 - idx;
              const isActive = currentLayer === actualIndex;
              
              return (
                <div 
                  key={`layer-${actualIndex}`}
                  className={`mb-2 p-2 rounded border ${
                    isActive 
                      ? 'bg-stone-700 border-teal-500 text-teal-300' 
                      : 'bg-stone-800 border-stone-700 text-teal-50 hover:bg-stone-700'
                  }`}
                  onClick={() => setCurrentLayer(actualIndex)}
                >
                  <div className="flex items-center justify-between">
                    <div className="flex items-center">
                      {/* Layer visibility toggle */}
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          onToggleLayerVisibility(actualIndex);
                        }}
                        className="mr-2 hover:bg-stone-600 p-1 rounded"
                        title={layer.visible ? "Hide layer" : "Show layer"}
                      >
                        {layer.visible ? <Eye size={14} /> : <EyeOff size={14} />}
                      </button>
                      
                      {/* Layer name - either editable or static */}
                      {editingLayerIndex === actualIndex ? (
                        <input
                          ref={layerNameInputRef}
                          className="bg-stone-600 text-sm text-teal-100 px-1 py-0.5 rounded border border-teal-500 focus:outline-none"
                          value={editedLayerName}
                          onChange={(e) => setEditedLayerName(e.target.value)}
                          onKeyDown={(e) => handleInputKeyDown(e, actualIndex)}
                          onBlur={() => handleSaveLayerName(actualIndex)}
                          onClick={(e) => e.stopPropagation()}
                          size={15}
                        />
                      ) : (
                        <span className="text-sm">{layer.name}</span>
                      )}
                    </div>
                    
                    {/* Layer operations */}
                    <div className="flex">
                      {/* Toggle opacity controls button */}
                      <button
                        onClick={(e) => toggleOpacityControls(actualIndex, e)}
                        className={`p-1 hover:bg-stone-600 rounded ${expandedOpacityLayers[actualIndex] ? 'bg-stone-600' : ''}`}
                        title="Toggle opacity controls"
                      >
                        {expandedOpacityLayers[actualIndex] ? 
                          <ChevronUp size={14} /> : 
                          <ChevronDown size={14} />
                        }
                      </button>
                      <button
                        onClick={(e) => handleStartEditing(e, actualIndex)}
                        className="p-1 hover:bg-stone-600 rounded"
                        title="Rename layer"
                      >
                        <Edit2 size={14} />
                      </button>
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          onMoveLayerUp(actualIndex);
                        }}
                        className="p-1 hover:bg-stone-600 rounded"
                        title="Move layer up"
                        disabled={actualIndex === layers.length - 1}
                      >
                        <ArrowUp size={14} className={actualIndex === layers.length - 1 ? "opacity-30" : ""} />
                      </button>
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          onMoveLayerDown(actualIndex);
                        }}
                        className="p-1 hover:bg-stone-600 rounded"
                        title="Move layer down"
                        disabled={actualIndex === 0}
                      >
                        <ArrowDown size={14} className={actualIndex === 0 ? "opacity-30" : ""} />
                      </button>
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          onRemoveLayer(actualIndex);
                        }}
                        className="p-1 hover:bg-red-900 rounded text-red-400 hover:text-red-300"
                        title="Delete layer"
                        disabled={layers.length <= 1}
                      >
                        <Trash2 size={14} className={layers.length <= 1 ? "opacity-30" : ""} />
                      </button>
                    </div>
                  </div>
                  
                  {/* Opacity controls - only shown when expanded */}
                  {expandedOpacityLayers[actualIndex] && (
                    <div 
                      className="mt-2 px-1 pt-2 border-t border-stone-600" 
                      onClick={e => e.stopPropagation()}
                    >
                      <div className="flex items-center">
                        <div className="text-xs text-stone-400 mr-2 w-14">Opacity:</div>
                        
                        {/* Numeric input */}
                        <div className="flex items-center">
                          <input
                            type="text"
                            value={Math.round((layer.opacity || 1.0) * 100)}
                            onChange={(e) => {
                              // Get the value as a number
                              let value = parseInt(e.target.value, 10);
                              
                              // Validate: ensure it's a number between 0-100
                              if (isNaN(value)) value = 100;
                              value = Math.max(0, Math.min(100, value));
                              
                              // Convert percentage to decimal (0-1 range) and update
                              const opacityValue = value / 100;
                              if (onUpdateLayerOpacity) {
                                onUpdateLayerOpacity(actualIndex, opacityValue);
                              }
                            }}
                            className="w-10 bg-stone-700 text-xs text-teal-100 px-1 py-0.5 rounded border border-stone-600 focus:border-teal-500 focus:outline-none text-center"
                            title="Layer opacity (0-100%)"
                          />
                          <span className="text-xs text-stone-400 ml-1">%</span>
                        </div>
                      </div>
                    </div>
                  )}
                </div>
              );
            })}
          </div>
        ) : (
          <div className="flex items-center justify-center h-full">
            <span className="text-stone-500">No layers defined</span>
          </div>
        )}
      </div>
      
      {/* Layer information */}
      <div className="p-2 border-t border-stone-700 text-xs">
        {layers && currentLayer !== undefined && layers[currentLayer] ? (
          <div>
            <div className="text-stone-400">Selected: {layers[currentLayer].name}</div>
            <div className="text-stone-400">Total cells: {layers[currentLayer].cells?.length || 0}</div>
          </div>
        ) : (
          <div className="text-stone-500">No layer selected</div>
        )}
      </div>
    </div>
  );
};

export default LayerPanel;

================
File: windows/mapeditor/MapCanvas.jsx
================
import React, { useRef, useEffect, useState, useLayoutEffect, useCallback } from 'react';
import { Grid } from 'lucide-react';
import { screenToGridCoordinates, gridToScreenCoordinates } from './utils/mapUtils';
import { getTileCoordinates, FLOOR_TILESET_PATH, WALL_TILESET_PATH, SHADOW_TILESET_PATH, TILE_SIZE, TILESET_COLS } from './utils/tileRegistry';

/**
 * The main canvas component for the Grid Map Editor
 * Handles rendering and interaction with the grid map
 */
const MapCanvas = ({ 
  mapData, 
  currentLayer, 
  currentTool, 
  selectedTileId = 0,
  selectedRotation = 0,
  onEdit, 
  showGrid = true, 
  resetViewRef,
  brushSize = 1,
  // Add the onViewportChange prop to save viewport changes
  onViewportChange = null
}) => {
  const containerRef = useRef(null);
  const canvasRef = useRef(null);
  // Initialize with default values, will be overridden if mapData contains viewport info
  const [gridSize, setGridSize] = useState(32);
  const [viewportOffset, setViewportOffset] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
  const [activeMouseButton, setActiveMouseButton] = useState(null);
  const [hoverCell, setHoverCell] = useState(null);
  const [canvasSize, setCanvasSize] = useState({ width: 800, height: 600 });
  const [isSpacePressed, setIsSpacePressed] = useState(false);
  const [floorTilesetImage, setFloorTilesetImage] = useState(null);
  const [wallTilesetImage, setWallTilesetImage] = useState(null);
  const [shadowTilesetImage, setShadowTilesetImage] = useState(null);
  const [actualColumns, setActualColumns] = useState(TILESET_COLS);

  const [initialViewportLoaded, setInitialViewportLoaded] = useState(false);

    // Function to save viewport changes
    const saveViewport = useCallback(() => {
      if (onViewportChange) {
        onViewportChange({
          x: viewportOffset.x,
          y: viewportOffset.y,
          scale: gridSize / 32 // Store scale as a ratio of the default grid size
        });
      }
    }, [viewportOffset, gridSize, onViewportChange]);
  
  // Reset view to origin (0,0) function
  const resetViewToOrigin = useCallback(() => {
    setViewportOffset({ x: 0, y: 0 });
  }, []);

  // Store the reset function in the provided ref
  useEffect(() => {
    if (resetViewRef) {
      resetViewRef.current = resetViewToOrigin;
    }
  }, [resetViewToOrigin, resetViewRef]);
  
  // Load the tileset images on component mount
  useEffect(() => {
    // Load floor tileset
    const floorImg = new Image();
    floorImg.onload = () => {
      // Calculate columns based on the image width
      const cols = Math.floor(floorImg.width / TILE_SIZE);
      console.log(`MapCanvas: Detected ${cols} columns in the floor sprite sheet`);
      
      // Batch state updates to avoid multiple re-renders
      setActualColumns(cols);
      setFloorTilesetImage(floorImg);
    };
    floorImg.onerror = () => console.error('Failed to load floor tileset');
    floorImg.src = FLOOR_TILESET_PATH;
    
    // Load wall tileset
    const wallImg = new Image();
    wallImg.onload = () => {
      setWallTilesetImage(wallImg);
      console.log('MapCanvas: Wall tileset loaded successfully');
    };
    wallImg.onerror = () => console.error('Failed to load wall tileset');
    wallImg.src = WALL_TILESET_PATH;

    const shadowImg = new Image();
    shadowImg.onload = () => {
      setShadowTilesetImage(shadowImg);
      console.log('MapCanvas: Shadow tileset loaded successfully');
    };
    shadowImg.onerror = () => console.error('Failed to load shadow tileset');
    shadowImg.src = SHADOW_TILESET_PATH;
  }, []);

  /**
   * Draw a tile on the canvas based on its type and tile ID
   * @param {CanvasRenderingContext2D} ctx - Canvas context
   * @param {number} x - X position on canvas
   * @param {number} y - Y position on canvas
   * @param {number} size - Size of the tile
   * @param {Object} cell - The cell data including type and tileId
   */
  // Pass showGrid to the drawTile function
  const drawTile = (ctx, x, y, size, cell) => {
    const { type, tileId, rotation = 0 } = cell;
    
    // Add debugging for rotation values
    if (rotation !== 0) {
      console.log(`Drawing cell at (${cell.x}, ${cell.y}) with rotation: ${rotation}°`);
    }
    
    // Handle floor tiles with tileset
    if (type === 'floor' && tileId !== undefined && floorTilesetImage) {
      // Calculate coordinates based on actual columns in the sheet
      // instead of using getTileCoordinates which might use the wrong column count
      const col = tileId % actualColumns;
      const row = Math.floor(tileId / actualColumns);
      const sourceX = col * TILE_SIZE;
      const sourceY = row * TILE_SIZE;
      
      // Handle rotation
      if (rotation !== 0) {
        // Save the current context state
        ctx.save();
        
        // Move to the center of the tile position
        ctx.translate(x + size/2, y + size/2);
        
        // Rotate the context by the specified angle (convert degrees to radians)
        const angleInRadians = (rotation * Math.PI) / 180;
        ctx.rotate(angleInRadians);
        
        // Draw the tile, but with coordinates adjusted to draw centered around origin
        ctx.drawImage(
          floorTilesetImage,
          sourceX, sourceY, TILE_SIZE, TILE_SIZE,
          -size/2, -size/2, size, size
        );
        
        // Restore the context to its original state
        ctx.restore();
        
        // Draw grid lines on top only if showGrid is true
        if (showGrid) {
          ctx.strokeStyle = '#44403c'; // Stone-700
          ctx.strokeRect(x, y, size, size);
        }
      } else {
        // No rotation, draw normally
        ctx.drawImage(
          floorTilesetImage,
          sourceX, sourceY, TILE_SIZE, TILE_SIZE,
          x, y, size, size
        );
        
        // Draw grid lines on top only if showGrid is true
        if (showGrid) {
          ctx.strokeStyle = '#44403c'; // Stone-700
          ctx.strokeRect(x, y, size, size);
        }
      }
      return;
    }
    
    // Handle wall tiles with tileset
    if (type === 'wall' && tileId !== undefined && wallTilesetImage) {
      // Calculate coordinates based on actual columns in the sheet
      const col = tileId % actualColumns;
      const row = Math.floor(tileId / actualColumns);
      const sourceX = col * TILE_SIZE;
      const sourceY = row * TILE_SIZE;
      
      // Handle rotation
      if (rotation !== 0) {
        // Save the current context state
        ctx.save();
        
        // Move to the center of the tile position
        ctx.translate(x + size/2, y + size/2);
        
        // Rotate the context by the specified angle (convert degrees to radians)
        const angleInRadians = (rotation * Math.PI) / 180;
        ctx.rotate(angleInRadians);
        
        // Draw the tile, but with coordinates adjusted to draw centered around origin
        ctx.drawImage(
          wallTilesetImage,
          sourceX, sourceY, TILE_SIZE, TILE_SIZE,
          -size/2, -size/2, size, size
        );
        
        // Restore the context to its original state
        ctx.restore();
        
        // Draw grid lines on top only if showGrid is true
        if (showGrid) {
          ctx.strokeStyle = '#44403c'; // Stone-700
          ctx.strokeRect(x, y, size, size);
        }
      } else {
        // No rotation, draw normally
        ctx.drawImage(
          wallTilesetImage,
          sourceX, sourceY, TILE_SIZE, TILE_SIZE,
          x, y, size, size
        );
        
        // Draw grid lines on top only if showGrid is true
        if (showGrid) {
          ctx.strokeStyle = '#44403c'; // Stone-700
          ctx.strokeRect(x, y, size, size);
        }
      }
      return;
    }

    // Handle shadow tiles with tileset
    if (type === 'shadow' && shadowTilesetImage) {
      // Calculate coordinates based on actual columns in the sheet
      const effectiveTileId = tileId !== undefined ? tileId : 0;
      const col = effectiveTileId  % actualColumns;
      const row = Math.floor(effectiveTileId  / actualColumns);
      const sourceX = col * TILE_SIZE;
      const sourceY = row * TILE_SIZE;
      
      // Handle rotation
      if (rotation !== 0) {
        // Save the current context state
        ctx.save();
        
        // Move to the center of the tile position
        ctx.translate(x + size/2, y + size/2);
        
        // Rotate the context by the specified angle (convert degrees to radians)
        const angleInRadians = (rotation * Math.PI) / 180;
        ctx.rotate(angleInRadians);
        
        // Draw the tile, but with coordinates adjusted to draw centered around origin
        ctx.drawImage(
          shadowTilesetImage,
          sourceX, sourceY, TILE_SIZE, TILE_SIZE,
          -size/2, -size/2, size, size
        );
        
        // Restore the context to its original state
        ctx.restore();
        
        // Draw grid lines on top only if showGrid is true
        if (showGrid) {
          ctx.strokeStyle = '#44403c'; // Stone-700
          ctx.strokeRect(x, y, size, size);
        }
      } else {
        // No rotation, draw normally
        ctx.drawImage(
          shadowTilesetImage,
          sourceX, sourceY, TILE_SIZE, TILE_SIZE,
          x, y, size, size
        );
        
        // Draw grid lines on top only if showGrid is true
        if (showGrid) {
          ctx.strokeStyle = '#44403c'; // Stone-700
          ctx.strokeRect(x, y, size, size);
        }
      }
      return;
    }
    
    // Fall back to original color-based rendering for other types
    switch(type) {
      case 'wall':
        // Fallback if wall tileset image failed to load or tileId is undefined
        ctx.fillStyle = '#6b7280'; // Gray
        ctx.fillRect(x, y, size, size);
        break;
      case 'floor':
        // Default floor if no tileId or image failed to load
        ctx.fillStyle = '#1e293b'; // Slate-800
        ctx.fillRect(x, y, size, size);
        break;
      case 'shadow':
        // Default floor if no tileId or image failed to load
        ctx.fillStyle = '#BF40BF'; // Slate-800
        ctx.fillRect(x, y, size, size);
        break;
      case 'door':
        // For doors, apply rotation to the whole door element
        if (rotation !== 0) {
          // Save the current context state
          ctx.save();
          
          // Move to the center of the tile position
          ctx.translate(x + size/2, y + size/2);
          
          // Rotate the context by the specified angle (convert degrees to radians)
          const angleInRadians = (rotation * Math.PI) / 180;
          ctx.rotate(angleInRadians);
          
          // Draw floor background
          ctx.fillStyle = '#1e293b'; // Slate background
          ctx.fillRect(-size/2, -size/2, size, size);
          
          // Draw door centered
          ctx.fillStyle = '#b45309'; // Amber-700
          ctx.fillRect(-size/4, -size/4, size/2, size/2);
          
          // Restore the context to its original state
          ctx.restore();
        } else {
          // Draw floor first (no rotation)
          ctx.fillStyle = '#1e293b'; // Slate background
          ctx.fillRect(x, y, size, size);
          // Then draw door
          ctx.fillStyle = '#b45309'; // Amber-700
          ctx.fillRect(x + size/4, y + size/4, size/2, size/2);
        }
        break;
      // Add more tile types as needed
      default:
        // Unknown tile type, draw placeholder
        ctx.fillStyle = '#ef4444'; // Red-500
        ctx.fillRect(x, y, size, size);
    }
    
    // Draw grid lines on top only if showGrid is true
    if (showGrid) {
      ctx.strokeStyle = '#44403c'; // Stone-700
      ctx.strokeRect(x, y, size, size);
    }
  };

  /**
   * Handle cell editing with a specific tool or the current selected tool
   */
  const handleCellEdit = (e, overrideTool) => {
    if (!canvasRef.current || !mapData || !onEdit) return;
    
    // Get mouse position relative to canvas
    const rect = canvasRef.current.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Convert to grid coordinates
    const gridCoords = screenToGridCoordinates(mouseX, mouseY, gridSize, viewportOffset);
        
    // Basic validation if the center point is outside map boundaries
    if (gridCoords.x < 0 || gridCoords.x >= mapData.width || 
        gridCoords.y < 0 || gridCoords.y >= mapData.height) {
      // Coordinates outside map boundary - do nothing
      return;
    }
    
    // Use the override tool if provided, otherwise use the current tool
    const toolToUse = overrideTool || currentTool;
    
    // Only edit if using a tool other than select
    if (toolToUse === 'select') return;
    
    // For brush size of 1, just edit the single cell
    if (brushSize === 1) {
  
      // Use the selectedRotation prop directly
      const rotation = parseInt(selectedRotation, 10) || 0;
      
      // CRITICAL DEBUG: Log the exact tileId being sent from MapCanvas
      console.log(`MapCanvas EDIT: At (${gridCoords.x}, ${gridCoords.y}) using tool=${toolToUse}, passing tileId=${selectedTileId}, rotation=${rotation}`);
      
      // This is especially important for shadow tiles
      if (toolToUse === 'shadow') {
        console.log(`SHADOW TILE EDIT: At (${gridCoords.x}, ${gridCoords.y}) tileId=${selectedTileId} - IMPORTANT! Verify this ID is preserved!`);
      }
      
      // Pass rotation and selectedTileId
      onEdit(gridCoords.x, gridCoords.y, toolToUse, rotation, selectedTileId);
  
      return;
    }
    
    // For larger brushes, always center around the hover cell
    // This matches the hover indicator logic for consistent behavior
    const halfBrush = Math.floor(brushSize / 2);
    
    // Calculate how to position the brush so the cursor is in the center
    // For even sizes, there's no true center cell, so we offset by half a cell
    const offset = brushSize % 2 === 0 ? 0.5 : 0;
    
    // Apply to all cells in the brush area
    for (let dy = -halfBrush + offset; dy < brushSize - halfBrush + offset; dy++) {
      for (let dx = -halfBrush + offset; dx < brushSize - halfBrush + offset; dx++) {
        const cellX = Math.floor(gridCoords.x + dx);
        const cellY = Math.floor(gridCoords.y + dy);
        
        // Skip if outside map boundaries
        if (cellX < 0 || cellX >= mapData.width || 
            cellY < 0 || cellY >= mapData.height) {
          continue;
        }
        
        // Edit this cell with the current rotation value from props
        const rotation = parseInt(selectedRotation, 10) || 0;
        
        // CRITICAL: For brush operations, also add logging for shadow tiles
        if (toolToUse === 'shadow') {
          console.log(`BRUSH: Shadow tile at (${cellX}, ${cellY}) with tileId=${selectedTileId}`);
        }
        
        onEdit(cellX, cellY, toolToUse, rotation, selectedTileId);
      }
    }
  };

  // Set up ResizeObserver to update canvas dimensions
  useLayoutEffect(() => {
    if (!containerRef.current) return;
    
    const updateCanvasSize = () => {
      if (containerRef.current) {
        const { width, height } = containerRef.current.getBoundingClientRect();
        setCanvasSize({ width, height });
      }
    };
    
    // Initial size update
    updateCanvasSize();
    
    // Set up ResizeObserver
    const resizeObserver = new ResizeObserver(entries => {
      if (entries.length > 0) {
        updateCanvasSize();
      }
    });
    
    resizeObserver.observe(containerRef.current);
    
    // Clean up
    return () => {
      resizeObserver.disconnect();
    };
  }, []);
  
  // Update hover cell when mouse moves
  const updateHoverCell = (e) => {
    if (!canvasRef.current || !mapData) return;
    
    const rect = canvasRef.current.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    const gridCoords = screenToGridCoordinates(mouseX, mouseY, gridSize, viewportOffset);
    
    // Only set hover cell if it's within map boundaries
    if (gridCoords.x >= 0 && gridCoords.x < mapData.width && 
        gridCoords.y >= 0 && gridCoords.y < mapData.height) {
      setHoverCell(gridCoords);
    } else {
      // Clear hover cell when outside map boundaries
      setHoverCell(null);
    }
  };

  // Handle keyboard events for spacebar
  useEffect(() => {
    const handleKeyDown = (e) => {
      // Space key
      if (e.key === ' ' || e.keyCode === 32) {
        setIsSpacePressed(true);
      }
    };

    const handleKeyUp = (e) => {
      // Space key
      if (e.key === ' ' || e.keyCode === 32) {
        setIsSpacePressed(false);
        setIsDragging(false);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  // Reference to the canvas context
  const ctxRef = useRef(null);
  
  // Function to draw the canvas contents
  const drawCanvas = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas || !mapData) return;
    
    const ctx = canvas.getContext('2d');
    ctxRef.current = ctx;
    
    const width = canvas.width;
    const height = canvas.height;

    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    
    // Background color
    ctx.fillStyle = '#1c1917'; // Stone-900 from Tailwind
    ctx.fillRect(0, 0, width, height);
    
    // Adjust for viewport offset
    const offsetX = viewportOffset.x;
    const offsetY = viewportOffset.y;
    
    // Draw default grid background - useful for visualizing empty spaces
    for (let x = 0; x < mapData.width; x++) {
      for (let y = 0; y < mapData.height; y++) {
        const screenX = Math.floor(x * gridSize + offsetX);
        const screenY = Math.floor(y * gridSize + offsetY);
        
        // Only draw if visible on screen
        if (screenX > -gridSize && screenX < width && 
            screenY > -gridSize && screenY < height) {
          // Draw a subtle background for all cells
          // ctx.fillStyle = '#0f172a'; // Very dark slate blue
          ctx.fillStyle = '#042f2e'; // Very dark slate blue
          ctx.fillRect(screenX, screenY, gridSize, gridSize);
        }
      }
    }
    
    // Draw a clear boundary around the map area
    const mapWidthPx = mapData.width * gridSize;
    const mapHeightPx = mapData.height * gridSize;
    const mapStartX = offsetX;
    const mapStartY = offsetY;
    
    // Draw boundary with more visible color
    ctx.strokeStyle = '#5eead4'; // Orange-500
    ctx.lineWidth = 2;
    ctx.strokeRect(mapStartX, mapStartY, mapWidthPx, mapHeightPx);
    
    // Add small corner markers for extra visibility
    const cornerSize = 8;
    ctx.fillStyle = '#5eead4'; // Orange-500
    
    // Top-left corner
    ctx.fillRect(mapStartX - 1, mapStartY - 1, cornerSize, cornerSize);
    
    // Top-right corner
    ctx.fillRect(mapStartX + mapWidthPx - cornerSize + 1, mapStartY - 1, cornerSize, cornerSize);
    
    // Bottom-left corner
    ctx.fillRect(mapStartX - 1, mapStartY + mapHeightPx - cornerSize + 1, cornerSize, cornerSize);
    
    // Bottom-right corner
    ctx.fillRect(mapStartX + mapWidthPx - cornerSize + 1, mapStartY + mapHeightPx - cornerSize + 1, cornerSize, cornerSize);
    
    // Draw map data (cells from each layer)
    if (mapData && mapData.layers && mapData.layers.length > 0) {
      // Render each visible layer from bottom to top
      mapData.layers.forEach((layer, layerIndex) => {
        if (!layer.visible) return;
        
        // Set layer opacity if defined, default to 1.0 (fully opaque)
        const layerOpacity = layer.opacity !== undefined ? layer.opacity : 1.0;
        ctx.globalAlpha = layerOpacity;
        
        // Draw cells
        layer.cells.forEach(cell => {
          // Calculate screen position for this cell
          const screenX = Math.floor(cell.x * gridSize + offsetX);
          const screenY = Math.floor(cell.y * gridSize + offsetY);
          
          // Draw the tile if it's visible on screen
          if (screenX > -gridSize && screenX < width && 
              screenY > -gridSize && screenY < height) {
            drawTile(ctx, screenX, screenY, gridSize, cell);
          }
        });
        
        // Highlight current layer with a subtle border if it matches the currentLayer (only if showGrid is true)
        if (layerIndex === currentLayer && showGrid) {
          // Make sure we use full opacity for the highlight, regardless of layer opacity
          ctx.globalAlpha = 1.0;
          ctx.strokeStyle = 'rgba(20, 184, 166, 0.5)'; // Teal with opacity
          ctx.lineWidth = 2;
          
          layer.cells.forEach(cell => {
            const screenX = Math.floor(cell.x * gridSize + offsetX);
            const screenY = Math.floor(cell.y * gridSize + offsetY);
            
            if (screenX > -gridSize && screenX < width && 
                screenY > -gridSize && screenY < height) {
              ctx.strokeRect(screenX, screenY, gridSize, gridSize);
            }
          });
        }
        
        // Reset global alpha to default (1.0) after drawing this layer
        ctx.globalAlpha = 1.0;
      });
    }
    
    // Draw grid on top (only if showGrid is true)
    if (showGrid) {
      ctx.strokeStyle = '#44403c'; // Stone-700 from Tailwind
      ctx.lineWidth = 1;
      
      // Calculate grid line positioning
      const gridOffsetX = offsetX % gridSize;
      const gridOffsetY = offsetY % gridSize;
      
      // Draw vertical lines
      for (let x = gridOffsetX; x < width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      
      // Draw horizontal lines
      for (let y = gridOffsetY; y < height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
    }
    
    // Draw hover highlight
    if (hoverCell) {
      // For brush size of 1, just highlight the single cell
      if (brushSize === 1) {
        const screenX = Math.floor(hoverCell.x * gridSize + offsetX);
        const screenY = Math.floor(hoverCell.y * gridSize + offsetY);
        
        ctx.fillStyle = 'rgba(20, 184, 166, 0.3)'; // Teal with opacity
        ctx.fillRect(screenX, screenY, gridSize, gridSize);
        
        // Show tool indicator
        ctx.fillStyle = '#14b8a6';
        ctx.font = '12px monospace';
        
        // If right mouse button is pressed, show "erase" as the tool
        const displayTool = activeMouseButton === 2 ? 'erase' : currentTool;
        ctx.fillText(displayTool, screenX + 5, screenY + 15);
      } else {
        // For larger brushes, always center around the hoverCell
        const halfBrush = Math.floor(brushSize / 2);
        
        // Calculate how to position the brush so the cursor is in the center
        // For even sizes, there's no true center cell, so we need to offset by half a cell
        const offset = brushSize % 2 === 0 ? 0.5 : 0;
        
        // Generate all cell positions that should be part of the brush
        for (let dy = -halfBrush + offset; dy < brushSize - halfBrush + offset; dy++) {
          for (let dx = -halfBrush + offset; dx < brushSize - halfBrush + offset; dx++) {
            const cellX = Math.floor(hoverCell.x + dx);
            const cellY = Math.floor(hoverCell.y + dy);
            
            // Skip if outside map boundaries
            if (cellX < 0 || cellX >= mapData.width || 
                cellY < 0 || cellY >= mapData.height) {
              continue;
            }
            
            // Calculate screen position (fixed to separate gridSize multiplication from offset)
            const screenX = Math.floor(cellX * gridSize) + offsetX;
            const screenY = Math.floor(cellY * gridSize) + offsetY;
            
            ctx.fillStyle = 'rgba(20, 184, 166, 0.3)'; // Teal with opacity
            ctx.fillRect(screenX, screenY, gridSize, gridSize);
          }
        }
        
        // Show tool indicator centered on the cursor position
        const indicatorX = Math.floor(hoverCell.x * gridSize) + offsetX;
        const indicatorY = Math.floor(hoverCell.y * gridSize) + offsetY;
        
        ctx.fillStyle = '#14b8a6';
        ctx.font = '12px monospace';
        
        // If right mouse button is pressed, show "erase" as the tool
        const displayTool = activeMouseButton === 2 ? 'erase' : currentTool;
        ctx.fillText(`${displayTool} (${brushSize}×${brushSize})`, indicatorX + 5, indicatorY + 15);
      }
    }
  }, [
    gridSize, 
    viewportOffset, 
    mapData, 
    currentLayer, 
    hoverCell, 
    currentTool, 
    activeMouseButton, 
    showGrid, 
    floorTilesetImage,
    wallTilesetImage,
    shadowTilesetImage,
    actualColumns,
    // selectedRotation, // Removed: Toolbar rotation shouldn't trigger full canvas redraw
    brushSize  // Add brushSize as a dependency too for completeness
  ]);
  
  // Call drawCanvas whenever relevant dependencies change
  useEffect(() => {
    if (canvasRef.current && mapData) {
      drawCanvas();
    }
  }, [drawCanvas]);
  
  // Update canvas size when container size changes
  useEffect(() => {
    if (canvasRef.current && canvasSize.width > 0 && canvasSize.height > 0) {
      drawCanvas();
    }
  }, [canvasSize, drawCanvas]);

  // Manually trigger a redraw whenever tileset images are loaded
  // Breaking the circular dependency by removing drawCanvas from dependencies
  useEffect(() => {
    if ((floorTilesetImage || wallTilesetImage || shadowTilesetImage) && canvasRef.current && mapData) {
      // Call drawCanvas without adding it to dependency array
      drawCanvas();
    }
  }, [floorTilesetImage, wallTilesetImage, shadowTilesetImage, mapData]); // Removed drawCanvas dependency

  // Handle canvas mouse events
  const handleMouseDown = (e) => {
    // Prevent context menu on right click
    if (e.button === 2) {
      e.preventDefault();
    }
    
    setActiveMouseButton(e.button);
    
    // Middle mouse button (1) for panning
    if (e.button === 1) {
      setIsDragging(true);
      setDragStart({ x: e.clientX, y: e.clientY });
      e.preventDefault(); // Prevent default scrolling behavior for middle mouse button
    } 
    // Right mouse button (2) for erasing
    else if (e.button === 2 && !isSpacePressed) {
      handleCellEdit(e, 'erase');
    }
    // Left mouse button (0) for drawing with current tool
    else if (e.button === 0 && !isSpacePressed) {
      handleCellEdit(e);
    }
    // If space is pressed, start dragging regardless of which mouse button
    else if (isSpacePressed) {
      setIsDragging(true);
      setDragStart({ x: e.clientX, y: e.clientY });
    }
  };

  const handleMouseMove = (e) => {
    // Always update hover cell
    updateHoverCell(e);
    
    // Handle dragging for pan with middle mouse button (1),
    // or spacebar + any mouse button
    if (isDragging && (activeMouseButton === 1 || isSpacePressed)) {
      const dx = e.clientX - dragStart.x;
      const dy = e.clientY - dragStart.y;
      
      setViewportOffset({
        x: viewportOffset.x + dx,
        y: viewportOffset.y + dy
      });
      
      setDragStart({ x: e.clientX, y: e.clientY });
    }
    // Handle spacebar + mouse move (even without button press)
    else if (isSpacePressed && !isDragging) {
      // Start dragging when space is pressed and mouse moves
      setIsDragging(true);
      setDragStart({ x: e.clientX, y: e.clientY });
    }
    // Handle continuous drawing while left mouse button is down
    else if (activeMouseButton === 0 && !isSpacePressed) {
      handleCellEdit(e);
    }
    // Handle continuous erasing while right mouse button is down
    else if (activeMouseButton === 2 && !isSpacePressed) {
      handleCellEdit(e, 'erase');
    }
  };

  const handleMouseUp = () => {
    // Only stop dragging if we're not using spacebar navigation
    if (!isSpacePressed) {
      setIsDragging(false);
    }
    setActiveMouseButton(null);
  };

  const handleWheel = (e) => {
    // Get cursor position relative to canvas
    const rect = canvasRef.current.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Get grid coordinates under cursor before zoom
    const gridCoordsBefore = screenToGridCoordinates(mouseX, mouseY, gridSize, viewportOffset);
    
    // Calculate new grid size
    let newGridSize;
    if (e.deltaY < 0) {
      // Zoom in - increase grid size
      newGridSize = Math.min(gridSize + 4, 64);
    } else {
      // Zoom out - decrease grid size
      newGridSize = Math.max(gridSize - 4, 16);
    }
    
    // Calculate screen coordinates after zoom with the current viewport offset
    const screenCoordsAfter = {
      x: gridCoordsBefore.x * newGridSize + viewportOffset.x,
      y: gridCoordsBefore.y * newGridSize + viewportOffset.y
    };
    
    // Calculate the difference to maintain cursor position
    const dx = mouseX - screenCoordsAfter.x;
    const dy = mouseY - screenCoordsAfter.y;
    
    // Update grid size and adjust viewport offset
    setGridSize(newGridSize);
    setViewportOffset(prev => ({
      x: prev.x + dx,
      y: prev.y + dy
    }));
  };

  return (
    <div 
      ref={containerRef}
      className="flex-1 relative flex overflow-hidden bg-stone-900"
    >
      <div className="absolute top-2 left-2 bg-stone-800 p-2 rounded text-xs text-teal-400 flex items-center z-10">
        <Grid size={14} className="mr-1" />
        <span>Grid Size: {gridSize}px</span>
        {!showGrid && <span className="ml-2">(Grid Hidden)</span>}
      </div>
      
      <canvas 
        ref={canvasRef}
        width={canvasSize.width}
        height={canvasSize.height}
        className="w-full h-full border border-stone-700"
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        onWheel={handleWheel}
        onContextMenu={(e) => e.preventDefault()} // Prevent context menu on right click
      />
      <div className="absolute bottom-2 right-2 bg-stone-800 p-2 rounded text-xs text-teal-400 z-10">
        {currentTool && <span>Tool: {activeMouseButton === 2 ? 'erase' : currentTool}</span>}
        {hoverCell && <span className="ml-2">Position: ({hoverCell.x}, {hoverCell.y})</span>}
      </div>
    </div>
  );
};

export default MapCanvas;

================
File: windows/mapeditor/MapPropertiesPanel.jsx
================
import React, { useState } from 'react';
import { Grid, Save, Settings, X } from 'lucide-react';

/**
 * Panel for editing map properties
 */
const MapPropertiesPanel = ({ mapData, onApply, onCancel }) => {
  const [width, setWidth] = useState(mapData ? mapData.width : 20);
  const [height, setHeight] = useState(mapData ? mapData.height : 15);
  const [gridSize, setGridSize] = useState(mapData ? mapData.gridSize : 32);
  const [name, setName] = useState(mapData ? mapData.name : 'New Map');
  const [error, setError] = useState(null);

  // Validate input and apply changes
  const handleApply = () => {
    // Validate width and height
    if (width < 1 || width > 100) {
      setError('Width must be between 1 and 100');
      return;
    }
    
    if (height < 1 || height > 100) {
      setError('Height must be between 1 and 100');
      return;
    }
    
    if (gridSize < 16 || gridSize > 64) {
      setError('Grid size must be between 16 and 64');
      return;
    }
    
    // Apply changes
    onApply({
      width: Number(width),
      height: Number(height),
      gridSize: Number(gridSize),
      name
    });
  };

  // Handle input changes
  const handleInputChange = (setter) => (e) => {
    const value = e.target.value;
    if (value === '' || /^\d+$/.test(value)) {
      setter(value === '' ? '' : Number(value));
    }
  };

  return (
    <div className="bg-stone-800 border border-stone-700 rounded-lg p-4 w-64">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-teal-400 text-sm font-semibold flex items-center">
          <Settings size={16} className="mr-1" />
          Map Properties
        </h2>
        <button
          onClick={onCancel}
          className="text-stone-500 hover:text-stone-300"
        >
          <X size={16} />
        </button>
      </div>
      
      {error && (
        <div className="bg-red-900/30 text-red-400 p-2 rounded mb-3 text-xs">
          {error}
        </div>
      )}
      
      <div className="space-y-3">
        <div>
          <label className="block text-xs text-stone-400 mb-1">Map Name</label>
          <input
            type="text"
            value={name}
            onChange={(e) => setName(e.target.value)}
            className="w-full bg-stone-900 border border-stone-700 rounded px-2 py-1 text-sm text-teal-100 focus:outline-none focus:border-teal-600"
          />
        </div>
        
        <div>
          <label className="block text-xs text-stone-400 mb-1">Width (cells)</label>
          <input
            type="text"
            value={width}
            onChange={handleInputChange(setWidth)}
            className="w-full bg-stone-900 border border-stone-700 rounded px-2 py-1 text-sm text-teal-100 focus:outline-none focus:border-teal-600"
          />
        </div>
        
        <div>
          <label className="block text-xs text-stone-400 mb-1">Height (cells)</label>
          <input
            type="text"
            value={height}
            onChange={handleInputChange(setHeight)}
            className="w-full bg-stone-900 border border-stone-700 rounded px-2 py-1 text-sm text-teal-100 focus:outline-none focus:border-teal-600"
          />
        </div>
        
        <div>
          <label className="block text-xs text-stone-400 mb-1">Grid Size (pixels)</label>
          <input
            type="text"
            value={gridSize}
            onChange={handleInputChange(setGridSize)}
            className="w-full bg-stone-900 border border-stone-700 rounded px-2 py-1 text-sm text-teal-100 focus:outline-none focus:border-teal-600"
          />
        </div>
        
        <div className="pt-2 flex justify-end">
          <button
            onClick={handleApply}
            className="bg-teal-700 hover:bg-teal-600 text-teal-100 px-3 py-1 rounded text-xs flex items-center"
          >
            <Save size={14} className="mr-1" />
            Apply Changes
          </button>
        </div>
      </div>
    </div>
  );
};

export default MapPropertiesPanel;

================
File: windows/mapeditor/MapToolbar.jsx
================
import React, { useState, useEffect } from 'react';
import { 
  Save, Undo, Redo, Trash2, Copy, Square, Circle, 
  Grid, ZoomIn, ZoomOut, Download, Upload, Plus, Minus,
  Layers, MousePointer, Hammer, Wand2, FileText, Settings,
  Home
} from 'lucide-react';

/**
 * Toolbar component for the Map Editor
 */
const MapToolbar = ({ 
  onSave, 
  onUndo, 
  onRedo, 
  onClear, 
  onExportAscii, 
  onImportAscii,
  onToggleGrid,
  onResetView,
  showGrid = true,
  saveStatus = 'saved', // default to 'saved'
  mapData,
  onApplyProperties
}) => {
  const [showProperties, setShowProperties] = useState(false);
  const [mapName, setMapName] = useState(mapData?.name || 'New Map');
  const [mapWidth, setMapWidth] = useState(mapData?.width || 20);
  const [mapHeight, setMapHeight] = useState(mapData?.height || 15);
  const [mapGridSize, setMapGridSize] = useState(mapData?.gridSize || 32);
  const [error, setError] = useState(null);

  // Update state when mapData changes
  useEffect(() => {
    if (mapData) {
      setMapName(mapData.name || 'New Map');
      setMapWidth(mapData.width || 20);
      setMapHeight(mapData.height || 15);
      setMapGridSize(mapData.gridSize || 32);
    }
  }, [mapData]);

  // Handle applying property changes
  const handleApplyProperties = () => {
    // Validate inputs
    if (mapWidth < 1 || mapWidth > 100) {
      setError('Width must be between 1 and 100');
      return;
    }
    if (mapHeight < 1 || mapHeight > 100) {
      setError('Height must be between 1 and 100');
      return;
    }
    if (mapGridSize < 16 || mapGridSize > 64) {
      setError('Grid size must be between 16 and 64');
      return;
    }

    // Clear any errors
    setError(null);

    // Apply changes
    onApplyProperties({
      name: mapName,
      width: Number(mapWidth),
      height: Number(mapHeight),
      gridSize: Number(mapGridSize)
    });
  };

  // Handle number input changes with validation
  const handleNumberChange = (setter) => (e) => {
    const value = e.target.value;
    if (value === '' || /^\d+$/.test(value)) {
      setter(value === '' ? '' : Number(value));
    }
  };

  // Toggle properties panel
  const toggleProperties = () => {
    setShowProperties(!showProperties);
  };

  return (
    <>
      <div className="flex justify-between items-center p-2 bg-stone-800 border-b border-stone-700">
        {/* File operations */}
        <div className="flex space-x-1 items-center">
          <button 
            onClick={onSave}
            className="p-2 hover:bg-stone-700 rounded text-teal-400"
            title="Save map"
          >
            <Save size={18} />
          </button>
          <button 
            className="p-2 hover:bg-stone-700 rounded text-teal-400"
            title="Clear map"
            onClick={onClear}
          >
            <Trash2 size={18} />
          </button>
          <button 
            className="p-2 hover:bg-stone-700 rounded text-teal-400"
            title="Export as PNG"
          >
            <Download size={18} />
          </button>
          <button 
            className="p-2 hover:bg-stone-700 rounded text-teal-400"
            title="Import tileset"
          >
            <Upload size={18} />
          </button>
          <div className="h-6 border-r border-stone-700 mx-1"></div>
          <button 
            className="p-2 hover:bg-stone-700 rounded text-teal-400"
            title="Export as ASCII"
            onClick={onExportAscii}
          >
            <FileText size={18} />
          </button>
          <button 
            className="p-2 hover:bg-stone-700 rounded text-teal-400"
            title="Import from ASCII"
            onClick={onImportAscii}
          >
            <Upload size={18} />
          </button>
        </div>

        {/* Empty space in the middle to maintain layout */}
        <div className="flex-1"></div>

        {/* View options */}
        <div className="flex space-x-1">
          <button
            onClick={onToggleGrid}
            className={`p-2 hover:bg-stone-700 rounded ${
              showGrid ? 'text-teal-400' : 'text-stone-500'
            }`}
            title={showGrid ? "Hide grid" : "Show grid"}
          >
            <Grid size={18} />
          </button>
          <button
            onClick={onResetView}
            className="p-2 hover:bg-stone-700 rounded text-teal-400"
            title="Return to origin (0,0)"
          >
            <Home size={18} />
          </button>
          <button 
            className={`p-2 hover:bg-stone-700 rounded ${showProperties ? 'bg-stone-700 text-teal-300' : 'text-teal-400'}`}
            title="Map Properties"
            onClick={toggleProperties}
          >
            <Settings size={18} />
          </button>
        </div>
      </div>
      
      {/* Properties Panel - Expandable */}
      {showProperties && (
        <div className="bg-stone-800 border-b border-stone-700 p-2 grid grid-cols-5 gap-2 items-center text-sm">
          {error && (
            <div className="col-span-5 bg-red-900/30 text-red-400 p-2 rounded mb-2 text-xs">
              {error}
            </div>
          )}
          
          <div className="flex items-center">
            <label className="mr-2 text-stone-400">Width:</label>
            <input
              type="text"
              value={mapWidth}
              onChange={handleNumberChange(setMapWidth)}
              className="w-16 bg-stone-900 border border-stone-700 rounded px-2 py-1 text-sm text-teal-100 focus:outline-none focus:border-teal-600"
            />
          </div>
          
          <div className="flex items-center">
            <label className="mr-2 text-stone-400">Height:</label>
            <input
              type="text"
              value={mapHeight}
              onChange={handleNumberChange(setMapHeight)}
              className="w-16 bg-stone-900 border border-stone-700 rounded px-2 py-1 text-sm text-teal-100 focus:outline-none focus:border-teal-600"
            />
          </div>
          
          <div className="flex items-center">
            <label className="mr-2 text-stone-400">Grid Size:</label>
            <input
              type="text"
              value={mapGridSize}
              onChange={handleNumberChange(setMapGridSize)}
              className="w-16 bg-stone-900 border border-stone-700 rounded px-2 py-1 text-sm text-teal-100 focus:outline-none focus:border-teal-600"
            />
          </div>
          
          <div className="flex justify-end">
            <button
              onClick={handleApplyProperties}
              className="bg-teal-700 hover:bg-teal-600 text-white px-3 py-1 rounded text-xs flex items-center"
            >
              <Save size={14} className="mr-1" />
              Apply
            </button>
          </div>
        </div>
      )}
    </>
  );
};

export default MapToolbar;

================
File: windows/mapeditor/README.md
================
# Gridmap Editor for SlumTerm

This directory contains the implementation of the Gridmap Editor for the SlumTerm virtual tabletop system. The editor allows users to create and edit grid-based maps for tabletop role-playing games.

## Components

- **MapEditorWindow.jsx**: Main window component that integrates all subcomponents
- **MapCanvas.jsx**: Canvas component for rendering and interacting with the grid map
- **MapToolbar.jsx**: Toolbar with editing tools and file operations
- **LayerPanel.jsx**: Panel for managing layers (create, toggle visibility, reorder)
- **utils/mapUtils.js**: Utility functions for map operations

## Integration with SlumTerm

The Gridmap Editor is integrated with the SlumTerm system in a similar way to the Markdown Editor:

1. When a user clicks on a file with the `.map` extension in the file explorer, the MapEditorWindow will open
2. The MapEditorWindow loads the map data from the file and displays it in the grid view
3. Users can edit the map using various tools and save the changes back to the file

## Map File Format (.map)

Map files use a JSON format to store the grid data:

```json
{
  "version": "1.0",
  "name": "Map Name",
  "gridSize": 32,
  "width": 20,
  "height": 15,
  "defaultTile": "floor",
  "layers": [
    {
      "name": "terrain",
      "visible": true,
      "cells": [
        { "x": 0, "y": 0, "type": "wall" },
        { "x": 1, "y": 0, "type": "wall" }
      ]
    },
    {
      "name": "objects",
      "visible": true,
      "cells": [
        { "x": 2, "y": 1, "type": "door" }
      ]
    }
  ],
  "tokenPositions": [],
  "metadata": {
    "author": "username",
    "created": "ISO date",
    "modified": "ISO date"
  }
}
```

## Features

- **Grid-based editing**: Place walls, floors, doors, and other map elements on a grid
- **Layer management**: Create, rename, reorder, and toggle visibility of layers
- **Zoom and pan**: Adjust the view to focus on different parts of the map
- **File operations**: Create new maps, open existing maps, save changes

## Future Plans

- **Multiplayer support**: Allow multiple players to view and interact with the map
- **Token placement**: Add player and monster tokens to the map
- **Line of sight**: Implement fog of war and dynamic lighting
- **Map scripting**: Add interactivity to map elements

## Usage

1. Create a new `.map` file in the file explorer
2. Click on the file to open it in the Gridmap Editor
3. Use the toolbar to select tools for editing the map
4. Save your changes

## Development Notes

- The grid map editor uses the HTML Canvas API for rendering
- Map data is stored in JSON format compatible with the server's file system
- Map editing operations use immutable data patterns to avoid direct state mutation

================
File: windows/mapeditor/styles/RangeSlider.css
================
/* Original Input Slider styling */
.opacity-slider {
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 6px;
  background: #44403c;
  border-radius: 5px;
  outline: none;
  margin: 10px 0;
  cursor: pointer;
}

.opacity-slider::-webkit-slider-runnable-track {
  -webkit-appearance: none;
  appearance: none;
  height: 6px;
  border-radius: 5px;
}

.opacity-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #14b8a6;
  cursor: pointer;
  border: 2px solid #f8fafc;
  margin-top: -6px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.opacity-slider::-moz-range-thumb {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #14b8a6;
  cursor: pointer;
  border: 2px solid #f8fafc;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.opacity-slider::-moz-range-track {
  height: 6px;
  background: #44403c;
  border-radius: 5px;
}

.opacity-slider:focus {
  outline: none;
}

/* Custom Slider Component Styling */
.custom-slider-container {
  position: relative;
  width: 100%;
  padding: 6px 0;
  user-select: none;
  touch-action: none;
}

.custom-slider-track {
  position: relative;
  height: 6px;
  width: 100%;
  background: #44403c;
  border-radius: 4px;
  cursor: pointer;
  margin: 8px 0;
}

.custom-slider-thumb {
  position: absolute;
  top: 50%;
  width: 18px;
  height: 18px;
  background-color: #14b8a6;
  border-radius: 50%;
  border: 2px solid #f8fafc;
  transform: translate(-50%, -50%);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  cursor: grab;
  z-index: 2;
  transition: transform 0.1s, background-color 0.2s;
}

.custom-slider-thumb:hover {
  background-color: #0d9488;
  transform: translate(-50%, -50%) scale(1.1);
}

.custom-slider-thumb:active {
  background-color: #0f766e;
  cursor: grabbing;
  transform: translate(-50%, -50%) scale(1.15);
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
}

================
File: windows/mapeditor/TilePalette.jsx
================
import React, { useEffect, useState, useMemo, useRef, useCallback } from 'react';
import { 
  FLOOR_TILESET_PATH,
  WALL_TILESET_PATH,
  SHADOW_TILESET_PATH, // Import the shadow path
  TILE_SIZE,
  TILESET_COLS,
  getTileCoordinates, 
  getTileName, 
  TILE_SECTIONS,
  WALL_TILE_SECTIONS,
  SHADOW_TILE_SECTIONS
} from './utils/tileRegistry';
import { Heart, RotateCw, CheckCircle, XCircle } from 'lucide-react';
import axios from 'axios';
import API_CONFIG from '../../../config/api';

// Debug helper to log API requests and responses
const logApiCall = (method, url, status, data) => {
  console.log(`API ${method} ${url} - Status: ${status}`);
  console.log('Data:', data);
};

/**
 * Component for displaying and selecting tiles from a tileset
 */
const TilePalette = ({ 
  onSelectTile, 
  selectedTileId = 0, 
  tileType = 'floor',
  onChangeTileType,
  selectedRotation = 0,
  onRotateTile
}) => {
  // Local state to track rotation, will sync back to parent
  const [localRotation, setLocalRotation] = useState(selectedRotation);
  
  // Sync with parent's rotation when it changes
  useEffect(() => {
    setLocalRotation(selectedRotation);
  }, [selectedRotation]);
  const [favoriteTiles, setFavoriteTiles] = useState([]);
  const [isAddingToFavorites, setIsAddingToFavorites] = useState(false);
  const [addFavoriteError, setAddFavoriteError] = useState(null);
  const [isFavorited, setIsFavorited] = useState(false);
  const [floorTilesetImage, setFloorTilesetImage] = useState(null);
  const [wallTilesetImage, setWallTilesetImage] = useState(null);
  const [shadowTilesetImage, setShadowTilesetImage] = useState(null);
  const [loading, setLoading] = useState(true);
  const [currentSection, setCurrentSection] = useState(null); // Filter by section for floor
  const [currentWallSection, setCurrentWallSection] = useState(null); // Filter by section for wall
  const [currentShadowSection, setCurrentShadowSection] = useState(null);
  const [totalFloorTiles, setTotalFloorTiles] = useState(0);
  const [totalWallTiles, setTotalWallTiles] = useState(0);
  const [totalShadowTiles, setTotalShadowTiles] = useState(0); // Add state for shadow tiles count
  const [isInitialized, setIsInitialized] = useState(false);
  const initialTileTypeRef = useRef(tileType);
  const [showFavoritesSection, setShowFavoritesSection] = useState(true);
  
  // Available tile types
  const tileTypes = [
    { id: 'floor', name: 'Floor' },
    { id: 'wall', name: 'Wall' },
    { id: 'shadow', name: 'Shadow' },
    { id: 'door', name: 'Door' }
  ];
  
  // Store the initial tile type to handle first render properly
  useEffect(() => {
    initialTileTypeRef.current = tileType;
  }, []);

  // Track the actual columns detected in the image
  const [actualColumns, setActualColumns] = useState(TILESET_COLS);

  // Load favorite tiles when component mounts
  useEffect(() => {
    loadFavoriteTiles();
  }, []);

  // Check if the currently selected tile is a favorite
  useEffect(() => {
    checkIsFavorite();
  }, [selectedTileId, tileType]);

// Function to load favorite tiles
const loadFavoriteTiles = async () => {
  try {
    const token = localStorage.getItem('auth_token');
    if (!token) return;

    console.log('Fetching favorite tiles from:', `${API_CONFIG.BASE_URL}/favorite-tiles`);
    const response = await axios.get(
      `${API_CONFIG.BASE_URL}/favorite-tiles`,
      { headers: { Authorization: `Bearer ${token}` } }
    );

    logApiCall('GET', '/favorite-tiles', response.status, response.data);
    
    // Ensure we have an array, even if the response is unexpected
    if (Array.isArray(response.data)) {
      setFavoriteTiles(response.data);
    } else if (response.data && Array.isArray(response.data.favorites)) {
      setFavoriteTiles(response.data.favorites);
    } else {
      console.error('Unexpected response format for favorite tiles:', response.data);
      setFavoriteTiles([]);
    }
  } catch (error) {
    console.error('Error loading favorite tiles from server:', error);
    setFavoriteTiles([]);
  }
};

const debugTileIndexes = () => {
  if (!shadowTilesetImage) return;
  
  const cols = Math.floor(shadowTilesetImage.width / TILE_SIZE);
  const rows = Math.floor(shadowTilesetImage.height / TILE_SIZE);
  
  console.log('==== SHADOW TILE INDEX MAP ====');
  let output = '';
  for (let row = 0; row < rows; row++) {
    let rowOutput = '';
    for (let col = 0; col < cols; col++) {
      const index = row * cols + col;
      // Format to ensure alignment
      rowOutput += index.toString().padStart(3, ' ') + ' ';
    }
    output += rowOutput + '\n';
  }
  console.log(output);
  console.log('===============================');
};

// Call this in useEffect after loading
useEffect(() => {
  if (shadowTilesetImage) {
    debugTileIndexes();
  }
}, [shadowTilesetImage]);

// Function to check if selected tile is a favorite
const checkIsFavorite = async () => {
  try {
    const token = localStorage.getItem('auth_token');
    if (!token) return;

    const response = await axios.get(
      `${API_CONFIG.BASE_URL}/favorite-tiles/check/${selectedTileId}/${tileType}`,
      { headers: { Authorization: `Bearer ${token}` } }
    );

    logApiCall('GET', `/favorite-tiles/check/${selectedTileId}/${tileType}`, response.status, response.data);
    setIsFavorited(response.data.isFavorite);
  } catch (error) {
    console.error('Error checking favorite status from server:', error);
    setIsFavorited(false);
  }
};

// Function to add a tile to favorites
const addToFavorites = async () => {
  setIsAddingToFavorites(true);
  setAddFavoriteError(null);
  
  try {
    const token = localStorage.getItem('auth_token');
    if (!token) {
      setAddFavoriteError('Authentication required');
      setIsAddingToFavorites(false);
      return;
    }

    const response = await axios.post(
      `${API_CONFIG.BASE_URL}/favorite-tiles`,
      { tileIndex: selectedTileId, tileType },
      { headers: { 
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}` 
        } 
      }
    );
    
    logApiCall('POST', '/favorite-tiles', response.status, response.data);
    
    // Reload favorite tiles
    await loadFavoriteTiles();
    setIsFavorited(true);
  } catch (error) {
    console.error('Error adding tile to favorites:', error);
    setAddFavoriteError(error.response?.data?.message || 'Failed to add to favorites');
  } finally {
    setIsAddingToFavorites(false);
  }
};

// Function to remove a tile from favorites
const removeFromFavorites = async () => {
  try {
    const token = localStorage.getItem('auth_token');
    if (!token) return;

    const response = await axios.delete(
      `${API_CONFIG.BASE_URL}/favorite-tiles/${selectedTileId}/${tileType}`,
      { headers: { Authorization: `Bearer ${token}` } }
    );
    
    logApiCall('DELETE', `/favorite-tiles/${selectedTileId}/${tileType}`, response.status, response.data);
    
    // Reload favorite tiles
    await loadFavoriteTiles();
    setIsFavorited(false);
  } catch (error) {
    console.error('Error removing tile from favorites:', error);
  }
};

  // Render a tile canvas
  const renderTileCanvas = (tileIndex, tileType, size = 40, rotation = 0) => {
    const image = tileType === 'floor' ? floorTilesetImage : 
    tileType === 'wall' ? wallTilesetImage : 
    shadowTilesetImage;
    
    if (!image) return null;
    
    return (
      <canvas
        ref={canvas => {
          if (canvas && image) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, size, size);
            
            // Calculate coordinates based on actual columns in the sheet
            const col = tileIndex % actualColumns;
            const row = Math.floor(tileIndex / actualColumns);
            const sourceX = col * TILE_SIZE;
            const sourceY = row * TILE_SIZE;
            
            // Save the context state before transformations
            ctx.save();
            
            // Move to the center of the canvas for rotation
            ctx.translate(size/2, size/2);
            
            // Convert degrees to radians and rotate
            const angleInRadians = (rotation * Math.PI) / 180;
            ctx.rotate(angleInRadians);
            
            // Draw the image centered and rotated
            ctx.drawImage(
              image,
              sourceX, // sourceX
              sourceY, // sourceY
              TILE_SIZE, // sourceWidth
              TILE_SIZE, // sourceHeight
              -size/2, // destX (negative half-size to center)
              -size/2, // destY (negative half-size to center)
              size, // destWidth
              size  // destHeight
            );
            
            // Restore the context to its original state
            ctx.restore();
          }
        }}
        width={size}
        height={size}
        className="mx-auto"
        style={{ display: 'block' }}
      />
    );
  };
  
  // Load the tileset images
  useEffect(() => {
    let floorLoaded = false;
    let wallLoaded = false;
    let shadowLoaded = false;

    const checkAllLoaded = () => {
      if (floorLoaded && wallLoaded && shadowLoaded) {
        setLoading(false);
        setIsInitialized(true);
      }
    };

    // Load floor tileset
    const floorImg = new Image();
    floorImg.onload = () => {
      setFloorTilesetImage(floorImg);
      
      // Calculate total available tiles based on image dimensions
      const cols = Math.floor(floorImg.width / TILE_SIZE);
      const rows = Math.floor(floorImg.height / TILE_SIZE);
      const total = cols * rows;
      
      console.log(`Detected ${total} floor tiles (${cols}x${rows}) in the sprite sheet`);
      setActualColumns(cols); // Store the actual number of columns
      setTotalFloorTiles(total);
      floorLoaded = true;
      checkAllLoaded();
    };
    floorImg.onerror = () => {
      console.error('Failed to load floor tileset image');
      floorLoaded = true; // Still mark as loaded to prevent blocking
      checkAllLoaded();
    };
    floorImg.src = FLOOR_TILESET_PATH;
    
    // Load wall tileset
    const wallImg = new Image();
    wallImg.onload = () => {
      setWallTilesetImage(wallImg);
      
      // Calculate total available tiles based on image dimensions
      const cols = Math.floor(wallImg.width / TILE_SIZE);
      const rows = Math.floor(wallImg.height / TILE_SIZE);
      const total = cols * rows;
      
      console.log(`Detected ${total} wall tiles (${cols}x${rows}) in the sprite sheet`);
      setTotalWallTiles(total);
      wallLoaded = true;
      checkAllLoaded();
    };
    wallImg.onerror = () => {
      console.error('Failed to load wall tileset image');
      wallLoaded = true; // Still mark as loaded
      checkAllLoaded();
    };
    wallImg.src = WALL_TILESET_PATH;

    // Load shadow tileset
    const shadowImg = new Image();
    shadowImg.onload = () => {
      setShadowTilesetImage(shadowImg);
    
      // Calculate total available tiles based on image dimensions
      const cols = Math.floor(shadowImg.width / TILE_SIZE);
      const rows = Math.floor(shadowImg.height / TILE_SIZE);
      const total = cols * rows;
    
      // Purple console logs for better visibility
      console.log("%c 🟣 SHADOW TILESET: Detected " + total + " shadow tiles (" + cols + "×" + rows + ")", 
        "color: #9c27b0; font-weight: bold; background-color: #f3e5f5; padding: 5px; border-radius: 3px;");
      console.log("%c 🟣 SHADOW Image dimensions: " + shadowImg.width + "×" + shadowImg.height + "px", 
        "color: #9c27b0; font-weight: bold; background-color: #f3e5f5; padding: 5px; border-radius: 3px;");
      
      setTotalShadowTiles(total);
      shadowLoaded = true;
      checkAllLoaded();
    };
    shadowImg.src = SHADOW_TILESET_PATH;

  }, []); // Empty dependency array ensures this runs only once on mount

  // Force a re-render when the component first mounts (removed, handled by checkAllLoaded)
  // useEffect(() => { ... });
  
  // Get floor tiles to display based on current section filter
  const displayFloorTiles = useMemo(() => {
    if (currentSection === null) {
      // Show all tiles from the tileset - all positions are valid
      if (totalFloorTiles > 0) {
        // Simply create an array of indices from 0 to totalFloorTiles-1
        return Array.from({ length: totalFloorTiles }, (_, i) => i);
      }
      return [];
    } else {
      // Show only tiles from the selected section
      const section = TILE_SECTIONS[currentSection];
      return Array.from({ length: section.count }, (_, i) => section.startIndex + i);
    }
  }, [currentSection, totalFloorTiles]);
  
  // Get wall tiles to display based on current section filter
  const displayWallTiles = useMemo(() => {
    if (currentWallSection === null) {
      // Show all tiles from the tileset - all positions are valid
      if (totalWallTiles > 0) {
        // Simply create an array of indices from 0 to totalWallTiles-1
        return Array.from({ length: totalWallTiles }, (_, i) => i);
      }
      return [];
    } else {
      // Show only tiles from the selected section
      const section = WALL_TILE_SECTIONS[currentWallSection];
      return Array.from({ length: section.count }, (_, i) => section.startIndex + i);
    }
  }, [currentWallSection, totalWallTiles]);

  // Get shadow tiles to display based on current section filter
  const displayShadowTiles = useMemo(() => {
    if (currentShadowSection === null) {
      // Show all tiles from the tileset
      if (totalShadowTiles > 0) {
        return Array.from({ length: totalShadowTiles }, (_, i) => i);
      }
      return [];
    } else {
      const section = SHADOW_TILE_SECTIONS[currentShadowSection];
      return Array.from({ length: section.count }, (_, i) => section.startIndex + i);
    }
  }, [currentShadowSection, totalShadowTiles]);


  return (
    <div className="bg-stone-800 border-t border-stone-700 p-2 max-h-64 overflow-y-auto">
      {/* Tile Type Selector */}
      <div className="flex flex-col space-y-2 mb-4">
        <div className="flex justify-between items-center">
          <h3 className="text-sm font-mono text-teal-400">TILE TYPE</h3>
          
          {/* Buttons for Selected Tile */}
          <div className="flex items-center">
            {/* Rotate Button */}
            <button 
              className="text-blue-400 hover:text-blue-300 flex items-center mr-2"
              onClick={() => {
                console.log("Rotate button clicked!");
                // Keep track of the previous value for debugging
                console.log("Previous rotation value (local):", localRotation);
                console.log("Previous rotation value (props):", selectedRotation);
                
                // Calculate the new rotation value
                const newRotation = (localRotation + 90) % 360;
                console.log("New rotation value:", newRotation);
                
                // Update local state immediately for visual feedback
                setLocalRotation(newRotation);
                
                // Force update of the DOM display (safely)
                const debugElement = document.getElementById('debug-rotation-value');
                if (debugElement) {
                  debugElement.textContent = `Rotation set to: ${newRotation}°`;
                }
                
                // Update the local rotation display
                const tileRotationDisplay = document.getElementById('tile-rotation-display');
                if (tileRotationDisplay) {
                  tileRotationDisplay.textContent = `${newRotation}°`;
                }
                
                // Then notify parent (if callback exists) 
                if (typeof onRotateTile === 'function') {
                  console.log("Calling parent onRotateTile with:", newRotation);
                  // Pass the value explicitly (not relying on state)
                  onRotateTile(newRotation);
                } else {
                  console.warn("onRotateTile is not a function");
                  // If no callback, the local state update handles the visual feedback
                }
              }}
              title="Rotate tile"
            >
              <RotateCw size={16} className="mr-1" />
              <span className="text-xs" id="tile-rotation-display">{localRotation}°</span>
            </button>
            
            {/* Favorite Button */}
            {isFavorited ? (
              <button 
                className="text-pink-500 hover:text-pink-400 flex items-center mr-2"
                onClick={removeFromFavorites}
                title="Remove from favorites"
              >
                <Heart size={16} fill="currentColor" className="mr-1" />
                <span className="text-xs">Unfavorite</span>
              </button>
            ) : (
              <button 
                className="text-gray-400 hover:text-pink-500 flex items-center mr-2"
                onClick={addToFavorites}
                title="Add to favorites"
                disabled={isAddingToFavorites}
              >
                <Heart size={16} className="mr-1" />
                <span className="text-xs">{isAddingToFavorites ? 'Adding...' : 'Favorite'}</span>
              </button>
            )}
          </div>
        </div>
        
        {addFavoriteError && (
          <div className="text-red-500 text-xs mb-2">{addFavoriteError}</div>
        )}
        
        <select
          className="bg-stone-700 text-teal-300 text-sm rounded p-2 w-full border-none"
          value={tileType}
          onChange={(e) => onChangeTileType(e.target.value)}
        >
          {tileTypes.map(type => (
            <option key={type.id} value={type.id}>{type.name}</option>
          ))}
        </select>
      </div>
      
      {/* Favorite Tiles Section */}
      {Array.isArray(favoriteTiles) && favoriteTiles.length > 0 && (
        <div className="mb-4">
          <div className="flex justify-between items-center mb-2">
            <h3 className="text-sm font-mono text-stone-400">FAVORITE TILES</h3>
            <button 
              className="text-xs text-stone-400 hover:text-stone-300"
              onClick={() => setShowFavoritesSection(!showFavoritesSection)}
            >
              {showFavoritesSection ? 'Hide' : 'Show'}
            </button>
          </div>
          
          {showFavoritesSection && (
            <div className="grid grid-cols-5 gap-1 justify-items-center mb-3">
              {Array.isArray(favoriteTiles) && favoriteTiles.map((tile) => (
                <div
                  key={`fav-${tile.tile_type}-${tile.tile_index}`}
                  className={`rounded cursor-pointer border ${
                    selectedTileId === tile.tile_index && tileType === tile.tile_type 
                      ? 'bg-teal-900 border-teal-500' 
                      : 'hover:bg-stone-700 border-transparent'
                  }`}
                  onClick={() => {
                    onSelectTile(tile.tile_index);
                    if (tile.tile_type !== tileType) {
                      onChangeTileType(tile.tile_type);
                    }
                  }}
                  title={getTileName(tile.tile_index, tile.tile_type)}
                >
                  <div className="w-10 h-10 bg-stone-900 relative overflow-hidden flex items-center justify-center">
                    {(tile.tile_type === 'floor' && floorTilesetImage) || 
                     (tile.tile_type === 'wall' && wallTilesetImage) ||
                     (tile.tile_type === 'shadow' && shadowTilesetImage)
                      ? renderTileCanvas(tile.tile_index, tile.tile_type, 40, selectedTileId === tile.tile_index && tileType === tile.tile_type ? selectedRotation : 0)
                      : <div className="w-full h-full flex items-center justify-center text-xs text-stone-500">Loading</div>
                    }
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      )}
      
      {/* Always include the floor section headings when floor type is selected */}
      {tileType === 'floor' && (
        <>
          <div className="flex justify-between items-center mb-2">
            <h3 className="text-sm font-mono text-teal-400">FLOORS</h3>
            
            {/* Section filter dropdown */}
            <select 
              className="bg-stone-700 text-teal-300 text-xs rounded p-1 border-none"
              value={currentSection || ""}
              onChange={(e) => setCurrentSection(e.target.value || null)}
            >
              <option value="">All Tiles</option>
              {Object.entries(TILE_SECTIONS).map(([key, section]) => (
                <option key={key} value={key}>{section.name}</option>
              ))}
            </select>
          </div>
        </>
      )}
      
      {/* Wall tile palette - shown when wall type is selected */}
      {tileType === 'wall' && (
        <>
          <div className="flex justify-between items-center mb-2">
            <h3 className="text-sm font-mono text-teal-400">WALLS</h3>
            
            {/* Section filter dropdown */}
            <select 
              className="bg-stone-700 text-teal-300 text-xs rounded p-1 border-none"
              value={currentWallSection || ""}
              onChange={(e) => setCurrentWallSection(e.target.value || null)}
            >
              <option value="">All Wall Tiles</option>
              {Object.entries(WALL_TILE_SECTIONS).map(([key, section]) => (
                <option key={key} value={key}>{section.name}</option>
              ))}
            </select>
          </div>
          
          {loading ? (
            <div className="text-center p-4 text-stone-400">Loading wall tiles...</div>
          ) : !wallTilesetImage ? (
            <div className="text-center p-4 text-red-400">Failed to load wall tile set</div>
          ) : (
            <div key={`wall-grid-${isInitialized ? 'ready' : 'loading'}`} className="grid grid-cols-5 gap-1 justify-items-center">
              {displayWallTiles.map(tileIndex => (
                <div
                  key={tileIndex}
                  className={`rounded cursor-pointer border ${
                    selectedTileId === tileIndex ? 'bg-teal-900 border-teal-500' : 'hover:bg-stone-700 border-transparent'
                  }`}
                  onClick={() => onSelectTile(tileIndex)}
                  title={getTileName(tileIndex, 'wall')}
                >
                  <div className="w-10 h-10 bg-stone-900 relative overflow-hidden flex items-center justify-center">
                    {renderTileCanvas(tileIndex, 'wall', 40, selectedTileId === tileIndex ? selectedRotation : 0)}
                  </div>
                </div>
              ))}
            </div>
          )}
        </>
      )}

      {/* Shadow tile palette - shown when shadow type is selected */}
      {tileType === 'shadow' && (
        <>
          <div className="flex justify-between items-center mb-2">
            <h3 className="text-sm font-mono text-teal-400">SHADOWS</h3>
            
            {/* Section filter dropdown */}
            <select 
              className="bg-stone-700 text-teal-300 text-xs rounded p-1 border-none"
              value={currentShadowSection || ""}
              onChange={(e) => setCurrentShadowSection(e.target.value || null)}
            >
              <option value="">All Shadow Tiles</option>
              {Object.entries(SHADOW_TILE_SECTIONS).map(([key, section]) => (
                <option key={key} value={key}>{section.name}</option>
              ))}
            </select>
          </div>
          
          {loading ? (
            <div className="text-center p-4 text-stone-400">Loading shadow tiles...</div>
          ) : !shadowTilesetImage ? (
            <div className="text-center p-4 text-red-400">Failed to load shadow tile set</div>
          ) : (
            <div key={`shadow-grid-${currentShadowSection}-${isInitialized ? 'ready' : 'loading'}`} className="grid grid-cols-5 gap-1 justify-items-center">
              {/* Use the defined displayShadowTiles */}
              {displayShadowTiles.map(tileIndex => (
                <div
                  key={`shadow-${tileIndex}`}
                  className={`rounded cursor-pointer border ${
                    selectedTileId === tileIndex ? 'bg-teal-900 border-teal-500' : 'hover:bg-stone-700 border-transparent'
                  }`}
                  onClick={() => {
                    console.log(`Shadow tile ${tileIndex} clicked`);
                    // Ensure both the tile ID and type are propagated
                    onSelectTile(tileIndex);
                    // This shouldn't be necessary if tileType is already 'shadow', but just to be sure
                    if (tileType !== 'shadow') {
                      onChangeTileType('shadow');
                    }
                }}
                title={getTileName(tileIndex, 'shadow')}
              >
                <div className="w-10 h-10 bg-stone-900 relative overflow-hidden flex items-center justify-center">
                  {renderTileCanvas(tileIndex, 'shadow', 40, selectedTileId === tileIndex ? selectedRotation : 0)}
                </div>
              </div>
              ))}
            </div>
          )}
        </>
      )}
      
      {/* Door tile simple selector - shown when door type is selected */}
      {tileType === 'door' && (
        <div className="mb-2">
          <h3 className="text-sm font-mono text-teal-400 mb-2">DOOR STYLE</h3>
          <div className="grid grid-cols-2 gap-2">
            <div 
              className="bg-stone-700 p-3 rounded cursor-pointer border-2 border-teal-500 text-center"
              onClick={() => onSelectTile(0)}
            >
              <div className="bg-slate-900 h-10 w-full flex items-center justify-center">
                <div className="bg-amber-700 h-5 w-8"></div>
              </div>
              <div className="mt-1 text-xs text-teal-300">Basic Door</div>
            </div>
          </div>
        </div>
      )}
      
      {/* Floor tile palette - shown when floor type is selected 
          The key addition forces a re-render when initialized changes */}
      {tileType === 'floor' && (
        loading ? (
          <div className="text-center p-4 text-stone-400">Loading tile set...</div>
        ) : !floorTilesetImage ? (
          <div className="text-center p-4 text-red-400">Failed to load tile set</div>
        ) : (
          <div key={`floor-grid-${isInitialized ? 'ready' : 'loading'}`} className="grid grid-cols-5 gap-1 justify-items-center">
            {displayFloorTiles.map(tileIndex => (
              <div
                key={tileIndex}
                className={`rounded cursor-pointer border ${
                  selectedTileId === tileIndex ? 'bg-teal-900 border-teal-500' : 'hover:bg-stone-700 border-transparent'
                }`}
                onClick={() => onSelectTile(tileIndex)}
                title={getTileName(tileIndex)}
              >
                <div className="w-10 h-10 bg-stone-900 relative overflow-hidden flex items-center justify-center">
                  {renderTileCanvas(tileIndex, 'floor', 40, selectedTileId === tileIndex ? selectedRotation : 0)}
                </div>
              </div>
            ))}
          </div>
        )
      )}
    </div>
  );
};

export default TilePalette;

================
File: windows/mapeditor/TilePaletteWithMarketplace.jsx
================
import React, { useEffect, useState, useMemo, useRef, useCallback } from 'react';
import { Heart, RotateCw, CheckCircle, XCircle, Store } from 'lucide-react';
import axios from 'axios';
import API_CONFIG from '../../../config/api';
import { 
  TILE_SIZE,
  getTileName,
  getTileCoordinates
} from './utils/tileRegistry';

// Import the dynamic tile registry
import dynamicTileRegistry from './utils/dynamicTileRegistry';

// Debug helper to log API requests and responses
const logApiCall = (method, url, status, data) => {
  console.log(`API ${method} ${url} - Status: ${status}`);
  console.log('Data:', data);
};

/**
 * Enhanced TilePalette component with marketplace integration
 */
const TilePaletteWithMarketplace = ({ 
  onSelectTile, 
  selectedTileId = 0, 
  tileType = 'floor',
  onChangeTileType,
  selectedRotation = 0,
  onRotateTile,
  createWindow
}) => {
  // Local state to track rotation, will sync back to parent
  const [localRotation, setLocalRotation] = useState(selectedRotation);
  
  // Sync with parent's rotation when it changes
  useEffect(() => {
    setLocalRotation(selectedRotation);
  }, [selectedRotation]);
  
  const [favoriteTiles, setFavoriteTiles] = useState([]);
  const [isAddingToFavorites, setIsAddingToFavorites] = useState(false);
  const [addFavoriteError, setAddFavoriteError] = useState(null);
  const [isFavorited, setIsFavorited] = useState(false);
  const [tilesetImages, setTilesetImages] = useState({});
  const [loading, setLoading] = useState(true);
  const [currentSection, setCurrentSection] = useState(null); // Filter by section for floor
  const [currentWallSection, setCurrentWallSection] = useState(null); // Filter by section for wall
  const [currentShadowSection, setCurrentShadowSection] = useState(null);
  const [sections, setSections] = useState({});
  const [isInitialized, setIsInitialized] = useState(false);
  const initialTileTypeRef = useRef(tileType);
  const [showFavoritesSection, setShowFavoritesSection] = useState(true);
  const [marketplaceStatus, setMarketplaceStatus] = useState('idle'); // 'idle', 'loading', 'success', 'error'
  
  // Available tile types
  const tileTypes = [
    { id: 'floor', name: 'Floor' },
    { id: 'wall', name: 'Wall' },
    { id: 'shadow', name: 'Shadow' },
    { id: 'door', name: 'Door' }
  ];
  
  // Store the initial tile type to handle first render properly
  useEffect(() => {
    initialTileTypeRef.current = tileType;
  }, []);

  // Initialize dynamic tile registry
  useEffect(() => {
    const initRegistry = async () => {
      setLoading(true);
      try {
        await dynamicTileRegistry.initializeTileRegistry();
        
        // Get all sections
        const allSections = dynamicTileRegistry.getAllSections();
        setSections(allSections);
        
        // Get images for each category
        const images = {
          floor: dynamicTileRegistry.getTilesetImageForCategory('floor'),
          wall: dynamicTileRegistry.getTilesetImageForCategory('wall'),
          shadow: dynamicTileRegistry.getTilesetImageForCategory('shadow')
        };
        setTilesetImages(images);
        
        setIsInitialized(true);
      } catch (error) {
        console.error('Error initializing dynamic tile registry:', error);
      } finally {
        setLoading(false);
      }
    };
    
    initRegistry();
  }, []);

  // Load favorite tiles when component mounts
  useEffect(() => {
    loadFavoriteTiles();
  }, []);

  // Check if the currently selected tile is a favorite
  useEffect(() => {
    checkIsFavorite();
  }, [selectedTileId, tileType]);

  // Function to load favorite tiles
  const loadFavoriteTiles = async () => {
    try {
      const token = localStorage.getItem('auth_token');
      if (!token) return;

      console.log('Fetching favorite tiles from:', `${API_CONFIG.BASE_URL}/favorite-tiles`);
      const response = await axios.get(
        `${API_CONFIG.BASE_URL}/favorite-tiles`,
        { headers: { Authorization: `Bearer ${token}` } }
      );

      logApiCall('GET', '/favorite-tiles', response.status, response.data);
      
      // Ensure we have an array, even if the response is unexpected
      if (Array.isArray(response.data)) {
        setFavoriteTiles(response.data);
      } else if (response.data && Array.isArray(response.data.favorites)) {
        setFavoriteTiles(response.data.favorites);
      } else {
        console.error('Unexpected response format for favorite tiles:', response.data);
        setFavoriteTiles([]);
      }
    } catch (error) {
      console.error('Error loading favorite tiles from server:', error);
      setFavoriteTiles([]);
    }
  };

  // Function to check if selected tile is a favorite
  const checkIsFavorite = async () => {
    try {
      const token = localStorage.getItem('auth_token');
      if (!token) return;

      const response = await axios.get(
        `${API_CONFIG.BASE_URL}/favorite-tiles/check/${selectedTileId}/${tileType}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );

      logApiCall('GET', `/favorite-tiles/check/${selectedTileId}/${tileType}`, response.status, response.data);
      setIsFavorited(response.data.isFavorite);
    } catch (error) {
      console.error('Error checking favorite status from server:', error);
      setIsFavorited(false);
    }
  };

  // Function to add a tile to favorites
  const addToFavorites = async () => {
    setIsAddingToFavorites(true);
    setAddFavoriteError(null);
    
    try {
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setAddFavoriteError('Authentication required');
        setIsAddingToFavorites(false);
        return;
      }

      const response = await axios.post(
        `${API_CONFIG.BASE_URL}/favorite-tiles`,
        { tileIndex: selectedTileId, tileType },
        { headers: { 
            'Content-Type': 'application/json',
            Authorization: `Bearer ${token}` 
          } 
        }
      );
      
      logApiCall('POST', '/favorite-tiles', response.status, response.data);
      
      // Reload favorite tiles
      await loadFavoriteTiles();
      setIsFavorited(true);
    } catch (error) {
      console.error('Error adding tile to favorites:', error);
      setAddFavoriteError(error.response?.data?.message || 'Failed to add to favorites');
    } finally {
      setIsAddingToFavorites(false);
    }
  };

  // Function to remove a tile from favorites
  const removeFromFavorites = async () => {
    try {
      const token = localStorage.getItem('auth_token');
      if (!token) return;

      const response = await axios.delete(
        `${API_CONFIG.BASE_URL}/favorite-tiles/${selectedTileId}/${tileType}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      logApiCall('DELETE', `/favorite-tiles/${selectedTileId}/${tileType}`, response.status, response.data);
      
      // Reload favorite tiles
      await loadFavoriteTiles();
      setIsFavorited(false);
    } catch (error) {
      console.error('Error removing tile from favorites:', error);
    }
  };

  // Function to open the marketplace window
  const openMarketplace = () => {
    if (createWindow) {
      setMarketplaceStatus('loading');
      
      try {
        // Create the marketplace window
        createWindow({
          type: 'marketplace',
          title: 'Tileset Marketplace',
          width: 900,
          height: 700
        });
        
        setMarketplaceStatus('success');
      } catch (error) {
        console.error('Error opening marketplace window:', error);
        setMarketplaceStatus('error');
      }
    } else {
      console.warn('createWindow function not provided');
      setMarketplaceStatus('error');
    }
  };

  // Function to refresh tilesets after marketplace changes
  const refreshTilesets = async () => {
    setLoading(true);
    try {
      await dynamicTileRegistry.refreshTileRegistry();
      
      // Get all sections
      const allSections = dynamicTileRegistry.getAllSections();
      setSections(allSections);
      
      // Get images for each category
      const images = {
        floor: dynamicTileRegistry.getTilesetImageForCategory('floor'),
        wall: dynamicTileRegistry.getTilesetImageForCategory('wall'),
        shadow: dynamicTileRegistry.getTilesetImageForCategory('shadow')
      };
      setTilesetImages(images);
      
      setMarketplaceStatus('success');
    } catch (error) {
      console.error('Error refreshing tilesets:', error);
      setMarketplaceStatus('error');
    } finally {
      setLoading(false);
    }
  };

  // Render a tile canvas
  const renderTileCanvas = (tileIndex, tileType, size = 40, rotation = 0) => {
    const image = tilesetImages[tileType];
    
    if (!image) return null;
    
    return (
      <canvas
        ref={canvas => {
          if (canvas && image) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, size, size);
            
            // Calculate coordinates
            const { sourceX, sourceY } = getTileCoordinates(tileIndex);
            
            // Save the context state before transformations
            ctx.save();
            
            // Move to the center of the canvas for rotation
            ctx.translate(size/2, size/2);
            
            // Convert degrees to radians and rotate
            const angleInRadians = (rotation * Math.PI) / 180;
            ctx.rotate(angleInRadians);
            
            // Draw the image centered and rotated
            ctx.drawImage(
              image,
              sourceX, // sourceX
              sourceY, // sourceY
              TILE_SIZE, // sourceWidth
              TILE_SIZE, // sourceHeight
              -size/2, // destX (negative half-size to center)
              -size/2, // destY (negative half-size to center)
              size, // destWidth
              size  // destHeight
            );
            
            // Restore the context to its original state
            ctx.restore();
          }
        }}
        width={size}
        height={size}
        className="mx-auto"
        style={{ display: 'block' }}
      />
    );
  };

  // Get tiles to display based on current section filter and tile type
  const displayTiles = useMemo(() => {
    if (!isInitialized) return [];
    
    const categorySections = sections[tileType] || {};
    
    let sectionFilter = null;
    if (tileType === 'floor') sectionFilter = currentSection;
    else if (tileType === 'wall') sectionFilter = currentWallSection;
    else if (tileType === 'shadow') sectionFilter = currentShadowSection;
    
    let result = [];
    
    // If no section filter, show all tiles for this category
    if (!sectionFilter) {
      // Collect all tiles from all sections
      for (const section of Object.values(categorySections)) {
        const { startIndex, count } = section;
        for (let i = 0; i < count; i++) {
          result.push(startIndex + i);
        }
      }
    } else {
      // Show only tiles from the selected section
      const section = categorySections[sectionFilter];
      if (section) {
        const { startIndex, count } = section;
        result = Array.from({ length: count }, (_, i) => startIndex + i);
      }
    }
    
    return result;
  }, [isInitialized, sections, tileType, currentSection, currentWallSection, currentShadowSection]);

  // Get section options for the dropdown
  const sectionOptions = useMemo(() => {
    if (!isInitialized) return [];
    
    const categorySections = sections[tileType] || {};
    
    return Object.entries(categorySections).map(([key, section]) => ({
      value: key,
      label: `${section.name} (${section.tilesetName})`
    }));
  }, [isInitialized, sections, tileType]);

  return (
    <div className="bg-stone-800 border-t border-stone-700 p-2 max-h-64 overflow-y-auto">
      {/* Tile Type Selector with Marketplace Button */}
      <div className="flex flex-col space-y-2 mb-4">
        <div className="flex justify-between items-center">
          <h3 className="text-sm font-mono text-teal-400">TILE TYPE</h3>
          
          {/* Buttons for Selected Tile */}
          <div className="flex items-center">
            {/* Marketplace Button */}
            <button 
              className="text-blue-400 hover:text-blue-300 flex items-center mr-2"
              onClick={() => {
                if (marketplaceStatus !== 'loading') {
                  openMarketplace();
                }
              }}
              title="Open Tileset Marketplace"
            >
              <Store size={16} className="mr-1" />
              <span className="text-xs">Marketplace</span>
            </button>
            
            {/* Refresh Button */}
            <button 
              className="text-green-400 hover:text-green-300 flex items-center mr-2"
              onClick={refreshTilesets}
              disabled={loading}
              title="Refresh Tilesets"
            >
              <RotateCw size={16} className={`mr-1 ${loading ? 'animate-spin' : ''}`} />
              <span className="text-xs">{loading ? 'Loading...' : 'Refresh'}</span>
            </button>
            
            {/* Rotate Button */}
            <button 
              className="text-blue-400 hover:text-blue-300 flex items-center mr-2"
              onClick={() => {
                // Calculate the new rotation value
                const newRotation = (localRotation + 90) % 360;
                
                // Update local state immediately for visual feedback
                setLocalRotation(newRotation);
                
                // Then notify parent (if callback exists) 
                if (typeof onRotateTile === 'function') {
                  onRotateTile(newRotation);
                }
              }}
              title="Rotate tile"
            >
              <RotateCw size={16} className="mr-1" />
              <span className="text-xs" id="tile-rotation-display">{localRotation}°</span>
            </button>
            
            {/* Favorite Button */}
            {isFavorited ? (
              <button 
                className="text-pink-500 hover:text-pink-400 flex items-center mr-2"
                onClick={removeFromFavorites}
                title="Remove from favorites"
              >
                <Heart size={16} fill="currentColor" className="mr-1" />
                <span className="text-xs">Unfavorite</span>
              </button>
            ) : (
              <button 
                className="text-gray-400 hover:text-pink-500 flex items-center mr-2"
                onClick={addToFavorites}
                title="Add to favorites"
                disabled={isAddingToFavorites}
              >
                <Heart size={16} className="mr-1" />
                <span className="text-xs">{isAddingToFavorites ? 'Adding...' : 'Favorite'}</span>
              </button>
            )}
          </div>
        </div>
        
        {addFavoriteError && (
          <div className="text-red-500 text-xs mb-2">{addFavoriteError}</div>
        )}
        
        {/* Tile Type Select */}
        <select
          className="bg-stone-700 text-teal-300 text-sm rounded p-2 w-full border-none"
          value={tileType}
          onChange={(e) => onChangeTileType(e.target.value)}
        >
          {tileTypes.map(type => (
            <option key={type.id} value={type.id}>{type.name}</option>
          ))}
        </select>
      </div>
      
      {/* Favorite Tiles Section */}
      {Array.isArray(favoriteTiles) && favoriteTiles.length > 0 && (
        <div className="mb-4">
          <div className="flex justify-between items-center mb-2">
            <h3 className="text-sm font-mono text-stone-400">FAVORITE TILES</h3>
            <button 
              className="text-xs text-stone-400 hover:text-stone-300"
              onClick={() => setShowFavoritesSection(!showFavoritesSection)}
            >
              {showFavoritesSection ? 'Hide' : 'Show'}
            </button>
          </div>
          
          {showFavoritesSection && (
            <div className="grid grid-cols-5 gap-1 justify-items-center mb-3">
              {Array.isArray(favoriteTiles) && favoriteTiles.map((tile) => (
                <div
                  key={`fav-${tile.tile_type}-${tile.tile_index}`}
                  className={`rounded cursor-pointer border ${
                    selectedTileId === tile.tile_index && tileType === tile.tile_type 
                      ? 'bg-teal-900 border-teal-500' 
                      : 'hover:bg-stone-700 border-transparent'
                  }`}
                  onClick={() => {
                    onSelectTile(tile.tile_index);
                    if (tile.tile_type !== tileType) {
                      onChangeTileType(tile.tile_type);
                    }
                  }}
                  title={getTileName(tile.tile_index, tile.tile_type)}
                >
                  <div className="w-10 h-10 bg-stone-900 relative overflow-hidden flex items-center justify-center">
                    {tilesetImages[tile.tile_type] 
                      ? renderTileCanvas(tile.tile_index, tile.tile_type, 40, selectedTileId === tile.tile_index && tileType === tile.tile_type ? selectedRotation : 0)
                      : <div className="w-full h-full flex items-center justify-center text-xs text-stone-500">Loading</div>
                    }
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      )}
      
      {/* Section filter dropdown */}
      <div className="flex justify-between items-center mb-2">
        <h3 className="text-sm font-mono text-teal-400">
          {tileType === 'floor' ? 'FLOORS' : 
          tileType === 'wall' ? 'WALLS' : 
          tileType === 'shadow' ? 'SHADOWS' : 
          tileType === 'door' ? 'DOORS' : 'TILES'}
        </h3>
        
        {/* Section filter dropdown */}
        {tileType !== 'door' && (
          <select 
            className="bg-stone-700 text-teal-300 text-xs rounded p-1 border-none"
            value={
              tileType === 'floor' ? currentSection || "" : 
              tileType === 'wall' ? currentWallSection || "" : 
              tileType === 'shadow' ? currentShadowSection || "" : ""
            }
            onChange={(e) => {
              const value = e.target.value || null;
              if (tileType === 'floor') setCurrentSection(value);
              else if (tileType === 'wall') setCurrentWallSection(value);
              else if (tileType === 'shadow') setCurrentShadowSection(value);
            }}
          >
            <option value="">All Tiles</option>
            {sectionOptions.map(option => (
              <option key={option.value} value={option.value}>{option.label}</option>
            ))}
          </select>
        )}
      </div>
      
      {/* Door tile simple selector */}
      {tileType === 'door' && (
        <div className="mb-2">
          <div className="grid grid-cols-2 gap-2">
            <div 
              className="bg-stone-700 p-3 rounded cursor-pointer border-2 border-teal-500 text-center"
              onClick={() => onSelectTile(0)}
            >
              <div className="bg-slate-900 h-10 w-full flex items-center justify-center">
                <div className="bg-amber-700 h-5 w-8"></div>
              </div>
              <div className="mt-1 text-xs text-teal-300">Basic Door</div>
            </div>
          </div>
        </div>
      )}
      
      {/* Tiles grid - shown for all tile types except door */}
      {tileType !== 'door' && (
        loading ? (
          <div className="text-center p-4 text-stone-400">Loading tile set...</div>
        ) : !tilesetImages[tileType] ? (
          <div className="text-center p-4 text-red-400">Failed to load tile set</div>
        ) : (
          <div className="grid grid-cols-5 gap-1 justify-items-center">
            {displayTiles.map(tileIndex => (
              <div
                key={tileIndex}
                className={`rounded cursor-pointer border ${
                  selectedTileId === tileIndex ? 'bg-teal-900 border-teal-500' : 'hover:bg-stone-700 border-transparent'
                }`}
                onClick={() => onSelectTile(tileIndex)}
                title={dynamicTileRegistry.getTileName(tileIndex, tileType)}
              >
                <div className="w-10 h-10 bg-stone-900 relative overflow-hidden flex items-center justify-center">
                  {renderTileCanvas(tileIndex, tileType, 40, selectedTileId === tileIndex ? selectedRotation : 0)}
                </div>
              </div>
            ))}
          </div>
        )
      )}
    </div>
  );
};

export default TilePaletteWithMarketplace;

================
File: windows/mapeditor/TilesetSelector.jsx
================
import React, { useState, useEffect } from 'react';
import { Image, Check, X } from 'lucide-react';

/**
 * Component for selecting and previewing available tilesets
 */
const TilesetSelector = ({ 
  onSelectTileset, 
  onClose,
  currentTileset
}) => {
  const [tilesets, setTilesets] = useState([]);
  const [loading, setLoading] = useState(true);
  const [selectedTileset, setSelectedTileset] = useState(currentTileset || null);
  const [error, setError] = useState(null);

  // Predefined tilesets from the oryx_ultimate_fantasy_1.2 folder
  useEffect(() => {
    // In a real app, this would be fetched from the server or file system
    const availableTilesets = [
      {
        id: 'uf_terrain',
        name: 'Fantasy Terrain',
        path: '/oryx_ultimate_fantasy_1.2/uf_terrain.png',
        preview: '/oryx_ultimate_fantasy_1.2/uf_terrain.png',
        tileSize: 48,
        cols: 16
      },
      {
        id: 'uf_items',
        name: 'Fantasy Items',
        path: '/oryx_ultimate_fantasy_1.2/uf_items.png',
        preview: '/oryx_ultimate_fantasy_1.2/uf_items.png',
        tileSize: 48,
        cols: 16
      },
      {
        id: 'uf_heroes',
        name: 'Fantasy Heroes',
        path: '/oryx_ultimate_fantasy_1.2/uf_heroes.png',
        preview: '/oryx_ultimate_fantasy_1.2/uf_heroes.png',
        tileSize: 48,
        cols: 16
      }
    ];

    setTilesets(availableTilesets);
    setLoading(false);
  }, []);

  const handleSelectTileset = (tileset) => {
    setSelectedTileset(tileset);
  };

  const handleConfirm = () => {
    if (!selectedTileset) {
      setError('Please select a tileset first');
      return;
    }
    onSelectTileset(selectedTileset);
    onClose();
  };

  return (
    <div className="bg-stone-800 border border-stone-700 rounded-lg p-4 w-full max-w-3xl">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-teal-400 text-lg font-semibold flex items-center">
          <Image size={20} className="mr-2" />
          Select Tileset
        </h2>
        <button
          onClick={onClose}
          className="text-stone-500 hover:text-stone-300"
        >
          <X size={20} />
        </button>
      </div>
      
      {error && (
        <div className="bg-red-900/30 text-red-400 p-2 rounded mb-3 text-sm">
          {error}
        </div>
      )}
      
      {loading ? (
        <div className="p-4 text-center text-stone-400">Loading available tilesets...</div>
      ) : (
        <div className="grid grid-cols-2 gap-4 mb-4">
          {tilesets.map(tileset => (
            <div 
              key={tileset.id}
              className={`p-3 rounded-lg cursor-pointer border ${
                selectedTileset?.id === tileset.id 
                  ? 'border-teal-500 bg-stone-700' 
                  : 'border-stone-700 hover:bg-stone-700/50'
              }`}
              onClick={() => handleSelectTileset(tileset)}
            >
              <div className="flex justify-between items-start mb-2">
                <h3 className="text-teal-300 font-medium">{tileset.name}</h3>
                {selectedTileset?.id === tileset.id && (
                  <Check size={16} className="text-teal-400" />
                )}
              </div>
              
              <div className="bg-stone-900 rounded h-32 flex items-center justify-center overflow-hidden">
                <img 
                  src={tileset.preview} 
                  alt={tileset.name}
                  className="max-w-full max-h-full object-contain"
                />
              </div>
              
              <div className="mt-2 text-xs text-stone-400">
                <div>Tile Size: {tileset.tileSize}px</div>
                <div>Columns: {tileset.cols}</div>
              </div>
            </div>
          ))}
        </div>
      )}
      
      <div className="flex justify-end space-x-2 mt-4 pt-3 border-t border-stone-700">
        <button
          onClick={onClose}
          className="px-4 py-2 bg-stone-700 hover:bg-stone-600 text-stone-300 rounded text-sm"
        >
          Cancel
        </button>
        <button
          onClick={handleConfirm}
          className="px-4 py-2 bg-teal-700 hover:bg-teal-600 text-white rounded text-sm flex items-center"
          disabled={!selectedTileset}
        >
          <Check size={16} className="mr-1" />
          Select Tileset
        </button>
      </div>
    </div>
  );
};

export default TilesetSelector;

================
File: windows/mapeditor/utils/dynamicTileRegistry.js
================
/**
 * Dynamic tile registry and helper functions for managing tileset images
 * This version supports loading tilesets from the server
 */
import axios from 'axios';
import API_CONFIG from '../../../../config/api';

// Tile dimensions and sprite sheet configuration
export const TILE_SIZE = 48; // Size of each tile in pixels
export const DEFAULT_TILESET_COLS = 16; // Default number of columns in the sprite sheet

// Import default tilesets for fallback
import defaultFloorTilesetImage from '../../../../assets/sheets/floors/uf_terrain_sheet.png';
import defaultWallTilesetImage from '/sheets/walls/uf_terrain_sheet_walls.png';
import defaultShadowTilesetImage from '/sheets/shadows/uf_terrain_shadows.png';

// Dynamic tileset registry
let tilesets = [];
let sections = {
  floor: {},
  wall: {},
  shadow: {},
  door: {},
  object: {}
};
let tilesetImages = {};
let selectedTilesets = [];
let initialized = false;

// Default sections (same as original tileRegistry)
export const DEFAULT_FLOOR_SECTIONS = {
  BLUE_FLOORS: { startIndex: 0, count: 5, name: "Blue Stone Floors" },
  GRAY_FLOORS: { startIndex: 16, count: 5, name: "Gray Stone Floors" },
  DARK_FLOORS: { startIndex: 32, count: 5, name: "Dark Stone Floors" },
  DIRT: { startIndex: 48, count: 2, name: "Dirt" },
  GRASS: { startIndex: 64, count: 2, name: "Grass" },
  SAND: { startIndex: 80, count: 2, name: "Sand" },
  STONE_PATTERN: { startIndex: 96, count: 3, name: "Stone Pattern" },
  CHECKERED: { startIndex: 112, count: 3, name: "Checkered" },
};

export const DEFAULT_WALL_SECTIONS = {
  STONE_WALLS: { startIndex: 0, count: 8, name: "Stone Walls" },
  BRICK_WALLS: { startIndex: 16, count: 8, name: "Brick Walls" },
  WOOD_WALLS: { startIndex: 32, count: 4, name: "Wooden Walls" },
};

export const DEFAULT_SHADOW_SECTIONS = {
  SHADOWS: { startIndex: 0, count: 4, name: "Shadows" }
};

/**
 * Initialize the tile registry with user-selected tilesets
 * @returns {Promise<boolean>} True if initialization succeeded
 */
export const initializeTileRegistry = async () => {
  if (initialized) return true;
  
  try {
    const token = localStorage.getItem('auth_token');
    if (!token) {
      console.log('No auth token found, using default tilesets');
      initializeWithDefaults();
      return true;
    }
    
    // Fetch user-selected tilesets
    console.log('Fetching user-selected tilesets from server...');
    const response = await axios.get(
      `${API_CONFIG.BASE_URL}/tilesets/user/selected`,
      { headers: { Authorization: `Bearer ${token}` } }
    );
    
    if (!response.data || !Array.isArray(response.data) || response.data.length === 0) {
      console.log('No selected tilesets found, using defaults');
      initializeWithDefaults();
      return true;
    }
    
    selectedTilesets = response.data;
    tilesets = response.data;
    
    // Process and organize sections by category
    for (const tileset of tilesets) {
      if (!tileset.sections || !Array.isArray(tileset.sections)) {
        console.warn(`Tileset ${tileset.id} has no sections`);
        continue;
      }
      
      // Preload tileset image
      const tilesetImage = new Image();
      tilesetImage.src = `${API_CONFIG.BASE_URL}${tileset.image_path}`;
      
      // Wait for image to load
      await new Promise((resolve) => {
        tilesetImage.onload = resolve;
        tilesetImage.onerror = () => {
          console.error(`Failed to load tileset image for ${tileset.name}`);
          resolve();
        };
      });
      
      // Store the image reference
      tilesetImages[tileset.id] = tilesetImage;
      
      // Organize sections by category
      for (const section of tileset.sections) {
        if (!sections[section.category]) {
          sections[section.category] = {};
        }
        
        const sectionKey = `${tileset.id}_${section.id}`;
        sections[section.category][sectionKey] = {
          tilesetId: tileset.id,
          sectionId: section.id,
          startIndex: section.start_index,
          count: section.count,
          name: section.section_name,
          tilesetName: tileset.name
        };
      }
    }
    
    console.log('Tile registry initialized with user tilesets');
    initialized = true;
    
    // If no tilesets were loaded successfully, fall back to defaults
    if (Object.keys(tilesetImages).length === 0) {
      console.warn('No tileset images were loaded, using defaults');
      initializeWithDefaults();
    }
    
    return true;
  } catch (error) {
    console.error('Failed to initialize tile registry:', error);
    // Fall back to default tilesets
    initializeWithDefaults();
    return false;
  }
};

/**
 * Initialize with default tilesets
 */
const initializeWithDefaults = () => {
  // Create default floor sections
  Object.entries(DEFAULT_FLOOR_SECTIONS).forEach(([key, section]) => {
    sections.floor[key] = {
      tilesetId: 'default_floor',
      sectionId: key,
      startIndex: section.startIndex,
      count: section.count,
      name: section.name,
      tilesetName: 'Default Floor Tileset'
    };
  });
  
  // Create default wall sections
  Object.entries(DEFAULT_WALL_SECTIONS).forEach(([key, section]) => {
    sections.wall[key] = {
      tilesetId: 'default_wall',
      sectionId: key,
      startIndex: section.startIndex,
      count: section.count,
      name: section.name,
      tilesetName: 'Default Wall Tileset'
    };
  });
  
  // Create default shadow sections
  Object.entries(DEFAULT_SHADOW_SECTIONS).forEach(([key, section]) => {
    sections.shadow[key] = {
      tilesetId: 'default_shadow',
      sectionId: key,
      startIndex: section.startIndex,
      count: section.count,
      name: section.name,
      tilesetName: 'Default Shadow Tileset'
    };
  });
  
  // Add default images
  tilesetImages['default_floor'] = defaultFloorTilesetImage;
  tilesetImages['default_wall'] = defaultWallTilesetImage;
  tilesetImages['default_shadow'] = defaultShadowTilesetImage;
  
  initialized = true;
};

/**
 * Get a tileset image for a specific category
 * @param {string} category - The tile category (floor, wall, shadow, etc.)
 * @param {string|null} tilesetId - Optional specific tileset ID
 * @returns {HTMLImageElement|null} - The tileset image or null if not found
 */
export const getTilesetImageForCategory = (category, tilesetId = null) => {
  // If a specific tileset ID is provided and exists, return that
  if (tilesetId && tilesetImages[tilesetId]) {
    return tilesetImages[tilesetId];
  }
  
  // Otherwise, find the first tileset that has sections for this category
  for (const tileset of tilesets) {
    if (tileset.sections && tileset.sections.some(s => s.category === category)) {
      if (tilesetImages[tileset.id]) {
        return tilesetImages[tileset.id];
      }
    }
  }
  
  // Fall back to default images
  if (category === 'floor') return tilesetImages['default_floor'] || defaultFloorTilesetImage;
  if (category === 'wall') return tilesetImages['default_wall'] || defaultWallTilesetImage;
  if (category === 'shadow') return tilesetImages['default_shadow'] || defaultShadowTilesetImage;
  
  // If no appropriate tileset found, return the default floor tileset as a last resort
  return tilesetImages['default_floor'] || defaultFloorTilesetImage;
};

/**
 * Get sections for a specific category
 * @param {string} category - The tile category (floor, wall, shadow, etc.)
 * @returns {Object} - Object of sections for the category
 */
export const getSectionsForCategory = (category) => {
  return sections[category] || {};
};

/**
 * Get all sections from all tilesets
 * @returns {Object} - Sections organized by category and tileset
 */
export const getAllSections = () => {
  return sections;
};

/**
 * Get all available categories
 * @returns {string[]} - Array of category names
 */
export const getCategories = () => {
  return Object.keys(sections).filter(category => 
    Object.keys(sections[category]).length > 0
  );
};

/**
 * Get tile coordinates in the sprite sheet
 * @param {number} tileIndex - The index of the tile
 * @param {number} cols - Number of columns in the sprite sheet
 * @returns {Object} - Object with source coordinates for the tile
 */
export const getTileCoordinates = (tileIndex, cols = DEFAULT_TILESET_COLS) => {
  const col = tileIndex % cols;
  const row = Math.floor(tileIndex / cols);
  
  return {
    sourceX: col * TILE_SIZE,
    sourceY: row * TILE_SIZE,
    sourceWidth: TILE_SIZE,
    sourceHeight: TILE_SIZE,
    col, 
    row
  };
};

/**
 * Gets a descriptive name for a tile based on its index
 * @param {number} tileIndex - The index of the tile
 * @param {string} tileType - The type of tile ('floor', 'wall', etc.)
 * @param {string|null} tilesetId - Optional specific tileset ID
 * @returns {string} A human-readable name for the tile
 */
export const getTileName = (tileIndex, tileType = 'floor', tilesetId = null) => {
  // Find which section this tile belongs to
  const categorySections = sections[tileType] || {};
  
  for (const [sectionKey, section] of Object.entries(categorySections)) {
    // Skip sections from other tilesets if a specific tileset ID is provided
    if (tilesetId && section.tilesetId !== tilesetId) continue;
    
    if (tileIndex >= section.startIndex && tileIndex < section.startIndex + section.count) {
      const tileNumber = tileIndex - section.startIndex + 1;
      return `${section.name} ${tileNumber} (${section.tilesetName})`;
    }
  }
  
  // Fallback if no section matches
  return `${tileType.charAt(0).toUpperCase() + tileType.slice(1)} Tile ${tileIndex}`;
};

/**
 * Get tilesets that have been selected by the user
 * @returns {Array} - Array of selected tilesets
 */
export const getSelectedTilesets = () => {
  return selectedTilesets;
};

/**
 * Check if the registry has been initialized
 * @returns {boolean} - True if initialized
 */
export const isInitialized = () => {
  return initialized;
};

/**
 * Force re-initialization of the tile registry
 * Useful when user selects new tilesets in the marketplace
 */
export const refreshTileRegistry = async () => {
  initialized = false;
  tilesets = [];
  sections = {
    floor: {},
    wall: {},
    shadow: {},
    door: {},
    object: {}
  };
  tilesetImages = {};
  selectedTilesets = [];
  
  // Re-initialize
  return await initializeTileRegistry();
};

export default {
  initializeTileRegistry,
  getTilesetImageForCategory,
  getSectionsForCategory,
  getAllSections,
  getCategories,
  getTileCoordinates,
  getTileName,
  getSelectedTilesets,
  isInitialized,
  refreshTileRegistry,
  TILE_SIZE,
  DEFAULT_TILESET_COLS
};

================
File: windows/mapeditor/utils/mapUtils.js
================
/**
 * Map editor utility functions
 */

/**
 * Creates a new empty map with default settings
 * @param {string} name - Name of the map
 * @param {number} width - Width of the map in cells
 * @param {number} height - Height of the map in cells
 * @param {number} gridSize - Size of each grid cell in pixels
 * @returns {Object} A new map object
 */
export const createEmptyMap = (name = 'New Map', width = 20, height = 15, gridSize = 32) => {
  return {
    version: '1.0',
    name,
    gridSize,
    width,
    height,
    defaultTile: 'floor',
    layers: [
      {
        name: 'terrain',
        visible: true,
        cells: []
      }
    ],
    tokenPositions: [],
    // Add viewport property with default values
    viewport: {
      x: 0,
      y: 0,
      scale: 1 // For zoom level
    },
    metadata: {
      author: 'user',
      created: new Date().toISOString(),
      modified: new Date().toISOString()
    }
  };
};

/**
 * Updates the viewport data in the map
 * @param {Object} mapData - The map data
 * @param {number} x - The viewport x position
 * @param {number} y - The viewport y position
 * @param {number} scale - The viewport scale/zoom level
 * @returns {Object} The updated map data
 */
export const updateViewport = (mapData, x, y, scale) => {
  if (!mapData) return mapData;
  
  // Clone the map data to avoid direct state mutation
  const newMapData = { ...mapData };
  
  // Create or update viewport property
  newMapData.viewport = {
    x: x !== undefined ? x : (mapData.viewport?.x || 0),
    y: y !== undefined ? y : (mapData.viewport?.y || 0),
    scale: scale !== undefined ? scale : (mapData.viewport?.scale || 1)
  };
  
  return newMapData;
};

/**
 * Parses a map file string into a map object
 * @param {string} mapContent - The string content of the map file
 * @returns {Object} The parsed map object
 * @throws {Error} If the map file is invalid
 */
export const parseMapFile = (mapContent) => {
  try {
    const mapData = JSON.parse(mapContent);
    
    // Validate the map structure
    if (!mapData.version || !mapData.layers || !Array.isArray(mapData.layers)) {
      throw new Error('Invalid map file format');
    }
    
    // Ensure viewport property exists
    if (!mapData.viewport) {
      console.log("Adding missing viewport data during loading");
      mapData.viewport = { x: 0, y: 0, scale: 1 };
    }
    
    // Ensure all cells have a rotation property and shadow cells have tileId
    mapData.layers.forEach(layer => {
      if (layer.cells && Array.isArray(layer.cells)) {
        layer.cells.forEach(cell => {
          // If rotation doesn't exist, add it with default value of 0
          if (cell.rotation === undefined) {
            cell.rotation = 0;
          } else {
            // Ensure rotation is a number
            cell.rotation = Number(cell.rotation);
          }
          
          // If it's a shadow type but missing tileId, add default tileId
          if (cell.type === 'shadow' && cell.tileId === undefined) {
            cell.tileId = 0;
            console.log("Added missing tileId to shadow cell during loading:", cell);
          }
        });
      }
    });
    
    console.log("Parsed map data with proper rotation values:", mapData);
    return mapData;
  } catch (err) {
    console.error('Error parsing map file:', err);
    throw new Error('Failed to parse map file. It may be corrupted or in an invalid format.');
  }
};

/**
 * Serializes a map object to a string
 * @param {Object} mapData - The map object to serialize
 * @returns {string} The serialized map as a JSON string
 */
export const serializeMap = (mapData) => {
  try {
    // Update the modified timestamp
    const updatedMapData = {
      ...mapData,
      metadata: {
        ...mapData.metadata,
        modified: new Date().toISOString()
      }
    };
    
      // CRITICAL FIX: Process all cells to ensure they have rotation property and shadow cells have tileId
      if (updatedMapData.layers && Array.isArray(updatedMapData.layers)) {
        updatedMapData.layers = updatedMapData.layers.map(layer => {
          if (layer.cells && Array.isArray(layer.cells)) {
            layer.cells = layer.cells.map(cell => {
              let updatedCell = { ...cell };
              
              // Get the most current rotation value - prioritize global state
              const globalRotation = window.currentMapRotation;
              
              // If rotation doesn't exist, add it with current global value or default to 0
              if (updatedCell.rotation === undefined) {
                updatedCell.rotation = globalRotation !== undefined ? Number(globalRotation) : 0;
              }
              // If global rotation is set, use it to update existing cells
              else if (globalRotation !== undefined) {
                updatedCell.rotation = Number(globalRotation);
              }
              // Otherwise ensure rotation is a number (not string)
              else if (typeof updatedCell.rotation !== 'number') {
                updatedCell.rotation = Number(updatedCell.rotation);
              }
              
              // Debug shadow tile tileId values before serialization
              if (updatedCell.type === 'shadow') {
                console.log(`SERIALIZE: Shadow cell at (${updatedCell.x}, ${updatedCell.y}) has tileId: ${updatedCell.tileId}`);
                
                // Ensure shadow tiles always have a tileId property
                if (updatedCell.tileId === undefined) {
                  updatedCell.tileId = 0;
                  console.log(`WARNING: Missing tileId for shadow tile at (${updatedCell.x}, ${updatedCell.y}), defaulting to 0`);
                }
              }
              
              return updatedCell;
            });
          }
          return layer;
        });
      }
    
    // Ensure all shadow tiles have a valid tileId before serialization
    console.log("=== ENSURING SHADOW TILES HAVE TILEID BEFORE SERIALIZATION ===");
    let shadowTileCount = 0;
    updatedMapData.layers.forEach(layer => {
      if (layer.cells && Array.isArray(layer.cells)) {
        layer.cells.forEach(cell => {
          if (cell.type === 'shadow') {
            shadowTileCount++;
            // Make sure tileId is present and is a number
            if (cell.tileId === undefined || cell.tileId === null) {
              console.log(`FIXING: Shadow Cell (${cell.x}, ${cell.y}) missing tileId, setting to 0`);
              cell.tileId = 0;
            } else if (typeof cell.tileId !== 'number') {
              console.log(`FIXING: Shadow Cell (${cell.x}, ${cell.y}) has non-number tileId: ${cell.tileId}, converting to number`);
              cell.tileId = Number(cell.tileId);
            } else {
              console.log(`OK: Shadow Cell (${cell.x}, ${cell.y}) has tileId=${cell.tileId}`);
            }
          }
        });
      }
    });
    console.log(`Total shadow tiles processed: ${shadowTileCount}`);
    
    // Use a replacer function to ensure values are properly serialized
    const serialized = JSON.stringify(updatedMapData, (key, value) => {
      // Handle rotation to ensure it's always saved as a number
      if (key === 'rotation') {
        return value === undefined ? 0 : Number(value);
      }
      
      // No need for special tileId handling here since we've already 
      // ensured all shadow cells have a proper tileId value above
      return value;
    }, 2);
    
    // Debug the serialized output for shadow cells
    try {
      const parsed = JSON.parse(serialized);
      console.log("=== SHADOW CELLS AFTER SERIALIZATION (parsed back) ===");
      parsed.layers.forEach(layer => {
        layer.cells.forEach(cell => {
          if (cell.type === 'shadow') {
            console.log(`Serialized Shadow Cell (${cell.x}, ${cell.y}): tileId=${cell.tileId}, type=${typeof cell.tileId}`);
          }
        });
      });
    } catch (err) {
      console.error("Failed to parse serialized map for debug:", err);
    }
    
    return serialized;
  } catch (err) {
    console.error('Error serializing map:', err);
    throw new Error('Failed to serialize map data.');
  }
};

/**
 * Applies the saved viewport position to the canvas
 * @param {Object} mapData - The map data containing viewport information
 * @param {Object} canvas - The canvas element or rendering context
 * @param {Function} setViewportState - Optional callback to update viewport state in React/Vue
 * @returns {void}
 */
export const applyViewport = (mapData, canvas, setViewportState = null) => {
  if (!mapData || !mapData.viewport) return;
  
  const { x, y, scale } = mapData.viewport;
  
  // If you're using a canvas directly
  if (canvas && canvas.getContext) {
    const ctx = canvas.getContext('2d');
    // Reset any existing transformations
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    // Apply the saved viewport transformation
    ctx.setTransform(scale, 0, 0, scale, x, y);
  }
  
  // If you're using a state-based approach (React/Vue)
  if (setViewportState) {
    setViewportState({ x, y, scale });
  }
  
  console.log(`Applied viewport from map: x=${x}, y=${y}, scale=${scale}`);
};

/**
 * Finds a cell in a specific layer at the given coordinates
 * @param {Object} mapData - The map data
 * @param {number} layerIndex - The index of the layer to search in
 * @param {number} x - The x coordinate
 * @param {number} y - The y coordinate
 * @returns {Object|null} The cell object if found, null otherwise
 */
export const findCellInLayer = (mapData, layerIndex, x, y) => {
  if (!mapData || !mapData.layers || !mapData.layers[layerIndex]) return null;
  
  const layer = mapData.layers[layerIndex];
  return layer.cells.find(cell => cell.x === x && cell.y === y) || null;
};

/**
 * Adds or updates a cell in a layer
 * @param {Object} mapData - The map data
 * @param {number} layerIndex - The index of the layer to update
 * @param {number} x - The x coordinate
 * @param {number} y - The y coordinate
 * @param {string} type - The type of the cell
 * @param {number} tileId - The ID of the tile (optional)
 * @param {number} rotation - The rotation angle in degrees (0, 90, 180, 270) (optional)
 * @returns {Object} The updated map data
 */
export const setCellInLayer = (mapData, layerIndex, x, y, type, tileId, rotation = 0) => {
  if (!mapData || !mapData.layers || !mapData.layers[layerIndex]) return mapData;
  
  // Use global rotation state as fallback if available
  const rotationValue = rotation !== undefined ? rotation : (window.currentMapRotation || 0);
  
  // Ensure rotation is a number with explicit conversion
  const numRotation = parseInt(rotationValue, 10) || 0;
  
  console.log(`setCellInLayer called with: x=${x}, y=${y}, type=${type}, tileId=${tileId}`);
  console.log(`Using rotation: ${numRotation} (converted from ${rotation}, global=${window.currentMapRotation})`);
  
  // Clone the map data to avoid direct state mutation
  const newMapData = { ...mapData };
  const layerData = { ...newMapData.layers[layerIndex] };
  
  // Clone the cells array
  layerData.cells = [...layerData.cells];
  
  // Find if the cell already exists in this layer
  const existingCellIndex = layerData.cells.findIndex(cell => cell.x === x && cell.y === y);
  
  // Create cell data with required properties
  const cellData = { x, y, type };
  
  // For shadow tiles, always include tileId (using the provided tileId or defaulting to 0)
  // For other types, include tileId only if explicitly provided
  if (type === 'shadow') {
    // DEBUG: Log the incoming tileId value to track exactly what's being passed
    console.log(`EDIT: Shadow tile at (${x}, ${y}) - Incoming tileId: ${tileId}, type: ${typeof tileId}`);
    
    // CRITICAL FIX: Always explicitly set tileId for shadow tiles
    // Never default to 0 if tileId is provided
    cellData.tileId = tileId;
    
    // Debug the actual tileId value that was set
    console.log(`EDIT: Shadow tile tileId set to: ${cellData.tileId}`);
  } else if (tileId !== undefined) {
    // For non-shadow tiles, only include tileId if explicitly provided
    cellData.tileId = tileId;
  }
  
  // Always include rotation in the cell data, even if it's 0
  // This ensures rotation is explicitly stored in the map file
  cellData.rotation = numRotation;
  
  if (existingCellIndex !== -1) {
    console.log(`Updating existing cell at (${x}, ${y}) with rotation=${rotation}`);
    // Update existing cell, preserving any properties not explicitly changed
    let updatedCell = { 
      ...layerData.cells[existingCellIndex], 
      ...cellData 
    };
    
    // CRITICAL FIX: Double-check if this is a shadow cell and ensure tileId is defined
    if (updatedCell.type === 'shadow' && updatedCell.tileId === undefined) {
      updatedCell.tileId = tileId;
      console.log(`FIX: Shadow cell at (${x}, ${y}) missing tileId in update operation, explicitly setting to ${tileId}`);
    }
    
    // Update the cell in the array
    layerData.cells[existingCellIndex] = updatedCell;
    
    // Log the updated cell to verify all properties are properly set
    console.log("Updated cell:", layerData.cells[existingCellIndex]);
  } else {
    console.log(`Adding new cell at (${x}, ${y}) with rotation=${rotation}`);
    // Add new cell
    layerData.cells.push(cellData);
    
    // Log the added cell to verify rotation was properly set
    console.log("Added cell:", cellData);
  }
  
  // Update the layer in the map data
  newMapData.layers[layerIndex] = layerData;
  
  return newMapData;
};

/**
 * Removes a cell from a layer
 * @param {Object} mapData - The map data
 * @param {number} layerIndex - The index of the layer to update
 * @param {number} x - The x coordinate
 * @param {number} y - The y coordinate
 * @returns {Object} The updated map data
 */
export const removeCellFromLayer = (mapData, layerIndex, x, y) => {
  if (!mapData || !mapData.layers || !mapData.layers[layerIndex]) return mapData;
  
  // Clone the map data to avoid direct state mutation
  const newMapData = { ...mapData };
  const layerData = { ...newMapData.layers[layerIndex] };
  
  // Remove the cell if it exists
  layerData.cells = layerData.cells.filter(cell => !(cell.x === x && cell.y === y));
  
  // Update the layer in the map data
  newMapData.layers[layerIndex] = layerData;
  
  return newMapData;
};

/**
 * Gets all visible cells at a specific coordinate across all layers
 * @param {Object} mapData - The map data
 * @param {number} x - The x coordinate
 * @param {number} y - The y coordinate
 * @returns {Array} Array of cells at the coordinate, from bottom to top layer
 */
export const getCellsAtCoordinate = (mapData, x, y) => {
  if (!mapData || !mapData.layers) return [];
  
  const cells = [];
  
  mapData.layers.forEach((layer, index) => {
    if (layer.visible) {
      const cell = findCellInLayer(mapData, index, x, y);
      if (cell) {
        cells.push({ ...cell, layerIndex: index });
      }
    }
  });
  
  return cells;
};

/**
 * Converts screen coordinates to grid coordinates
 * @param {number} screenX - The x screen coordinate
 * @param {number} screenY - The y screen coordinate
 * @param {number} gridSize - The size of each grid cell
 * @param {Object} viewportOffset - The viewport offset { x, y }
 * @returns {Object} The grid coordinates { x, y }
 */
export const screenToGridCoordinates = (screenX, screenY, gridSize, viewportOffset) => {
  const gridX = Math.floor((screenX - viewportOffset.x) / gridSize);
  const gridY = Math.floor((screenY - viewportOffset.y) / gridSize);
  return { x: gridX, y: gridY };
};

/**
 * Converts grid coordinates to screen coordinates
 * @param {number} gridX - The x grid coordinate
 * @param {number} gridY - The y grid coordinate
 * @param {number} gridSize - The size of each grid cell
 * @param {Object} viewportOffset - The viewport offset { x, y }
 * @returns {Object} The screen coordinates { x, y }
 */
export const gridToScreenCoordinates = (gridX, gridY, gridSize, viewportOffset) => {
  const screenX = gridX * gridSize + viewportOffset.x;
  const screenY = gridY * gridSize + viewportOffset.y;
  return { x: screenX, y: screenY };
};

/**
 * Converts JSON map data to ASCII format for the roguelike game engine
 * @param {Object} mapData - The map data in JSON format
 * @returns {string} The map data in ASCII format
 */
export const convertMapToAscii = (mapData) => {
  // Create a 2D array filled with void spaces
  const width = mapData.width;
  const height = mapData.height;
  const asciiMap = Array(height).fill().map(() => Array(width).fill(' ')); // ' ' for void
  
  // Process each layer from bottom to top
  mapData.layers.forEach(layer => {
    if (!layer.visible) return;
    
    // Process each cell in the layer
    layer.cells.forEach(cell => {
      // Skip cells outside the map bounds
      if (cell.x < 0 || cell.x >= width || cell.y < 0 || cell.y >= height) return;
      
      // Map cell types to ASCII characters
      let asciiChar;
      switch(cell.type) {
        case 'wall':
          asciiChar = '#';
          break;
        case 'floor':
          asciiChar = '.';
          break;
        case 'door':
          asciiChar = '+';
          break;
        case 'grass':
          asciiChar = '"';
          break;
        case 'ashes':
          asciiChar = "'";
          break;
        case 'stairs':
          asciiChar = '>';
          break;
        case 'spawn':
          asciiChar = '@';
          break;
        default:
          // For unknown types, use a default character
          asciiChar = '?';
      }
      
      // Place the character in the grid
      asciiMap[cell.y][cell.x] = asciiChar;
    });
  });
  
  // Convert 2D array to string with newlines
  return asciiMap.map(row => row.join('')).join('\n');
};

/**
 * Converts ASCII map to JSON format
 * @param {string} asciiMap - The map data in ASCII format
 * @param {string} name - Optional name for the map
 * @returns {Object} The map data in JSON format
 */
export const convertAsciiToMap = (asciiMap, name = 'Imported Map') => {
  const lines = asciiMap.trim().split('\n');
  const height = lines.length;
  const width = lines.reduce((max, line) => Math.max(max, line.length), 0);
  
  // Create a basic map structure
  const mapData = createEmptyMap(name, width, height);
  
  // Create a terrain layer
  const terrainCells = [];
  
  // Process each character in the ASCII map
  for (let y = 0; y < lines.length; y++) {
    const line = lines[y];
    for (let x = 0; x < line.length; x++) {
      const char = line[x];
      let cellType;
      
      // Map ASCII characters to cell types
      switch(char) {
        case '#':
          cellType = 'wall';
          break;
        case '.':
          cellType = 'floor';
          break;
        case '+':
          cellType = 'door';
          break;
        case '"':
          cellType = 'grass';
          break;
        case "'":
          cellType = 'ashes';
          break;
        case '>':
          cellType = 'stairs';
          break;
        case '@':
          cellType = 'spawn';
          // Could also mark this as a player spawn point
          break;
        case ' ':
          // Void/empty space, skip
          continue;
        default:
          // Unknown character, interpret as custom type
          cellType = `custom-${char}`;
      }
      
      // Add the cell to the terrain layer
      terrainCells.push({ x, y, type: cellType });
    }
  }
  
  // Update the terrain layer with the cells
  mapData.layers[0].cells = terrainCells;
  
  return mapData;
};

================
File: windows/mapeditor/utils/tileRegistry.js
================
/**
 * Tile registry and helper functions for managing sprite sheet tiles
 */

// Import the tilesets directly
import terrainTilesetImage from '../../../../assets/sheets/floors/uf_terrain_sheet.png';
import wallTilesetImage from '/sheets/walls/uf_terrain_sheet_walls.png'; // Using absolute path from public folder
import shadowTilesetImage from '/sheets/shadows/uf_terrain_shadows.png'

// Tile dimensions and sprite sheet configuration
export const TILE_SIZE = 48; // Size of each tile in pixels
export const TILESET_COLS = 16; // Number of columns in the sprite sheet (adjust based on actual width)

// Path to the tilesets (using imported images)
export const FLOOR_TILESET_PATH = terrainTilesetImage;
export const WALL_TILESET_PATH = wallTilesetImage;
export const SHADOW_TILESET_PATH = shadowTilesetImage;

// Named sections for better organization
export const TILE_SECTIONS = {
  BLUE_FLOORS: { startIndex: 0, count: 5, name: "Blue Stone Floors" },
  GRAY_FLOORS: { startIndex: 16, count: 5, name: "Gray Stone Floors" },
  DARK_FLOORS: { startIndex: 32, count: 5, name: "Dark Stone Floors" },
  DIRT: { startIndex: 48, count: 2, name: "Dirt" },
  GRASS: { startIndex: 64, count: 2, name: "Grass" },
  SAND: { startIndex: 80, count: 2, name: "Sand" },
  STONE_PATTERN: { startIndex: 96, count: 3, name: "Stone Pattern" },
  CHECKERED: { startIndex: 112, count: 3, name: "Checkered" },
  // Add more sections as needed
};

// Wall tile sections
export const WALL_TILE_SECTIONS = {
  STONE_WALLS: { startIndex: 0, count: 8, name: "Stone Walls" },
  BRICK_WALLS: { startIndex: 16, count: 8, name: "Brick Walls" },
  WOOD_WALLS: { startIndex: 32, count: 4, name: "Wooden Walls" },
  // Add more wall sections as needed
};

export const SHADOW_TILE_SECTIONS = {
  SHADOWS: { startIndex: 0, count: 4, name: "Shadows" }
};

/**
 * Calculates pixel coordinates in the sprite sheet for a given tile index
 * @param {number} tileIndex - The index of the tile
 * @returns {Object} Object with source coordinates for the tile
 */
export const getTileCoordinates = (tileIndex) => {
  const col = tileIndex % TILESET_COLS;
  const row = Math.floor(tileIndex / TILESET_COLS);
  
  return {
    sourceX: col * TILE_SIZE,
    sourceY: row * TILE_SIZE,
    sourceWidth: TILE_SIZE,
    sourceHeight: TILE_SIZE,
    // Include calculated positions for easier debugging
    col, row
  };
};

/**
 * Gets a descriptive name for a tile based on its index
 * @param {number} tileIndex - The index of the tile
 * @param {string} tileType - The type of tile ('floor', 'wall', etc.)
 * @returns {string} A human-readable name for the tile
 */
export const getTileName = (tileIndex, tileType = 'floor') => {
  // Find which section this tile belongs to
  if (tileType === 'floor') {
    for (const [sectionKey, section] of Object.entries(TILE_SECTIONS)) {
      if (tileIndex >= section.startIndex && tileIndex < section.startIndex + section.count) {
        const tileNumber = tileIndex - section.startIndex + 1;
        return `${section.name} ${tileNumber}`;
      }
    }
    return `Floor Tile ${tileIndex}`;
  } else if (tileType === 'wall') {
    for (const [sectionKey, section] of Object.entries(WALL_TILE_SECTIONS)) {
      if (tileIndex >= section.startIndex && tileIndex < section.startIndex + section.count) {
        const tileNumber = tileIndex - section.startIndex + 1;
        return `${section.name} ${tileNumber}`;
      }
    }
    return `Wall Tile ${tileIndex}`;
  } else if (tileType === 'shadow') {
    for (const [sectionKey, section] of Object.entries(SHADOW_TILE_SECTIONS)) {
      if (tileIndex >= section.startIndex && tileIndex < section.startIndex + section.count) {
        const tileNumber = tileIndex - section.startIndex + 1;
        return `${section.name} ${tileNumber}`;
      }
    }
    return `Shadow Tile ${tileIndex}`;
  } else if (tileType === 'door') {
    return `Door`;
  }
  
  // Fallback if not in a named section or unknown type
  return `Tile ${tileIndex}`;
};

================
File: windows/MapEditorWindow.jsx
================
import React, { useState, useEffect } from 'react';
import { Map } from 'lucide-react';
import MapCanvas from './mapeditor/MapCanvas';
import MapToolbar from './mapeditor/MapToolbar';
import LayerPanel from './mapeditor/LayerPanel';
import TilePaletteWithMarketplace from './mapeditor/TilePaletteWithMarketplace';
import { setCellInLayer, removeCellFromLayer } from './mapeditor/utils/mapUtils';

/**
 * Map Editor Window Component
 * This window allows users to create and edit grid-based maps
 */
const MapEditorWindow = ({ isActive, nodeId, onCommand, transformWindow, windowState, updateWindowState, focusRef }) => {
  // State for map data
  const [mapData, setMapData] = useState(null);
  const [currentLayer, setCurrentLayer] = useState(0);
  const [currentTool, setCurrentTool] = useState('select');
  const [isDirty, setIsDirty] = useState(false);
  const [error, setError] = useState(null);
  const [selectedTileId, setSelectedTileId] = useState(0);
  const [selectedTileType, setSelectedTileType] = useState('floor');
  const [selectedRotation, setSelectedRotation] = useState(0); // 0, 90, 180, 270 degrees

  // Load map data from file when selected
  useEffect(() => {
    if (windowState?.selectedFile?.path && windowState.selectedFile.name.endsWith('.map')) {
      loadMapFromFile(windowState.selectedFile.path);
    }
  }, [windowState?.selectedFile]);

  // Handler for loading a map file
  const loadMapFromFile = async (filePath) => {
    try {
      // Reset state for new file
      setError(null);
      
      // If there's no file path, create a new empty map
      if (!filePath) {
        createNewMap();
        return;
      }
      
      // This is a placeholder - in a real implementation, we would fetch the content
      // from the server using a similar approach to how the file explorer works
      
      // For now, create a simple map structure
      // In the future, this would parse the JSON from the file
      setMapData({
        version: "1.0",
        name: "Sample Map",
        gridSize: 32,
        width: 20,
        height: 15,
        defaultTile: "floor",
        layers: [
          {
            name: "terrain",
            visible: true,
            cells: []
          },
          {
            name: "objects",
            visible: true,
            cells: []
          }
        ],
        tokenPositions: [],
        metadata: {
          author: "user",
          created: new Date().toISOString(),
          modified: new Date().toISOString()
        }
      });
      
      setCurrentLayer(0);
      setIsDirty(false);
    } catch (err) {
      console.error('Error loading map:', err);
      setError('Failed to load map file. It may be corrupted or in an unsupported format.');
    }
  };

  // Create a new empty map
  const createNewMap = () => {
    setMapData({
      version: "1.0",
      name: "New Map",
      gridSize: 32,
      width: 20,
      height: 15,
      defaultTile: "floor",
      layers: [
        {
          name: "terrain",
          visible: true,
          cells: []
        }
      ],
      tokenPositions: [],
      metadata: {
        author: "user",
        created: new Date().toISOString(),
        modified: new Date().toISOString()
      }
    });
    setCurrentLayer(0);
    setIsDirty(true);
  };

  // Handler for saving the map
  const handleSaveMap = async () => {
    if (!mapData) return;
    if (!windowState?.selectedFile?.path) {
      // Would normally prompt for save location
      setError('No file path specified for saving.');
      return;
    }
    
    try {
      console.log("========== SAVING MAP ==========");
      console.log("Current window.currentMapRotation value:", window.currentMapRotation);
      console.log("Current selectedRotation state value:", selectedRotation);
      
      // Update modified timestamp
      const updatedMapData = {
        ...mapData,
        metadata: {
          ...mapData.metadata,
          modified: new Date().toISOString()
        }
      };
      
  // CRITICAL FIX: Ensure every cell has rotation property and shadow cells have tileId BEFORE serialization
  // This guarantees these properties are always in the JSON output
  updatedMapData.layers.forEach(layer => {
    if (layer.cells && Array.isArray(layer.cells)) {
      layer.cells = layer.cells.map(cell => {
        let updatedCell = { ...cell };
        
        // If rotation doesn't exist, add it with default value of 0
        if (updatedCell.rotation === undefined) {
          updatedCell.rotation = 0;
        }
        // Ensure rotation is a number (not string)
        else if (typeof updatedCell.rotation !== 'number') {
          updatedCell.rotation = Number(updatedCell.rotation);
        }
        
        // Special case for shadow tiles - debug the current tileId
        if (updatedCell.type === 'shadow') {
          console.log(`SAVE: Shadow cell at (${updatedCell.x}, ${updatedCell.y}) has tileId: ${updatedCell.tileId}`);
        }
        
        return updatedCell;
      });
    }
  });
      
      // Debug: Check shadow tile values before we pass to the serializer
      let shadowCount = 0;
      let rotationCount = 0;
      console.log("=== SHADOW TILES BEFORE SERIALIZATION (MapEditorWindow) ===");
      updatedMapData.layers.forEach(layer => {
        layer.cells.forEach(cell => {
          // Log all cell rotation values
          console.log(`Cell at (${cell.x}, ${cell.y}) has rotation: ${cell.rotation}`);
          rotationCount++;
          
          // Specifically log shadow tile values
          if (cell.type === 'shadow') {
            shadowCount++;
            console.log(`SAVE CHECK: Shadow Cell (${cell.x}, ${cell.y}): tileId=${cell.tileId}, type=${typeof cell.tileId}`);
          }
        });
      });
      
      console.log(`Total cells: ${rotationCount}, Shadow tiles: ${shadowCount}`);
      
      // Use a custom replacer function for critical special case properties
      const serializedMap = JSON.stringify(updatedMapData, (key, value) => {
        // Handle rotation values (all cell types)
        if (key === 'rotation') {
          return value === undefined ? 0 : Number(value);
        }
        
        // Special handling for tileId in shadow cells
        if (key === 'tileId' && value === undefined && this && this.type === 'shadow') {
          console.log(`JSON.stringify: Missing tileId for shadow tile, adding default`);
          return 0;
        }
        
        return value;
      }, 2);
      
      // Check the localStorage copy to ensure shadow tiles have tileId
      try {
        // First check the map data BEFORE serialization
        console.log("==== SHADOW TILES IN PRE-SERIALIZED MAPDATA ====");
        updatedMapData.layers.forEach(layer => {
          layer.cells.forEach(cell => {
            if (cell.type === 'shadow') {
              console.log(`PRE-SAVE: Shadow Cell at (${cell.x}, ${cell.y}): tileId=${cell.tileId}, type=${typeof cell.tileId}`);
            }
          });
        });
        
        // Then check the final serialized version
        const parsed = JSON.parse(serializedMap);
        const shadowTiles = [];
        parsed.layers.forEach(layer => {
          layer.cells.forEach(cell => {
            if (cell.type === 'shadow') {
              shadowTiles.push(`(${cell.x},${cell.y}): tileId=${cell.tileId}`);
            }
          });
        });
        console.log("==== SHADOW TILES IN FINAL SERIALIZED MAP ====");
        console.log(shadowTiles.join(', '));
      } catch (err) {
        console.error("Error checking serialized map:", err);
      }
      
      console.log('Saving map with explicit rotation values included');
      
      // Actually save the map data to localStorage for demo purposes
      localStorage.setItem('last_saved_map', serializedMap);
      localStorage.setItem('last_saved_map_pretty', JSON.stringify(JSON.parse(serializedMap), null, 2));
      console.log('Map saved to localStorage - check with: localStorage.getItem("last_saved_map_pretty")');
      
      // Update state
      setMapData(updatedMapData);
      setIsDirty(false);
    } catch (err) {
      console.error('Error saving map:', err);
      setError('Failed to save map file.');
    }
  };

  // Handler for map edits
  const handleEdit = (x, y, tool, rotation = 0, tileId = selectedTileId) => {
    if (!mapData || !mapData.layers || !mapData.layers[currentLayer]) return;
    
    // Log that we're receiving the rotation value
    console.log("============== EDIT CELL ==============");
    console.log("MapEditorWindow received edit with rotation:", rotation);
    console.log(`Cell coordinates: (${x}, ${y}), Tool: ${tool}, tileId: ${tileId}`);
    
    // CRITICAL: Make sure the tileId is set explicitly for shadow tiles
    let effectiveTileId = tileId;
    if (tool === 'shadow') {
      // Force shadow tiles to use the selected tileId
      if (effectiveTileId === undefined) {
        effectiveTileId = selectedTileId;
        console.log(`Shadow tile tileId was undefined, using selectedTileId: ${selectedTileId}`);
      }
      console.log(`Using tileId: ${effectiveTileId} for shadow tile at (${x}, ${y})`);
    }
    
    // Ensure rotation is a number
    const numRotation = Number(rotation);
    console.log("Rotation converted to number:", numRotation);
    
    let newMapData;
    
    if (tool === 'erase') {
      // If erasing, remove the cell from the layer
      newMapData = removeCellFromLayer(mapData, currentLayer, x, y);
      console.log("Cell erased successfully");
    } else {
      // For tile placement tools (floor, wall, etc.), use the selected tile and rotation
      console.log(`Setting cell in layer ${currentLayer} with tileId: ${effectiveTileId}, rotation: ${numRotation}`);
      
      newMapData = setCellInLayer(
        mapData, 
        currentLayer, 
        x, 
        y, 
        tool,
        effectiveTileId, // Use our locally validated tileId value
        numRotation // Use the numeric rotation value
      );
      
      // Check if the rotation was stored correctly
      const updatedCell = newMapData.layers[currentLayer].cells.find(
        cell => cell.x === x && cell.y === y
      );
      
      if (updatedCell) {
        console.log("Cell updated:", updatedCell);
        if (updatedCell.rotation !== undefined) {
          console.log(`Rotation set successfully: ${updatedCell.rotation}°`);
        } else {
          console.warn("Rotation was not stored in the cell data!");
        }
      } else {
        console.warn("Could not find the updated cell in the map data!");
      }
    }
    
    // Update state
    setMapData(newMapData);
    setIsDirty(true);
    
    // Store to localStorage for debugging
    localStorage.setItem('debug_mapData', JSON.stringify(newMapData));
    console.log("Map data stored to localStorage for debugging");
    console.log("=========================================");
  };
  
  // Handle tile selection
  const handleSelectTile = (tileId) => {
    console.log(`handleSelectTile called with: ${tileId} (previous: ${selectedTileId}), tileType: ${selectedTileType}`);
    
    // Update state
    setSelectedTileId(tileId);
    
    // When selecting a tile, switch to the corresponding tool
    if (currentTool === 'select' || currentTool === 'erase') {
      console.log(`Switching tool from ${currentTool} to ${selectedTileType}`);
      setCurrentTool(selectedTileType);
    }
    
    // Debug - check state immediately after update
    setTimeout(() => {
      console.log(`After update: selectedTileId: ${selectedTileId}, tileType: ${selectedTileType}`);
    }, 0);
  };
  
  // Handle tile type change
  const handleChangeTileType = (tileType) => {
    setSelectedTileType(tileType);

    // When changing to shadow type, we no longer force tileId=0
    // This allows users to select any shadow tile and have it properly saved
    console.log(`Changed tile type to: ${tileType}, keeping current selectedTileId: ${selectedTileId}`);
    
    // When changing tile type, also change the current tool
    if (currentTool !== 'select' && currentTool !== 'erase') {
      setCurrentTool(tileType);
    }
  };
  
  // Handle tile rotation - fixes React async state update issue
  const handleRotateTile = (rotation) => {
    console.log("---------------------------------------");
    console.log("handleRotateTile called with rotation:", rotation);
    
    // Convert to number to ensure consistent handling
    const numRotation = Number(rotation);
    
    // Update the DOM immediately for visual feedback (safely)
    const debugElement = document.getElementById('debug-rotation-value');
    if (debugElement) {
      debugElement.textContent = `Rotation set to: ${numRotation}°`;
    }
    
    // Set window-level variable to ensure it's globally accessible
    window.currentMapRotation = numRotation;
    
    // Update the state
    setSelectedRotation(numRotation);
    
    // Force update any tile displays
    if (document.getElementById('tile-rotation-display')) {
      document.getElementById('tile-rotation-display').textContent = `${numRotation}°`;
    }
    
    // When rotating a tile, make sure we're in a tile placement mode
    if (currentTool === 'select' || currentTool === 'erase') {
      setCurrentTool(selectedTileType);
    }
    
    console.log("Rotation has been set to:", numRotation);
    console.log("Global rotation tracker:", window.currentMapRotation);
    console.log("---------------------------------------");
  };

  // Layer management functions
  const handleToggleLayerVisibility = (layerIndex) => {
    if (!mapData || !mapData.layers || !mapData.layers[layerIndex]) return;
    
    const newMapData = { ...mapData };
    newMapData.layers[layerIndex] = {
      ...newMapData.layers[layerIndex],
      visible: !newMapData.layers[layerIndex].visible
    };
    
    setMapData(newMapData);
    setIsDirty(true);
  };

  const handleAddLayer = () => {
    if (!mapData) return;
    
    const newLayerName = `Layer ${mapData.layers.length + 1}`;
    const newLayer = {
      name: newLayerName,
      visible: true,
      cells: []
    };
    
    const newMapData = { 
      ...mapData,
      layers: [...mapData.layers, newLayer]
    };
    
    setMapData(newMapData);
    setCurrentLayer(newMapData.layers.length - 1);
    setIsDirty(true);
  };

  const handleRemoveLayer = (layerIndex) => {
    if (!mapData || !mapData.layers || mapData.layers.length <= 1) return;
    
    const newMapData = { ...mapData };
    newMapData.layers = newMapData.layers.filter((_, index) => index !== layerIndex);
    
    setMapData(newMapData);
    
    // Adjust current layer if necessary
    if (currentLayer >= newMapData.layers.length) {
      setCurrentLayer(newMapData.layers.length - 1);
    }
    
    setIsDirty(true);
  };

  const handleMoveLayerUp = (layerIndex) => {
    if (!mapData || !mapData.layers || layerIndex >= mapData.layers.length - 1) return;
    
    const newMapData = { ...mapData };
    const layers = [...newMapData.layers];
    
    // Swap layers
    [layers[layerIndex], layers[layerIndex + 1]] = [layers[layerIndex + 1], layers[layerIndex]];
    
    newMapData.layers = layers;
    setMapData(newMapData);
    
    // Update current layer if necessary
    if (currentLayer === layerIndex) {
      setCurrentLayer(layerIndex + 1);
    } else if (currentLayer === layerIndex + 1) {
      setCurrentLayer(layerIndex);
    }
    
    setIsDirty(true);
  };

  const handleMoveLayerDown = (layerIndex) => {
    if (!mapData || !mapData.layers || layerIndex <= 0) return;
    
    const newMapData = { ...mapData };
    const layers = [...newMapData.layers];
    
    // Swap layers
    [layers[layerIndex], layers[layerIndex - 1]] = [layers[layerIndex - 1], layers[layerIndex]];
    
    newMapData.layers = layers;
    setMapData(newMapData);
    
    // Update current layer if necessary
    if (currentLayer === layerIndex) {
      setCurrentLayer(layerIndex - 1);
    } else if (currentLayer === layerIndex - 1) {
      setCurrentLayer(layerIndex);
    }
    
    setIsDirty(true);
  };

  const handleRenameLayer = (layerIndex, newName) => {
    if (!mapData || !mapData.layers || !mapData.layers[layerIndex]) return;
    
    // Use the provided name instead of prompting
    if (!newName || newName.trim() === '') return;
    
    const newMapData = { ...mapData };
    newMapData.layers[layerIndex] = {
      ...newMapData.layers[layerIndex],
      name: newName
    };
    
    setMapData(newMapData);
    setIsDirty(true);
    
    // Save the changes to the file
    handleSaveMap();
  };

  // Show placeholder if no file is loaded
  if (!mapData) {
    return (
      <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400 overflow-hidden">
        <div className="p-2 border-b border-stone-700">
          <h2 className="text-lg font-semibold flex items-center">
            <Map className="mr-2" size={18} />
            Map Editor
          </h2>
        </div>
        <div className="flex-1 overflow-auto p-4 flex items-center justify-center">
          <div className="text-center">
            <Map size={48} className="mx-auto mb-4 text-teal-500" />
            <h3 className="text-xl mb-2">Grid Map Editor</h3>
            <p className="text-stone-400">
              {error ? (
                <span className="text-red-400">{error}</span>
              ) : (
                <>
                  Select a .map file to edit, or create a new one.
                  <br />
                  <button 
                    className="mt-4 px-4 py-2 bg-teal-800 hover:bg-teal-700 rounded text-white"
                    onClick={createNewMap}
                  >
                    Create New Map
                  </button>
                </>
              )}
            </p>
          </div>
        </div>
      </div>
    );
  }

  // Render the map editor with all components
  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400 overflow-hidden">
      <div className="p-2 border-b border-stone-700 flex justify-between items-center">
        <h2 className="text-lg font-semibold flex items-center">
          <Map className="mr-2" size={18} />
          {mapData.name} {isDirty && '*'}
        </h2>
        {error && <div className="text-red-400 text-sm">{error}</div>}
      </div>
      
      {/* Toolbar */}
      <MapToolbar 
        currentTool={currentTool}
        setCurrentTool={setCurrentTool}
        onSave={handleSaveMap}
        onUndo={() => console.log('Undo not implemented')}
        onRedo={() => console.log('Redo not implemented')}
        onClear={() => createNewMap()}
      />
      
      {/* For debugging - hidden in production */}
      <div id="debug-rotation-value" className="p-1 bg-red-800 text-white text-xs">
        Rotation set to: {selectedRotation}°
      </div>
      
      {/* Main content area */}
      <div className="flex-1 flex flex-col overflow-hidden">
        <div className="flex-1 flex overflow-hidden">
          {/* Canvas for map editing */}
          <MapCanvas 
            mapData={mapData}
            currentLayer={currentLayer}
            currentTool={currentTool}
            onEdit={handleEdit}
            selectedTileId={selectedTileId}
            selectedRotation={selectedRotation}
          />
          
          {/* Layer panel */}
          <LayerPanel 
            layers={mapData.layers}
            currentLayer={currentLayer}
            setCurrentLayer={setCurrentLayer}
            onToggleLayerVisibility={handleToggleLayerVisibility}
            onAddLayer={handleAddLayer}
            onRemoveLayer={handleRemoveLayer}
            onMoveLayerUp={handleMoveLayerUp}
            onMoveLayerDown={handleMoveLayerDown}
            onRenameLayer={handleRenameLayer}
          />
        </div>
        
        {/* Tile Palette with Marketplace Integration */}
        <TilePaletteWithMarketplace 
          onSelectTile={handleSelectTile}
          selectedTileId={selectedTileId}
          tileType={selectedTileType}
          onChangeTileType={handleChangeTileType}
          selectedRotation={selectedRotation}
          onRotateTile={handleRotateTile}
          createWindow={transformWindow}
        />
      </div>
    </div>
  );
};

export default MapEditorWindow;

================
File: windows/MarketplaceWindow.jsx
================
import React, { useState, useEffect, useCallback } from 'react';
import axios from 'axios';
import { X, Check, Upload, Info, AlertTriangle, RotateCw } from 'lucide-react';
import API_CONFIG from '../../config/api';
import { useAuth } from '../../context/AuthContext';

/**
 * Marketplace window component for browsing and selecting tilesets
 */
const MarketplaceWindow = ({ windowId }) => {
  const [tilesets, setTilesets] = useState([]);
  const [selectedTilesets, setSelectedTilesets] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const { user } = useAuth();
  const [showUploadForm, setShowUploadForm] = useState(false);
  const [debugInfo, setDebugInfo] = useState(null);

  // Fetch all tilesets and user-selected tilesets with enhanced debugging
  const fetchTilesets = useCallback(async () => {
    setLoading(true);
    setError(null);
    setDebugInfo(null);
    
    // Debug: Log API configuration
    const authToken = localStorage.getItem('auth_token');
    const debugData = {
      baseUrl: API_CONFIG.BASE_URL,
      tilesetsEndpoint: `${API_CONFIG.BASE_URL}/tilesets`,
      auth: authToken ? 'Token exists' : 'No token',
      tokenLength: authToken ? authToken.length : 0,
      userInfo: user ? `User: ${user.username}, Admin: ${user.isAdmin}` : 'No user'
    };
    
    console.log('Marketplace API Config:', debugData);
    setDebugInfo(debugData);
    
    try {
      console.log('Attempting to fetch tilesets from:', `${API_CONFIG.BASE_URL}/tilesets`);
      
      // First try the main endpoint, then fall back to the simple endpoint if it fails
      try {
        console.log('Trying main tilesets endpoint');
        // Fetch all available tilesets
        const [tilesetsResponse, selectedResponse] = await Promise.all([
          axios.get(`${API_CONFIG.BASE_URL}/tilesets`),
          axios.get(`${API_CONFIG.BASE_URL}/tilesets/user/selected`, {
            headers: { Authorization: `Bearer ${localStorage.getItem('auth_token')}` }
          })
        ]);

        console.log('Tilesets response:', tilesetsResponse);
        console.log('Selected tilesets response:', selectedResponse);

        setTilesets(tilesetsResponse.data || []);
        setSelectedTilesets(selectedResponse.data || []);
      } catch (mainError) {
        console.error('Main endpoint failed, trying fallback:', mainError);
        
        // Try the debug/simple endpoint as fallback
        console.log('Trying simple fallback endpoint');
        const fallbackResponse = await axios.get(`${API_CONFIG.BASE_URL}/tilesets/simple`);
        console.log('Fallback response:', fallbackResponse);
        
        if (fallbackResponse.data && Array.isArray(fallbackResponse.data)) {
          setTilesets(fallbackResponse.data);
          // We don't have selected tilesets in fallback mode
          setSelectedTilesets([]);
          
          // Still set a warning about using fallback mode
          setDebugInfo(prevDebug => ({ 
            ...prevDebug, 
            warning: 'Using fallback tileset data. Some features may be limited.',
            fallbackMode: true
          }));
        } else {
          // If even the fallback fails, re-throw the original error
          throw mainError;
        }
      }
    } catch (err) {
      console.error('Error fetching tilesets (all attempts failed):', err);
      
      // Enhanced error reporting
      const errorDetails = {
        message: err.message,
        status: err.response?.status,
        statusText: err.response?.statusText,
        responseData: err.response?.data,
        config: {
          url: err.config?.url,
          method: err.config?.method,
          headers: err.config?.headers ? 'Headers present' : 'No headers'
        }
      };
      
      console.error('Error details:', errorDetails);
      setDebugInfo(prevDebug => ({ ...prevDebug, error: errorDetails }));
      
      // Set a more informative error message
      setError(`Failed to load tilesets: ${err.message}. ${err.response ? `Server responded with ${err.response.status} ${err.response.statusText}` : 'Server unreachable'}`);
    } finally {
      setLoading(false);
    }
  }, [user]);

  // Load tilesets on component mount
  useEffect(() => {
    fetchTilesets();
  }, [fetchTilesets]);

  // Toggle tileset selection
  const toggleTilesetSelection = async (tilesetId) => {
    try {
      const isSelected = selectedTilesets.some(t => t.id === tilesetId);
      
      if (isSelected) {
        // Deselect the tileset
        await axios.delete(`${API_CONFIG.BASE_URL}/tilesets/user/select/${tilesetId}`, {
          headers: { Authorization: `Bearer ${localStorage.getItem('auth_token')}` }
        });
        setSelectedTilesets(prev => prev.filter(t => t.id !== tilesetId));
      } else {
        // Select the tileset
        await axios.post(`${API_CONFIG.BASE_URL}/tilesets/user/select/${tilesetId}`, {}, {
          headers: { Authorization: `Bearer ${localStorage.getItem('auth_token')}` }
        });
        const tilesetToAdd = tilesets.find(t => t.id === tilesetId);
        if (tilesetToAdd) {
          setSelectedTilesets(prev => [...prev, tilesetToAdd]);
        }
      }
    } catch (err) {
      console.error('Error toggling tileset selection:', err);
      setError('Failed to update tileset selection. Please try again.');
    }
  };

  // Check if a tileset is selected
  const isTilesetSelected = (tilesetId) => {
    return selectedTilesets.some(t => t.id === tilesetId);
  };

  // Render the tileset preview image
  const renderTilesetPreview = (tileset) => {
    return (
      <div className="w-full h-32 bg-stone-900 overflow-hidden relative">
        <img 
          src={`${API_CONFIG.BASE_URL}${tileset.image_path}`} 
          alt={`Preview of ${tileset.name}`}
          className="object-cover w-full h-full"
          onError={(e) => {
            e.target.onerror = null;
            e.target.src = '/images/tileset-placeholder.png';
          }}
        />
      </div>
    );
  };

  return (
    <div className="flex flex-col h-full bg-stone-800 text-stone-200">
      {/* Header */}
      <div className="p-2 border-b bg-stone-900 border-stone-700 flex justify-between items-center">
        <div>
          <h2 className="mr-2 text-teal-400">Tileset Marketplace</h2>
        </div>
        
        <button 
          className="px-3 py-1 bg-blue-700 hover:bg-blue-600 text-white rounded text-sm flex items-center"
          onClick={fetchTilesets}
          disabled={loading}
        >
          <RotateCw size={16} className={`mr-1 ${loading ? 'animate-spin' : ''}`} />
          Refresh
        </button>
      </div>

      {/* Main content */}
      <div className="flex-1 overflow-auto p-4">
        {loading ? (
          <div className="flex items-center justify-center h-full">
            <div className="animate-pulse text-stone-400">Loading tilesets...</div>
          </div>
        ) : error ? (
          <div className="bg-red-900/30 text-red-300 p-4 rounded">
            <div className="flex items-center mb-2">
              <AlertTriangle size={20} className="mr-2" />
              <span className="font-semibold">API Connection Error</span>
            </div>
            <p className="mb-2">{error}</p>
            {debugInfo && (
              <div className="text-xs bg-red-900/50 p-2 rounded mt-2">
                <p className="font-semibold mb-1">Debugging Information:</p>
                <p>API URL: {debugInfo.tilesetsEndpoint}</p>
                <p>Auth Status: {debugInfo.auth}</p>
                <p>Token Length: {debugInfo.tokenLength} characters</p>
                <p>Admin Status: {user?.isAdmin ? 'Admin' : 'Not admin'}</p>
                {debugInfo.error && (
                  <>
                    <p className="mt-1 font-semibold">Error Details:</p>
                    <p>Status: {debugInfo.error.status || 'None'}</p>
                    <p>Status Text: {debugInfo.error.statusText || 'None'}</p>
                    <p>URL: {debugInfo.error.config?.url || 'Unknown'}</p>
                  </>
                )}
                <div className="mt-3 flex space-x-2">
                  <button 
                    className="px-2 py-1 bg-red-800 hover:bg-red-700 rounded text-xs"
                    onClick={fetchTilesets}
                  >
                    Retry Connection
                  </button>
                  
                  <a 
                    href={`${API_CONFIG.BASE_URL}/tilesets/debug/check-paths`} 
                    target="_blank" 
                    rel="noopener noreferrer"
                    className="px-2 py-1 bg-blue-800 hover:bg-blue-700 rounded text-xs"
                  >
                    Check Server Paths
                  </a>
                </div>
                
                <div className="mt-2 text-amber-300 bg-amber-900/30 p-2 rounded">
                  <p className="font-semibold">Administrator Tip:</p>
                  <p>This error often occurs when the tilesets directory doesn't exist on the server.</p>
                  <p>Make sure to create the directory at: <code>windowmanager-files/tilesets</code></p>
                </div>
              </div>
            )}
          </div>
      ) : debugInfo?.warning ? (
        <div className="bg-amber-900/30 text-amber-300 p-4 rounded mb-4">
          <div className="flex items-center mb-2">
            <Info size={20} className="mr-2" />
            <span className="font-semibold">Using Fallback Data</span>
          </div>
          <p>{debugInfo.warning}</p>
          <button 
            className="mt-2 px-2 py-1 bg-amber-800 hover:bg-amber-700 rounded text-xs"
            onClick={fetchTilesets}
          >
            Try Normal Mode Again
          </button>
        </div>
      ) : tilesets.length === 0 ? (
          <div className="text-center py-10">
            <Info size={48} className="mx-auto text-stone-500 mb-4" />
            <p className="text-stone-400">No tilesets available yet.</p>
            {user?.isAdmin && (
              <button
                className="mt-4 px-4 py-2 bg-teal-700 hover:bg-teal-600 rounded text-sm"
                onClick={() => setShowUploadForm(true)}
              >
                Upload a New Tileset
              </button>
            )}
          </div>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {tilesets.map(tileset => (
              <div 
                key={tileset.id} 
                className={`rounded-lg overflow-hidden border ${
                  isTilesetSelected(tileset.id)
                    ? 'border-teal-500'
                    : 'border-stone-700'
                }`}
              >
                {renderTilesetPreview(tileset)}
                <div className="p-3">
                  <div className="flex justify-between items-start">
                    <div>
                      <h3 className="font-bold text-teal-400">{tileset.name}</h3>
                      <p className="text-xs text-stone-400">By {tileset.author}</p>
                    </div>
                    {isTilesetSelected(tileset.id) && (
                      <span className="bg-teal-800 text-teal-200 text-xs px-2 py-1 rounded-full flex items-center">
                        <Check size={12} className="mr-1" />
                        Selected
                      </span>
                    )}
                  </div>
                  
                  <p className="text-sm mt-2 text-stone-300">
                    {tileset.description || 'No description provided.'}
                  </p>
                  
                  {/* Display section summary */}
                  <div className="mt-3 flex flex-wrap gap-1">
                    {tileset.sections && tileset.sections.map(section => (
                      <span 
                        key={`${tileset.id}-${section.id}`}
                        className="text-xs px-2 py-1 rounded bg-stone-700 text-stone-300"
                      >
                        {section.section_name}
                      </span>
                    ))}
                  </div>
                  
                  <div className="mt-4">
                    <button
                      className={`px-3 py-1 rounded text-sm ${
                        isTilesetSelected(tileset.id)
                          ? 'bg-red-900 hover:bg-red-800 text-stone-200'
                          : 'bg-teal-700 hover:bg-teal-600 text-stone-200'
                      }`}
                      onClick={() => toggleTilesetSelection(tileset.id)}
                    >
                      {isTilesetSelected(tileset.id) ? 'Remove from Editor' : 'Add to Editor'}
                    </button>
                  </div>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Admin upload section, conditionally shown */}
      {user?.isAdmin && (
        <div className="border-t border-stone-700 p-4">
          <div className="flex justify-between items-center">
            <h3 className="text-lg text-teal-400 font-bold">Admin: Tileset Manager</h3>
            <button
              className="px-3 py-1 bg-teal-700 hover:bg-teal-600 rounded text-sm flex items-center"
              onClick={() => setShowUploadForm(!showUploadForm)}
            >
              <Upload size={16} className="mr-1" />
              {showUploadForm ? 'Hide Form' : 'Upload New Tileset'}
            </button>
          </div>

          {showUploadForm && <TilesetUploadForm onUploadComplete={fetchTilesets} />}
        </div>
      )}
    </div>
  );
};

/**
 * Component for uploading a new tileset (admin only)
 */
const TilesetUploadForm = ({ onUploadComplete }) => {
  const [formData, setFormData] = useState({
    name: '',
    description: '',
    author: '',
    columns: '16'
  });
  
  const [tilesetImage, setTilesetImage] = useState(null);
  const [imagePreview, setImagePreview] = useState('');
  const [sections, setSections] = useState([
    { category: 'floor', section_name: 'Floor Tiles', start_index: 0, count: 16 }
  ]);
  
  const [uploading, setUploading] = useState(false);
  const [uploadError, setUploadError] = useState(null);
  const [uploadSuccess, setUploadSuccess] = useState(false);
  const [uploadDebugInfo, setUploadDebugInfo] = useState(null);
  
  // Handle form input changes
  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };
  
  // Handle image file selection
  const handleImageChange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    console.log('Selected file:', file.name, file.type, `${file.size} bytes`);
    setTilesetImage(file);
    
    // Create preview
    const reader = new FileReader();
    reader.onloadend = () => {
      setImagePreview(reader.result);
    };
    reader.readAsDataURL(file);
  };
  
  // Handle section changes
  const handleSectionChange = (index, field, value) => {
    const newSections = [...sections];
    
    // Convert numerical fields to integers
    if (field === 'start_index' || field === 'count') {
      value = parseInt(value, 10) || 0;
    }
    
    newSections[index] = { ...newSections[index], [field]: value };
    setSections(newSections);
  };
  
  // Add a new section
  const addSection = () => {
    setSections([...sections, { 
      category: 'floor', 
      section_name: 'New Section', 
      start_index: 0, 
      count: 8 
    }]);
  };
  
  // Remove a section
  const removeSection = (index) => {
    const newSections = [...sections];
    newSections.splice(index, 1);
    setSections(newSections);
  };
  
  // Submit the form
  const handleSubmit = async (e) => {
    e.preventDefault();
    setUploading(true);
    setUploadError(null);
    setUploadSuccess(false);
    setUploadDebugInfo(null);
    
    if (!tilesetImage) {
      setUploadError('Please select a tileset image.');
      setUploading(false);
      return;
    }
    
    if (!formData.name) {
      setUploadError('Please provide a name for the tileset.');
      setUploading(false);
      return;
    }
    
    if (sections.length === 0) {
      setUploadError('Please define at least one section.');
      setUploading(false);
      return;
    }
    
    try {
      const formPayload = new FormData();
      formPayload.append('tilesetImage', tilesetImage);
      formPayload.append('name', formData.name);
      formPayload.append('description', formData.description);
      formPayload.append('author', formData.author);
      formPayload.append('columns', formData.columns);
      formPayload.append('sections', JSON.stringify(sections));
      
      // Log what we're uploading
      console.log('Uploading tileset:', {
        name: formData.name,
        description: formData.description,
        author: formData.author,
        columns: formData.columns,
        sections: sections,
        imageInfo: {
          name: tilesetImage.name,
          type: tilesetImage.type,
          size: tilesetImage.size
        }
      });
      
      const authToken = localStorage.getItem('auth_token');
      console.log('Using auth token:', authToken ? `${authToken.substring(0, 10)}...` : 'None');
      
      const response = await axios.post(
        `${API_CONFIG.BASE_URL}/tilesets`,
        formPayload,
        {
          headers: {
            'Content-Type': 'multipart/form-data',
            Authorization: `Bearer ${authToken}`
          }
        }
      );
      
      console.log('Upload response:', response);
      
      setUploadSuccess(true);
      
      // Reset form
      setFormData({
        name: '',
        description: '',
        author: '',
        columns: '16'
      });
      setTilesetImage(null);
      setImagePreview('');
      setSections([{ category: 'floor', section_name: 'Floor Tiles', start_index: 0, count: 16 }]);
      
      // Notify parent to refresh
      if (onUploadComplete) {
        onUploadComplete();
      }
    } catch (err) {
      console.error('Error uploading tileset:', err);
      
      const errorDetails = {
        message: err.message,
        status: err.response?.status,
        statusText: err.response?.statusText,
        responseData: err.response?.data,
        config: {
          url: err.config?.url,
          method: err.config?.method,
          headers: err.config?.headers ? 'Headers present' : 'No headers'
        }
      };
      
      console.error('Upload error details:', errorDetails);
      setUploadDebugInfo(errorDetails);
      
      setUploadError(err.response?.data?.message || 'Failed to upload tileset. Please try again.');
    } finally {
      setUploading(false);
    }
  };
  
  return (
    <div className="mt-4 bg-stone-900 rounded-lg p-4">
      {uploadSuccess && (
        <div className="mb-4 bg-green-900/30 text-green-300 p-3 rounded flex items-center">
          <Check size={20} className="mr-2" />
          <span>Tileset uploaded successfully!</span>
        </div>
      )}
      
      {uploadError && (
        <div className="mb-4 bg-red-900/30 text-red-300 p-3 rounded">
          <div className="flex items-center mb-1">
            <AlertTriangle size={20} className="mr-2" />
            <span>{uploadError}</span>
          </div>
          
          {uploadDebugInfo && (
            <div className="mt-2 text-xs bg-red-900/50 p-2 rounded">
              <p>Error: {uploadDebugInfo.message}</p>
              <p>Status: {uploadDebugInfo.status || 'None'}</p>
              <p>Response: {uploadDebugInfo.responseData?.message || 'No message'}</p>
            </div>
          )}
        </div>
      )}
      
      <form onSubmit={handleSubmit}>
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {/* Tileset metadata */}
          <div>
            <div className="mb-3">
              <label className="block text-sm font-medium text-stone-300 mb-1">
                Tileset Name*
              </label>
              <input
                type="text"
                name="name"
                value={formData.name}
                onChange={handleInputChange}
                className="w-full bg-stone-800 border border-stone-700 rounded p-2 text-stone-200"
                required
              />
            </div>
            
            <div className="mb-3">
              <label className="block text-sm font-medium text-stone-300 mb-1">
                Author
              </label>
              <input
                type="text"
                name="author"
                value={formData.author}
                onChange={handleInputChange}
                className="w-full bg-stone-800 border border-stone-700 rounded p-2 text-stone-200"
                placeholder="(Optional) Override author name"
              />
            </div>
            
            <div className="mb-3">
              <label className="block text-sm font-medium text-stone-300 mb-1">
                Description
              </label>
              <textarea
                name="description"
                value={formData.description}
                onChange={handleInputChange}
                className="w-full bg-stone-800 border border-stone-700 rounded p-2 text-stone-200 min-h-[80px]"
                placeholder="Describe this tileset..."
              />
            </div>
            
            <div className="mb-3">
              <label className="block text-sm font-medium text-stone-300 mb-1">
                Columns in Sprite Sheet
              </label>
              <input
                type="number"
                name="columns"
                value={formData.columns}
                onChange={handleInputChange}
                className="w-full bg-stone-800 border border-stone-700 rounded p-2 text-stone-200"
                min="1"
                max="32"
              />
              <p className="text-xs text-stone-500 mt-1">
                Number of columns in the sprite sheet (default: 16)
              </p>
            </div>
            
            <div className="mb-3">
              <label className="block text-sm font-medium text-stone-300 mb-1">
                Tileset Image*
              </label>
              <input
                type="file"
                accept="image/png,image/jpeg"
                onChange={handleImageChange}
                className="w-full bg-stone-800 border border-stone-700 rounded p-2 text-stone-200"
                required
              />
              <p className="text-xs text-stone-500 mt-1">
                Upload a PNG or JPG image (max 10MB)
              </p>
            </div>
          </div>
          
          {/* Image preview and sections */}
          <div>
            {imagePreview ? (
              <div className="mb-3">
                <label className="block text-sm font-medium text-stone-300 mb-1">
                  Preview
                </label>
                <div className="border border-stone-700 rounded overflow-hidden h-48">
                  <img
                    src={imagePreview}
                    alt="Tileset Preview"
                    className="w-full h-full object-cover"
                  />
                </div>
              </div>
            ) : (
              <div className="mb-3 border border-stone-700 rounded h-48 flex items-center justify-center bg-stone-800 text-stone-500">
                No image selected
              </div>
            )}
            
            <div>
              <label className="block text-sm font-medium text-stone-300 mb-1">
                Tileset Sections*
              </label>
              <p className="text-xs text-stone-500 mb-2">
                Define sections for different types of tiles (floors, walls, etc.)
              </p>
              
              {sections.map((section, index) => (
                <div key={index} className="mb-2 p-3 bg-stone-800 rounded border border-stone-700">
                  <div className="flex justify-between mb-2">
                    <span className="text-sm font-medium text-stone-300">Section {index + 1}</span>
                    {sections.length > 1 && (
                      <button
                        type="button"
                        onClick={() => removeSection(index)}
                        className="text-red-400 hover:text-red-300"
                      >
                        <X size={16} />
                      </button>
                    )}
                  </div>
                  
                  <div className="grid grid-cols-2 gap-2 mb-2">
                    <div>
                      <label className="block text-xs text-stone-400 mb-1">
                        Category
                      </label>
                      <select
                        value={section.category}
                        onChange={(e) => handleSectionChange(index, 'category', e.target.value)}
                        className="w-full bg-stone-700 border border-stone-600 rounded p-1 text-stone-200 text-sm"
                      >
                        <option value="floor">Floor</option>
                        <option value="wall">Wall</option>
                        <option value="shadow">Shadow</option>
                        <option value="door">Door</option>
                        <option value="object">Object</option>
                      </select>
                    </div>
                    
                    <div>
                      <label className="block text-xs text-stone-400 mb-1">
                        Section Name
                      </label>
                      <input
                        type="text"
                        value={section.section_name}
                        onChange={(e) => handleSectionChange(index, 'section_name', e.target.value)}
                        className="w-full bg-stone-700 border border-stone-600 rounded p-1 text-stone-200 text-sm"
                      />
                    </div>
                  </div>
                  
                  <div className="grid grid-cols-2 gap-2">
                    <div>
                      <label className="block text-xs text-stone-400 mb-1">
                        Start Index
                      </label>
                      <input
                        type="number"
                        value={section.start_index}
                        onChange={(e) => handleSectionChange(index, 'start_index', e.target.value)}
                        className="w-full bg-stone-700 border border-stone-600 rounded p-1 text-stone-200 text-sm"
                        min="0"
                      />
                    </div>
                    
                    <div>
                      <label className="block text-xs text-stone-400 mb-1">
                        Tile Count
                      </label>
                      <input
                        type="number"
                        value={section.count}
                        onChange={(e) => handleSectionChange(index, 'count', e.target.value)}
                        className="w-full bg-stone-700 border border-stone-600 rounded p-1 text-stone-200 text-sm"
                        min="1"
                      />
                    </div>
                  </div>
                </div>
              ))}
              
              <button
                type="button"
                onClick={addSection}
                className="mt-2 px-3 py-1 bg-stone-700 hover:bg-stone-600 rounded text-sm"
              >
                + Add Section
              </button>
            </div>
          </div>
        </div>
        
        <div className="mt-4 flex justify-end">
          <button
            type="submit"
            disabled={uploading}
            className={`px-4 py-2 rounded text-sm flex items-center ${
              uploading
                ? 'bg-stone-600 cursor-not-allowed'
                : 'bg-teal-700 hover:bg-teal-600'
            }`}
          >
            {uploading ? 'Uploading...' : 'Upload Tileset'}
          </button>
        </div>
      </form>
    </div>
  );
};

export default MarketplaceWindow;

================
File: windows/TerminalWindow.jsx
================
import React, { useState, useEffect, useRef, useReducer } from 'react';
import d20Gif from '../../assets/GIF/d20.gif';
import { WINDOW_TYPES } from '../../utils/windowTypes';
import { useAuth } from '../../context/AuthContext';
import { useAnnouncement } from '../../context/AnnouncementContext';
import { useWindowState } from '../../context/WindowStateContext';
import { useParty } from '../../context/PartyContext';
import { saveTerminalState, getTerminalState } from '../../services/indexedDBService';
import { parseDiceExpression, rollDice, formatRollResult, isValidDiceType } from '../../utils/diceUtils';
import DebugLogger from '../../utils/debugLogger';
import { executeCommand } from '../../utils/terminal/executor';
import { registerCommands } from '../../utils/terminal/commandLoader';

// Initialize the command system
registerCommands();

const TerminalWindow = ({ onCommand, isActive, nodeId, transformWindow, windowState, updateWindowState, focusRef }) => {
  // Get user authentication info
  const { user } = useAuth();
  // Get announcement context
  const { updateAnnouncement } = useAnnouncement();
  // Get window state context for additional persistence
  const { setActiveWindow } = useWindowState();
  // Get party context
  const { 
    currentParty, 
    parties, 
    joinParty, 
    leaveParty, 
    createParty, 
    refreshParty,
    refreshParties,
    deleteParty
  } = useParty();
  
  // Ref for managing scrolling
  const terminalRef = useRef(null);
  // Ref to track if state has been loaded from IndexedDB
  const stateLoadedRef = useRef(false);
  // Ref to store the dice roll animation timeout
  const diceTimeoutRef = useRef(null);

  // Terminal state - use windowState if available
  const [history, setHistory] = useState(
    windowState?.history || ['SLUMNET TERMINAL - Type "help" for available commands.']
  );
  const [commandHistory, setCommandHistory] = useState(windowState?.commandHistory || []);
  const [currentInput, setCurrentInput] = useState(windowState?.currentInput || '');
  const [historyIndex, setHistoryIndex] = useState(windowState?.historyIndex || -1);

  // Load terminal state from IndexedDB on mount if not already in windowState
  useEffect(() => {
    const loadTerminalState = async () => {
      // Skip if we already have state from the WindowStateContext
      if (windowState?.history && windowState?.commandHistory) {
        stateLoadedRef.current = true;
        return;
      }
      
      try {
        // Try to load terminal state from IndexedDB
        const savedState = await getTerminalState(nodeId);
        
        if (savedState && savedState.content && !stateLoadedRef.current) {
          console.log(`Loaded terminal state for window ${nodeId} from IndexedDB:`, savedState.content);
          
          // Update state with saved values
          if (savedState.content.history) {
            setHistory(savedState.content.history);
          }
          
          if (savedState.content.commandHistory) {
            setCommandHistory(savedState.content.commandHistory);
          }
          
          if (savedState.content.historyIndex !== undefined) {
            setHistoryIndex(savedState.content.historyIndex);
          }
          
          // Mark as loaded
          stateLoadedRef.current = true;
        }
      } catch (error) {
        console.error(`Failed to load terminal state for window ${nodeId} from IndexedDB:`, error);
      }
    };
    
    loadTerminalState();
  }, [nodeId, windowState]);

  // Auto-scroll to bottom when new output is added
  useEffect(() => {
    if (terminalRef.current) {
      terminalRef.current.scrollTop = terminalRef.current.scrollHeight;
    }
  }, [history]);
  
  // Clear input when window becomes active or when transformed back to terminal
  useEffect(() => {
    // Always clear the input when the component mounts or is transformed back to terminal
    setCurrentInput('');
  }, []);
  
  // Handle window activation
  useEffect(() => {
    if (isActive) {
      // Clear input when window becomes active
      setCurrentInput('');
      
      // Save this as the active terminal window
      setActiveWindow(nodeId, WINDOW_TYPES.TERMINAL);
    }
  }, [isActive, nodeId, setActiveWindow]);
  
  // Cleanup dice animation timeout when component unmounts
  useEffect(() => {
    // Return cleanup function
    return () => {
      // Clear any pending dice roll timeouts when unmounting
      if (diceTimeoutRef.current) {
        clearTimeout(diceTimeoutRef.current);
        diceTimeoutRef.current = null;
      }
    };
  }, []);
  
  // Create a reducer for forced updates - useReducer guarantees a re-render
  const [updateCounter, forceUpdate] = useReducer(state => state + 1, 0);
  
  // Force re-render to check dice GIFs that need to be replaced with results
  // This ensures the transition happens even when the component was unmounted and remounted
  useEffect(() => {
    // This checks and processes all dice GIFs that have completed their display duration
    const processDiceGifs = () => {
      let needsUpdate = false;
      
      // Process the history array to find and update dice GIFs
      const updatedHistory = history.map(item => {
        // Only process dice-gif items that have completed their duration
        if (typeof item === 'object' && 
            item.type === 'dice-gif' && 
            Date.now() - item.timestamp >= item.displayDuration) {
          
          needsUpdate = true;
          // Return the result instead of the GIF
          return item.result;
        }
        return item;
      });
      
      // If we found and updated any completed dice GIFs, update the history
      if (needsUpdate) {
        setHistory(updatedHistory);
      }
      
      // Check if there are still any active dice GIFs
      return history.some(item => 
        typeof item === 'object' && 
        item.type === 'dice-gif' && 
        Date.now() - item.timestamp < item.displayDuration
      );
    };
    
    // Initial check and processing
    const hasActiveDiceGifs = processDiceGifs();
    
    // If we have active dice GIFs, set up an interval to keep checking
    let intervalId;
    if (hasActiveDiceGifs) {
      intervalId = setInterval(() => {
        const stillHasActiveDiceGifs = processDiceGifs();
        
        // Force a render update regardless of whether we processed any GIFs
        forceUpdate();
        
        // If no more active dice GIFs, clear the interval
        if (!stillHasActiveDiceGifs && intervalId) {
          clearInterval(intervalId);
        }
      }, 200); // Check more frequently (200ms) for smoother transitions
    }
    
    return () => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [history]);

  // Update window state when terminal state changes
  useEffect(() => {
    if (updateWindowState) {
      const newState = {
        history,
        commandHistory,
        currentInput,
        historyIndex
      };
      
      // Update window state in context
      updateWindowState(newState);
      
      // Also save directly to IndexedDB for redundancy
      if (stateLoadedRef.current) { // Only save after initial load to avoid overwriting with empty state
        saveTerminalState({
          id: nodeId,
          content: newState
        }).catch(error => {
          console.error(`Failed to save terminal state for window ${nodeId} to IndexedDB:`, error);
        });
      }
    }
  }, [history, commandHistory, currentInput, historyIndex, updateWindowState, nodeId]);

  const handleTerminalClick = () => {
    focusRef.current?.focus();
  };

  const processCommand = async (command) => {
    setHistory(prev => [...prev, `$ ${command}`]);
    setCommandHistory(prev => [...prev, command]);
    
    // Legacy window transformation handling (direct conversion)
    const parts = command.split(' ');
    const cmd = parts[0].toLowerCase();
    
    if (Object.keys(WINDOW_TYPES).some(type => type.toLowerCase() === cmd)) {
      const requestedType = WINDOW_TYPES[cmd.toUpperCase()];
      transformWindow(nodeId, requestedType);
      return;
    }
    
    // Create recursive executeCommand function for legacy redirects
    const executeCommandFn = async (cmdStr) => {
      // Don't add the command to history since it's an internal redirect
      return await processCommand(cmdStr);
    };
    
    // Create the execution context with all necessary terminal state and functions
    const context = {
      // Original command text
      original: command,
      
      // User and authentication
      user,
      
      // Window management
      nodeId,
      transformWindow,
      
      // Announcement management
      updateAnnouncement,
      
      // Party system
      parties,
      currentParty,
      joinParty,
      leaveParty,
      createParty,
      refreshParty,
      refreshParties,
      deleteParty,
      
      // Dice utilities
      parseDiceExpression,
      rollDice,
      formatRollResult,
      isValidDiceType,
      
      // Debug utilities
      debugLogger: DebugLogger,
      
      // Terminal management
      clearTerminal: () => setHistory(['']),
      
      // Recursive command execution (for legacy redirects)
      executeCommand: executeCommandFn
    };
    
    try {
      // Execute the command using our new command system
      const response = await executeCommand(command, context);
      
      // Handle special return values
      if (response === '__CLEAR_TERMINAL__') {
        setHistory(['']);
        return;
      }
      
      // Handle response based on its type
      if (response) {
        if (typeof response === 'object' && response.type === 'dice-roll') {
          // Add the GIF to history with timestamp and result data
          setHistory(prev => [...prev, { 
            type: 'dice-gif', 
            src: d20Gif,
            timestamp: Date.now(), // Add current timestamp
            displayDuration: 2000, // Display for 2 seconds
            result: response.content // Store the result with the GIF
          }]);
        } else {
          // Handle regular text responses
          setHistory(prev => [...prev, response]);
        }
      }
    } catch (error) {
      console.error('Error executing command:', error);
      setHistory(prev => [...prev, `Error: ${error.message}`]);
    }
  };

  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && currentInput.trim()) {
      processCommand(currentInput.trim());
      setCurrentInput('');
      setHistoryIndex(-1);
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      if (historyIndex < commandHistory.length - 1) {
        const newIndex = historyIndex + 1;
        setHistoryIndex(newIndex);
        setCurrentInput(commandHistory[commandHistory.length - 1 - newIndex] || '');
      }
    } else if (e.key === 'ArrowDown') {
      e.preventDefault();
      if (historyIndex > -1) {
        const newIndex = historyIndex - 1;
        setHistoryIndex(newIndex);
        setCurrentInput(newIndex === -1 ? '' : commandHistory[commandHistory.length - 1 - newIndex] || '');
      }
    }
  };

  return (
    <div 
      className="bg-stone-900 text-white font-mono text-sm h-full flex flex-col"
      onClick={handleTerminalClick}
    >
<div ref={terminalRef} className="p-2 flex-1 overflow-auto whitespace-pre-wrap">
  {history.map((item, i) => {
    // If the item is an object with a type of 'dice-gif', handle it specially
    if (typeof item === 'object' && item.type === 'dice-gif') {
      // Check if enough time has passed since creation (2 seconds)
      const timeElapsed = Date.now() - item.timestamp;
      
      if (timeElapsed < item.displayDuration) {
        // If not enough time has passed, show the GIF
        return (
          <div key={i} className="mb-2">
            <img src={item.src} alt="Rolling dice" className="inline-block max-w-full h-32" />
          </div>
        );
      } else {
        // If enough time has passed, show the result instead
        return (
          <div key={i} className="mb-2">
            {item.result}
          </div>
        );
      }
    }
    // Keep backward compatibility with any 'gif' type items
    else if (typeof item === 'object' && item.type === 'gif') {
      return (
        <div key={i} className="mb-2">
          <img src={item.src} alt="Rolling dice" className="inline-block max-w-full h-32" />
        </div>
      );
    }
    // Otherwise, render as before
    return (
      <div key={i} className={`mb-2 ${typeof item === 'string' && item.startsWith('$ ') ? 'text-teal-400' : ''}`}>
        {item}
      </div>
    );
  })}
</div>

      <div className="p-2 flex items-center gap-2 border-t border-stone-700">
        <span className="mr-2">$</span>
        <input
          ref={focusRef}
          type="text"
          value={currentInput}
          onChange={(e) => setCurrentInput(e.target.value)}
          onKeyDown={handleKeyDown}
          className="flex-1 bg-stone-800 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
          autoFocus
        />
      </div>
    </div>
  );
};

export default TerminalWindow;



================================================================
End of Codebase
================================================================
