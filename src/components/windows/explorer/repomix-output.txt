This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
api/fileOperations.js
components/canvas/CanvasContainer.jsx
components/canvas/CanvasEditor.jsx
components/canvas/TextNode.jsx
components/CanvasEditor.jsx
components/CommandInput.jsx
components/dialogs/FileDialogs.jsx
components/FileContent.jsx
components/FileTree.jsx
components/MapEditor.jsx
components/nodes/index.js
components/nodes/TextNode.jsx
components/StorageStats.jsx
ExplorerWindow.jsx
README.md
state/useExplorerState.js
utils/canvasUtils.js
utils/fileUtils.js
utils/markdownUtils.js

================================================================
Files
================================================================

================
File: api/fileOperations.js
================
import API_CONFIG from '../../../../config/api';

// Function to fetch public directory contents
export const fetchPublicDirectoryContents = async (publicPath = '/', refreshAll = false) => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // If refreshAll is true, start from the root
    const pathToFetch = refreshAll ? '/' : publicPath;
    
    // Fetch public directory contents from the server
    const response = await fetch(
      `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PUBLIC_FILES_LIST}?path=${encodeURIComponent(pathToFetch)}`,
      {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      }
    );
    
    if (!response.ok) {
      throw new Error(`Failed to load public files: ${response.statusText}`);
    }
    
    const data = await response.json();
    
    // Transform the data to match our expected format
    const transformedFiles = data.items.map(item => ({
      name: item.name,
      type: item.type,
      path: item.path,
      children: item.children || [],
      isPublic: true
    }));
    
    return {
      files: transformedFiles,
      error: null
    };
  } catch (error) {
    console.error('Error fetching public directory contents:', error);
    return {
      files: [],
      error: error.message || 'Failed to load public files. Please try again.'
    };
  }
};

// Function to fetch public file content
export const fetchPublicFileContent = async (filePath) => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // Fetch public file content from the server
    const url = `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PUBLIC_FILE_CONTENT}?path=${encodeURIComponent(filePath)}`;
    
    const response = await fetch(
      url,
      {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      }
    );
    
    const data = await response.json();
    console.log(`[DEBUG] Public file fetch - Content received length: ${data.content?.length || 0} characters`);
    
    return {
      content: data.content,
      error: null
    };
  } catch (error) {
    console.error('[DEBUG] Error fetching public file content:', error);
    return {
      content: '',
      error: error.message || 'Error loading file'
    };
  }
};

// Function to fetch private directory contents from the server (admin only)
export const fetchDirectoryContents = async (path = '/', refreshAll = false) => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // If refreshAll is true, start from the root
    const pathToFetch = refreshAll ? '/' : path;
    
    // Fetch directory contents from the server
    const response = await fetch(
      `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILES_LIST}?path=${encodeURIComponent(pathToFetch)}`,
      {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      }
    );
    
    if (!response.ok) {
      // If response is 403, it means the user doesn't have admin access
      if (response.status === 403) {
        throw new Error('Admin access required to view files.');
      } else {
        throw new Error(`Failed to load files: ${response.statusText}`);
      }
    }
    
    const data = await response.json();
    
    // Transform the data to match our expected format
    const transformedFiles = data.items.map(item => ({
      name: item.name,
      type: item.type,
      path: item.path,
      children: item.children || []
    }));
    
    return {
      files: transformedFiles,
      error: null
    };
  } catch (error) {
    return {
      files: [],
      error: error.message || 'Failed to load files. Please try again.'
    };
  }
};

// Function to fetch file content
export const fetchFileContent = async (filePath) => {
  console.log(`[DEBUG] fetchFileContent called with path: ${filePath}`);
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // Fetch file content from the server
    const url = `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_CONTENT}?path=${encodeURIComponent(filePath)}`;
    
    const response = await fetch(
      url,
      {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      }
    );
    
    
    if (!response.ok) {
      // If response is 403, it means the user doesn't have admin access
      if (response.status === 403) {
        throw new Error('Admin access required to view file content.');
      } else {
        const errorText = await response.text();
        throw new Error(`Failed to load file content: ${response.statusText}`);
      }
    }
    
    const data = await response.json();
    
    return {
      content: data.content,
      error: null
    };
  } catch (error) {
    return {
      content: '',
      error: error.message || 'Error loading file'
    };
  }
};

// Function to save file content
export const saveFileContent = async (filePath, content) => {

  
  try {
    // Check if filePath is valid
    if (!filePath || filePath.trim() === '') {
      throw new Error('No file selected. Please select a file first.');
    }
    
    // Special handling for .map files to ensure rotation is included
    let contentToSave = content;
    if (filePath?.endsWith('.map') && typeof content === 'string') {
      // For map files, parse the JSON, process it, and re-stringify it
      try {
        const mapData = JSON.parse(content);
        
        // Ensure all cells have rotation property
        if (mapData.layers && Array.isArray(mapData.layers)) {
          mapData.layers.forEach(layer => {
            if (layer.cells && Array.isArray(layer.cells)) {
              layer.cells = layer.cells.map(cell => {
                // If rotation doesn't exist, add it with default value of 0
                if (cell.rotation === undefined) {
                  return { ...cell, rotation: 0 };
                }
                // Ensure rotation is a number
                if (typeof cell.rotation !== 'number') {
                  return { ...cell, rotation: Number(cell.rotation) };
                }
                return cell;
              });
            }
          });
        }
        
        // Use a custom replacer to guarantee rotation values are included
        contentToSave = JSON.stringify(mapData, (key, value) => {
          if (key === 'rotation') {
            return value === undefined ? 0 : Number(value);
          }
          return value;
        }, 2);
        
      } catch (parseError) {
        // If we can't parse, just use the original content
        contentToSave = content;
      }
    }
    
    // Create request body
    const requestBody = JSON.stringify({
      path: filePath,
      content: contentToSave
    });
    
    
    // Make the API request
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_SAVE}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
      },
      body: requestBody
    });
    
    
    const responseData = await response.json();
    
    if (!response.ok) {
      throw new Error(responseData.message || `Failed to save file: ${response.statusText}`);
    }
    
    console.log(`[DEBUG] saveFileContent - Success!`);
    return { 
      error: null,
      size: responseData.size,
      modified: responseData.modified
    };
  } catch (error) {
    console.error('[DEBUG] Error saving file:', error);
    return { error: error.message || 'Error saving file' };
  }
};

// Simple path join function for browser environment
const joinPaths = (...parts) => {
  // Filter out empty parts and normalize
  const normalized = parts.map(part => {
    if (part === undefined || part === null) return '';
    // Remove leading/trailing slashes
    return part.toString().replace(/^\/+|\/+$/g, '');
  }).filter(Boolean);
  
  // Join with slashes and add leading slash
  return '/' + normalized.join('/');
};

// Function to create a new file or folder
export const createNewItem = async (activeTab, activeFolderPath, newItemName, createType) => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // Determine if we're creating in the public folder or private folder
    const isPublicFolder = activeTab === 'public';
    
    // Construct the full path for the new item
    let newItemPath;
    if (isPublicFolder) {
      // For public folder, prefix with /public if not already included
      const publicPrefix = activeFolderPath.startsWith('/public') ? '' : '/public';
      // Remove any leading slash from activeFolderPath if it exists and if using publicPrefix
      const folderPath = publicPrefix && activeFolderPath.startsWith('/') 
        ? activeFolderPath.substring(1) 
        : activeFolderPath;
      newItemPath = joinPaths(publicPrefix, folderPath, newItemName.trim());
    } else {
      // For private folder (admin only)
      newItemPath = joinPaths(activeFolderPath, newItemName.trim());
    }
    
    // Create the new file or folder
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_CREATE}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        path: newItemPath,
        type: createType,
        content: createType === 'file' ? '' : undefined
      })
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || `Failed to create ${createType}: ${response.statusText}`);
    }
    
    return { 
      success: true, 
      path: newItemPath,
      error: null
    };
  } catch (error) {
    console.error(`Error creating ${createType}:`, error);
    return { 
      success: false, 
      path: null,
      error: error.message || `Failed to create ${createType}` 
    };
  }
};

// Function to rename a file or folder
export const renameItem = async (itemPath, newName) => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // Rename the file or folder
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_RENAME}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        oldPath: itemPath,
        newName: newName.trim()
      })
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || `Failed to rename: ${response.statusText}`);
    }
    
    return { success: true, error: null };
  } catch (error) {
    console.error('Error renaming:', error);
    return { success: false, error: error.message || 'Failed to rename' };
  }
};

// Function to delete a file or folder
export const deleteItem = async (itemPath) => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // Delete the file or folder
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_DELETE}?path=${encodeURIComponent(itemPath)}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || `Failed to delete: ${response.statusText}`);
    }
    
    return { success: true, error: null };
  } catch (error) {
    console.error('Error deleting:', error);
    return { success: false, error: error.message || 'Failed to delete' };
  }
};

// Function to move a file or folder
// Function to get storage usage statistics
export const getStorageStats = async () => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // Fetch storage stats from the server
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.STORAGE_STATS}`, {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });
    
    if (!response.ok) {
      throw new Error(`Failed to load storage stats: ${response.statusText}`);
    }
    
    const data = await response.json();
    
    return {
      quota: data.quota,
      used: data.used,
      available: data.available,
      unlimited: data.unlimited,
      error: null
    };
  } catch (error) {
    console.error('Error fetching storage stats:', error);
    return {
      quota: 0,
      used: 0,
      available: 0,
      unlimited: false,
      error: error.message || 'Failed to load storage stats'
    };
  }
};

export const moveItem = async (sourcePath, destinationPath) => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // Call the API to move the file
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_MOVE}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        sourcePath,
        destinationPath
      })
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || `Failed to move: ${response.statusText}`);
    }
    
    return { success: true, error: null };
  } catch (error) {
    console.error('Error moving item:', error);
    return { success: false, error: error.message || 'Failed to move item' };
  }
};

================
File: components/canvas/CanvasContainer.jsx
================
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { 
  generateId, 
  isPointInNode, 
  createTextNode, 
  createEdge,
  calculateBestConnectionSides,
  getConnectionPoints,
  drawConnection,
  getCanvasColor
} from '../../utils/canvasUtils';
import TextNode from './TextNode';

/**
 * CanvasContainer handles the infinite canvas, viewport, and interactions
 */
const CanvasContainer = ({ 
  canvasData, 
  onChange,
  readOnly = false
}) => {
  // State for viewport and interaction
  const [scale, setScale] = useState(1);
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  const [isPanning, setIsPanning] = useState(false);
  const [panStart, setPanStart] = useState({ x: 0, y: 0 });
  const [selectedNodeIds, setSelectedNodeIds] = useState([]);
  const [editingNodeId, setEditingNodeId] = useState(null);
  const [isConnecting, setIsConnecting] = useState(false);
  const [connectionStart, setConnectionStart] = useState(null);
  const [hoveredNodeId, setHoveredNodeId] = useState(null);
  const [isDragging, setIsDragging] = useState(false);
  const [draggedNodeIds, setDraggedNodeIds] = useState([]);

  // Refs for canvas elements
  const containerRef = useRef(null);
  const canvasRef = useRef(null);
  const interactionLayerRef = useRef(null);

  // Get the currently selected node
  const selectedNode = canvasData.nodes.find(node => node.id === selectedNodeIds[0]);

  // Draw the canvas with nodes and edges
  const drawCanvas = useCallback(() => {
    if (!canvasRef.current) return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const { width, height } = canvas;
    
    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    
    // Apply viewport transformation
    ctx.save();
    ctx.translate(offset.x, offset.y);
    ctx.scale(scale, scale);
    
    // Draw background grid (optional)
    ctx.strokeStyle = '#2a2a2a';
    ctx.lineWidth = 1 / scale;
    
    const gridSize = 20;
    const startX = Math.floor(-offset.x / scale / gridSize) * gridSize;
    const startY = Math.floor(-offset.y / scale / gridSize) * gridSize;
    const endX = Math.ceil((width - offset.x) / scale / gridSize) * gridSize;
    const endY = Math.ceil((height - offset.y) / scale / gridSize) * gridSize;
    
    // Draw vertical grid lines
    for (let x = startX; x <= endX; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, startY);
      ctx.lineTo(x, endY);
      ctx.stroke();
    }
    
    // Draw horizontal grid lines
    for (let y = startY; y <= endY; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(startX, y);
      ctx.lineTo(endX, y);
      ctx.stroke();
    }
    
    // Draw edges
    canvasData.edges.forEach(edge => {
      const sourceNode = canvasData.nodes.find(n => n.id === edge.fromNode);
      const targetNode = canvasData.nodes.find(n => n.id === edge.toNode);
      
      if (sourceNode && targetNode) {
        // Get connection points
        const points = getConnectionPoints(
          sourceNode, 
          targetNode, 
          edge.fromSide, 
          edge.toSide
        );
        
        // Draw the connection
        drawConnection(
          ctx, 
          points.source, 
          points.target, 
          getCanvasColor(edge.color),
          edge.fromEnd === 'arrow',
          edge.toEnd === 'arrow'
        );
      }
    });
    
    // Restore the context
    ctx.restore();
  }, [canvasData, offset, scale]);

  // Resize canvas to fit container
  const resizeCanvas = useCallback(() => {
    if (!containerRef.current || !canvasRef.current || !interactionLayerRef.current) return;
    
    const container = containerRef.current;
    const canvas = canvasRef.current;
    const interactionLayer = interactionLayerRef.current;
    
    // Set canvas size to match container
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    interactionLayer.width = container.clientWidth;
    interactionLayer.height = container.clientHeight;
    
    // Redraw canvas
    drawCanvas();
  }, [drawCanvas]);

  // Initialize and set up event listeners
  useEffect(() => {
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    return () => {
      window.removeEventListener('resize', resizeCanvas);
    };
  }, [resizeCanvas]);

  // Redraw canvas when data changes
  useEffect(() => {
    drawCanvas();
  }, [canvasData, drawCanvas, selectedNodeIds, scale, offset]);

  // Handle mouse wheel for zooming
  const handleWheel = (e) => {
    e.preventDefault();
    
    const { deltaY } = e;
    const direction = deltaY > 0 ? -1 : 1;
    
    // Calculate zoom
    const factor = 0.1;
    const newScale = Math.max(0.1, scale * (1 + direction * factor));
    
    // Get mouse position relative to canvas
    const rect = canvasRef.current.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Calculate new offset to zoom around mouse position
    const newOffsetX = mouseX - (mouseX - offset.x) * (newScale / scale);
    const newOffsetY = mouseY - (mouseY - offset.y) * (newScale / scale);
    
    setScale(newScale);
    setOffset({ x: newOffsetX, y: newOffsetY });
  };

  // Handle mouse down for panning and selection
  const handleMouseDown = (e) => {
    // Get mouse position relative to canvas
    const rect = canvasRef.current.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Convert to canvas coordinates
    const canvasX = (mouseX - offset.x) / scale;
    const canvasY = (mouseY - offset.y) / scale;
    
    // Check if clicked on a node
    const nodeUnderMouse = canvasData.nodes.find(node => 
      isPointInNode({ x: canvasX, y: canvasY }, node)
    );
    
    if (nodeUnderMouse) {
      // Select the node
      if (e.shiftKey) {
        // Add to selection if holding shift
        setSelectedNodeIds(prev => 
          prev.includes(nodeUnderMouse.id) 
            ? prev.filter(id => id !== nodeUnderMouse.id) 
            : [...prev, nodeUnderMouse.id]
        );
      } else if (!selectedNodeIds.includes(nodeUnderMouse.id)) {
        // Replace selection
        setSelectedNodeIds([nodeUnderMouse.id]);
      }
      
      // Prepare for dragging
      setIsDragging(true);
      setDraggedNodeIds(selectedNodeIds.includes(nodeUnderMouse.id) 
        ? selectedNodeIds 
        : [nodeUnderMouse.id]
      );
    } else {
      // Start panning
      setIsPanning(true);
      setPanStart({ x: mouseX, y: mouseY });
      
      // Clear selection unless shift is held
      if (!e.shiftKey) {
        setSelectedNodeIds([]);
      }
    }
  };

  // Handle mouse move for panning and dragging
  const handleMouseMove = (e) => {
    // Get mouse position relative to canvas
    const rect = canvasRef.current.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Convert to canvas coordinates
    const canvasX = (mouseX - offset.x) / scale;
    const canvasY = (mouseY - offset.y) / scale;
    
    // Handle panning
    if (isPanning) {
      const deltaX = mouseX - panStart.x;
      const deltaY = mouseY - panStart.y;
      
      setOffset(prev => ({
        x: prev.x + deltaX,
        y: prev.y + deltaY
      }));
      
      setPanStart({ x: mouseX, y: mouseY });
    }
    
    // Handle dragging
    if (isDragging && draggedNodeIds.length > 0 && !readOnly) {
      // Calculate the delta from last mouse position
      const lastMousePos = {
        x: (panStart.x - offset.x) / scale,
        y: (panStart.y - offset.y) / scale
      };
      
      const deltaX = canvasX - lastMousePos.x;
      const deltaY = canvasY - lastMousePos.y;
      
      // Update node positions
      const updatedNodes = canvasData.nodes.map(node => {
        if (draggedNodeIds.includes(node.id)) {
          return {
            ...node,
            x: node.x + deltaX,
            y: node.y + deltaY
          };
        }
        return node;
      });
      
      // Update canvas data
      onChange({
        ...canvasData,
        nodes: updatedNodes
      });
      
      // Update pan start
      setPanStart({ x: mouseX, y: mouseY });
    }
    
    // Check for node under mouse for hover effect
    const nodeUnderMouse = canvasData.nodes.find(node => 
      isPointInNode({ x: canvasX, y: canvasY }, node)
    );
    
    setHoveredNodeId(nodeUnderMouse?.id || null);
  };

  // Handle mouse up to stop panning and dragging
  const handleMouseUp = () => {
    setIsPanning(false);
    setIsDragging(false);
    setDraggedNodeIds([]);
  };

  // Handle node selection
  const handleNodeSelect = (nodeId) => {
    setSelectedNodeIds([nodeId]);
  };

  // Handle node text change
  const handleNodeTextChange = (nodeId, text) => {
    const updatedNodes = canvasData.nodes.map(node => {
      if (node.id === nodeId) {
        return {
          ...node,
          text
        };
      }
      return node;
    });
    
    onChange({
      ...canvasData,
      nodes: updatedNodes
    });
  };

  // Handle node resize
  const handleNodeResize = (nodeId, width, height) => {
    const updatedNodes = canvasData.nodes.map(node => {
      if (node.id === nodeId) {
        return {
          ...node,
          width,
          height
        };
      }
      return node;
    });
    
    onChange({
      ...canvasData,
      nodes: updatedNodes
    });
  };

  // Handle node move
  const handleNodeMove = (nodeId, x, y) => {
    const updatedNodes = canvasData.nodes.map(node => {
      if (node.id === nodeId) {
        return {
          ...node,
          x,
          y
        };
      }
      return node;
    });
    
    onChange({
      ...canvasData,
      nodes: updatedNodes
    });
  };

  // Add a new text node at a specific position
  const addTextNode = (x, y, text = 'New note') => {
    if (readOnly) return;
    
    // Convert screen coordinates to canvas coordinates
    const canvasX = (x - offset.x) / scale;
    const canvasY = (y - offset.y) / scale;
    
    // Create a new node
    const newNode = createTextNode(canvasX, canvasY, text);
    
    // Add to canvas data
    onChange({
      ...canvasData,
      nodes: [...canvasData.nodes, newNode]
    });
    
    // Select the new node
    setSelectedNodeIds([newNode.id]);
    
    // Start editing the new node
    setEditingNodeId(newNode.id);
    
    return newNode.id;
  };

  // Create a connection between two nodes
  const connectNodes = (sourceId, targetId) => {
    if (readOnly) return;
    
    // Find the nodes
    const sourceNode = canvasData.nodes.find(n => n.id === sourceId);
    const targetNode = canvasData.nodes.find(n => n.id === targetId);
    
    if (!sourceNode || !targetNode) return;
    
    // Calculate best connection sides
    const { fromSide, toSide } = calculateBestConnectionSides(sourceNode, targetNode);
    
    // Create a new edge
    const newEdge = createEdge(sourceId, targetId, fromSide, toSide);
    
    // Add to canvas data
    onChange({
      ...canvasData,
      edges: [...canvasData.edges, newEdge]
    });
    
    return newEdge.id;
  };

  // Delete selected nodes and their connections
  const deleteSelected = () => {
    if (readOnly || selectedNodeIds.length === 0) return;
    
    // Filter out selected nodes
    const updatedNodes = canvasData.nodes.filter(node => 
      !selectedNodeIds.includes(node.id)
    );
    
    // Filter out edges connected to deleted nodes
    const updatedEdges = canvasData.edges.filter(edge => 
      !selectedNodeIds.includes(edge.fromNode) && 
      !selectedNodeIds.includes(edge.toNode)
    );
    
    // Update canvas data
    onChange({
      ...canvasData,
      nodes: updatedNodes,
      edges: updatedEdges
    });
    
    // Clear selection
    setSelectedNodeIds([]);
  };

  // Start editing a node
  const startNodeEditing = (nodeId) => {
    setEditingNodeId(nodeId);
  };

  // Stop editing a node
  const stopNodeEditing = () => {
    setEditingNodeId(null);
  };

  return (
    <div 
      ref={containerRef}
      className="relative w-full h-full overflow-hidden bg-stone-900"
      tabIndex={0} // Make container focusable for keyboard shortcuts
      onKeyDown={(e) => {
        // Delete key to remove selected nodes
        if (e.key === 'Delete' && !readOnly) {
          deleteSelected();
        }
      }}
    >
      {/* Canvas for rendering edges */}
      <canvas 
        ref={canvasRef}
        className="absolute top-0 left-0 w-full h-full"
      />
      
      {/* Interaction layer */}
      <canvas 
        ref={interactionLayerRef}
        className="absolute top-0 left-0 w-full h-full"
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        onWheel={handleWheel}
        onDoubleClick={(e) => {
          if (readOnly) return;
          
          // Get mouse position
          const rect = canvasRef.current.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          
          // Add a new node at this position
          addTextNode(mouseX, mouseY);
        }}
      />
      
      {/* Node elements */}
      <div className="absolute top-0 left-0 w-full h-full pointer-events-none">
        {canvasData.nodes.map(node => (
          node.type === 'text' && (
            <TextNode
              key={node.id}
              node={node}
              selected={selectedNodeIds.includes(node.id)}
              onSelect={handleNodeSelect}
              onChange={handleNodeTextChange}
              onResize={handleNodeResize}
              onMove={handleNodeMove}
              scale={scale}
              isEditing={editingNodeId === node.id}
              onStartEditing={startNodeEditing}
              onStopEditing={stopNodeEditing}
            />
          )
        ))}
      </div>
      
      {/* Controls */}
      <div className="absolute bottom-4 right-4 flex flex-col gap-2 bg-stone-800 p-2 rounded shadow">
        <button 
          className="p-2 bg-stone-700 hover:bg-stone-600 rounded text-white"
          onClick={() => setScale(scale + 0.1)}
        >
          +
        </button>
        <button 
          className="p-2 bg-stone-700 hover:bg-stone-600 rounded text-white"
          onClick={() => setScale(Math.max(0.1, scale - 0.1))}
        >
          -
        </button>
        <button 
          className="p-2 bg-stone-700 hover:bg-stone-600 rounded text-white"
          onClick={() => {
            // Reset view
            setScale(1);
            setOffset({ x: 0, y: 0 });
          }}
        >
          Reset
        </button>
      </div>
    </div>
  );
};

export default CanvasContainer;

================
File: components/canvas/CanvasEditor.jsx
================
import React, { useState, useEffect, useCallback } from 'react';
import { 
  createEmptyCanvas, 
  createTextNode, 
  createEdge, 
  generateId 
} from '../../utils/canvasUtils';
import CanvasContainer from './CanvasContainer';
import { 
  Plus, 
  Save, 
  Trash2, 
  Type,
  Link as LinkIcon,
  ArrowRight
} from 'lucide-react';

/**
 * Canvas Editor component that implements the JSONCanvas format
 * This is the main component for editing .canvas files
 */
const CanvasEditor = ({ fileContent, selectedFile, onSave }) => {
  const [canvasData, setCanvasData] = useState(createEmptyCanvas());
  const [canvasName, setCanvasName] = useState('Untitled Canvas');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [saveStatus, setSaveStatus] = useState('saved'); // 'saved', 'saving', 'error'
  const [showNodeCreator, setShowNodeCreator] = useState(false);
  const [newNodeText, setNewNodeText] = useState('');
  const [showConnectionCreator, setShowConnectionCreator] = useState(false);
  const [connectionNodes, setConnectionNodes] = useState({ source: '', target: '' });

  // Load canvas data when fileContent changes
  useEffect(() => {
    try {
      if (fileContent) {
        setIsLoading(true);
        
        // Parse the JSON canvas file
        const parsed = JSON.parse(fileContent);
        
        // Check if it has the basic JSONCanvas structure
        if (parsed.nodes || parsed.edges) {
          setCanvasData({
            nodes: parsed.nodes || [],
            edges: parsed.edges || []
          });
          
          // Extract canvas name from file path
          if (selectedFile) {
            const pathParts = selectedFile.path.split('/');
            const fileName = pathParts[pathParts.length - 1];
            setCanvasName(fileName.replace('.canvas', ''));
          }
          
          setSaveStatus('saved');
        } else {
          // Create a new canvas if the structure is invalid
          setCanvasData(createEmptyCanvas());
          console.warn('Invalid canvas format, creating new canvas');
        }
        
        setError(null);
      } else {
        // Create a new canvas if no content
        setCanvasData(createEmptyCanvas());
      }
    } catch (err) {
      console.error('Error parsing canvas file:', err);
      setError('Failed to parse canvas file. Creating a new canvas.');
      setCanvasData(createEmptyCanvas());
    } finally {
      setIsLoading(false);
    }
  }, [fileContent, selectedFile]);

  // Save canvas to file
  const handleSaveCanvas = useCallback(() => {
    if (!selectedFile) return;
    
    try {
      // Set status to saving
      setSaveStatus('saving');
      
      // Convert canvasData to proper format for saving
      // Make sure to remove any runtime-only properties
      const saveData = {
        nodes: canvasData.nodes.map(node => ({
          id: node.id,
          type: node.type,
          x: node.x,
          y: node.y,
          width: node.width,
          height: node.height,
          text: node.text,
          color: node.color
        })),
        edges: canvasData.edges.map(edge => ({
          id: edge.id,
          fromNode: edge.fromNode,
          toNode: edge.toNode,
          fromSide: edge.fromSide,
          toSide: edge.toSide,
          fromEnd: edge.fromEnd,
          toEnd: edge.toEnd,
          color: edge.color
        }))
      };
      
      // Serialize to JSON
      const jsonData = JSON.stringify(saveData, null, 2);
      
      // Call parent onSave function
      onSave(jsonData);
      
      // Update status
      setSaveStatus('saved');
    } catch (err) {
      console.error('Error saving canvas:', err);
      setError('Failed to save canvas file.');
      setSaveStatus('error');
    }
  }, [canvasData, selectedFile, onSave]);

  // Auto-save when canvas data changes
  useEffect(() => {
    if (canvasData.nodes.length > 0 || canvasData.edges.length > 0) {
      // Only trigger auto-save if we have content
      const timer = setTimeout(() => {
        handleSaveCanvas();
      }, 1000); // 1 second debounce
      
      return () => clearTimeout(timer);
    }
  }, [canvasData, handleSaveCanvas]);

  // Add a new node to the canvas
  const addNode = (type, text) => {
    // Create a node positioned in the center of the visible area
    const centerX = 100;
    const centerY = 100;
    
    let newNode;
    if (type === 'text') {
      newNode = createTextNode(centerX, centerY, text || 'New note');
    } else {
      // Default to text node
      newNode = createTextNode(centerX, centerY, text || 'New note');
    }
    
    // Add node to canvas data
    setCanvasData(prev => ({
      ...prev,
      nodes: [...prev.nodes, newNode]
    }));
    
    // Reset UI state
    setShowNodeCreator(false);
    setNewNodeText('');
    
    return newNode.id;
  };

  // Create a connection between two nodes
  const createConnection = (sourceId, targetId) => {
    // Find nodes to connect
    const sourceNode = canvasData.nodes.find(n => n.id === sourceId);
    const targetNode = canvasData.nodes.find(n => n.id === targetId);
    
    if (!sourceNode || !targetNode) {
      setError('Could not find one or both nodes to connect.');
      return;
    }
    
    // Create the edge and add it to canvas data
    const newEdge = createEdge(sourceId, targetId);
    
    setCanvasData(prev => ({
      ...prev,
      edges: [...prev.edges, newEdge]
    }));
    
    // Reset UI state
    setShowConnectionCreator(false);
    setConnectionNodes({ source: '', target: '' });
    
    return newEdge.id;
  };

  // Delete selected nodes
  const handleDeleteSelected = (nodeIds) => {
    if (!nodeIds || nodeIds.length === 0) return;
    
    // Remove nodes
    const updatedNodes = canvasData.nodes.filter(node => 
      !nodeIds.includes(node.id)
    );
    
    // Remove edges connected to those nodes
    const updatedEdges = canvasData.edges.filter(edge => 
      !nodeIds.includes(edge.fromNode) && 
      !nodeIds.includes(edge.toNode)
    );
    
    // Update canvas data
    setCanvasData({
      nodes: updatedNodes,
      edges: updatedEdges
    });
  };

  // Handle canvas data changes from CanvasContainer
  const handleCanvasChange = (newData) => {
    setCanvasData(newData);
    setSaveStatus('saving');
  };

  // If the canvas is still loading, show a loading state
  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-full">
        <span className="text-teal-300">Loading canvas editor...</span>
      </div>
    );
  }

  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400 overflow-hidden">
      {/* Toolbar */}
      <div className="p-2 border-b border-stone-700 flex justify-between items-center bg-stone-800">
        <h2 className="text-md font-semibold text-teal-400">{canvasName}</h2>
        
        <div className="flex gap-2">
          <button 
            onClick={handleSaveCanvas}
            className="px-2 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs flex items-center gap-1"
            title="Save canvas"
          >
            <Save size={14} />
            Save
          </button>
          
          <button 
            onClick={() => setShowNodeCreator(true)}
            className="px-2 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs flex items-center gap-1"
            title="Add text node"
          >
            <Type size={14} />
            Add Note
          </button>
          
          <button 
            onClick={() => setShowConnectionCreator(true)}
            className="px-2 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs flex items-center gap-1"
            title="Create connection"
          >
            <ArrowRight size={14} />
            Connect
          </button>
        </div>
      </div>
      
      {/* Error message */}
      {error && (
        <div className="p-2 bg-red-900 text-red-200 text-sm">
          {error}
        </div>
      )}
      
      {/* Node creator dialog */}
      {showNodeCreator && (
        <div className="p-2 border-b border-stone-700 bg-stone-800">
          <div className="flex items-center justify-between mb-1">
            <span className="text-sm font-bold">
              New Text Node
            </span>
            <button
              onClick={() => setShowNodeCreator(false)}
              className="p-1 rounded hover:bg-stone-700 text-stone-400"
            >
              <Trash2 size={14} />
            </button>
          </div>
          
          <div className="flex flex-col gap-2">
            <textarea
              value={newNodeText}
              onChange={(e) => setNewNodeText(e.target.value)}
              placeholder="Enter text content"
              className="w-full bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
              rows={3}
            />
            <div className="flex justify-end">
              <button
                onClick={() => addNode('text', newNodeText)}
                className="px-2 py-1 bg-teal-700 text-teal-100 hover:bg-teal-600 rounded text-xs"
              >
                Create
              </button>
            </div>
          </div>
        </div>
      )}
      
      {/* Connection creator dialog */}
      {showConnectionCreator && (
        <div className="p-2 border-b border-stone-700 bg-stone-800">
          <div className="flex items-center justify-between mb-1">
            <span className="text-sm font-bold">
              Create Connection
            </span>
            <button
              onClick={() => setShowConnectionCreator(false)}
              className="p-1 rounded hover:bg-stone-700 text-stone-400"
            >
              <Trash2 size={14} />
            </button>
          </div>
          
          <div className="flex flex-col gap-2">
            <div className="flex gap-2 items-center">
              <label className="text-xs w-20">From Node:</label>
              <select
                value={connectionNodes.source}
                onChange={(e) => setConnectionNodes(prev => ({ ...prev, source: e.target.value }))}
                className="flex-1 bg-stone-700 text-teal-400 px-2 py-1 rounded text-xs focus:outline-none"
              >
                <option value="">Select source node</option>
                {canvasData.nodes.map(node => (
                  <option key={node.id} value={node.id}>
                    {node.text ? node.text.substring(0, 20) + (node.text.length > 20 ? '...' : '') : node.id}
                  </option>
                ))}
              </select>
            </div>
            
            <div className="flex gap-2 items-center">
              <label className="text-xs w-20">To Node:</label>
              <select
                value={connectionNodes.target}
                onChange={(e) => setConnectionNodes(prev => ({ ...prev, target: e.target.value }))}
                className="flex-1 bg-stone-700 text-teal-400 px-2 py-1 rounded text-xs focus:outline-none"
              >
                <option value="">Select target node</option>
                {canvasData.nodes.map(node => (
                  <option key={node.id} value={node.id}>
                    {node.text ? node.text.substring(0, 20) + (node.text.length > 20 ? '...' : '') : node.id}
                  </option>
                ))}
              </select>
            </div>
            
            <div className="flex justify-end">
              <button
                onClick={() => createConnection(connectionNodes.source, connectionNodes.target)}
                disabled={!connectionNodes.source || !connectionNodes.target}
                className={`px-2 py-1 rounded text-xs ${
                  connectionNodes.source && connectionNodes.target
                    ? 'bg-teal-700 text-teal-100 hover:bg-teal-600'
                    : 'bg-stone-600 text-stone-400 cursor-not-allowed'
                }`}
              >
                Connect
              </button>
            </div>
          </div>
        </div>
      )}
      
      {/* Canvas container */}
      <div className="flex-1 overflow-hidden">
        <CanvasContainer 
          canvasData={canvasData}
          onChange={handleCanvasChange}
          onDeleteSelected={handleDeleteSelected}
        />
      </div>
      
      {/* Status indicator */}
      <div className="px-2 py-1 border-t border-stone-700 bg-stone-800 text-xs flex justify-between">
        <span>
          {canvasData.nodes.length} nodes, {canvasData.edges.length} connections
        </span>
        <span>
          {saveStatus === 'saving' && <span className="text-yellow-400">Saving...</span>}
          {saveStatus === 'saved' && <span className="text-green-400">Saved</span>}
          {saveStatus === 'error' && <span className="text-red-400">Error saving!</span>}
        </span>
      </div>
    </div>
  );
};

export default CanvasEditor;

================
File: components/canvas/TextNode.jsx
================
import React, { useState, useRef, useEffect } from 'react';
import { getCanvasColor } from '../../utils/canvasUtils';

/**
 * TextNode component renders an individual text node in the canvas
 */
const TextNode = ({
  node,
  selected,
  onSelect,
  onChange,
  onResize,
  onMove,
  scale,
  isEditing,
  onStartEditing,
  onStopEditing
}) => {
  const [localText, setLocalText] = useState(node.text || '');
  const textareaRef = useRef(null);
  const nodeRef = useRef(null);
  const resizeHandleRef = useRef(null);
  const [isResizing, setIsResizing] = useState(false);
  const [initialSize, setInitialSize] = useState({ width: 0, height: 0 });
  const [initialPosition, setInitialPosition] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });

  // Update local text when node text changes
  useEffect(() => {
    setLocalText(node.text || '');
  }, [node.text]);

  // Focus the textarea when editing starts
  useEffect(() => {
    if (isEditing && textareaRef.current) {
      textareaRef.current.focus();
    }
  }, [isEditing]);

  // Handle mouse down for node selection and drag start
  const handleMouseDown = (e) => {
    e.stopPropagation();
    
    // Select this node
    onSelect(node.id);
    
    // If not already editing, prepare for dragging
    if (!isEditing) {
      setIsDragging(true);
      setInitialPosition({ x: node.x, y: node.y });
      setDragOffset({
        x: e.clientX / scale - node.x,
        y: e.clientY / scale - node.y
      });
    }
  };

  // Handle mouse down on resize handle
  const handleResizeMouseDown = (e) => {
    e.stopPropagation();
    
    // Start resizing
    setIsResizing(true);
    setInitialSize({ width: node.width, height: node.height });
    setInitialPosition({ x: e.clientX, y: e.clientY });
  };

  // Handle text change
  const handleTextChange = (e) => {
    const newText = e.target.value;
    setLocalText(newText);
    onChange(node.id, newText);
  };

  // Handle double click to start editing
  const handleDoubleClick = (e) => {
    e.stopPropagation();
    
    // Start editing
    if (!isEditing) {
      onStartEditing(node.id);
    }
  };

  // Handle blur to stop editing
  const handleBlur = () => {
    if (isEditing) {
      onStopEditing();
    }
  };

  // Get the background color
  const bgColor = getCanvasColor(node.color) || '#1e293b';
  const borderColor = selected ? '#14b8a6' : '#334155';

  return (
    <div
      ref={nodeRef}
      className="absolute select-none"
      style={{
        left: node.x,
        top: node.y,
        width: node.width,
        height: node.height,
        transform: `scale(${scale})`,
        transformOrigin: 'top left',
        zIndex: selected ? 10 : 1
      }}
      onMouseDown={handleMouseDown}
      onDoubleClick={handleDoubleClick}
    >
      <div
        className="w-full h-full rounded-md overflow-hidden flex flex-col"
        style={{
          backgroundColor: bgColor,
          border: `2px solid ${borderColor}`,
          boxShadow: selected ? '0 0 0 2px rgba(20, 184, 166, 0.5)' : 'none'
        }}
      >
        {isEditing ? (
          <textarea
            ref={textareaRef}
            className="w-full h-full p-2 bg-transparent text-white resize-none focus:outline-none"
            value={localText}
            onChange={handleTextChange}
            onBlur={handleBlur}
          />
        ) : (
          <div className="w-full h-full p-2 text-white overflow-auto whitespace-pre-wrap">
            {localText}
          </div>
        )}
        
        {/* Resize handle - only show when selected */}
        {selected && (
          <div
            ref={resizeHandleRef}
            className="absolute bottom-0 right-0 w-4 h-4 bg-teal-500 rounded-tl-md cursor-nwse-resize"
            onMouseDown={handleResizeMouseDown}
          />
        )}
      </div>
    </div>
  );
};

export default TextNode;

================
File: components/CanvasEditor.jsx
================
import React, { useState, useEffect, useRef, useCallback } from 'react';
import ReactFlow, {
  Background,
  Controls,
  MiniMap,
  useNodesState,
  useEdgesState,
  addEdge,
  Panel
} from 'reactflow';
import 'reactflow/dist/style.css';
import { 
  Plus, 
  Save, 
  FileText, 
  Trash2, 
  Type,
  Square,
  Link as LinkIcon,
  Edit,
} from 'lucide-react';

// Import node types from the node registry
import nodeTypes from './nodes';

/**
 * Canvas Editor component for use within the FileContent area
 * This component handles the editing of .canvas files in the file explorer
 */
const CanvasEditor = ({ fileContent, selectedFile, onSave }) => {
  const [canvasName, setCanvasName] = useState('Untitled Canvas');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [saveStatus, setSaveStatus] = useState('saved'); // 'saved', 'saving', 'error'
  
  // ReactFlow states
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [reactFlowInstance, setReactFlowInstance] = useState(null);
  
  // UI states
  const [selectedElements, setSelectedElements] = useState([]);
  const [showNodeCreator, setShowNodeCreator] = useState(false);
  const [newNodeType, setNewNodeType] = useState('text');
  const [newNodeText, setNewNodeText] = useState('');
  const [editingNode, setEditingNode] = useState(null);
  
  // For auto-save functionality
  const saveTimeoutRef = useRef(null);
  
  // Setup custom node types with required props
  const customNodeTypes = {};
  
  // Add the TextNode and pass required props
  customNodeTypes.text = (props) => {
    // Create a handler for text updates
    const handleNodeTextChange = (nodeId, newText) => {
      setNodes((nds) => 
        nds.map((node) => {
          if (node.id === nodeId) {
            return {
              ...node,
              data: {
                ...node.data,
                text: newText
              }
            };
          }
          return node;
        })
      );
    };
    
    // Add the onChange handler to node data
    const nodeWithHandlers = {
      ...props,
      data: {
        ...props.data,
        onChange: handleNodeTextChange
      },
      editingNode: editingNode,
      setEditingNode: setEditingNode
    };
    
    // Use the TextNode component from the registry
    return React.createElement(nodeTypes.text, nodeWithHandlers);
  };
  
  // Load canvas data when fileContent changes
  useEffect(() => {
    try {
      if (fileContent) {
        setIsLoading(true);
        
        // Parse the JSON canvas file
        const canvasData = JSON.parse(fileContent);
        
        if (canvasData.nodes && canvasData.edges) {
          // Transform nodes from JSONCanvas format to ReactFlow format
          const transformedNodes = canvasData.nodes.map(node => {
            // Check if node has position as an object or direct x/y properties
            const nodeX = node.position?.x !== undefined ? node.position.x : (node.x || 0);
            const nodeY = node.position?.y !== undefined ? node.position.y : (node.y || 0);
            
            return {
              id: node.id,
              type: node.type,
              // For ReactFlow, use position property
              position: {
                x: nodeX,
                y: nodeY
              },
              // Preserve data, or create default data object with text if not present
              data: node.data || { text: node.text || "Text node" }
            };
          });
          
          console.log('[DEBUG] Transformed nodes:', transformedNodes.length);
          setNodes(transformedNodes);
          setEdges(canvasData.edges);
          
          // Extract canvas name from file path or use from canvas data
          if (canvasData.name) {
            setCanvasName(canvasData.name);
          } else if (selectedFile) {
            const pathParts = selectedFile.path.split('/');
            const fileName = pathParts[pathParts.length - 1];
            setCanvasName(fileName.replace('.canvas', ''));
          }
          
          setSaveStatus('saved');
        } else {
          // Create a new canvas if the structure is invalid
          createNewCanvas();
        }
        
        setIsLoading(false);
        setError(null);
      } else {
        // Create a new canvas if no content
        createNewCanvas();
      }
    } catch (err) {
      console.error('Error parsing canvas file:', err);
      setError('Failed to parse canvas file. Creating a new canvas.');
      createNewCanvas();
      setIsLoading(false);
    }
  }, [fileContent, selectedFile]);
  
  // Auto-save when node/edge data changes
  useEffect(() => {
    if (nodes.length > 0 || edges.length > 0) {
      // Only start auto-save if we have actual content
      
      // Clear any existing timeout
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
      
      // Set save status to 'saving'
      setSaveStatus('saving');
      
      // Set a new timeout for auto-save
      saveTimeoutRef.current = setTimeout(() => {
        handleSaveCanvas();
      }, 1000); // 1 second debounce
    }
    
    // Cleanup function to clear the timeout when component unmounts
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, [nodes, edges]);
  
  // Create a new canvas
  const createNewCanvas = () => {
    setNodes([]);
    setEdges([]);
    
    // Set canvas name from file if available
    if (selectedFile) {
      const pathParts = selectedFile.path.split('/');
      const fileName = pathParts[pathParts.length - 1];
      setCanvasName(fileName.replace('.canvas', ''));
    } else {
      setCanvasName('Untitled Canvas');
    }
    
    setSaveStatus('saved');
  };
  
  // Save canvas to file
  const handleSaveCanvas = () => {
    if (!selectedFile) return;
    
    try {
      // Transform nodes from ReactFlow format back to JSONCanvas format
      const transformedNodes = nodes.map(node => {
        // Extract position from ReactFlow format
        const nodePosition = node.position || { x: 0, y: 0 };
        
        return {
          id: node.id,
          type: node.type,
          // Store position in a position object for compatibility with JSONCanvas format
          position: {
            x: nodePosition.x,
            y: nodePosition.y
          },
          // Preserve the data object
          data: node.data
        };
      });
      
      // Create canvas data structure
      const canvasData = {
        name: canvasName,
        nodes: transformedNodes,
        edges,
        version: "1.0",
        metadata: {
          created: new Date().toISOString(),
          modified: new Date().toISOString()
        }
      };
      
      // Debug logs to track the data flow
      console.log('[DEBUG] Canvas Editor - Saving canvas data:', {
        nodesLength: transformedNodes.length,
        edgesLength: edges.length,
        selectedFile: selectedFile?.path
      });
      
      // Set status to saving
      setSaveStatus('saving');
      
      // Serialize to JSON string
      const canvasContent = JSON.stringify(canvasData, null, 2);
      
      // Call the parent onSave function
      onSave(canvasContent);
      
      // Update state
      setSaveStatus('saved');
      setError(null);
    } catch (err) {
      console.error('Error saving canvas:', err);
      setError('Failed to save canvas file.');
      setSaveStatus('error');
    }
  };
  
  // Handle connection (edge) creation
  const onConnect = useCallback((params) => {
    // Create a custom edge with styling and ID
    setEdges((eds) => addEdge({
      ...params,
      id: `edge-${Date.now()}`,
      type: 'default',
      animated: false,
      style: { stroke: '#14b8a6' }
    }, eds));
  }, [setEdges]);
  
  // Handle node selection
  const onSelectionChange = useCallback(({ nodes, edges }) => {
    setSelectedElements([...nodes, ...edges]);
  }, []);
  
  // Handle drag over for node creation
  const onDragOver = useCallback((event) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);
  
  // Handle drop for node creation
  const onDrop = useCallback(
    (event) => {
      event.preventDefault();
      
      const type = event.dataTransfer.getData('application/reactflow/type');
      if (!type || !reactFlowInstance) return;
      
      const position = reactFlowInstance.screenToFlowPosition({
        x: event.clientX,
        y: event.clientY,
      });
      
      const newNode = {
        id: `node-${Date.now()}`,
        type,
        position,
        data: { text: 'New text node' },
      };
      
      setNodes((nds) => nds.concat(newNode));
    },
    [reactFlowInstance, setNodes]
  );
  
  // Create a new node
  const createNode = (type) => {
    if (!reactFlowInstance) return;
    
    // If we have a viewport, center the node in the visible area
    const position = reactFlowInstance.project({
      x: window.innerWidth / 2,
      y: window.innerHeight / 2
    });
    
    const newNode = {
      id: `node-${Date.now()}`,
      type,
      position,
      data: { text: newNodeText || 'New text node' }
    };
    
    // Add the node and immediately set it to edit mode
    setNodes((nds) => {
      const updatedNodes = nds.concat(newNode);
      setTimeout(() => {
        setEditingNode(newNode.id);
      }, 100);
      return updatedNodes;
    });
    
    setShowNodeCreator(false);
    setNewNodeText('');
  };
  
  // Delete selected elements
  const deleteSelected = () => {
    const selectedNodeIds = selectedElements
      .filter(el => el.type !== 'default')
      .map(el => el.id);
    
    const selectedEdgeIds = selectedElements
      .filter(el => el.type === 'default')
      .map(el => el.id);
    
    setNodes(nodes.filter(node => !selectedNodeIds.includes(node.id)));
    setEdges(edges.filter(edge => !selectedEdgeIds.includes(edge.id)));
    setSelectedElements([]);
  };
  
  // If canvas data isn't loaded yet, show a loading state
  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-full">
        <span className="text-teal-300">Loading canvas editor...</span>
      </div>
    );
  }
  
  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400 overflow-hidden">
      {/* Toolbar */}
      <div className="p-2 border-b border-stone-700 flex justify-between items-center bg-stone-800">
        <h2 className="text-md font-semibold text-teal-400">{canvasName}</h2>
        
        <div className="flex gap-2">
          <button 
            onClick={handleSaveCanvas}
            className="px-2 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs flex items-center gap-1"
            title="Save canvas"
          >
            <Save size={14} />
            Save
          </button>
          
          <button 
            onClick={() => {
              setNewNodeType('text');
              setShowNodeCreator(true);
            }}
            className="px-2 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs flex items-center gap-1"
            title="Add text node"
          >
            <Type size={14} />
            Add Node
          </button>
          
          {/* Edit button - appears when a node is selected */}
          {selectedElements.length === 1 && selectedElements[0].type === 'text' && (
            <button 
              onClick={() => setEditingNode(selectedElements[0].id)}
              className="px-2 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs flex items-center gap-1"
              title="Edit selected node"
            >
              <Edit size={14} />
              Edit
            </button>
          )}
          
          {selectedElements.length > 0 && (
            <button 
              onClick={deleteSelected}
              className="px-2 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs flex items-center gap-1"
              title="Delete selected"
            >
              <Trash2 size={14} />
              Delete
            </button>
          )}
        </div>
      </div>
      
      {/* Error message */}
      {error && (
        <div className="p-2 bg-red-900 text-red-200 text-sm">
          {error}
        </div>
      )}
      
      {/* Node creator dialog */}
      {showNodeCreator && (
        <div className="p-2 border-b border-stone-700 bg-stone-800">
          <div className="flex items-center justify-between mb-1">
            <span className="text-sm font-bold">
              New Text Node
            </span>
            <button
              onClick={() => setShowNodeCreator(false)}
              className="p-1 rounded hover:bg-stone-700 text-stone-400"
            >
              <Trash2 size={14} />
            </button>
          </div>
          
          <div className="flex flex-col gap-2">
            <textarea
              value={newNodeText}
              onChange={(e) => setNewNodeText(e.target.value)}
              placeholder="Enter text content"
              className="w-full bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
              rows={3}
            />
            <div className="flex justify-end">
              <button
                onClick={() => createNode('text')}
                className="px-2 py-1 bg-teal-700 text-teal-100 hover:bg-teal-600 rounded text-xs"
              >
                Create
              </button>
            </div>
          </div>
        </div>
      )}
      
      {/* Canvas area */}
      <div className="flex-1 overflow-hidden">
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          connectionMode="loose"
          onConnect={onConnect}
          onInit={setReactFlowInstance}
          onDrop={onDrop}
          onDragOver={onDragOver}
          onSelectionChange={onSelectionChange}
          nodeTypes={customNodeTypes}
          fitView
          snapToGrid
          snapGrid={[15, 15]}
          defaultViewport={{ x: 0, y: 0, zoom: 1 }}
          minZoom={0.1}
          maxZoom={4}
          deleteKeyCode="Delete"
          multiSelectionKeyCode="Control"
          selectionKeyCode="Shift"
        >
          {/* Empty canvas help message */}
          {nodes.length === 0 && (
            <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
              <div className="bg-stone-800 bg-opacity-80 p-6 rounded-lg shadow-lg text-center max-w-md">
                <Type size={40} className="mx-auto mb-4 text-teal-500" />
                <h3 className="text-xl text-teal-400 mb-2 font-semibold">Canvas Editor</h3>
                <p className="text-stone-300 mb-4">
                  This is your canvas workspace. Create notes and connect them with arrows.
                </p>
                <ul className="text-left text-stone-300 space-y-2 mb-4">
                  <li> Click "Add Node" to create a new text node</li>
                  <li> Hover over a node and click the edit button to edit content</li>
                  <li> Drag from a node's connection handle (teal dot) to another node to create a connection</li>
                  <li> Select nodes and press Delete or use the Delete button</li>
                </ul>
                <p className="text-stone-400 text-sm">
                  See canvas-editor-documentation.md for more details
                </p>
              </div>
            </div>
          )}
          <Background color="#44403c" gap={16} />
          <Controls showInteractive={false} />
          <MiniMap
            nodeColor={(node) => '#14b8a6'}
            maskColor="rgba(0, 0, 0, 0.5)"
            style={{ backgroundColor: '#292524' }}
          />
          
          <Panel position="top-left" className="bg-stone-800 p-2 rounded shadow-md">
            <div className="flex flex-col gap-1">
              <div className="text-xs text-stone-400">Drag to create:</div>
              <div 
                className="flex items-center gap-1 p-1 bg-stone-700 rounded cursor-grab"
                draggable
                onDragStart={(event) => {
                  event.dataTransfer.setData('application/reactflow/type', 'text');
                  event.dataTransfer.effectAllowed = 'move';
                }}
              >
                <Type size={14} />
                <span className="text-xs">Text Node</span>
              </div>
            </div>
          </Panel>
        </ReactFlow>
      </div>
    </div>
  );
};

export default CanvasEditor;

================
File: components/CommandInput.jsx
================
import React from 'react';

const CommandInput = ({ focusRef, isAdmin, handleCommand }) => {
  // Handle command input
  const onKeyDown = (e) => {
    if (e.key === 'Enter' && e.target.value.trim()) {
      const cmd = e.target.value.trim();
      handleCommand(cmd);
      e.target.value = '';
    }
  };

  return (
    <div className="p-2 flex items-center gap-2 border-t border-stone-700">
      <span className="text-teal-400">$</span>
      <input
        ref={focusRef}
        type="text"
        onKeyDown={onKeyDown}
        className="flex-1 bg-stone-800 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
      />
    </div>
  );
};

export default CommandInput;

================
File: components/dialogs/FileDialogs.jsx
================
import React, { useRef, useEffect, useState } from 'react';
import { AVAILABLE_FILE_TYPES } from '../../utils/fileUtils';
import { 
  X, FileText, Code, Coffee, BookOpen, Globe, File, 
  Music, Image, Figma, Map 
} from 'lucide-react';

// Dialog for creating a new file or folder
export const CreateFileDialog = ({
  showCreateDialog,
  createType,
  newItemName,
  setNewItemName,
  isCreating,
  errorMessage,
  closeCreateDialog,
  createNewItem
}) => {
  const createInputRef = useRef(null);
  const [showAutocomplete, setShowAutocomplete] = useState(false);
  const [filteredTypes, setFilteredTypes] = useState([]);
  const [selectedTypeIndex, setSelectedTypeIndex] = useState(0);
  
  // Get file type icon for autocomplete menu
  const getFileTypeIcon = (fileType) => {
    const iconProps = { size: 16, className: "mr-2" };
    
    switch (fileType) {
      case 'md': return <FileText {...iconProps} />;
      case 'canvas': return <Figma {...iconProps} />;
      case 'map': return <Map {...iconProps} />;
      default: return <File {...iconProps} />;
    }
  };
  
  // Focus the input field when the dialog is shown
  useEffect(() => {
    if (showCreateDialog && createInputRef.current) {
      createInputRef.current.focus();
    }
  }, [showCreateDialog]);
  
  // Handle input change to detect periods and filter file types
  const handleInputChange = (e) => {
    const value = e.target.value;
    setNewItemName(value);
    
    // Only show autocomplete for files, not folders
    if (createType === 'file') {
      // Check if we should show autocomplete
      const lastPeriodIndex = value.lastIndexOf('.');
      if (lastPeriodIndex !== -1 && lastPeriodIndex < value.length) {
        const suffix = value.substring(lastPeriodIndex + 1);
        
        // Filter available types based on what user has typed after the period
        const filtered = AVAILABLE_FILE_TYPES.filter(type => 
          type.startsWith(suffix.toLowerCase())
        );
        
        setFilteredTypes(filtered);
        setShowAutocomplete(filtered.length > 0);
        setSelectedTypeIndex(0);
      } else {
        setShowAutocomplete(false);
      }
    }
  };
  
  // Function to select and apply a file type
  const selectFileType = (type) => {
    const lastPeriodIndex = newItemName.lastIndexOf('.');
    if (lastPeriodIndex !== -1) {
      // Replace everything after the period with the selected file type
      setNewItemName(newItemName.substring(0, lastPeriodIndex + 1) + type);
    }
    setShowAutocomplete(false);
  };
  
  // Handle key press in the create dialog
  const handleCreateKeyPress = (e) => {
    if (showAutocomplete) {
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        setSelectedTypeIndex(prev => 
          (prev + 1) % filteredTypes.length
        );
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        setSelectedTypeIndex(prev => 
          (prev - 1 + filteredTypes.length) % filteredTypes.length
        );
      } else if (e.key === 'Tab' || e.key === 'Enter') {
        e.preventDefault();
        selectFileType(filteredTypes[selectedTypeIndex]);
        if (e.key === 'Enter') {
          // If Enter was pressed and a type was selected, also create the item
          setTimeout(() => createNewItem(), 10);
        }
      } else if (e.key === 'Escape') {
        e.preventDefault();
        setShowAutocomplete(false);
      }
    } else if (e.key === 'Enter') {
      e.preventDefault();
      createNewItem();
    } else if (e.key === 'Escape') {
      closeCreateDialog();
    }
  };
  
  if (!showCreateDialog) return null;
  
  return (
    <div className="p-2 border-t border-stone-700 bg-stone-800">
      <div className="flex items-center justify-between mb-1">
        <span className="text-sm font-bold">
          {createType === 'file' ? 'New File' : 'New Folder'}
        </span>
        <button
          onClick={closeCreateDialog}
          className="p-1 rounded hover:bg-stone-700 text-stone-400"
        >
          <X size={14} />
        </button>
      </div>
      <div className="flex gap-2 relative">
        <div className="flex-1 relative">
          <input
            ref={createInputRef}
            type="text"
            value={newItemName}
            onChange={handleInputChange}
            onKeyDown={handleCreateKeyPress}
            placeholder={createType === 'file' ? 'filename.ext' : 'folder name'}
            className="w-full bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
            disabled={isCreating}
          />
          {showAutocomplete && (
            <div className="absolute bottom-full mb-1 w-full bg-stone-800 border border-stone-600 rounded shadow-lg z-50 max-h-32 overflow-y-auto">
              {filteredTypes.map((type, index) => (
                <div 
                  key={type}
                  onClick={() => selectFileType(type)}
                  className={`px-2 py-1 cursor-pointer text-sm flex items-center ${
                    index === selectedTypeIndex 
                      ? 'bg-stone-600 text-white' 
                      : 'hover:bg-stone-700 text-teal-400'
                  }`}
                >
                  {getFileTypeIcon(type)}
                  {type}
                </div>
              ))}
            </div>
          )}
        </div>
        <button
          onClick={createNewItem}
          disabled={isCreating || !newItemName.trim()}
          className={`px-2 py-1 rounded text-xs ${
            isCreating || !newItemName.trim()
              ? 'bg-stone-700 text-stone-500 cursor-not-allowed'
              : 'bg-teal-700 text-teal-100 hover:bg-teal-600'
          }`}
        >
          {isCreating ? 'Creating...' : 'Create'}
        </button>
      </div>
    </div>
  );
};

// Dialog for renaming a file or folder
export const RenameDialog = ({
  showRenameDialog,
  itemToRename,
  newName,
  setNewName,
  isRenaming,
  errorMessage,
  closeRenameDialog,
  renameItem
}) => {
  const renameInputRef = useRef(null);
  
  // Focus the input field when the dialog is shown
  useEffect(() => {
    if (showRenameDialog && renameInputRef.current) {
      renameInputRef.current.focus();
    }
  }, [showRenameDialog]);
  
  // Handle key press in the rename dialog
  const handleRenameKeyPress = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      renameItem();
    } else if (e.key === 'Escape') {
      closeRenameDialog();
    }
  };
  
  if (!showRenameDialog || !itemToRename) return null;
  
  return (
    <div className="p-2 border-t border-stone-700 bg-stone-800">
      <div className="flex items-center justify-between mb-1">
        <span className="text-sm font-bold">
          Rename {itemToRename.type === 'directory' ? 'Folder' : 'File'}
        </span>
        <button
          onClick={closeRenameDialog}
          className="p-1 rounded hover:bg-stone-700 text-stone-400"
        >
          <X size={14} />
        </button>
      </div>
      <div className="flex gap-2">
        <input
          ref={renameInputRef}
          type="text"
          value={newName}
          onChange={(e) => setNewName(e.target.value)}
          onKeyDown={handleRenameKeyPress}
          placeholder="New name"
          className="flex-1 bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
          disabled={isRenaming}
        />
        <button
          onClick={renameItem}
          disabled={isRenaming || !newName.trim() || newName === itemToRename.name}
          className={`px-2 py-1 rounded text-xs ${
            isRenaming || !newName.trim() || newName === itemToRename.name
              ? 'bg-stone-700 text-stone-500 cursor-not-allowed'
              : 'bg-teal-700 text-teal-100 hover:bg-teal-600'
          }`}
        >
          {isRenaming ? 'Renaming...' : 'Rename'}
        </button>
      </div>
    </div>
  );
};

// Dialog for deleting a file or folder
export const DeleteDialog = ({
  showDeleteDialog,
  itemToDelete,
  isDeleting,
  errorMessage,
  closeDeleteDialog,
  handleDeleteItem
}) => {
  if (!showDeleteDialog || !itemToDelete) return null;
  
  return (
    <div className="p-2 border-t border-stone-700 bg-stone-800">
      <div className="flex items-center justify-between mb-1">
        <span className="text-sm font-bold">
          Delete {itemToDelete.type === 'directory' ? 'Folder' : 'File'}
        </span>
        <button
          onClick={closeDeleteDialog}
          className="p-1 rounded hover:bg-stone-700 text-stone-400"
        >
          <X size={14} />
        </button>
      </div>
      <div className="mb-2 text-sm">
        <p>Are you sure you want to delete <span className="text-red-400 font-bold">{itemToDelete.name}</span>?</p>
        {itemToDelete.type === 'directory' && (
          <p className="text-red-400 text-xs mt-1">This will delete all files and folders inside it!</p>
        )}
      </div>
      <div className="flex gap-2 justify-end">
        <button
          onClick={closeDeleteDialog}
          className="px-2 py-1 rounded text-xs bg-stone-700 hover:bg-stone-600"
        >
          Cancel
        </button>
        <button
          onClick={handleDeleteItem}
          disabled={isDeleting}
          className={`px-2 py-1 rounded text-xs ${
            isDeleting
              ? 'bg-red-900 text-red-300 cursor-not-allowed'
              : 'bg-red-700 text-red-100 hover:bg-red-600'
          }`}
        >
          {isDeleting ? 'Deleting...' : 'Delete'}
        </button>
      </div>
    </div>
  );
};

================
File: components/FileContent.jsx
================
import React, { useRef, useEffect } from 'react';
import { FileText, Edit, Eye, Bold, Italic, Code as CodeIcon, Link, Heading, List, ListOrdered, CheckSquare, Download, Map } from 'lucide-react';
import { handleEditorKeyDown, convertMarkdownToHtml } from '../utils/markdownUtils';
import MapEditor from './MapEditor';
import CanvasEditor from './CanvasEditor';

const FileContent = ({
  selectedFile,
  isContentLoading,
  fileContent,
  errorMessage,
  showPreview,
  editMode,
  saveStatus,
  converter,
  isAdmin,
  user,
  activeTab,
  setFileContent,
  toggleEditMode,
  handleMarkdownChange,
  handleSaveFileContent,
  handleExportFile
}) => {
  // Debug logging

  // Add an effect to log when file content changes
  useEffect(() => {
  }, [fileContent]);

  // Add an effect to log when selected file changes
  useEffect(() => {
  }, [selectedFile]);
  
  // Add debugging for save file content function
  const wrappedHandleSaveFileContent = (content) => {

    
    // Call the original function
    handleSaveFileContent(content);
  };

  const textareaRef = useRef(null);

  // Insert markdown syntax at cursor position
  const insertMarkdown = (prefix, suffix = '') => {
    const textarea = textareaRef.current;
    if (!textarea) return;
    
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const text = fileContent;
    
    // If text is selected, wrap it with prefix and suffix
    if (start !== end) {
      const selectedText = text.substring(start, end);
      const newContent = text.substring(0, start) + prefix + selectedText + suffix + text.substring(end);
      setFileContent(newContent);
      
      // Set cursor position after the inserted text
      setTimeout(() => {
        textarea.selectionStart = start + prefix.length;
        textarea.selectionEnd = end + prefix.length;
        textarea.focus();
      }, 0);
    } else {
      // No selection, just insert at cursor
      const newContent = text.substring(0, start) + prefix + suffix + text.substring(start);
      setFileContent(newContent);
      
      // Move cursor between prefix and suffix
      setTimeout(() => {
        textarea.selectionStart = textarea.selectionEnd = start + prefix.length;
        textarea.focus();
      }, 0);
    }
  };

  // Insert list items
  const insertList = (listPrefix) => {
    const textarea = textareaRef.current;
    if (!textarea) return;
    
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const text = fileContent;
    
    // If text is selected, apply list formatting to each line
    if (start !== end) {
      const selectedText = text.substring(start, end);
      const lines = selectedText.split('\n');
      
      // Format each line as a list item
      const formattedLines = lines.map(line => {
        // Skip empty lines
        if (line.trim() === '') return line;
        
        // For numbered lists, increment the number for each line
        if (listPrefix === '1. ') {
          const index = lines.indexOf(line) + 1;
          return `${index}. ${line}`;
        }
        
        return `${listPrefix}${line}`;
      });
      
      const newContent = text.substring(0, start) + formattedLines.join('\n') + text.substring(end);
      setFileContent(newContent);
      
      // Set cursor position after the inserted text
      setTimeout(() => {
        textarea.selectionStart = start;
        textarea.selectionEnd = start + formattedLines.join('\n').length;
        textarea.focus();
      }, 0);
    } else {
      // No selection, just insert at cursor
      const newContent = text.substring(0, start) + listPrefix + text.substring(start);
      setFileContent(newContent);
      
      // Move cursor after the inserted prefix
      setTimeout(() => {
        textarea.selectionStart = textarea.selectionEnd = start + listPrefix.length;
        textarea.focus();
      }, 0);
    }
  };

  // Handle editor keyboard events
  const onEditorKeyDown = (e) => {
    handleEditorKeyDown(e, textareaRef, fileContent, setFileContent);
  };

  return (
    <div className="flex-1 flex flex-col overflow-hidden">
      {selectedFile ? (
        <>
          {/* Header with file name, status, and controls */}
          <div className="p-2 border-b border-stone-700 font-mono text-sm flex items-center justify-between">
            <div className="flex items-center">
              <span className="mr-2">{selectedFile.name}</span>
              {saveStatus === 'saving' && <span className="text-yellow-400 text-xs ml-2">Saving...</span>}
              {saveStatus === 'saved' && <span className="text-green-400 text-xs ml-2">Saved</span>}
              {saveStatus === 'error' && <span className="text-red-400 text-xs ml-2">Error!</span>}
            </div>
            
            <div className="flex gap-2">
              {/* Export button - available for all file types */}
              <button 
                onClick={handleExportFile}
                className="px-2 py-1 bg-stone-800 hover:bg-stone-700 rounded text-xs flex items-center gap-1"
                title="Export file"
              >
                <Download size={14} />
                Export
              </button>
              
              {/* Show edit/preview toggle for markdown files to admins or users with file access (for private files) */}
              {selectedFile.name.endsWith('.md') && (isAdmin || (user && user.has_file_access && activeTab === 'private')) && (
                <>
                  {editMode && (
                    <button 
                      onClick={handleSaveFileContent}
                      className="px-2 py-1 bg-stone-800 hover:bg-stone-700 rounded text-xs"
                      title="Save file"
                    >
                      Save
                    </button>
                  )}
                  <button 
                    onClick={toggleEditMode}
                    className={`px-2 py-1 rounded text-xs flex items-center gap-1 ${editMode ? 'bg-teal-700 text-teal-100' : 'bg-stone-800 hover:bg-stone-700'}`}
                    title={editMode ? "Switch to preview mode" : "Switch to edit mode"}
                  >
                    {editMode ? <Eye size={14} /> : <Edit size={14} />}
                    {editMode ? 'Preview' : 'Edit'}
                  </button>
                </>
              )}
            </div>
          </div>
          
          {/* Error message */}
          {errorMessage && (
            <div className="p-2 bg-red-900 text-red-200 text-sm">
              {errorMessage}
            </div>
          )}
          
          {/* Content area - editor or preview based on file type */}
          {isContentLoading ? (
            <div className="flex-1 flex items-center justify-center">
              <span className="text-teal-300">Loading content...</span>
            </div>
          ) : selectedFile.name.endsWith('.canvas') && (isAdmin || (user && user.has_file_access && activeTab === 'private')) ? (
            // Canvas Editor for .canvas files - only for admin users and users with file access
            <CanvasEditor
              fileContent={fileContent}
              selectedFile={selectedFile}
              onSave={wrappedHandleSaveFileContent}
            />
          ) : selectedFile.name.endsWith('.map') && (isAdmin || (user && user.has_file_access && activeTab === 'private')) ? (
            // Map Editor for .map files - only for admin users and users with file access
            <MapEditor 
              fileContent={fileContent}
              selectedFile={selectedFile}
              onSave={wrappedHandleSaveFileContent}
            />
          ) : editMode && selectedFile.name.endsWith('.md') && (isAdmin || (user && user.has_file_access && activeTab === 'private')) ? (
            // Markdown Editor mode - only for markdown files and admin users
            <div className="flex-1 flex flex-col">
              {/* Markdown toolbar */}
              <div className="p-2 border-b border-stone-700 bg-stone-800 flex flex-wrap gap-2">
                <button 
                  onClick={() => insertMarkdown('### ')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Heading"
                >
                  <Heading size={16} />
                </button>
                <button 
                  onClick={() => insertMarkdown('**', '**')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Bold"
                >
                  <Bold size={16} />
                </button>
                <button 
                  onClick={() => insertMarkdown('*', '*')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Italic"
                >
                  <Italic size={16} />
                </button>
                <button 
                  onClick={() => insertMarkdown('`', '`')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Inline Code"
                >
                  <CodeIcon size={16} />
                </button>
                <button 
                  onClick={() => insertMarkdown('[', '](url)')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Link"
                >
                  <Link size={16} />
                </button>
                <span className="border-r border-stone-700 h-6"></span>
                <button 
                  onClick={() => insertList('- ')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Bullet List"
                >
                  <List size={16} />
                </button>
                <button 
                  onClick={() => insertList('1. ')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Numbered List"
                >
                  <ListOrdered size={16} />
                </button>
                <button 
                  onClick={() => insertList('- [ ] ')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Checklist"
                >
                  <CheckSquare size={16} />
                </button>
              </div>
              
              <div className="flex-1 p-2">
                <textarea
                  ref={textareaRef}
                  className="w-full h-full bg-stone-800 text-teal-50 p-4 resize-none focus:outline-none font-mono"
                  value={fileContent}
                  onChange={handleMarkdownChange}
                  onKeyDown={onEditorKeyDown}
                  placeholder="# Start typing your markdown here..."
                />
              </div>
            </div>
          ) : (
            // Preview mode
            <div className="flex-1 overflow-auto p-4">
              <div className="markdown-preview text-teal-50">
                {selectedFile.name.endsWith('.md') ? (
                  <div 
                    dangerouslySetInnerHTML={{ 
                      __html: convertMarkdownToHtml(converter, fileContent) 
                    }} 
                    className="markdown-content"
                  />
                ) : (
                  <pre className="font-mono text-sm whitespace-pre-wrap">
                    {fileContent}
                  </pre>
                )}
              </div>
            </div>
          )}
        </>
      ) : (
        // No file selected
        <div className="flex items-center justify-center h-full text-stone-600">
          <div className="text-center">
            <FileText size={48} className="mx-auto mb-4" />
            <p>Select a file to view</p>
            <p className="text-xs mt-2">All file types are supported for viewing</p>
            {isAdmin && (
              <p className="text-xs mt-1">
                Admin users can edit markdown (.md), map (.map), and canvas (.canvas) files
              </p>
            )}
            {!isAdmin && user && user.has_file_access && (
              <p className="text-xs mt-1">
                Users with file access can edit markdown (.md), map (.map), and canvas (.canvas) files in the Private section
              </p>
            )}
          </div>
        </div>
      )}
    </div>
  );
};

export default FileContent;

================
File: components/FileTree.jsx
================
import React from 'react';
import { 
  FolderOpen, ChevronRight, ChevronDown, File, Coffee, Code, 
  BookOpen, FileText, Globe, Lock, FileEdit, Trash2, Music, Image, Figma,
  FolderPlus, Plus, Map
} from 'lucide-react';
import { getFileIconName } from '../utils/fileUtils';
import StorageStats from './StorageStats';
import { CreateFileDialog, RenameDialog, DeleteDialog } from './dialogs/FileDialogs';

const FileTree = ({ 
  files, 
  publicFiles, 
  activeTab,
  expandedFolders,
  currentPath,
  selectedFile,
  isTreeLoading,
  errorMessage,
  isAdmin,
  user,
  toggleFolder,
  handleFileSelect,
  openRenameDialog,
  openDeleteDialog,
  openCreateDialog,
  handleDragStart,
  handleDragOver,
  handleDragLeave,
  handleDrop,
  handleContainerDragOver,
  handleContainerDragLeave,
  handleContainerDrop,
  dropTarget,
  storageStats,
  // Dialog-related props
  showCreateDialog,
  createType,
  newItemName,
  setNewItemName,
  isCreating,
  closeCreateDialog,
  createNewItem,
  showRenameDialog,
  itemToRename,
  newName,
  setNewName,
  isRenaming,
  closeRenameDialog,
  renameItem,
  showDeleteDialog,
  itemToDelete,
  isDeleting,
  closeDeleteDialog,
  handleDeleteItem
}) => {
  
  // Get file icon based on file extension
  const getFileIcon = (fileName) => {
    const iconName = getFileIconName(fileName);
    const iconProps = { size: 16, className: "mr-2" };
    
    switch (iconName) {
      case 'FileText': return <FileText {...iconProps} />;
      case 'Code': return <Code {...iconProps} />;
      case 'Coffee': return <Coffee {...iconProps} />;
      case 'BookOpen': return <BookOpen {...iconProps} />;
      case 'Globe': return <Globe {...iconProps} />;
      case 'Music': return <Music {...iconProps} />;
      case 'Image': return <Image {...iconProps} />;
      case 'Figma': return <Figma {...iconProps} />;
      case 'Map': return <Map {...iconProps} />;
      default: return <File {...iconProps} />;
    }
  };
  
  // Render the file tree recursively
  const renderFileTree = (items) => {
    // Keep track of the path to the currently selected file to highlight its parent folder
    const selectedFilePath = selectedFile?.path || '';
    const selectedFileParentPath = selectedFile && selectedFile.type !== 'directory' ? 
      selectedFilePath.substring(0, selectedFilePath.lastIndexOf('/')) || '/' : '';
    
    return items.map(item => {
      if (item.type === 'directory') {
        const isExpanded = expandedFolders[item.path];
        // A folder is considered active if it's the current path OR if it's the parent of the selected file
        const isActive = currentPath === item.path || (selectedFileParentPath === item.path);
        return (
          <div key={item.path} className="ml-2">
            <div 
              className={`flex items-center justify-between py-1 px-1 rounded hover:bg-stone-700 cursor-pointer group ${
                isActive ? 'bg-stone-800 text-teal-300 font-bold' : 
                isExpanded ? 'text-teal-300' : 'text-teal-400'
              } ${dropTarget && dropTarget.path === item.path ? 'bg-teal-900 border border-teal-500' : ''}`}
              onClick={() => toggleFolder(item.path, item)}
              draggable={isAdmin || (user?.has_file_access && activeTab === 'private')}
              onDragStart={(e) => handleDragStart(e, item)}
              onDragOver={(e) => handleDragOver(e, item)}
              onDragLeave={(e) => handleDragLeave(e)}
              onDrop={(e) => handleDrop(e, item)}
            >
              <div className="flex items-center">
                {isExpanded ? <ChevronDown size={14} /> : <ChevronRight size={14} />}
                <FolderOpen size={16} className="ml-1 mr-2" />
                <span className="text-sm">{item.name}</span>
              </div>
              
              {/* File operation buttons */}
            {(isAdmin || (user && user.has_file_access && activeTab === 'private')) && (
                <div className="flex">
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      openRenameDialog(item);
                    }}
                    className="p-1 rounded hover:bg-stone-600 text-stone-400 hover:text-teal-300 opacity-0 group-hover:opacity-100"
                    title="Rename folder"
                  >
                    <FileEdit size={14} />
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      openDeleteDialog(item);
                    }}
                    className="p-1 rounded hover:bg-stone-600 text-stone-400 hover:text-red-400 opacity-0 group-hover:opacity-100"
                    title="Delete folder"
                  >
                    <Trash2 size={14} />
                  </button>
                </div>
              )}
            </div>
            
            {isExpanded && item.children && (
              <div className="ml-2 border-l border-stone-700">
                {renderFileTree(item.children)}
              </div>
            )}
          </div>
        );
      } else {
        const isSelected = selectedFile && selectedFile.path === item.path;
        return (
          <div 
            key={item.path} 
            className={`flex items-center justify-between py-1 px-1 ml-4 rounded cursor-pointer hover:bg-stone-700 group ${isSelected ? 'bg-stone-700 text-teal-300' : 'text-teal-50'}`}
            onClick={() => handleFileSelect(item)}
            draggable={isAdmin || (user?.has_file_access && activeTab === 'private')}
            onDragStart={(e) => handleDragStart(e, item)}
          >
            <div className="flex items-center">
              {getFileIcon(item.name)}
              <span className="text-sm">{item.name}</span>
            </div>
            
            {/* File operation buttons */}
            {(isAdmin || (user && user.has_file_access && activeTab === 'private')) && (
              <div className="flex">
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    openRenameDialog(item);
                  }}
                  className="p-1 rounded hover:bg-stone-600 text-stone-400 hover:text-teal-300 opacity-0 group-hover:opacity-100"
                  title="Rename file"
                >
                  <FileEdit size={14} />
                </button>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    openDeleteDialog(item);
                  }}
                  className="p-1 rounded hover:bg-stone-600 text-stone-400 hover:text-red-400 opacity-0 group-hover:opacity-100"
                  title="Delete file"
                >
                  <Trash2 size={14} />
                </button>
              </div>
            )}
          </div>
        );
      }
    });
  };

  return (
    <div className="w-1/4 border-r border-stone-700 flex flex-col overflow-hidden">
      <div className="p-2 border-b border-stone-700 font-mono text-sm flex items-center justify-between">
        <div className="flex items-center">
          <span>FILES</span>
          
          {/* Tabs for switching between public and private files */}
          <div className="flex ml-4">
            <button
              onClick={() => {
                if (activeTab !== 'public') {
                  // First set the active tab, then select the root folder
                  handleFileSelect({ 
                    path: '/', 
                    type: 'directory', 
                    name: 'Root', 
                    isPublic: true,
                    setTab: 'public' // Add flag to explicitly set the tab
                  });
                }
              }}
              className={`px-2 py-1 rounded-t text-xs flex items-center gap-1 ${
                activeTab === 'public' 
                  ? 'bg-stone-700 text-teal-300' 
                  : 'bg-stone-800 hover:bg-stone-700'
              }`}
              title="Public files (readable by all users)"
            >
              <Globe size={14} />
              <span>Public</span>
            </button>
            
            {(isAdmin || (user && user.has_file_access)) && (
              <button
                onClick={() => {
                  if (activeTab !== 'private') {
                    // First set the active tab, then select the root folder
                    handleFileSelect({ 
                      path: '/', 
                      type: 'directory', 
                      name: 'Root',
                      setTab: 'private' // Add flag to explicitly set the tab
                    });
                  }
                }}
                className={`px-2 py-1 rounded-t text-xs flex items-center gap-1 ml-1 ${
                  activeTab === 'private' 
                    ? 'bg-stone-700 text-teal-300' 
                    : 'bg-stone-800 hover:bg-stone-700'
                }`}
                title="Private files (admin only)"
              >
                <Lock size={14} />
                <span>Private</span>
              </button>
            )}
          </div>
        </div>
        
        {/* File creation buttons (admins for both tabs, users with file access only for private tab) */}
        {(isAdmin || (user && user.has_file_access && activeTab === 'private')) && (
          <div className="flex gap-2">
            <button
              onClick={() => openCreateDialog('file')}
              className="p-1 rounded hover:bg-stone-700 text-teal-400"
              title="Create new file"
            >
              <Plus size={16} />
            </button>
            <button
              onClick={() => openCreateDialog('directory')}
              className="p-1 rounded hover:bg-stone-700 text-teal-400"
              title="Create new folder"
            >
              <FolderPlus size={16} />
            </button>
          </div>
        )}
      </div>
      
      <div 
        className="flex-1 overflow-auto"
        onDragOver={handleContainerDragOver}
        onDragLeave={handleContainerDragLeave}
        onDrop={handleContainerDrop}
      >
        {isTreeLoading ? (
          <div className="flex items-center justify-center h-full">
            <span className="text-teal-300">Loading files...</span>
          </div>
        ) : errorMessage ? (
          <div className="p-2 text-red-400">{errorMessage}</div>
        ) : (
          <div className="p-2 font-mono">
            {activeTab === 'public' ? (
              // Show public files to all users
              <>
                <div className="flex items-center py-1 px-1 text-teal-300">
                  <Globe size={16} className="mr-2" />
                  <span className="text-sm font-bold">Public Files</span>
                </div>
                {publicFiles.length > 0 ? (
                  renderFileTree(publicFiles)
                ) : (
                  <div className="ml-4 text-stone-500 text-sm">No public files available</div>
                )}
              </>
            ) : (
              // Show private files to admin users
              <>
                <div className="flex items-center py-1 px-1 text-teal-300">
                  <Lock size={16} className="mr-2" />
                  <span className="text-sm font-bold">Private Files</span>
                </div>
                {files.length > 0 ? (
                  renderFileTree(files)
                ) : (
                  <div className="ml-4 text-stone-500 text-sm">No private files available</div>
                )}
              </>
            )}
          </div>
        )}
      </div>
      
      <div className="p-2 border-t border-stone-700 text-xs">
        {selectedFile ? selectedFile.path : currentPath}
      </div>
      
      {/* Storage statistics display */}
      {(isAdmin || (user && user.has_file_access)) && (
        <StorageStats stats={storageStats} />
      )}
      
      {/* File operation dialogs */}
      <CreateFileDialog
        showCreateDialog={showCreateDialog}
        createType={createType}
        newItemName={newItemName}
        setNewItemName={setNewItemName}
        isCreating={isCreating}
        errorMessage={errorMessage}
        closeCreateDialog={closeCreateDialog}
        createNewItem={createNewItem}
      />
        
      <RenameDialog
        showRenameDialog={showRenameDialog}
        itemToRename={itemToRename}
        newName={newName}
        setNewName={setNewName}
        isRenaming={isRenaming}
        errorMessage={errorMessage}
        closeRenameDialog={closeRenameDialog}
        renameItem={renameItem}
      />
        
      <DeleteDialog
        showDeleteDialog={showDeleteDialog}
        itemToDelete={itemToDelete}
        isDeleting={isDeleting}
        errorMessage={errorMessage}
        closeDeleteDialog={closeDeleteDialog}
        handleDeleteItem={handleDeleteItem}
      />
    </div>
  );
};

export default FileTree;

================
File: components/MapEditor.jsx
================
import React, { useState, useRef, useEffect, useCallback } from 'react';
import { Map, Save, FileDown } from 'lucide-react';
import { 
  createEmptyMap, 
  serializeMap, 
  parseMapFile, 
  convertMapToAscii, 
  convertAsciiToMap 
} from '../../mapeditor/utils/mapUtils';

// Import sub-components
import MapToolbar from '../../mapeditor/MapToolbar';
import MapCanvas from '../../mapeditor/MapCanvas';
import LayerPanel from '../../mapeditor/LayerPanel';
import TilePalette from '../../mapeditor/TilePalette';

/**
 * Map Editor component for use within the FileContent area
 * This component handles the editing of .map files in the file explorer
 */
const MapEditor = ({ fileContent, selectedFile, onSave }) => {
  // State for map data
  const [mapData, setMapData] = useState(null);
  const [currentLayer, setCurrentLayer] = useState(0);
  const [currentTool, setCurrentTool] = useState('floor'); // Default to floor instead of select
  const [isDirty, setIsDirty] = useState(false);
  const [error, setError] = useState(null);
  const [saveStatus, setSaveStatus] = useState('saved'); // 'saved', 'saving', 'error'
  const [showAsciiModal, setShowAsciiModal] = useState(false);
  const [asciiContent, setAsciiContent] = useState('');
  const [asciiImportText, setAsciiImportText] = useState('');
  const [asciiModalMode, setAsciiModalMode] = useState('export'); // 'export' or 'import'
  const [selectedTileId, setSelectedTileId] = useState(0);
  const [selectedRotation, setSelectedRotation] = useState(0); // Add state for rotation
  const [showGrid, setShowGrid] = useState(true); // State for grid visibility
  const [brushSize, setBrushSize] = useState(1); // State for brush size
  
  // Use ref instead of state for the reset view function to avoid render-phase updates
  const resetViewFnRef = useRef(null);
  
  // References
  const autoSaveTimeoutRef = useRef(null);
  const isInitialLoadRef = useRef(true); // Track initial load to prevent layer reset during auto-save

  // Load map data when fileContent changes
  useEffect(() => {
    try {
      if (fileContent) {
        const parsedMap = parseMapFile(fileContent);
        setMapData(parsedMap);
        
        // Only reset currentLayer on initial load, not on auto-saves
        if (isInitialLoadRef.current) {
          setCurrentLayer(0);
          isInitialLoadRef.current = false;
        }
        
        setIsDirty(false);
        setError(null);
      } else {
        // Create a new map if no content
        setMapData(createEmptyMap());
        setIsDirty(true);
      }
    } catch (err) {
      console.error('Error parsing map file:', err);
      setError('Failed to parse map file. Creating a new map.');
      setMapData(createEmptyMap());
      setIsDirty(true);
    }
  }, [fileContent]);
  
  // Auto-save when map data changes
  useEffect(() => {
    // If the map is dirty (has unsaved changes), auto-save after a delay
    if (isDirty && mapData) {
      // Clear any existing timeout
      if (autoSaveTimeoutRef.current) {
        clearTimeout(autoSaveTimeoutRef.current);
      }
      
      // Set save status to 'saving'
      setSaveStatus('saving');
      
      // Set a new timeout for auto-save
      autoSaveTimeoutRef.current = setTimeout(() => {
        handleSaveMap();
      }, 1000); // 1 second debounce
    }
    
    // Cleanup function to clear the timeout when component unmounts
    return () => {
      if (autoSaveTimeoutRef.current) {
        clearTimeout(autoSaveTimeoutRef.current);
      }
    };
  }, [isDirty, mapData]);

  // Handler for saving the map
  const handleSaveMap = () => {
    if (!mapData) return;
    
    try {
      // Serialize the map data to JSON string
      const mapContent = serializeMap(mapData);
      
      // Debug logs to track the data flow
      console.log('[DEBUG] Map Editor - Saving map data:', {
        mapDataExists: !!mapData,
        serializedLength: mapContent?.length,
        serializedPreview: mapContent?.substring(0, 100) + '...',
        selectedFile: selectedFile?.path
      });
      
      // Set status to saving
      setSaveStatus('saving');
      
      // Call the parent onSave function
      onSave(mapContent);
      
      // Update state
      setIsDirty(false);
      setSaveStatus('saved');
    } catch (err) {
      console.error('Error saving map:', err);
      setError('Failed to save map file.');
      setSaveStatus('error');
    }
  };

  // Handler for map edits
  // Add 'rotation' parameter to accept the rotation value from MapCanvas
  const handleEdit = (x, y, tool, rotation) => {
    if (!mapData || !mapData.layers || !mapData.layers[currentLayer]) return;
    
    // Clone the current map data to avoid direct state mutation
    const newMapData = { ...mapData };
    const layerData = { ...newMapData.layers[currentLayer] };
    
    // Find if the cell already exists in this layer
    const existingCellIndex = layerData.cells.findIndex(cell => cell.x === x && cell.y === y);
    
    if (tool === 'erase') {
      // If erasing and the cell exists, remove it
      if (existingCellIndex !== -1) {
        layerData.cells = layerData.cells.filter((_, index) => index !== existingCellIndex);
      }
    } else {
      // Create the cell data based on the tool type
      // Include the received rotation value
      let cellData = { x, y, type: tool, rotation: rotation || 0 }; // Default to 0 if rotation is undefined/falsy
      
      // CRITICAL FIX: Include the selected tile ID for shadow tiles as well!
      if (tool === 'floor' || tool === 'wall' || tool === 'shadow') {
        cellData.tileId = selectedTileId;
        
        // For shadow tiles, add extra debug logging
        if (tool === 'shadow') {
          console.log(`MapEditor CRITICAL: Creating shadow tile at (${x}, ${y}) with tileId=${selectedTileId}`);
        }
      }
      
      // If a cell already exists at this position, update it immutably
      if (existingCellIndex !== -1) {
        // Create a new array with the updated cell
        layerData.cells = layerData.cells.map((cell, index) => 
          index === existingCellIndex ? cellData : cell
        );
      } else {
        // Otherwise, add a new cell (already immutable via push to a cloned array)
        layerData.cells.push(cellData);
      }
    }
    
    // Update the layer in the map data
    newMapData.layers[currentLayer] = layerData;
    
    // Update state
    setMapData(newMapData);
    setIsDirty(true);
  };

  // Handler for rotation changes from TilePalette
  const handleRotateTile = (newRotation) => {
    setSelectedRotation(newRotation);
    // Note: We don't mark as dirty here, as rotation is a tool setting, not map data change
  };

  // Layer management functions
  const handleToggleLayerVisibility = (layerIndex) => {
    if (!mapData || !mapData.layers || !mapData.layers[layerIndex]) return;
    
    const newMapData = { ...mapData };
    newMapData.layers[layerIndex] = {
      ...newMapData.layers[layerIndex],
      visible: !newMapData.layers[layerIndex].visible
    };
    
    setMapData(newMapData);
    setIsDirty(true);
  };

  const handleAddLayer = () => {
    if (!mapData) return;
    
    const newLayerName = `Layer ${mapData.layers.length + 1}`;
    const newLayer = {
      name: newLayerName,
      visible: true,
      cells: []
    };
    
    const newMapData = { 
      ...mapData,
      layers: [...mapData.layers, newLayer]
    };
    
    setMapData(newMapData);
    setCurrentLayer(newMapData.layers.length - 1);
    setIsDirty(true);
  };

  const handleRemoveLayer = (layerIndex) => {
    if (!mapData || !mapData.layers || mapData.layers.length <= 1) return;
    
    const newMapData = { ...mapData };
    newMapData.layers = newMapData.layers.filter((_, index) => index !== layerIndex);
    
    setMapData(newMapData);
    
    // Adjust current layer if necessary
    if (currentLayer >= newMapData.layers.length) {
      setCurrentLayer(newMapData.layers.length - 1);
    }
    
    setIsDirty(true);
  };

  const handleMoveLayerUp = (layerIndex) => {
    if (!mapData || !mapData.layers || layerIndex >= mapData.layers.length - 1) return;
    
    const newMapData = { ...mapData };
    const layers = [...newMapData.layers];
    
    // Swap layers
    [layers[layerIndex], layers[layerIndex + 1]] = [layers[layerIndex + 1], layers[layerIndex]];
    
    newMapData.layers = layers;
    setMapData(newMapData);
    
    // Update current layer if necessary
    if (currentLayer === layerIndex) {
      setCurrentLayer(layerIndex + 1);
    } else if (currentLayer === layerIndex + 1) {
      setCurrentLayer(layerIndex);
    }
    
    setIsDirty(true);
  };

  const handleMoveLayerDown = (layerIndex) => {
    if (!mapData || !mapData.layers || layerIndex <= 0) return;
    
    const newMapData = { ...mapData };
    const layers = [...newMapData.layers];
    
    // Swap layers
    [layers[layerIndex], layers[layerIndex - 1]] = [layers[layerIndex - 1], layers[layerIndex]];
    
    newMapData.layers = layers;
    setMapData(newMapData);
    
    // Update current layer if necessary
    if (currentLayer === layerIndex) {
      setCurrentLayer(layerIndex - 1);
    } else if (currentLayer === layerIndex - 1) {
      setCurrentLayer(layerIndex);
    }
    
    setIsDirty(true);
  };

  const handleRenameLayer = (layerIndex, newName) => {
    if (!mapData || !mapData.layers || !mapData.layers[layerIndex] || !newName) return;
    
    const newMapData = { ...mapData };
    newMapData.layers[layerIndex] = {
      ...newMapData.layers[layerIndex],
      name: newName
    };
    
    setMapData(newMapData);
    setIsDirty(true);
  };

  // Handler for exporting to ASCII
  const handleExportAscii = () => {
    if (!mapData) return;
    
    try {
      // Convert the map data to ASCII
      const ascii = convertMapToAscii(mapData);
      setAsciiContent(ascii);
      setAsciiModalMode('export');
      setShowAsciiModal(true);
    } catch (err) {
      console.error('Error exporting to ASCII:', err);
      setError('Failed to export map to ASCII format.');
    }
  };

  // Handler for importing from ASCII
  const handleImportAscii = () => {
    setAsciiImportText('');
    setAsciiModalMode('import');
    setShowAsciiModal(true);
  };

  // Handler for confirming ASCII import
  const handleConfirmAsciiImport = () => {
    if (!asciiImportText.trim()) {
      setError('No ASCII content to import.');
      return;
    }
    
    try {
      // Convert ASCII to map data
      const newMapData = convertAsciiToMap(asciiImportText, mapData.name);
      
      // Preserve metadata from existing map if possible
      if (mapData.metadata) {
        newMapData.metadata = {
          ...newMapData.metadata,
          author: mapData.metadata.author || 'user',
          modified: new Date().toISOString()
        };
      }
      
      // Update the map data
      setMapData(newMapData);
      setIsDirty(true);
      setShowAsciiModal(false);
    } catch (err) {
      console.error('Error importing from ASCII:', err);
      setError('Failed to import ASCII map. The format may be invalid.');
    }
  };

  // Handler for downloading the ASCII map
  const handleDownloadAscii = () => {
    if (!asciiContent) return;
    
    try {
      // Create a blob with the ASCII content
      const blob = new Blob([asciiContent], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      
      // Create a temporary anchor element to trigger the download
      const a = document.createElement('a');
      a.href = url;
      a.download = `${mapData.name || 'map'}.txt`;
      
      // Append the anchor to the document, click it, and remove it
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      // Clean up by revoking the object URL
      URL.revokeObjectURL(url);
    } catch (err) {
      console.error('Error downloading ASCII map:', err);
      setError('Failed to download ASCII map.');
    }
  };


  // Handler for applying map property changes
  const handleApplyProperties = (properties) => {
    if (!mapData) return;

    const newMapData = { 
      ...mapData,
      name: properties.name,
      width: properties.width,
      height: properties.height,
      gridSize: properties.gridSize
    };

    // Update map data
    setMapData(newMapData);
    setIsDirty(true);
  };
  
  // Handler for updating layer opacity
  const handleUpdateLayerOpacity = (layerIndex, opacity) => {
    if (!mapData || !mapData.layers || !mapData.layers[layerIndex]) return;
    
    const newMapData = { ...mapData };
    newMapData.layers[layerIndex] = {
      ...newMapData.layers[layerIndex],
      opacity: opacity
    };
    
    setMapData(newMapData);
    setIsDirty(true);
  };

  // If map data isn't loaded yet, show a loading state
  if (!mapData) {
    return (
      <div className="flex items-center justify-center h-full">
        <span className="text-teal-300">Loading map editor...</span>
      </div>
    );
  }

  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400 overflow-hidden">
      {/* Toolbar */}
      <MapToolbar 
        onSave={handleSaveMap}
        onUndo={() => console.log('Undo not implemented')}
        onRedo={() => console.log('Redo not implemented')}
        onClear={() => {
          // Create a new empty map but preserve properties like name, width, height, gridSize
          const newMap = createEmptyMap();
          newMap.name = mapData.name;
          newMap.width = mapData.width;
          newMap.height = mapData.height;
          newMap.gridSize = mapData.gridSize;
          // Preserve metadata if it exists
          if (mapData.metadata) {
            newMap.metadata = { ...mapData.metadata };
          }
          setMapData(newMap);
          setIsDirty(true);
        }}
        onExportAscii={handleExportAscii}
        onImportAscii={handleImportAscii}
        onToggleGrid={() => setShowGrid(!showGrid)}
        onResetView={() => {
          // Call the reset view function if it exists
          if (resetViewFnRef.current) {
            resetViewFnRef.current();
          }
        }}
        showGrid={showGrid}
        saveStatus={saveStatus}
        mapData={mapData}
        onApplyProperties={handleApplyProperties}
      />
      
      {/* Error message */}
      {error && (
        <div className="p-2 bg-red-900 text-red-200 text-sm">
          {error}
        </div>
      )}
      
      {/* Main content area */}
      <div className="flex-1 flex overflow-hidden">
        {/* Canvas for map editing */}
        <MapCanvas 
          mapData={mapData}
          currentLayer={currentLayer}
          currentTool={currentTool}
          selectedTileId={selectedTileId}
          selectedRotation={selectedRotation} // Pass rotation state to canvas
          onEdit={handleEdit}
          showGrid={showGrid}
          resetViewRef={resetViewFnRef} // Pass ref instead of setter function
          brushSize={brushSize}
        />
        
        {/* Layer panel with integrated tile palette */}
        <LayerPanel 
          layers={mapData.layers}
          currentLayer={currentLayer}
          setCurrentLayer={setCurrentLayer}
          onToggleLayerVisibility={handleToggleLayerVisibility}
          onAddLayer={handleAddLayer}
          onRemoveLayer={handleRemoveLayer}
          onMoveLayerUp={handleMoveLayerUp}
          onMoveLayerDown={handleMoveLayerDown}
          onRenameLayer={handleRenameLayer}
          onUpdateLayerOpacity={handleUpdateLayerOpacity}
          selectedTileId={selectedTileId}
          onSelectTile={setSelectedTileId}
          selectedRotation={selectedRotation} // Pass rotation state to LayerPanel
          onRotateTile={handleRotateTile} // Pass rotation handler to LayerPanel
          currentTool={currentTool}
          setCurrentTool={setCurrentTool}
          brushSize={brushSize}
          setBrushSize={setBrushSize}
        />
      </div>
      
      
      {/* ASCII Modal */}
      {showAsciiModal && (
        <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50">
          <div className="bg-stone-800 border border-stone-700 rounded-lg shadow-lg w-full max-w-3xl max-h-[80vh] flex flex-col">
            <div className="flex justify-between items-center p-4 border-b border-stone-700">
              <h2 className="text-lg font-semibold text-teal-300">
                {asciiModalMode === 'export' ? 'ASCII Map Export' : 'Import ASCII Map'}
              </h2>
              <button 
                onClick={() => setShowAsciiModal(false)}
                className="p-1 hover:bg-stone-700 rounded text-teal-400"
              >
                &times;
              </button>
            </div>
            
            <div className="p-4 flex-1 overflow-auto">
              {asciiModalMode === 'export' ? (
                <div className="flex flex-col h-full">
                  <p className="mb-4 text-sm text-stone-300">
                    This is the ASCII representation of your map. Each character represents a cell type:
                    <br />
                    <code className="bg-stone-900 px-1 rounded">
                      # = Wall, . = Floor, + = Door, " = Grass, ' = Ashes, &gt; = Stairs, @ = Spawn
                    </code>
                  </p>
                  <pre className="bg-stone-900 p-4 rounded font-mono text-teal-100 text-sm overflow-auto flex-1 whitespace-pre">
                    {asciiContent}
                  </pre>
                </div>
              ) : (
                <div className="flex flex-col h-full">
                  <p className="mb-4 text-sm text-stone-300">
                    Paste ASCII map content below. Each character represents a cell type:
                    <br />
                    <code className="bg-stone-900 px-1 rounded">
                      # = Wall, . = Floor, + = Door, " = Grass, ' = Ashes, &gt; = Stairs, @ = Spawn
                    </code>
                  </p>
                  <textarea 
                    className="bg-stone-900 p-4 rounded font-mono text-teal-100 text-sm overflow-auto flex-1 resize-none focus:outline-none focus:ring-1 focus:ring-teal-500"
                    value={asciiImportText}
                    onChange={e => setAsciiImportText(e.target.value)}
                    placeholder="Paste ASCII map here..."
                  />
                </div>
              )}
            </div>
            
            <div className="p-4 border-t border-stone-700 flex justify-end space-x-2">
              <button 
                onClick={() => setShowAsciiModal(false)}
                className="px-4 py-2 bg-stone-700 hover:bg-stone-600 rounded text-teal-100"
              >
                Cancel
              </button>
              
              {asciiModalMode === 'export' ? (
                <button 
                  onClick={handleDownloadAscii}
                  className="px-4 py-2 bg-teal-700 hover:bg-teal-600 rounded text-teal-100 flex items-center"
                >
                  <FileDown size={16} className="mr-2" />
                  Download ASCII
                </button>
              ) : (
                <button 
                  onClick={handleConfirmAsciiImport}
                  className="px-4 py-2 bg-teal-700 hover:bg-teal-600 rounded text-teal-100"
                >
                  Import
                </button>
              )}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default MapEditor;

================
File: components/nodes/index.js
================
import TextNode from './TextNode';

/**
 * Node type registry
 * Export all node types from this file to easily import them elsewhere
 */

const nodeTypes = {
  // Add all node types here
  text: TextNode,
  // Additional node types can be added here in the future
};

export default nodeTypes;

================
File: components/nodes/TextNode.jsx
================
import React, { useState } from 'react';
import { Edit } from 'lucide-react';
import { Handle, Position } from 'reactflow';

/**
 * TextNode component for displaying and editing text nodes in the canvas
 * This component is used in the Canvas Editor
 */
const TextNode = ({ id, data, isConnectable, setEditingNode, editingNode }) => {
  const isEditing = editingNode === id;
  const [isHovered, setIsHovered] = useState(false);
  
  const handleEditClick = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setEditingNode(id);
  };
  
  const handleEdit = (e) => {
    const updatedText = e.target.value;
    
    // Update the node data is handled by the parent component
    // through the setNodes function passed via data
    if (data.onChange) {
      data.onChange(id, updatedText);
    }
  };
  
  const handleBlur = () => {
    setEditingNode(null);
  };
  
  const handleKeyDown = (e) => {
    if (e.key === 'Escape') {
      setEditingNode(null);
    } else if (e.key === 'Enter' && e.ctrlKey) {
      setEditingNode(null);
    }
  };
  
  return (
    <div 
      className="p-2 bg-stone-800 border border-stone-700 rounded shadow-md relative"
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
    >
      <Handle 
        type="source" 
        position={Position.Top} 
        isConnectable={isConnectable} 
        style={{ 
          background: '#14b8a6', // teal-500 color
          width: '0.45rem',
          height: '0.45rem',
          borderRadius: '9999px',
          border: 'none'
        }}
      />

      {/* Bottom handle */}
      <Handle 
        type="source" 
        position={Position.Bottom} 
        isConnectable={isConnectable} 
        style={{ 
          background: '#14b8a6', // teal-500 color
          width: '0.45rem',
          height: '0.45rem',
          borderRadius: '9999px',
          border: 'none'
        }}
      />

      {/* Right handle */}
      <Handle 
        type="source" 
        position={Position.Right} 
        id="right"
        isConnectable={isConnectable} 
        style={{ 
          background: '#14b8a6', // teal-500 color
          width: '0.45rem',
          height: '0.45rem',
          borderRadius: '9999px',
          border: 'none'
        }}
      />

      {/* Left handle */}
      <Handle 
        type="source" 
        position={Position.Left} 
        id="left"
        isConnectable={isConnectable} 
        style={{ 
          background: '#14b8a6', // teal-500 color
          width: '0.45rem',
          height: '0.45rem',
          borderRadius: '9999px',
          border: 'none'
        }}
      />
      {isEditing ? (
        <textarea
          className="w-full h-full bg-stone-700 text-teal-400 p-2 rounded font-mono text-sm focus:outline-none resize-none min-h-[80px]"
          value={data.text}
          onChange={handleEdit}
          onBlur={handleBlur}
          onKeyDown={handleKeyDown}
          autoFocus
        />
      ) : (
        <>
          <div className="text-teal-400 text-sm whitespace-pre-wrap pr-6">{data.text}</div>
          {isHovered && (
            <button
              className="absolute top-1 right-1 bg-stone-700 p-1 rounded-sm hover:bg-stone-600 transition-colors"
              onClick={handleEditClick}
              title="Edit node"
            >
              <Edit size={14} className="text-teal-400" />
            </button>
          )}
        </>
      )}
    </div>
  );
};

export default TextNode;

================
File: components/StorageStats.jsx
================
import React from 'react';

const StorageStats = ({ stats, isAdmin }) => {
  // If stats aren't available yet or the user doesn't have file access, don't show anything
  if (!stats || stats.isLoading) {
    return null;
  }

  // Format bytes to human-readable format
  const formatBytes = (bytes, decimals = 2) => {
    if (bytes === 0) return '0 Bytes';
    if (bytes === null || bytes === undefined) return 'Unlimited';
    
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
  };

  // Calculate percentage used
  const percentUsed = stats.unlimited ? 0 : Math.min(100, Math.round((stats.used / stats.quota) * 100)) || 0;
  
  return (
    <div className="px-2 py-1 bg-stone-800 text-xs border-t border-stone-700">
      <div className="flex justify-between items-center ${isAdmin ? 'mb-0' : 'mb-1'}">
        <span className="text-gray-400">Storage:</span>
        <span className="text-teal-400">
          {stats.unlimited 
            ? 'Unlimited (Admin)'
            : `${formatBytes(stats.used)} of ${formatBytes(stats.quota)}`
          }
        </span>
      </div>
      
      {!stats.unlimited && (
        <div className="w-full bg-stone-700 rounded-full h-1.5 mb-1">
          <div 
            className="bg-teal-600 h-1.5 rounded-full" 
            style={{ width: `${percentUsed}%` }}
          ></div>
        </div>
      )}
    </div>
  );
};

export default StorageStats;

================
File: ExplorerWindow.jsx
================
import React from 'react';
import useExplorerState from './state/useExplorerState';
import { useAuth } from '../../../context/AuthContext';
import FileTree from './components/FileTree';
import FileContent from './components/FileContent';
import CommandInput from './components/CommandInput';
import StorageStats from './components/StorageStats';
import '../ExplorerWindow.css';

const ExplorerWindow = ({ isActive, nodeId, onCommand, transformWindow, windowState, updateWindowState, focusRef }) => {
  // Get auth context to check user permissions
  const { user } = useAuth();
  // Use the custom hook to manage state and operations
  const explorerState = useExplorerState(nodeId, windowState, updateWindowState);
  
  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400 overflow-hidden">
      <div className="flex flex-1 overflow-hidden relative">
        {/* File tree panel */}
        <FileTree 
          files={explorerState.files}
          publicFiles={explorerState.publicFiles}
          activeTab={explorerState.activeTab}
          expandedFolders={explorerState.expandedFolders}
          currentPath={explorerState.currentPath}
          selectedFile={explorerState.selectedFile}
          isTreeLoading={explorerState.isTreeLoading}
          errorMessage={explorerState.errorMessage}
          isAdmin={explorerState.isAdmin}
          user={user}
          toggleFolder={explorerState.toggleFolder}
          handleFileSelect={explorerState.handleFileSelect}
          openRenameDialog={explorerState.openRenameDialog}
          openDeleteDialog={explorerState.openDeleteDialog}
          openCreateDialog={explorerState.openCreateDialog}
          handleDragStart={explorerState.handleDragStart}
          handleDragOver={explorerState.handleDragOver}
          handleDragLeave={explorerState.handleDragLeave}
          handleDrop={explorerState.handleDrop}
          handleContainerDragOver={explorerState.handleContainerDragOver}
          handleContainerDragLeave={explorerState.handleContainerDragLeave}
          handleContainerDrop={explorerState.handleContainerDrop}
          dropTarget={explorerState.dropTarget}
          storageStats={explorerState.storageStats}
          // Dialog-related props
          showCreateDialog={explorerState.showCreateDialog}
          createType={explorerState.createType}
          newItemName={explorerState.newItemName}
          setNewItemName={explorerState.setNewItemName}
          isCreating={explorerState.isCreating}
          closeCreateDialog={explorerState.closeCreateDialog}
          createNewItem={explorerState.createNewItem}
          showRenameDialog={explorerState.showRenameDialog}
          itemToRename={explorerState.itemToRename}
          newName={explorerState.newName}
          setNewName={explorerState.setNewName}
          isRenaming={explorerState.isRenaming}
          closeRenameDialog={explorerState.closeRenameDialog}
          renameItem={explorerState.renameItem}
          showDeleteDialog={explorerState.showDeleteDialog}
          itemToDelete={explorerState.itemToDelete}
          isDeleting={explorerState.isDeleting}
          closeDeleteDialog={explorerState.closeDeleteDialog}
          handleDeleteItem={explorerState.handleDeleteItem}
        />
        
        
        {/* File content panel */}
        <FileContent
          selectedFile={explorerState.selectedFile}
          isContentLoading={explorerState.isContentLoading}
          fileContent={explorerState.fileContent}
          errorMessage={explorerState.errorMessage}
          showPreview={explorerState.showPreview}
          editMode={explorerState.editMode}
          saveStatus={explorerState.saveStatus}
          converter={explorerState.converter}
          isAdmin={explorerState.isAdmin}
          user={user}
          activeTab={explorerState.activeTab}
          setFileContent={explorerState.setFileContent}
          toggleEditMode={explorerState.toggleEditMode}
          handleMarkdownChange={explorerState.handleMarkdownChange}
          handleSaveFileContent={explorerState.handleSaveFileContent}
          handleExportFile={explorerState.handleExportFile}
        />
      </div>
      
      {/* Command input */}
      <CommandInput
        focusRef={focusRef}
        isAdmin={explorerState.isAdmin}
        handleCommand={explorerState.handleCommand}
      />
    </div>
  );
};

export default ExplorerWindow;

================
File: README.md
================
# Explorer Window Component

This directory contains a modular implementation of the ExplorerWindow component. The code has been refactored to improve maintainability and make it easier to extend functionality.

## Architecture Overview

The ExplorerWindow has been split into several components and modules following a clean separation of concerns:

```
explorer/
 ExplorerWindow.jsx              # Main component (orchestrator)
 state/
    useExplorerState.js         # Custom hook for state management
 components/
    FileTree.jsx                # Tree view UI and navigation
    FileContent.jsx             # Content viewing/editing panel
    CommandInput.jsx            # Command input field
    dialogs/
        FileDialogs.jsx         # Dialog components for file operations
 api/
    fileOperations.js           # API calls and file operations
 utils/
    fileUtils.js                # File-related utility functions
    markdownUtils.js            # Markdown-specific utilities
 README.md                       # This documentation file
```

## Component Responsibilities

### ExplorerWindow.jsx
- Acts as the main component that orchestrates all other components
- Retrieves state and operations from useExplorerState
- Passes down props to child components

### useExplorerState.js
- Centralizes all state management
- Handles state persistence and retrieval
- Implements business logic for all user interactions
- Provides functions for file operations

### FileTree.jsx
- Displays the directory structure
- Handles file/folder selection
- Manages UI for drag and drop operations

### FileContent.jsx
- Displays file content based on file type
- Provides editing interface for markdown files
- Renders markdown preview

### CommandInput.jsx
- Provides command input interface
- Handles command execution

### FileDialogs.jsx
- Contains dialog components for creating, renaming, and deleting files/folders

### fileOperations.js
- Encapsulates API calls to the server
- Handles error states and response parsing

### fileUtils.js and markdownUtils.js
- Provide utility functions for file and markdown operations

## Data Flow

1. User interactions in UI components trigger functions received from useExplorerState
2. useExplorerState processes these actions, updates state, and interacts with the API as needed
3. State changes flow back to UI components through props

## Adding Support for New File Types

To add support for new file types (e.g., canvas files, audio files, images):

1. Update `fileUtils.js` to recognize and provide appropriate icons for the new file types
2. Extend `FileContent.jsx` to render the new file types appropriately
3. If needed, add specific utility files (similar to markdownUtils.js) for the new file types
4. Update state in `useExplorerState.js` to handle any special behaviors for the new file types

## State Management

The component uses a custom hook approach for state management, which offers several advantages:

- Centralizes state logic in one place
- Makes the main component simpler and more declarative
- Allows for easier testing of business logic
- Simplifies adding new features or file type support

This approach is more maintainable than using a context provider for this specific use case, as the component tree is not deeply nested. If the component structure becomes more complex in the future, the code could be adapted to use a context provider instead.

================
File: state/useExplorerState.js
================
import { useState, useEffect, useRef } from 'react';
import { useAuth } from '../../../../context/AuthContext';
import { useWindowState } from '../../../../context/WindowStateContext';
import { WINDOW_TYPES } from '../../../../utils/windowTypes';
import { saveExplorerState, getExplorerState } from '../../../../services/indexedDBService';
import { createMarkdownConverter } from '../utils/markdownUtils';
import { 
  fetchPublicDirectoryContents, 
  fetchDirectoryContents, 
  fetchPublicFileContent, 
  fetchFileContent,
  saveFileContent as apiSaveFileContent,
  createNewItem as apiCreateNewItem,
  renameItem as apiRenameItem,
  deleteItem as apiDeleteItem,
  moveItem as apiMoveItem,
  getStorageStats as apiGetStorageStats
} from '../api/fileOperations';
import { 
  getParentDirectoryPath, 
  expandParentFolders, 
  getActiveFolderPath 
} from '../utils/fileUtils';

const useExplorerState = (nodeId, windowState, updateWindowState) => {
  // Get auth context to check if user is admin
  const { user } = useAuth();
  const isAdmin = user?.is_admin || false;
  
  // Get window state context for additional persistence
  const { setActiveWindow } = useWindowState();
  
  // Refs to track state loading and saving
  const stateLoadedRef = useRef(false);
  const explorerSaveTimeoutRef = useRef(null); // New ref for debounced explorer state saving
  
  // Reference to store the saved state that needs to be restored after files are loaded
  const pendingStateRestoreRef = useRef(null);
  const fileLoadedRef = useRef(false);
  
  // Use state from windowState or initialize with defaults
  const [files, setFiles] = useState([]);
  const [publicFiles, setPublicFiles] = useState([]);
  const [currentPath, setCurrentPath] = useState(windowState?.currentPath || '/');
  const [selectedFile, setSelectedFile] = useState(windowState?.selectedFile || null);
  const [expandedFolders, setExpandedFolders] = useState(windowState?.expandedFolders || {});
  const [isTreeLoading, setIsTreeLoading] = useState(true);
  const [isContentLoading, setIsContentLoading] = useState(false);
  const [fileContent, setFileContent] = useState(windowState?.fileContent || '');
  const [errorMessage, setErrorMessage] = useState('');
  const [showPreview, setShowPreview] = useState(windowState?.showPreview || false);
  const [activeTab, setActiveTab] = useState(windowState?.activeTab || 'public'); // 'public' or 'private'
  
  // Additional state for markdown editing
  const [editMode, setEditMode] = useState(windowState?.editMode || false);
  const [saveStatus, setSaveStatus] = useState('saved'); // 'saved', 'saving', 'error'
  
  // State for file/folder creation
  const [showCreateDialog, setShowCreateDialog] = useState(false);
  const [createType, setCreateType] = useState('file'); // 'file' or 'directory'
  const [newItemName, setNewItemName] = useState('');
  const [isCreating, setIsCreating] = useState(false);
  
  // State for file/folder renaming
  const [showRenameDialog, setShowRenameDialog] = useState(false);
  const [itemToRename, setItemToRename] = useState(null);
  const [newName, setNewName] = useState('');
  const [isRenaming, setIsRenaming] = useState(false);
  
  // State for file/folder deletion
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [itemToDelete, setItemToDelete] = useState(null);
  const [isDeleting, setIsDeleting] = useState(false);
  
  // State for drag and drop
  const [draggedItem, setDraggedItem] = useState(null);
  const [dropTarget, setDropTarget] = useState(null);
  const [isMoving, setIsMoving] = useState(false);
  
  // For auto-save functionality and editor references
  const saveTimeoutRef = useRef(null);
  
  // Create markdown converter
  const converter = createMarkdownConverter();

  // Track previous node ID to detect window swaps
  const prevNodeIdRef = useRef(nodeId);

  // Load explorer state from IndexedDB on mount or when nodeId changes
  useEffect(() => {
    const loadExplorerState = async () => {
      console.log(`[DEBUG] Starting to load explorer state for window ${nodeId}`);
      
      // If nodeId changed but it's not the first load, it likely means a window swap occurred
      const isSwapDetected = prevNodeIdRef.current !== nodeId && prevNodeIdRef.current !== null;
      if (isSwapDetected) {
        console.log(`[DEBUG] Node ID changed from ${prevNodeIdRef.current} to ${nodeId}, possible window swap detected`);
        // Reset the state loaded flag to force a reload after a swap
        stateLoadedRef.current = false;
        // Clear any pending state
        pendingStateRestoreRef.current = null;
      }
      
      // Update prevNodeIdRef for future comparisons
      prevNodeIdRef.current = nodeId;
      
      try {
        // Try to load explorer state from IndexedDB
        const savedState = await getExplorerState(nodeId);
        console.log(`[DEBUG] Retrieved state from IndexedDB:`, savedState);
        
        if (savedState && savedState.content && !stateLoadedRef.current) {
          console.log(`[DEBUG] Valid saved state found for window ${nodeId}:`, savedState.content);
          
          // Store the saved state in the ref for later restoration after files are loaded
          pendingStateRestoreRef.current = savedState.content;
          
          // Restore expanded folders and active tab immediately
          if (savedState.content.expandedFolders) {
            console.log(`[DEBUG] Restoring expanded folders`);
            setExpandedFolders(savedState.content.expandedFolders);
          }
          
          if (savedState.content.activeTab) {
            console.log(`[DEBUG] Restoring active tab: ${savedState.content.activeTab}`);
            setActiveTab(savedState.content.activeTab);
          }
          
          if (savedState.content.editMode !== undefined && isAdmin) {
            console.log(`[DEBUG] Restoring edit mode: ${savedState.content.editMode}`);
            setEditMode(savedState.content.editMode);
          }
          
          // Mark as loaded
          stateLoadedRef.current = true;
        } else {
          console.log(`[DEBUG] No valid saved state found or state already loaded`);
          // Even if no state is loaded, mark as loaded to allow future saves
          stateLoadedRef.current = true;
        }
      } catch (error) {
        console.error(`[DEBUG] Failed to load explorer state:`, error);
        // Ensure we still mark state as loaded even if there's an error
        stateLoadedRef.current = true;
      }
    };
    
    loadExplorerState();
  }, [nodeId, isAdmin]);
  
  // Handle window activation
  useEffect(() => {
    if (windowState?.isActive) {
      // Save this as the active explorer window
      setActiveWindow(nodeId, WINDOW_TYPES.EXPLORER);
    }
  }, [windowState?.isActive, nodeId, setActiveWindow]);
  
  // Save explorer state to IndexedDB when it changes
  useEffect(() => {
    // Early return if state hasn't been loaded yet (prevents overwriting with default values)
    if (!stateLoadedRef.current) return;
    
    // Clear any existing timeout
    if (explorerSaveTimeoutRef.current) {
      clearTimeout(explorerSaveTimeoutRef.current);
    }
    
    // Save the explorer state to IndexedDB with debounce
    explorerSaveTimeoutRef.current = setTimeout(() => {
      console.log(`[DEBUG] Saving explorer state for window ${nodeId}:`, {
        selectedFile,
        expandedFolders,
        activeTab,
        editMode
      });
      
      saveExplorerState({
        id: nodeId,
        content: {
          selectedFile,
          expandedFolders,
          activeTab,
          editMode
        }
      }).catch(error => {
        console.error(`[DEBUG] Failed to save explorer state for window ${nodeId} to IndexedDB:`, error);
      });
    }, 300); // 300ms debounce
    
    // Clear timeout on cleanup
    return () => {
      if (explorerSaveTimeoutRef.current) {
        clearTimeout(explorerSaveTimeoutRef.current);
      }
    };
  }, [selectedFile, expandedFolders, activeTab, editMode, nodeId]);

  // Load initial directory contents and restore selected file afterward
  useEffect(() => {
    console.log('[DEBUG] Starting to load directory contents');
    
    // First, load the files
    const loadFilesAndRestoreSelection = async () => {
      try {
        // Load public files for all users
        await handleFetchPublicDirectoryContents('/', true);
        
      // Load private files for admin users or users with file access (if applicable)
      if (isAdmin || user?.has_file_access) {
        try {
          await handleFetchDirectoryContents('/', true);
        } catch (error) {
          console.error('Failed to load private files:', error);
          setFiles([]);
          if (activeTab === 'private') {
            setErrorMessage('Failed to load private files. Please ensure your directory exists.');
          }
        }
      }
        
        // Mark files as loaded
        fileLoadedRef.current = true;
        
        // Now that files are loaded, restore the selected file if we have one pending
        if (pendingStateRestoreRef.current && pendingStateRestoreRef.current.selectedFile) {
          const restoredFile = pendingStateRestoreRef.current.selectedFile;
          console.log(`[DEBUG] Now restoring selected file after files are loaded:`, restoredFile);
          
          // Set the selected file
          setSelectedFile(restoredFile);
          
          // Update the current path to ensure parent directories are visible
          if (restoredFile.type === 'file') {
            // For files, set the current path to the parent directory
            const parentPath = getParentDirectoryPath(restoredFile.path);
            setCurrentPath(parentPath);
          } else {
            // For directories, set the current path to the directory itself
            setCurrentPath(restoredFile.path);
          }
          
          // Ensure parent folders are expanded
          setExpandedFolders(prev => expandParentFolders(restoredFile.path, prev));
          
          // If it's a file, load its content
          if (restoredFile.type === 'file') {
            console.log(`[DEBUG] Loading content for restored file: ${restoredFile.path}`);
            
            // Set the preview mode for markdown files
            if (restoredFile.name.endsWith('.md')) {
              console.log(`[DEBUG] Setting preview mode for markdown file`);
              setShowPreview(true);
              
              // Also restore edit mode if it was saved
              if (pendingStateRestoreRef.current.editMode && isAdmin) {
                console.log(`[DEBUG] Restoring edit mode: ${pendingStateRestoreRef.current.editMode}`);
                setEditMode(pendingStateRestoreRef.current.editMode);
              }
            }
            
            // Use handleFileSelect to load the file content
            // Use setTimeout to ensure this happens after state updates
            setTimeout(() => {
              console.log(`[DEBUG] Executing delayed file selection for: ${restoredFile.path}`);
              handleFileSelect(restoredFile, true);
            }, 100);
          }
          
          // Clear the pending restore
          pendingStateRestoreRef.current = null;
        } else {
          console.log('[DEBUG] No file to restore or files not loaded yet');
        }
      } catch (error) {
        console.error('[DEBUG] Error in loadFilesAndRestoreSelection:', error);
      }
    };
    
    loadFilesAndRestoreSelection();
  }, [isAdmin, activeTab]);

  // State for storage statistics
  const [storageStats, setStorageStats] = useState({
    quota: 0,
    used: 0,
    available: 0,
    unlimited: false,
    isLoading: false
  });

  // Fetch storage statistics
  const fetchStorageStats = async () => {
    if (!user?.has_file_access && !isAdmin) return;
    
    setStorageStats(prev => ({ ...prev, isLoading: true }));
    
    try {
      const stats = await apiGetStorageStats();
      if (stats.error) {
        setErrorMessage(stats.error);
        setStorageStats(prev => ({
          ...prev,
          isLoading: false
        }));
      } else {
        setStorageStats({
          quota: stats.quota,
          used: stats.used,
          available: stats.available,
          unlimited: stats.unlimited,
          isLoading: false
        });
      }
    } catch (error) {
      console.error('Error fetching storage stats:', error);
      setStorageStats(prev => ({
        ...prev,
        isLoading: false
      }));
    }
  };

  // Fetch storage stats on mount and after file operations
  useEffect(() => {
    if (user?.has_file_access || isAdmin) {
      fetchStorageStats();
    }
  }, [user, isAdmin]);

  // Reset content states when switching tabs
  useEffect(() => {
    // Clear file content and reset view states when changing tabs
    setSelectedFile(null);
    setFileContent('');
    setShowPreview(false);
    setEditMode(false);
    setSaveStatus('saved');
    setErrorMessage('');
    
    // Reset current path to root for the selected tab
    setCurrentPath('/');
  }, [activeTab]);

  // Auto-save functionality with debounce
  useEffect(() => {
    // Auto-save if in edit mode, user has permission, and we have a markdown file selected
    // Allow for admins and users with file_access (for private files)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (editMode && hasEditPermission && selectedFile && selectedFile.name.endsWith('.md') && fileContent) {
      // Clear any existing timeout
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
      
      // Set status to saving
      setSaveStatus('saving');
      
      // Set a new timeout for auto-save
      saveTimeoutRef.current = setTimeout(() => {
        handleSaveFileContent();
      }, 1000); // 1 second debounce
    }
    
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, [fileContent, editMode, isAdmin, selectedFile]);

  // Update window state when relevant state changes
  useEffect(() => {
    if (updateWindowState) {
      updateWindowState({
        currentPath,
        selectedFile,
        expandedFolders,
        fileContent,
        showPreview,
        editMode,
        saveStatus,
        activeTab
      });
    }
  }, [currentPath, selectedFile, expandedFolders, fileContent, showPreview, editMode, saveStatus, activeTab, updateWindowState]);
  
  // Fetch public directory contents
  const handleFetchPublicDirectoryContents = async (publicPath = '/', refreshAll = false) => {
    setIsTreeLoading(true);
    setErrorMessage('');
    
    const result = await fetchPublicDirectoryContents(publicPath, refreshAll);
    
    if (result.error) {
      setErrorMessage(result.error);
    } else {
      setPublicFiles(result.files);
      
      // Only update the current path if we're not refreshing the entire tree
      if (!refreshAll) {
        setCurrentPath(publicPath);
      }
      
      // If we refreshed the entire tree, make sure the current path's parent folders are expanded
      if (refreshAll && currentPath !== '/') {
        setExpandedFolders(prev => expandParentFolders(currentPath, prev));
      }
    }
    
    setIsTreeLoading(false);
    return result; // Return result so we can chain promises
  };
  
  // Fetch public file content
  const handleFetchPublicFileContent = async (filePath) => {
    setIsContentLoading(true);
    setErrorMessage('');
    
    const result = await fetchPublicFileContent(filePath);
    
    if (result.error) {
      setErrorMessage(result.error);
      setSaveStatus('error');
    } else {
      setFileContent(result.content);
      setSaveStatus('saved');
    }
    
    setIsContentLoading(false);
  };
  
  // Fetch private directory contents
  const handleFetchDirectoryContents = async (path = '/', refreshAll = false) => {
    setIsTreeLoading(true);
    setErrorMessage('');
    
    const result = await fetchDirectoryContents(path, refreshAll);
    
    if (result.error) {
      setErrorMessage(result.error);
    } else {
      setFiles(result.files);
      
      // Only update the current path if we're not refreshing the entire tree
      if (!refreshAll) {
        setCurrentPath(path);
      }
      
      // If we refreshed the entire tree, make sure the current path's parent folders are expanded
      if (refreshAll && currentPath !== '/') {
        setExpandedFolders(prev => expandParentFolders(currentPath, prev));
      }
    }
    
    setIsTreeLoading(false);
    return result; // Return result so we can chain promises
  };
  
  // Fetch private file content
  const handleFetchFileContent = async (filePath) => {
    setIsContentLoading(true);
    setErrorMessage('');
    
    const result = await fetchFileContent(filePath);
    
    if (result.error) {
      setErrorMessage(result.error);
      setSaveStatus('error');
    } else {
      setFileContent(result.content);
      setSaveStatus('saved');
    }
    
    setIsContentLoading(false);
  };
  
  // Save file content
  const handleSaveFileContent = async (content) => {
    console.log('[DEBUG] useExplorerState - handleSaveFileContent called:', {
      selectedFilePath: selectedFile?.path,
      selectedFileName: selectedFile?.name,
      contentProvided: content !== undefined,
      // If content is provided, use it, otherwise use the state's fileContent
      contentToSaveType: typeof (content !== undefined ? content : fileContent),
      contentToSaveLength: (content !== undefined ? content : fileContent)?.length || 0,
      contentToSavePreview: typeof (content !== undefined ? content : fileContent) === 'string' 
        ? (content !== undefined ? content : fileContent).substring(0, 100) + '...' 
        : 'not a string'
    });
    
    // Check if filePath is valid
    if (!selectedFile || !selectedFile.path || selectedFile.path.trim() === '') {
      console.error('[DEBUG] handleSaveFileContent - No file selected');
      setErrorMessage('No file selected. Please select a file first.');
      setSaveStatus('error');
      return;
    }
    
    setSaveStatus('saving');
    
    // Use content parameter if provided, otherwise use state's fileContent
    const contentToSave = content !== undefined ? content : fileContent;
    
    console.log('[DEBUG] Sending to API:', {
      path: selectedFile.path,
      contentType: typeof contentToSave,
      contentLength: contentToSave?.length || 0
    });
    
    const result = await apiSaveFileContent(selectedFile.path, contentToSave);
    
    if (result.error) {
      console.error('[DEBUG] API Save Error:', result.error);
      setErrorMessage(result.error);
      setSaveStatus('error');
    } else {
      console.log('[DEBUG] API Save Success:', result);
      setErrorMessage('');
      setSaveStatus('saved');
      
      // If content parameter was provided, update the state's fileContent
      if (content !== undefined) {
        setFileContent(content);
      }
    }
  };
  
  // Toggle folder expansion
  const toggleFolder = (folderPath, folder) => {
    const isExpanding = !expandedFolders[folderPath];
    
    setExpandedFolders(prev => ({
      ...prev,
      [folderPath]: isExpanding
    }));
    
    // If we're expanding the folder, also set it as the current path
    if (isExpanding) {
      setCurrentPath(folderPath);
      setSelectedFile(folder);
    }
  };
  
  // Create a new file or folder
  const createNewItem = async () => {
    if (!newItemName.trim()) {
      setErrorMessage('Name cannot be empty');
      return;
    }
    
    setIsCreating(true);
    setErrorMessage('');
    
    // Get the active folder path where the new item should be created
    const activeFolderPath = getActiveFolderPath(selectedFile, currentPath);
    
    const result = await apiCreateNewItem(activeTab, activeFolderPath, newItemName, createType);
    
    if (result.error) {
      setErrorMessage(result.error);
    } else {
      // Close the dialog and reset the form
      setShowCreateDialog(false);
      setNewItemName('');
      
      // Refresh the entire file tree from the root
      if (activeTab === 'public') {
        handleFetchPublicDirectoryContents('/', true);
      } else {
        handleFetchDirectoryContents('/', true);
      }
      
      // If it's a directory, expand it
      if (createType === 'directory' && result.path) {
        setExpandedFolders(prev => ({
          ...prev,
          [result.path]: true
        }));
      }
    }
    
    setIsCreating(false);
  };
  
  // Open the create dialog
  const openCreateDialog = (type) => {
    setCreateType(type);
    setNewItemName('');
    setErrorMessage('');
    setShowCreateDialog(true);
  };
  
  // Close the create dialog
  const closeCreateDialog = () => {
    setShowCreateDialog(false);
    setNewItemName('');
    setErrorMessage('');
  };
  
  // Open the rename dialog
  const openRenameDialog = (item) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission) {
      setErrorMessage('Admin access required to rename files or file access permission for private files.');
      return;
    }
    
    setItemToRename(item);
    setNewName(item.name);
    setErrorMessage('');
    setShowRenameDialog(true);
  };
  
  // Close the rename dialog
  const closeRenameDialog = () => {
    setShowRenameDialog(false);
    setItemToRename(null);
    setNewName('');
    setErrorMessage('');
  };
  
  // Rename a file or folder
  const renameItem = async () => {
    if (!newName.trim()) {
      setErrorMessage('Name cannot be empty');
      return;
    }
    
    if (!itemToRename) {
      setErrorMessage('No item selected for renaming');
      return;
    }
    
    setIsRenaming(true);
    setErrorMessage('');
    
    const result = await apiRenameItem(itemToRename.path, newName);
    
    if (result.error) {
      setErrorMessage(result.error);
    } else {
      // Close the dialog and reset the form
      setShowRenameDialog(false);
      setItemToRename(null);
      setNewName('');
      
      // If the renamed item was selected, update the selected file
      if (selectedFile && selectedFile.path === itemToRename.path) {
        setSelectedFile(null);
      }
      
      // Refresh the appropriate file list
      if (itemToRename.isPublic) {
        handleFetchPublicDirectoryContents('/', true);
      } else {
        handleFetchDirectoryContents('/', true);
      }
    }
    
    setIsRenaming(false);
  };
  
  // Open the delete dialog
  const openDeleteDialog = (item) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission) {
      setErrorMessage('Admin access required to delete files or file access permission for private files.');
      return;
    }
    
    setItemToDelete(item);
    setErrorMessage('');
    setShowDeleteDialog(true);
  };
  
  // Close the delete dialog
  const closeDeleteDialog = () => {
    setShowDeleteDialog(false);
    setItemToDelete(null);
    setErrorMessage('');
  };
  
  // Delete a file or folder
  const handleDeleteItem = async () => {
    if (!itemToDelete) {
      setErrorMessage('No item selected for deletion');
      return;
    }
    
    setIsDeleting(true);
    setErrorMessage('');
    
    const result = await apiDeleteItem(itemToDelete.path);
    
    if (result.error) {
      setErrorMessage(result.error);
    } else {
      // Close the dialog
      setShowDeleteDialog(false);
      setItemToDelete(null);
      
      // If the deleted item was selected, clear the selection
      if (selectedFile && selectedFile.path === itemToDelete.path) {
        setSelectedFile(null);
        setFileContent('');
        setShowPreview(false);
        if (editMode) {
          setEditMode(false);
        }
      }
      
      // Refresh the appropriate file list
      if (itemToDelete.isPublic) {
        handleFetchPublicDirectoryContents('/', true);
      } else {
        handleFetchDirectoryContents('/', true);
      }
    }
    
    setIsDeleting(false);
  };
  
  // Handle drag start event
  const handleDragStart = (e, item) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission) return;
    
    setDraggedItem(item);
    e.dataTransfer.setData('text/plain', item.path);
    e.dataTransfer.effectAllowed = 'move';
    
    // Add dragging class to the element
    e.currentTarget.classList.add('dragging');
    
    // Remove the class after a short delay to ensure it's applied
    setTimeout(() => {
      if (e.currentTarget) {
        e.currentTarget.classList.remove('dragging');
      }
    }, 100);
  };
  
  // Handle drag over event
  const handleDragOver = (e, folder) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission || !draggedItem) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    // Only allow dropping into directories
    if (folder.type === 'directory') {
      setDropTarget(folder);
      e.dataTransfer.dropEffect = 'move';
      
      // Add drop-target class to the element
      e.currentTarget.classList.add('drop-target');
    }
  };
  
  // Handle drag over for the file tree container (to allow dropping to root)
  const handleContainerDragOver = (e) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission || !draggedItem) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    // Set root as the drop target
    const rootFolder = {
      type: 'directory',
      path: draggedItem.isPublic ? '/public' : '/',
      name: 'Root'
    };
    setDropTarget(rootFolder);
    e.dataTransfer.dropEffect = 'move';
  };
  
  // Handle drag leave event
  const handleDragLeave = (e) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission) return;
    
    e.preventDefault();
    e.stopPropagation();
    setDropTarget(null);
    
    // Remove drop-target class from the element
    e.currentTarget.classList.remove('drop-target');
  };
  
  // Handle drag leave for the container
  const handleContainerDragLeave = (e) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission) return;
    
    e.preventDefault();
    e.stopPropagation();
    setDropTarget(null);
  };
  
  // Handle drop event
  const handleDrop = async (e, targetFolder) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission || !draggedItem || !targetFolder) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    // Reset drop target
    setDropTarget(null);
    
    // Remove drop-target class from the element
    e.currentTarget.classList.remove('drop-target');
    
    // Only allow dropping into directories
    if (targetFolder.type !== 'directory') {
      return;
    }
    
    // Check if dropping on itself
    if (draggedItem.path === targetFolder.path) {
      return;
    }
    
    // Check if dropping in current location (parent folder is the same)
    const draggedParent = getParentDirectoryPath(draggedItem.path);
    if (draggedParent === targetFolder.path) {
      return;
    }
    
    setIsMoving(true);
    setErrorMessage('');
    
    const result = await apiMoveItem(draggedItem.path, targetFolder.path);
    
    if (result.error) {
      setErrorMessage(result.error);
    } else {
      // If the moved item was selected, clear the selection
      if (selectedFile && selectedFile.path === draggedItem.path) {
        setSelectedFile(null);
        setFileContent('');
        setShowPreview(false);
        if (editMode) {
          setEditMode(false);
        }
      }
      
      // Refresh the appropriate file list
      if (draggedItem.isPublic) {
        handleFetchPublicDirectoryContents('/', true);
      } else {
        handleFetchDirectoryContents('/', true);
      }
    }
    
    // Clear drag state
    setDraggedItem(null);
    setIsMoving(false);
  };
  
  // Handle drop event for the container (moving to root)
  const handleContainerDrop = async (e) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission || !draggedItem || !dropTarget) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    // Process the drop using the dropTarget which was set in handleContainerDragOver
    const targetFolder = dropTarget;
    
    // Reset drop target
    setDropTarget(null);
    
    // Check if dropping in current location (parent folder is the same)
    const draggedParent = getParentDirectoryPath(draggedItem.path);
    if (draggedParent === targetFolder.path) {
      return;
    }
    
    setIsMoving(true);
    setErrorMessage('');
    
    const result = await apiMoveItem(draggedItem.path, targetFolder.path);
    
    if (result.error) {
      setErrorMessage(result.error);
    } else {
      // If the moved item was selected, clear the selection
      if (selectedFile && selectedFile.path === draggedItem.path) {
        setSelectedFile(null);
        setFileContent('');
        setShowPreview(false);
        if (editMode) {
          setEditMode(false);
        }
      }
      
      // Refresh the appropriate file list
      if (draggedItem.isPublic) {
        handleFetchPublicDirectoryContents('/', true);
      } else {
        handleFetchDirectoryContents('/', true);
      }
    }
    
    // Clear drag state
    setDraggedItem(null);
    setIsMoving(false);
  };
  
  // Handle folder selection
  const handleFolderSelect = (folder) => {
    // Update the current path to the selected folder's path
    setCurrentPath(folder.path);
    
    // Set the selected folder
    setSelectedFile(folder);
    
    // Expand the folder
    setExpandedFolders(prev => ({
      ...prev,
      [folder.path]: true
    }));
    
    // Reset content and preview
    setFileContent('');
    setShowPreview(false);
    
    // Reset edit mode
    if (editMode) {
      setEditMode(false);
    }
  };
  
  // Handle file selection
  const handleFileSelect = (file, skipTabSwitch = false) => {
    // Check if this selection should change the active tab, but skip when restoring files
    if (!skipTabSwitch) {
      if (file.setTab) {
        setActiveTab(file.setTab);
      } else if (file.isPublic !== undefined) {
        // Update active tab based on file's isPublic property
        setActiveTab(file.isPublic ? 'public' : 'private');
      }
    }

    // If it's a directory, handle it differently
    if (file.type === 'directory') {
      handleFolderSelect(file);
      return;
    }
    
    setSelectedFile(file);
    
    // Make sure parent folders are expanded so the file is visible on reload
    setExpandedFolders(prev => expandParentFolders(file.path, prev));
    
    // Set current path to the parent directory for better context
    const parentPath = getParentDirectoryPath(file.path);
    setCurrentPath(parentPath);
    
    // Reset edit mode when selecting a new file
    if (editMode) {
      setEditMode(false);
    }
    
    // Fetch content for all file types
    if (file.isPublic) {
      // Fetch public file content
      handleFetchPublicFileContent(file.path);
    } else {
      // Fetch private file content (admin only)
      handleFetchFileContent(file.path);
    }
    
    // Only set preview mode for markdown files
    if (file.name.endsWith('.md')) {
      setShowPreview(true);
    } else {
      setShowPreview(false);
    }
  };
  
  // Toggle edit mode
  const toggleEditMode = () => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission) {
      setErrorMessage('Admin access required to edit files or file access permission for private files.');
      return;
    }
    
    if (!selectedFile || !selectedFile.name.endsWith('.md')) {
      setErrorMessage('Only markdown files can be edited.');
      return;
    }
    
    setEditMode(!editMode);
    // When switching to preview mode, ensure preview is shown
    if (editMode) {
      setShowPreview(true);
    }
  };
  
  // Handle markdown content change
  const handleMarkdownChange = (e) => {
    setFileContent(e.target.value);
  };
  
  // Handle commands (for the command input)
  const handleCommand = (cmd) => {
    // Commands:
    // - refresh: refresh file list
    // - preview: toggle markdown preview
    // - edit: toggle edit mode (users with permission)
    // - save: manually save the current file
    // - new-file: create a new file (users with permission)
    // - new-folder: create a new folder (users with permission)
    // - rename: rename selected file or folder (users with permission)
    // - delete: delete selected file or folder (users with permission)
    // - public: switch to public files tab
    // - private: switch to private files tab (users with permission)
    
    // Check permission for file operations
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    const canAccessPrivate = isAdmin || user?.has_file_access;
    
    if (cmd === 'refresh') {
      if (activeTab === 'public') {
        handleFetchPublicDirectoryContents('/', true);
      } else {
        handleFetchDirectoryContents('/', true);
      }
    } else if (cmd === 'preview' && selectedFile?.name.endsWith('.md')) {
      setShowPreview(!showPreview);
      if (editMode) {
        setEditMode(false);
      }
    } else if (cmd === 'edit' && selectedFile?.name.endsWith('.md')) {
      toggleEditMode();
    } else if (cmd === 'save' && editMode && selectedFile?.name.endsWith('.md')) {
      handleSaveFileContent();
    } else if (cmd === 'new-file' && hasEditPermission) {
      openCreateDialog('file');
    } else if (cmd === 'new-folder' && hasEditPermission) {
      openCreateDialog('directory');
    } else if (cmd === 'rename' && selectedFile && hasEditPermission) {
      openRenameDialog(selectedFile);
    } else if (cmd === 'delete' && selectedFile && hasEditPermission) {
      openDeleteDialog(selectedFile);
    } else if (cmd === 'public') {
      setActiveTab('public');
    } else if (cmd === 'private' && canAccessPrivate) {
      setActiveTab('private');
    } else {
      setErrorMessage(`Unknown command: ${cmd}`);
    }
  };

  // Handle file or folder export/download
  const handleExportFile = async () => {
    if (!selectedFile) {
      setErrorMessage('No file or folder selected');
      return;
    }
    
    try {
      // If it's a directory, create a zip file
      if (selectedFile.type === 'directory') {
        // Import JSZip dynamically 
        const JSZip = (await import('jszip')).default;
        const zip = new JSZip();
        
        setErrorMessage('Creating zip file...');
        
        // Function to recursively gather files from a folder
        const addFolderToZip = async (folderPath, zipFolder) => {
          // Determine which API to use based on whether the folder is public or private
          const fetchApi = selectedFile.isPublic ? fetchPublicDirectoryContents : fetchDirectoryContents;
          
          // Fetch directory contents
          const result = await fetchApi(folderPath, false);
          
          if (result.error) {
            throw new Error(`Failed to access folder: ${result.error}`);
          }
          
          // Process each item in the folder
          for (const item of result.files) {
            if (item.type === 'directory') {
              // Create a subfolder in the zip and process recursively
              const newFolder = zipFolder.folder(item.name);
              await addFolderToZip(item.path, newFolder);
            } else {
              // Fetch file content
              const contentApi = selectedFile.isPublic ? fetchPublicFileContent : fetchFileContent;
              const contentResult = await contentApi(item.path);
              
              if (contentResult.error) {
                console.error(`Error loading file content for ${item.path}: ${contentResult.error}`);
                continue;
              }
              
              // Add file to zip
              zipFolder.file(item.name, contentResult.content);
            }
          }
        };
        
        // Start the recursive process from the selected folder
        await addFolderToZip(selectedFile.path, zip);
        
        // Generate the zip file
        const content = await zip.generateAsync({type: 'blob'});
        
        // Create a filename for the zip file (folder name + .zip)
        const zipFileName = `${selectedFile.name}.zip`;
        
        // Create a temporary URL for the blob
        const url = URL.createObjectURL(content);
        
        // Create a temporary anchor element to trigger the download
        const a = document.createElement('a');
        a.href = url;
        a.download = zipFileName;
        
        // Append the anchor to the document, click it, and remove it
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        // Clean up by revoking the object URL
        URL.revokeObjectURL(url);
        
        // Clear the export message
        setErrorMessage('');
      } else {
        // For single file export, keep existing behavior
        if (!fileContent) {
          setErrorMessage('File has no content');
          return;
        }
        
        // Create a blob with the file content
        const blob = new Blob([fileContent], { type: 'text/plain' });
        
        // Create a temporary URL for the blob
        const url = URL.createObjectURL(blob);
        
        // Create a temporary anchor element to trigger the download
        const a = document.createElement('a');
        a.href = url;
        a.download = selectedFile.name;
        
        // Append the anchor to the document, click it, and remove it
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        // Clean up by revoking the object URL
        URL.revokeObjectURL(url);
      }
    } catch (error) {
      console.error('Error exporting:', error);
      setErrorMessage(`Failed to export: ${error.message}`);
    }
  };
  
  return {
    files,
    publicFiles,
    currentPath,
    selectedFile,
    expandedFolders,
    isTreeLoading,
    isContentLoading,
    fileContent,
    errorMessage,
    showPreview,
    activeTab,
    editMode,
    saveStatus,
    showCreateDialog,
    createType, 
    newItemName,
    isCreating,
    showRenameDialog,
    itemToRename,
    newName,
    isRenaming,
    showDeleteDialog,
    itemToDelete,
    isDeleting,
    draggedItem,
    dropTarget,
    isMoving,
    converter,
    isAdmin,
    storageStats,
    fetchStorageStats,
    handleFetchPublicDirectoryContents,
    handleFetchDirectoryContents,
    handleSaveFileContent,
    handleExportFile,
    toggleFolder,
    createNewItem,
    openCreateDialog,
    closeCreateDialog,
    openRenameDialog,
    closeRenameDialog,
    renameItem,
    openDeleteDialog,
    closeDeleteDialog,
    handleDeleteItem,
    handleDragStart,
    handleDragOver,
    handleContainerDragOver,
    handleDragLeave,
    handleContainerDragLeave,
    handleDrop,
    handleContainerDrop,
    handleFileSelect,
    toggleEditMode,
    handleMarkdownChange,
    handleCommand,
    setNewItemName,
    setNewName,
    setErrorMessage,
    setFileContent,
    setSelectedFile
  };
};

export default useExplorerState;

================
File: utils/canvasUtils.js
================
/**
 * Utility functions for the canvas editor
 */

/**
 * Generate a unique ID for a node or edge
 * @param {string} prefix - Prefix for the ID (e.g., 'node' or 'edge')
 * @returns {string} Unique ID
 */
export const generateId = (prefix = 'node') => {
  return `${prefix}-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
};

/**
 * Calculate the distance between two points
 * @param {Object} point1 - First point {x, y}
 * @param {Object} point2 - Second point {x, y}
 * @returns {number} Distance
 */
export const distance = (point1, point2) => {
  return Math.sqrt(
    Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2)
  );
};

/**
 * Check if a point is inside a node
 * @param {Object} point - Point to check {x, y}
 * @param {Object} node - Node {x, y, width, height}
 * @returns {boolean} True if point is inside node
 */
export const isPointInNode = (point, node) => {
  return (
    point.x >= node.x &&
    point.x <= node.x + node.width &&
    point.y >= node.y &&
    point.y <= node.y + node.height
  );
};

/**
 * Get connection points for edges based on the fromSide and toSide
 * @param {Object} fromNode - Source node {x, y, width, height}
 * @param {Object} toNode - Target node {x, y, width, height}
 * @param {string} fromSide - Side of source node to connect from ('top', 'right', 'bottom', 'left')
 * @param {string} toSide - Side of target node to connect to ('top', 'right', 'bottom', 'left')
 * @returns {Object} Connection points {source: {x, y}, target: {x, y}}
 */
export const getConnectionPoints = (fromNode, toNode, fromSide = 'right', toSide = 'left') => {
  const source = { x: 0, y: 0 };
  const target = { x: 0, y: 0 };

  // Source node connection point
  switch (fromSide) {
    case 'top':
      source.x = fromNode.x + fromNode.width / 2;
      source.y = fromNode.y;
      break;
    case 'right':
      source.x = fromNode.x + fromNode.width;
      source.y = fromNode.y + fromNode.height / 2;
      break;
    case 'bottom':
      source.x = fromNode.x + fromNode.width / 2;
      source.y = fromNode.y + fromNode.height;
      break;
    case 'left':
      source.x = fromNode.x;
      source.y = fromNode.y + fromNode.height / 2;
      break;
    default:
      source.x = fromNode.x + fromNode.width;
      source.y = fromNode.y + fromNode.height / 2;
  }

  // Target node connection point
  switch (toSide) {
    case 'top':
      target.x = toNode.x + toNode.width / 2;
      target.y = toNode.y;
      break;
    case 'right':
      target.x = toNode.x + toNode.width;
      target.y = toNode.y + toNode.height / 2;
      break;
    case 'bottom':
      target.x = toNode.x + toNode.width / 2;
      target.y = toNode.y + toNode.height;
      break;
    case 'left':
      target.x = toNode.x;
      target.y = toNode.y + toNode.height / 2;
      break;
    default:
      target.x = toNode.x;
      target.y = toNode.y + toNode.height / 2;
  }

  return { source, target };
};

/**
 * Calculate the best connection sides for two nodes
 * @param {Object} fromNode - Source node {x, y, width, height}
 * @param {Object} toNode - Target node {x, y, width, height}
 * @returns {Object} Best sides {fromSide, toSide}
 */
export const calculateBestConnectionSides = (fromNode, toNode) => {
  // Calculate center points
  const fromCenter = {
    x: fromNode.x + fromNode.width / 2,
    y: fromNode.y + fromNode.height / 2
  };
  const toCenter = {
    x: toNode.x + toNode.width / 2,
    y: toNode.y + toNode.height / 2
  };

  // Calculate angle between centers
  const angle = Math.atan2(toCenter.y - fromCenter.y, toCenter.x - fromCenter.x);
  
  // Convert angle to degrees
  const degrees = (angle * 180) / Math.PI;
  
  // Determine from side based on angle
  let fromSide;
  if (degrees >= -45 && degrees < 45) {
    fromSide = 'right';
  } else if (degrees >= 45 && degrees < 135) {
    fromSide = 'bottom';
  } else if (degrees >= 135 || degrees < -135) {
    fromSide = 'left';
  } else {
    fromSide = 'top';
  }
  
  // Calculate opposite side for target
  let toSide;
  switch (fromSide) {
    case 'right': toSide = 'left'; break;
    case 'bottom': toSide = 'top'; break;
    case 'left': toSide = 'right'; break;
    case 'top': toSide = 'bottom'; break;
    default: toSide = 'left';
  }
  
  return { fromSide, toSide };
};

/**
 * Draw an arrow at the end of a line
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {number} x - X coordinate of arrow tip
 * @param {number} y - Y coordinate of arrow tip
 * @param {number} angle - Angle of the line in radians
 * @param {number} size - Size of the arrow
 */
export const drawArrow = (ctx, x, y, angle, size = 10) => {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(-size, -size / 2);
  ctx.lineTo(-size, size / 2);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
};

/**
 * Draw a connection line between two points with optional arrow
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {Object} source - Source point {x, y}
 * @param {Object} target - Target point {x, y}
 * @param {string} color - Line color
 * @param {boolean} showSourceArrow - Whether to show an arrow at the source
 * @param {boolean} showTargetArrow - Whether to show an arrow at the target
 */
export const drawConnection = (ctx, source, target, color = '#14b8a6', showSourceArrow = false, showTargetArrow = true) => {
  const angle = Math.atan2(target.y - source.y, target.x - source.x);
  
  // Draw line
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(source.x, source.y);
  ctx.lineTo(target.x, target.y);
  ctx.stroke();
  
  // Draw arrows
  ctx.fillStyle = color;
  if (showSourceArrow) {
    drawArrow(ctx, source.x, source.y, angle + Math.PI);
  }
  if (showTargetArrow) {
    drawArrow(ctx, target.x, target.y, angle);
  }
};

/**
 * Convert a canvas color code to an actual color
 * @param {string} colorCode - Color code (e.g., '1', '2', '#FF0000')
 * @returns {string} CSS color value
 */
export const getCanvasColor = (colorCode) => {
  // Map of preset colors
  const colorMap = {
    '1': '#ef4444', // red
    '2': '#f97316', // orange
    '3': '#eab308', // yellow
    '4': '#22c55e', // green
    '5': '#06b6d4', // cyan
    '6': '#a855f7'  // purple
  };
  
  // If colorCode is a preset, return the mapped color
  if (colorMap[colorCode]) {
    return colorMap[colorCode];
  }
  
  // Otherwise, return the color code as is (assuming it's a valid CSS color)
  return colorCode || '#14b8a6'; // Default to teal if no color provided
};

/**
 * Create a new empty canvas with the JSONCanvas format
 * @returns {Object} Empty canvas data
 */
export const createEmptyCanvas = () => {
  return {
    nodes: [],
    edges: []
  };
};

/**
 * Create a new text node with default properties
 * @param {number} x - X position
 * @param {number} y - Y position
 * @param {string} text - Node text content
 * @returns {Object} New text node
 */
export const createTextNode = (x, y, text = 'New note') => {
  return {
    id: generateId('node'),
    type: 'text',
    x,
    y,
    width: 200,
    height: 100,
    text
  };
};

/**
 * Create a new edge connecting two nodes
 * @param {string} fromNode - ID of source node
 * @param {string} toNode - ID of target node
 * @param {string} fromSide - Side of source node ('top', 'right', 'bottom', 'left')
 * @param {string} toSide - Side of target node ('top', 'right', 'bottom', 'left')
 * @returns {Object} New edge
 */
export const createEdge = (fromNode, toNode, fromSide = 'right', toSide = 'left') => {
  return {
    id: generateId('edge'),
    fromNode,
    toNode,
    fromSide,
    toSide,
    fromEnd: 'none',
    toEnd: 'arrow'
  };
};

================
File: utils/fileUtils.js
================
// List of available file types. idk why canvas exists atm this doesnt even do anything
export const AVAILABLE_FILE_TYPES = [
  'md',
  'canvas',
  'map'
];

// Helper function to get parent directory path from a file path
export const getParentDirectoryPath = (filePath) => {
  // Remove trailing slash if present
  const normalizedPath = filePath.endsWith('/') ? filePath.slice(0, -1) : filePath;
  // Find the last slash in the path
  const lastSlashIndex = normalizedPath.lastIndexOf('/');
  
  if (lastSlashIndex === -1) {
    // No slash found, return root
    return '/';
  }
  
  // Return everything up to the last slash
  return normalizedPath.substring(0, lastSlashIndex) || '/';
};

// Helper function to expand all parent folders of a path
export const expandParentFolders = (filePath, currentExpandedFolders) => {
  const parts = filePath.split('/').filter(Boolean);
  let currentPath = '';
  
  // Create a new expanded folders object
  const newExpandedFolders = { ...currentExpandedFolders };
  
  // Expand each parent folder
  for (let i = 0; i < parts.length; i++) {
    currentPath += '/' + parts[i];
    newExpandedFolders[currentPath] = true;
  }
  
  return newExpandedFolders;
};

// Get file icon based on file extension
export const getFileIconName = (fileName) => {
  if (fileName.endsWith('.md')) return 'FileText';
  if (fileName.endsWith('.jsx') || fileName.endsWith('.js')) return 'Code';
  if (fileName.endsWith('.json')) return 'Coffee';
  if (fileName.endsWith('.css')) return 'BookOpen';
  if (fileName.endsWith('.html')) return 'Globe';
  if (fileName.endsWith('.svg') || fileName.endsWith('.png') || fileName.endsWith('.jpg') || fileName.endsWith('.jpeg') || fileName.endsWith('.gif')) return 'Image';
  if (fileName.endsWith('.mp3') || fileName.endsWith('.wav') || fileName.endsWith('.ogg')) return 'Music';
  if (fileName.endsWith('.canvas')) return 'Figma';
  if (fileName.endsWith('.map')) return 'Map';
  return 'File';
};

// Helper function to get the active folder path based on selected item and current path
export const getActiveFolderPath = (selectedFile, currentPath) => {
  if (selectedFile) {
    // If selected item is a directory, use its path
    if (selectedFile.type === 'directory') {
      return selectedFile.path;
    }
    // If selected item is a file, use its parent directory
    return getParentDirectoryPath(selectedFile.path);
  }
  // Fall back to current path if no file is selected
  return currentPath;
};

================
File: utils/markdownUtils.js
================
import showdown from 'showdown';

// Initialize Showdown converter for Markdown with enhanced options
export const createMarkdownConverter = () => {
  const converter = new showdown.Converter({
    tables: true,
    tasklists: true,
    strikethrough: true,
    emoji: true,
    breaks: true,  // Enable line breaks to be rendered as <br> tags
    simpleLineBreaks: true,
    openLinksInNewWindow: true,
    backslashEscapesHTMLTags: true,
    ghCodeBlocks: true,
    ghCompatibleHeaderId: true,
    ghMentions: true,
    smoothLivePreview: true
  });
  
  // Enable additional extensions
  converter.setFlavor('github');
  
  return converter;
};

// Insert markdown syntax at cursor position
export const insertMarkdown = (textareaRef, fileContent, setFileContent, prefix, suffix = '') => {
  const textarea = textareaRef.current;
  if (!textarea) return;
  
  const start = textarea.selectionStart;
  const end = textarea.selectionEnd;
  const text = fileContent;
  
  // If text is selected, wrap it with prefix and suffix
  if (start !== end) {
    const selectedText = text.substring(start, end);
    const newContent = text.substring(0, start) + prefix + selectedText + suffix + text.substring(end);
    setFileContent(newContent);
    
    // Set cursor position after the inserted text
    setTimeout(() => {
      textarea.selectionStart = start + prefix.length;
      textarea.selectionEnd = end + prefix.length;
      textarea.focus();
    }, 0);
  } else {
    // No selection, just insert at cursor
    const newContent = text.substring(0, start) + prefix + suffix + text.substring(start);
    setFileContent(newContent);
    
    // Move cursor between prefix and suffix
    setTimeout(() => {
      textarea.selectionStart = textarea.selectionEnd = start + prefix.length;
      textarea.focus();
    }, 0);
  }
};

// Insert list items
export const insertList = (textareaRef, fileContent, setFileContent, listPrefix) => {
  const textarea = textareaRef.current;
  if (!textarea) return;
  
  const start = textarea.selectionStart;
  const end = textarea.selectionEnd;
  const text = fileContent;
  
  // If text is selected, apply list formatting to each line
  if (start !== end) {
    const selectedText = text.substring(start, end);
    const lines = selectedText.split('\n');
    
    // Format each line as a list item
    const formattedLines = lines.map(line => {
      // Skip empty lines
      if (line.trim() === '') return line;
      
      // For numbered lists, increment the number for each line
      if (listPrefix === '1. ') {
        const index = lines.indexOf(line) + 1;
        return `${index}. ${line}`;
      }
      
      return `${listPrefix}${line}`;
    });
    
    const newContent = text.substring(0, start) + formattedLines.join('\n') + text.substring(end);
    setFileContent(newContent);
    
    // Set cursor position after the inserted text
    setTimeout(() => {
      textarea.selectionStart = start;
      textarea.selectionEnd = start + formattedLines.join('\n').length;
      textarea.focus();
    }, 0);
  } else {
    // No selection, just insert at cursor
    const newContent = text.substring(0, start) + listPrefix + text.substring(start);
    setFileContent(newContent);
    
    // Move cursor after the inserted prefix
    setTimeout(() => {
      textarea.selectionStart = textarea.selectionEnd = start + listPrefix.length;
      textarea.focus();
    }, 0);
  }
};

// Get the current line of text at cursor position
export const getCurrentLine = (text, cursorPos) => {
  const textBeforeCursor = text.substring(0, cursorPos);
  const lineStartPos = textBeforeCursor.lastIndexOf('\n') + 1;
  const lineEndPos = text.indexOf('\n', cursorPos);
  const actualLineEndPos = lineEndPos !== -1 ? lineEndPos : text.length;
  return text.substring(lineStartPos, actualLineEndPos);
};

// Handle keyboard events in the editor
export const handleEditorKeyDown = (e, textareaRef, fileContent, setFileContent) => {
  // Handle keyboard shortcuts
  if (e.ctrlKey || e.metaKey) {
    // Ctrl+B or Cmd+B for bold
    if (e.key === 'b') {
      e.preventDefault();
      insertMarkdown(textareaRef, fileContent, setFileContent, '**', '**');
      return;
    }
    
    // Ctrl+I or Cmd+I for italic
    if (e.key === 'i') {
      e.preventDefault();
      insertMarkdown(textareaRef, fileContent, setFileContent, '*', '*');
      return;
    }
    
    // Ctrl+Shift+L for unordered list
    if (e.shiftKey && e.key === 'L') {
      e.preventDefault();
      insertList(textareaRef, fileContent, setFileContent, '- ');
      return;
    }
    
    // Ctrl+Shift+O for ordered list
    if (e.shiftKey && e.key === 'O') {
      e.preventDefault();
      insertList(textareaRef, fileContent, setFileContent, '1. ');
      return;
    }
    
    // Ctrl+Shift+C for checklist
    if (e.shiftKey && e.key === 'C') {
      e.preventDefault();
      insertList(textareaRef, fileContent, setFileContent, '- [ ] ');
      return;
    }
  }
  
  // Auto-continue lists on Enter
  if (e.key === 'Enter' && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
    const textarea = textareaRef.current;
    if (!textarea) return;
    
    const cursorPos = textarea.selectionStart;
    const text = fileContent;
    const currentLine = getCurrentLine(text, cursorPos);
    
    // Check for list patterns
    const bulletListMatch = currentLine.match(/^(\s*)(-|\*|\+)\s+(.*)/);
    const numberedListMatch = currentLine.match(/^(\s*)(\d+)\.?\s+(.*)/);
    const checklistMatch = currentLine.match(/^(\s*)(-|\*|\+)\s+\[([ xX])\]\s+(.*)/);
    
    if (bulletListMatch || numberedListMatch || checklistMatch) {
      // Get the indentation and list marker
      let indentation, marker, content;
      
      if (checklistMatch) {
        indentation = checklistMatch[1];
        marker = checklistMatch[2];
        const checkState = checklistMatch[3];
        content = checklistMatch[4];
        
        // If the checklist item is empty, remove the list marker
        if (content.trim() === '') {
          e.preventDefault();
          const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
          const newContent = text.substring(0, lineStart) + text.substring(cursorPos);
          setFileContent(newContent);
          setTimeout(() => {
            textarea.selectionStart = textarea.selectionEnd = lineStart;
            textarea.focus();
          }, 0);
          return;
        }
        
        // Continue the checklist with an unchecked box
        e.preventDefault();
        const newListItem = `\n${indentation}${marker} [ ] `;
        insertMarkdown(textareaRef, fileContent, setFileContent, newListItem);
        return;
      } else if (bulletListMatch) {
        indentation = bulletListMatch[1];
        marker = bulletListMatch[2];
        content = bulletListMatch[3];
        
        // If the list item is empty, remove the list marker
        if (content.trim() === '') {
          e.preventDefault();
          const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
          const newContent = text.substring(0, lineStart) + text.substring(cursorPos);
          setFileContent(newContent);
          setTimeout(() => {
            textarea.selectionStart = textarea.selectionEnd = lineStart;
            textarea.focus();
          }, 0);
          return;
        }
        
        // Continue the bullet list
        e.preventDefault();
        const newListItem = `\n${indentation}${marker} `;
        insertMarkdown(textareaRef, fileContent, setFileContent, newListItem);
        return;
      } else if (numberedListMatch) {
        indentation = numberedListMatch[1];
        const number = parseInt(numberedListMatch[2], 10);
        content = numberedListMatch[3];
        
        // If the list item is empty, remove the list marker
        if (content.trim() === '') {
          e.preventDefault();
          const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
          const newContent = text.substring(0, lineStart) + text.substring(cursorPos);
          setFileContent(newContent);
          setTimeout(() => {
            textarea.selectionStart = textarea.selectionEnd = lineStart;
            textarea.focus();
          }, 0);
          return;
        }
        
        // Continue the numbered list with incremented number
        e.preventDefault();
        const newListItem = `\n${indentation}${number + 1}. `;
        insertMarkdown(textareaRef, fileContent, setFileContent, newListItem);
        return;
      }
    }
  }
  
  // Handle tab for indentation in lists
  if (e.key === 'Tab') {
    const textarea = textareaRef.current;
    if (!textarea) return;
    
    const cursorPos = textarea.selectionStart;
    const text = fileContent;
    const currentLine = getCurrentLine(text, cursorPos);
    
    // Check if we're in a list item
    const listMatch = currentLine.match(/^(\s*)(-|\*|\+|\d+\.|\[[ xX]\])\s+/);
    if (listMatch) {
      e.preventDefault();
      
      // Add or remove indentation based on shift key
      if (e.shiftKey) {
        // Outdent: remove 2 spaces from the beginning if they exist
        if (currentLine.startsWith('  ')) {
          const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
          const lineEnd = text.indexOf('\n', cursorPos);
          const actualLineEnd = lineEnd !== -1 ? lineEnd : text.length;
          
          const newContent = text.substring(0, lineStart) + currentLine.substring(2) + text.substring(actualLineEnd);
          setFileContent(newContent);
          
          // Adjust cursor position
          const newCursorPos = cursorPos - 2;
          setTimeout(() => {
            textarea.selectionStart = textarea.selectionEnd = newCursorPos > lineStart ? newCursorPos : lineStart;
            textarea.focus();
          }, 0);
        }
      } else {
        // Indent: add 2 spaces at the beginning
        const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
        const lineEnd = text.indexOf('\n', cursorPos);
        const actualLineEnd = lineEnd !== -1 ? lineEnd : text.length;
        
        const newContent = text.substring(0, lineStart) + '  ' + currentLine + text.substring(actualLineEnd);
        setFileContent(newContent);
        
        // Adjust cursor position
        const newCursorPos = cursorPos + 2;
        setTimeout(() => {
          textarea.selectionStart = textarea.selectionEnd = newCursorPos;
          textarea.focus();
        }, 0);
      }
    }
  }
};

// Convert markdown to HTML
export const convertMarkdownToHtml = (converter, markdown) => {
  return converter.makeHtml(markdown);
};



================================================================
End of Codebase
================================================================
