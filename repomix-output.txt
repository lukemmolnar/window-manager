This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.git_disabled/COMMIT_EDITMSG
.git_disabled/config
.git_disabled/description
.git_disabled/HEAD
.git_disabled/hooks/applypatch-msg.sample
.git_disabled/hooks/commit-msg.sample
.git_disabled/hooks/fsmonitor-watchman.sample
.git_disabled/hooks/post-update.sample
.git_disabled/hooks/pre-applypatch.sample
.git_disabled/hooks/pre-commit.sample
.git_disabled/hooks/pre-merge-commit.sample
.git_disabled/hooks/pre-push.sample
.git_disabled/hooks/pre-rebase.sample
.git_disabled/hooks/pre-receive.sample
.git_disabled/hooks/prepare-commit-msg.sample
.git_disabled/hooks/push-to-checkout.sample
.git_disabled/hooks/sendemail-validate.sample
.git_disabled/hooks/update.sample
.git_disabled/info/exclude
.git_disabled/refs/heads/master
.gitignore
eslint.config.js
index.html
package.json
public/vite.svg
README.md
src/App.css
src/App.jsx
src/assets/react.svg
src/components/CommandBar.jsx
src/components/EmptyState.jsx
src/components/WindowManager.jsx
src/components/windows/EditorWindow.jsx
src/components/windows/ExplorerWindow.jsx
src/components/windows/index.js
src/components/windows/PreviewWindow.jsx
src/components/windows/TerminalWindow.jsx
src/hocs/withCommandHandling.jsx
src/hooks/useKeyboardShortcuts.js
src/hooks/useWindowManager.js
src/index.html
src/main.jsx
src/models/Node.js
src/styles.css
src/styles/main.css
src/utils/treeUtils.js
src/utils/windowTypes.js
src/utils/windowUtils.js
vite.config.js

================================================================
Files
================================================================

================
File: .git_disabled/COMMIT_EDITMSG
================
Initial commit

================
File: .git_disabled/config
================
[core]
	repositoryformatversion = 0
	filemode = false
	bare = false
	logallrefupdates = true
	symlinks = false
	ignorecase = true

================
File: .git_disabled/description
================
Unnamed repository; edit this file 'description' to name the repository.

================
File: .git_disabled/HEAD
================
ref: refs/heads/master

================
File: .git_disabled/hooks/applypatch-msg.sample
================
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:

================
File: .git_disabled/hooks/commit-msg.sample
================
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}

================
File: .git_disabled/hooks/fsmonitor-watchman.sample
================
#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 2) and last update token
# formatted as a string and outputs to stdout a new update token and
# all files that have been modified since the update token. Paths must
# be relative to the root of the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $last_update_token) = @ARGV;

# Uncomment for debugging
# print STDERR "$0 $version $last_update_token\n";

# Check the hook interface version
if ($version ne 2) {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree = get_working_dir();

my $retry = 1;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

launch_watchman();

sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}
}

sub output_result {
	my ($clockid, @files) = @_;

	# Uncomment for debugging watchman output
	# open (my $fh, ">", ".git/watchman-output.out");
	# binmode $fh, ":utf8";
	# print $fh "$clockid\n@files\n";
	# close $fh;

	binmode STDOUT, ":utf8";
	print $clockid;
	print "\0";
	local $, = "\0";
	print @files;
}

sub watchman_clock {
	my $response = qx/watchman clock "$git_work_tree"/;
	die "Failed to get clock id on '$git_work_tree'.\n" .
		"Falling back to scanning...\n" if $? != 0;

	return $json_pkg->new->utf8->decode($response);
}

sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	or die "open2() failed: $!\n" .
	"Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	my $last_update_line = "";
	if (substr($last_update_token, 0, 1) eq "c") {
		$last_update_token = "\"$last_update_token\"";
		$last_update_line = qq[\n"since": $last_update_token,];
	}
	my $query = <<"	END";
		["query", "$git_work_tree", {$last_update_line
			"fields": ["name"],
			"expression": ["not", ["dirname", ".git"]]
		}]
	END

	# Uncomment for debugging the watchman query
	# open (my $fh, ">", ".git/watchman-query.json");
	# print $fh $query;
	# close $fh;

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	# Uncomment for debugging the watch response
	# open ($fh, ">", ".git/watchman-response.json");
	# print $fh $response;
	# close $fh;

	die "Watchman: command returned no output.\n" .
	"Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	"Falling back to scanning...\n" unless $response =~ /^\{/;

	return $json_pkg->new->utf8->decode($response);
}

sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry--;
		my $response = qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		# Uncomment for debugging watchman output
		# open (my $fh, ">", ".git/watchman-output.out");
		# close $fh;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};

		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		output_result($o->{clock}, ("/"));
		$last_update_token = $o->{clock};

		eval { launch_watchman() };
		return 0;
	}

	die "Watchman: $error.\n" .
	"Falling back to scanning...\n" if $error;

	return 1;
}

sub get_working_dir {
	my $working_dir;
	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}

	return $working_dir;
}

================
File: .git_disabled/hooks/post-update.sample
================
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info

================
File: .git_disabled/hooks/pre-applypatch.sample
================
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:

================
File: .git_disabled/hooks/pre-commit.sample
================
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --type=bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --

================
File: .git_disabled/hooks/pre-merge-commit.sample
================
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:

================
File: .git_disabled/hooks/pre-push.sample
================
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

while read local_ref local_oid remote_ref remote_oid
do
	if test "$local_oid" = "$zero"
	then
		# Handle delete
		:
	else
		if test "$remote_oid" = "$zero"
		then
			# New branch, examine all commits
			range="$local_oid"
		else
			# Update to existing branch, examine new commits
			range="$remote_oid..$local_oid"
		fi

		# Check for WIP commit
		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
		if test -n "$commit"
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0

================
File: .git_disabled/hooks/pre-rebase.sample
================
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END

================
File: .git_disabled/hooks/pre-receive.sample
================
#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi

================
File: .git_disabled/hooks/prepare-commit-msg.sample
================
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi

================
File: .git_disabled/hooks/push-to-checkout.sample
================
#!/bin/sh

# An example hook script to update a checked-out tree on a git push.
#
# This hook is invoked by git-receive-pack(1) when it reacts to git
# push and updates reference(s) in its repository, and when the push
# tries to update the branch that is currently checked out and the
# receive.denyCurrentBranch configuration variable is set to
# updateInstead.
#
# By default, such a push is refused if the working tree and the index
# of the remote repository has any difference from the currently
# checked out commit; when both the working tree and the index match
# the current commit, they are updated to match the newly pushed tip
# of the branch. This hook is to be used to override the default
# behaviour; however the code below reimplements the default behaviour
# as a starting point for convenient modification.
#
# The hook receives the commit with which the tip of the current
# branch is going to be updated:
commit=$1

# It can exit with a non-zero status to refuse the push (when it does
# so, it must not modify the index or the working tree).
die () {
	echo >&2 "$*"
	exit 1
}

# Or it can make any necessary changes to the working tree and to the
# index to bring them to the desired state when the tip of the current
# branch is updated to the new commit, and exit with a zero status.
#
# For example, the hook can simply run git read-tree -u -m HEAD "$1"
# in order to emulate git fetch that is run in the reverse direction
# with git push, as the two-tree form of git read-tree -u -m is
# essentially the same as git switch or git checkout that switches
# branches while keeping the local changes in the working tree that do
# not interfere with the difference between the branches.

# The below is a more-or-less exact translation to shell of the C code
# for the default behaviour for git's push-to-checkout hook defined in
# the push_to_deploy() function in builtin/receive-pack.c.
#
# Note that the hook will be executed from the repository directory,
# not from the working tree, so if you want to perform operations on
# the working tree, you will have to adapt your code accordingly, e.g.
# by adding "cd .." or using relative paths.

if ! git update-index -q --ignore-submodules --refresh
then
	die "Up-to-date check failed"
fi

if ! git diff-files --quiet --ignore-submodules --
then
	die "Working directory has unstaged changes"
fi

# This is a rough translation of:
#
#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
if git cat-file -e HEAD 2>/dev/null
then
	head=HEAD
else
	head=$(git hash-object -t tree --stdin </dev/null)
fi

if ! git diff-index --quiet --cached --ignore-submodules $head --
then
	die "Working directory has staged changes"
fi

if ! git read-tree -u -m "$commit"
then
	die "Could not update working tree to new HEAD"
fi

================
File: .git_disabled/hooks/sendemail-validate.sample
================
#!/bin/sh

# An example hook script to validate a patch (and/or patch series) before
# sending it via email.
#
# The hook should exit with non-zero status after issuing an appropriate
# message if it wants to prevent the email(s) from being sent.
#
# To enable this hook, rename this file to "sendemail-validate".
#
# By default, it will only check that the patch(es) can be applied on top of
# the default upstream branch without conflicts in a secondary worktree. After
# validation (successful or not) of the last patch of a series, the worktree
# will be deleted.
#
# The following config variables can be set to change the default remote and
# remote ref that are used to apply the patches against:
#
#   sendemail.validateRemote (default: origin)
#   sendemail.validateRemoteRef (default: HEAD)
#
# Replace the TODO placeholders with appropriate checks according to your
# needs.

validate_cover_letter () {
	file="$1"
	# TODO: Replace with appropriate checks (e.g. spell checking).
	true
}

validate_patch () {
	file="$1"
	# Ensure that the patch applies without conflicts.
	git am -3 "$file" || return
	# TODO: Replace with appropriate checks for this patch
	# (e.g. checkpatch.pl).
	true
}

validate_series () {
	# TODO: Replace with appropriate checks for the whole series
	# (e.g. quick build, coding style checks, etc.).
	true
}

# main -------------------------------------------------------------------------

if test "$GIT_SENDEMAIL_FILE_COUNTER" = 1
then
	remote=$(git config --default origin --get sendemail.validateRemote) &&
	ref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&
	worktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&
	git worktree add -fd --checkout "$worktree" "refs/remotes/$remote/$ref" &&
	git config --replace-all sendemail.validateWorktree "$worktree"
else
	worktree=$(git config --get sendemail.validateWorktree)
fi || {
	echo "sendemail-validate: error: failed to prepare worktree" >&2
	exit 1
}

unset GIT_DIR GIT_WORK_TREE
cd "$worktree" &&

if grep -q "^diff --git " "$1"
then
	validate_patch "$1"
else
	validate_cover_letter "$1"
fi &&

if test "$GIT_SENDEMAIL_FILE_COUNTER" = "$GIT_SENDEMAIL_FILE_TOTAL"
then
	git config --unset-all sendemail.validateWorktree &&
	trap 'git worktree remove -ff "$worktree"' EXIT &&
	validate_series
fi

================
File: .git_disabled/hooks/update.sample
================
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --type=bool hooks.allowunannotated)
allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0

================
File: .git_disabled/info/exclude
================
# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~

================
File: .git_disabled/refs/heads/master
================
c1ae64f6e95b0e8b3693241e4b425b28768fe423

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import react from 'eslint-plugin-react'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    settings: { react: { version: '18.3' } },
    plugins: {
      react,
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...react.configs.recommended.rules,
      ...react.configs['jsx-runtime'].rules,
      ...reactHooks.configs.recommended.rules,
      'react/jsx-no-target-blank': 'off',
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

================
File: package.json
================
{
  "name": "window-manager",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tailwindcss/vite": "^4.0.6",
    "lucide-react": "^0.475.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "tailwindcss": "^4.0.6"
  },
  "devDependencies": {
    "@eslint/js": "^9.19.0",
    "@types/react": "^19.0.8",
    "@types/react-dom": "^19.0.3",
    "@vitejs/plugin-react": "^1.3.2",
    "eslint": "^9.19.0",
    "eslint-plugin-react": "^7.37.4",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.18",
    "globals": "^15.14.0",
    "vite": "^6.1.0"
  }
}

================
File: public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: README.md
================
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

================
File: src/App.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

#root {
  width: 100%;
  height: 100%;
}

================
File: src/App.jsx
================
import React from 'react';
import { WindowManager } from './components/WindowManager';
import { CommandBar } from './components/CommandBar';
import { EmptyState } from './components/EmptyState';
import { useWindowManager } from './hooks/useWindowManager';
import { useKeyboardShortcuts } from './hooks/useKeyboardShortcuts';
import { WINDOW_CONTENT } from './utils/windowTypes';

/**
 * Main application component that composes our window management system.
 * This component is intentionally kept simple, delegating most functionality
 * to specialized components and hooks.
 */
function App() {
  // Initialize window management system
  const {
    rootNode,
    activeNodeId,
    setActiveNodeId,
    createNewWindow,
    splitWindow,
    closeWindow,
    transformWindow,
    handleCommand,
    handleResizeStart,
    handleResizeMove,
    handleResizeEnd,
    hasActiveWindow,
    hasRootNode
  } = useWindowManager();

  // Set up keyboard shortcuts
  useKeyboardShortcuts({
    onSplitVertical: () => splitWindow(activeNodeId, 'vertical'),
    onSplitHorizontal: () => splitWindow(activeNodeId, 'horizontal'),
    onClose: () => closeWindow(activeNodeId),
    createNewWindow,
    hasActiveWindow,
    hasRootNode
  });

  // Define component to render based on whether we have a root node
  const renderContent = () => {
    if (!rootNode) {
      return <EmptyState />;
    }

    // Render the window tree with all necessary props
    return (
      <WindowTreeRenderer
        node={rootNode}
        activeNodeId={activeNodeId}
        setActiveNodeId={setActiveNodeId}
        transformWindow={transformWindow}
        onResizeStart={handleResizeStart}
        onResizeMove={handleResizeMove}
        onResizeEnd={handleResizeEnd}
      />
    );
  };

  return (
    <div className="w-full h-screen flex flex-col">
      {/* Global command bar */}
      <CommandBar onCommand={handleCommand} />
      
      {/* Main content area */}
      <div className="flex-1 relative">
        {renderContent()}
      </div>
    </div>
  );
}

/**
 * Renders the window tree recursively. This component is kept within App.jsx
 * since it's tightly coupled with the WindowManager's functionality.
 */
const WindowTreeRenderer = ({
  node,
  depth = 0,
  available = { x: 0, y: 0, width: 100, height: 100 },
  activeNodeId,
  setActiveNodeId,
  transformWindow,
  onResizeStart,
  onResizeMove,
  onResizeEnd
}) => {
  // Handle window nodes
  if (node.type === 'window') {
    const windowContent = WINDOW_CONTENT[node.windowType];
    const Component = windowContent.component;
    const isActive = node.id === activeNodeId;

    return (
      <div
        className={`absolute overflow-hidden border-2 ${
          isActive ? 'border-teal-500' : 'border-stone-600'
        }`}
        style={{
          left: `${available.x}%`,
          top: `${available.y}%`,
          width: `${available.width}%`,
          height: `${available.height}%`,
        }}
        onClick={() => setActiveNodeId(node.id)}
      >
        <Component
          key={`window-${node.id}-${node.windowType}`}
          isActive={isActive}
          nodeId={node.id}
          transformWindow={transformWindow}
        />
      </div>
    );
  }

  // Handle split nodes
  let firstDimensions, secondDimensions;
  if (node.direction === 'horizontal') {
    firstDimensions = {
      x: available.x,
      y: available.y,
      width: available.width * node.splitRatio,
      height: available.height
    };
    secondDimensions = {
      x: available.x + (available.width * node.splitRatio),
      y: available.y,
      width: available.width * (1 - node.splitRatio),
      height: available.height
    };
  } else {
    firstDimensions = {
      x: available.x,
      y: available.y,
      width: available.width,
      height: available.height * node.splitRatio
    };
    secondDimensions = {
      x: available.x,
      y: available.y + (available.height * node.splitRatio),
      width: available.width,
      height: available.height * (1 - node.splitRatio)
    };
  }

  // Render split container with resize handle
  return (
    <>
      <WindowTreeRenderer
        node={node.first}
        depth={depth + 1}
        available={firstDimensions}
        activeNodeId={activeNodeId}
        setActiveNodeId={setActiveNodeId}
        transformWindow={transformWindow}
        onResizeStart={onResizeStart}
        onResizeMove={onResizeMove}
        onResizeEnd={onResizeEnd}
      />
      
      {/* Resize handle */}
      <div
        className={`absolute z-10 ${
          node.direction === 'horizontal' 
            ? 'w-1 cursor-col-resize hover:bg-teal-500' 
            : 'h-1 cursor-row-resize hover:bg-teal-500'
        }`}
        style={{
          left: node.direction === 'horizontal' ? `${available.x + (available.width * node.splitRatio)}%` : `${available.x}%`,
          top: node.direction === 'horizontal' ? `${available.y}%` : `${available.y + (available.height * node.splitRatio)}%`,
          height: node.direction === 'horizontal' ? `${available.height}%` : '2px',
          width: node.direction === 'horizontal' ? '2px' : `${available.width}%`,
        }}
        onMouseDown={(e) => onResizeStart(e, node)}
      />
      
      <WindowTreeRenderer
        node={node.second}
        depth={depth + 1}
        available={secondDimensions}
        activeNodeId={activeNodeId}
        setActiveNodeId={setActiveNodeId}
        transformWindow={transformWindow}
        onResizeStart={onResizeStart}
        onResizeMove={onResizeMove}
        onResizeEnd={onResizeEnd}
      />
    </>
  );
};

export default App;

================
File: src/assets/react.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================
File: src/components/CommandBar.jsx
================
import React, { useState, useEffect, useRef } from 'react';

export const CommandBar = ({ 
  onCommand, 
  currentWorkspaceIndex = 0
}) => {
  const [command, setCommand] = useState('');
  const inputRef = useRef(null);

  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && command.trim()) {
      onCommand(command.trim());
      setCommand('');
    }
  };

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (e.key === '/' && document.activeElement !== inputRef.current) {
        e.preventDefault();
        inputRef.current?.focus();
      }
    };
    
    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, []);

  return (
    <div className="w-full bg-stone-800 p-2 flex items-center gap-2">
      <div className="flex gap-2 items-center pr-2 border-r border-stone-600">
        {Array.from({ length: 4 }, (_, i) => (
          <div
            key={i}
            className={`rounded-full transition-all duration-200 ${
              i === currentWorkspaceIndex 
                ? 'w-3 h-3 bg-teal-400' 
                : 'w-2 h-2 bg-stone-600'
            }`}
          />
        ))}
      </div>
      <span className="text-gray-400 text-sm font-mono">$</span>
      <input
        ref={inputRef}
        type="text"
        value={command}
        onChange={(e) => setCommand(e.target.value)}
        onKeyDown={handleKeyDown}
        placeholder="Type 'help' for available commands or press '/' to focus"
        className="flex-1 bg-stone-700 text-white px-4 py-1 rounded text-sm font-mono focus:outline-none focus:ring-2 focus:ring-blue-500"
      />
    </div>
  );
};

export default CommandBar;

================
File: src/components/EmptyState.jsx
================
import React from 'react';

export const EmptyState = () => (
  <div className="absolute inset-0 flex items-center justify-center bg-stone-950">
    <div className="text-center">
      <h2 className="text-xl font-semibold text-teal-400 mb-4">SLUMNET</h2>
      <p className="text-teal-400 mb-4">Bub boils the seed!</p>
      <div className="text-teal-50 bg-stone-950 p-2 font-mono text-sm">
        <p>Keyboard shortcuts:</p>
        <p>Ctrl+Enter - Create/Split Vertical</p>
        <p>Ctrl+Shift+Enter - Split Horizontal</p>
        <p>Ctrl+Backspace - Close Window</p>
      </div>
    </div>
  </div>
);

export default EmptyState;

================
File: src/components/WindowManager.jsx
================
import React, { useState, useCallback, useEffect } from 'react';
import { WINDOW_CONTENT } from '../utils/windowTypes';
import { getWindowBounds } from '../utils/windowUtils';
import { useWindowManager } from '../hooks/useWindowManager';
import { useKeyboardShortcuts } from '../hooks/useKeyboardShortcuts';
import { CommandBar } from './CommandBar';
import EmptyState from './EmptyState';

export const WindowManager = ({ defaultLayout = null }) => {
  // Get all state from useWindowManager
  const windowManager = useWindowManager({ defaultLayout });
  const {
    rootNode,
    activeNodeId,
    setActiveNodeId,
    terminalStates,
    updateTerminalState,
    splitWindow,
    createNewWindow,
    closeWindow,
    transformWindow,
    currentWorkspaceIndex,
    workspaceCount,
    switchWorkspace
  } = windowManager;

  const [dragState, setDragState] = useState(null);

  // Add keyboard shortcuts
  useKeyboardShortcuts({
    activeNodeId,
    rootNode,
    splitWindow,
    closeWindow,
    createNewWindow
  });

  // Command handling for terminal
  const handleCommand = useCallback((command) => {
    const parts = command.split(' ');
    const cmd = parts[0].toLowerCase();

    switch (cmd) {
      case 'split':
        if (activeNodeId) {
          const direction = parts[1] === 'vertical' ? 'vertical' : 'horizontal';
          splitWindow(activeNodeId, direction);
        }
        break;
      case 'close':
        if (activeNodeId) {
          closeWindow(activeNodeId);
        }
        break;
    }
  }, [activeNodeId, splitWindow, closeWindow]);

  // Resize handling
  const handleResizeStart = useCallback((e, split) => {
    e.preventDefault();
    e.stopPropagation();
    const rect = e.currentTarget.getBoundingClientRect();
    setDragState({
      split,
      initialPos: {
        x: e.clientX,
        y: e.clientY
      },
      initialRatio: split.splitRatio
    });
  }, []);

  const handleResizeMove = useCallback((e) => {
    if (!dragState) return;

    const { split, initialPos, initialRatio } = dragState;
    const delta = split.direction === 'horizontal' 
      ? (e.clientX - initialPos.x) / window.innerWidth 
      : (e.clientY - initialPos.y) / window.innerHeight;

    const newRatio = Math.max(0.1, Math.min(0.9, initialRatio + delta));
    split.splitRatio = newRatio;

    // Force a re-render
    setDragState(prev => ({ ...prev }));
  }, [dragState]);

  const handleResizeEnd = useCallback(() => {
    setDragState(null);
  }, []);

  useEffect(() => {
    if (dragState) {
      window.addEventListener('mousemove', handleResizeMove);
      window.addEventListener('mouseup', handleResizeEnd);
      return () => {
        window.removeEventListener('mousemove', handleResizeMove);
        window.removeEventListener('mouseup', handleResizeEnd);
      };
    }
  }, [dragState, handleResizeMove, handleResizeEnd]);

  // Window tree renderer
  const WindowTreeRenderer = ({ node, depth = 0, available = { x: 0, y: 0, width: 100, height: 100 } }) => {
    if (!node) return null;

    if (node.type === 'window') {
      const windowContent = WINDOW_CONTENT[node.windowType];
      if (!windowContent) {
        console.error('No window content found for type:', node.windowType);
        return null;
      }
      const Component = windowContent.component;
      const isActive = node.id === activeNodeId;
  
      return (
        <div
          className={`absolute overflow-hidden border-2 ${
            isActive ? 'border-teal-500' : 'border-stone-600'
          }`}
          style={{
            left: `${available.x}%`,
            top: `${available.y}%`,
            width: `${available.width}%`,
            height: `${available.height}%`,
          }}
          onClick={() => setActiveNodeId(node.id)}
        >
          <Component 
            key={`window-${node.id}-${node.windowType}`}
            onCommand={handleCommand} 
            isActive={isActive}
            nodeState={node.state}
            nodeId={node.id}
            transformWindow={transformWindow}
            onStateChange={(newState) => {
              updateTerminalState(node.id, newState);
            }}
          />
        </div>
      );
    }

    // Calculate split dimensions
    let firstDimensions, secondDimensions;
    if (node.direction === 'horizontal') {
      firstDimensions = {
        x: available.x,
        y: available.y,
        width: available.width * node.splitRatio,
        height: available.height
      };
      secondDimensions = {
        x: available.x + (available.width * node.splitRatio),
        y: available.y,
        width: available.width * (1 - node.splitRatio),
        height: available.height
      };
    } else {
      firstDimensions = {
        x: available.x,
        y: available.y,
        width: available.width,
        height: available.height * node.splitRatio
      };
      secondDimensions = {
        x: available.x,
        y: available.y + (available.height * node.splitRatio),
        width: available.width,
        height: available.height * (1 - node.splitRatio)
      };
    }

    return (
      <div className="absolute inset-0" style={{ pointerEvents: 'none' }}>
        <WindowTreeRenderer 
          node={node.first} 
          depth={depth + 1} 
          available={firstDimensions} 
        />
        <div
          className="absolute bg-stone-700 hover:bg-stone-500 transition-colors"
          style={{
            left: node.direction === 'horizontal' ? `${firstDimensions.width}%` : 0,
            top: node.direction === 'vertical' ? `${firstDimensions.height}%` : 0,
            width: node.direction === 'horizontal' ? '4px' : '100%',
            height: node.direction === 'vertical' ? '4px' : '100%',
            cursor: node.direction === 'horizontal' ? 'col-resize' : 'row-resize',
            pointerEvents: 'auto',
            zIndex: 10
          }}
          onMouseDown={(e) => handleResizeStart(e, node)}
        />
        <WindowTreeRenderer 
          node={node.second} 
          depth={depth + 1} 
          available={secondDimensions}
        />
      </div>
    );
  };

  return (
    <div className="w-full h-screen flex flex-col">
      <CommandBar 
        onCommand={handleCommand}
        currentWorkspaceIndex={Number(currentWorkspaceIndex)}
        workspaceCount={Number(workspaceCount)}
      />
      <div className="flex-1 relative bg-stone-900">
        {rootNode ? (
          <WindowTreeRenderer 
            node={rootNode}
            terminalStates={terminalStates}
            updateTerminalState={updateTerminalState}
          />
        ) : (
          <EmptyState />
        )}
      </div>
    </div>
  );
};

export default WindowManager;

================
File: src/components/windows/EditorWindow.jsx
================
import React, { useState } from 'react';

const EditorWindow = ({ nodeId, onCommand }) => {
  const [command, setCommand] = useState('');
  
  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && command.trim()) {
      onCommand(command.trim());
      setCommand('');
    }
  };

  return (
    <div className="p-4 font-mono text-sm h-full flex flex-col bg-white">
      <div className="flex-1">
        <pre className="text-gray-800">
          {`function hello() {
  console.log("Hello, World!");
}

// Call the function
hello();`}
        </pre>
      </div>

      {/* Command input */}
      <div className="mt-2 flex items-center gap-2">
        <span className="text-gray-400">$</span>
        <input
          type="text"
          value={command}
          onChange={(e) => setCommand(e.target.value)}
          onKeyDown={handleKeyDown}
          className="flex-1 bg-gray-100 px-2 py-1 rounded text-sm focus:outline-none"
          placeholder="Type a command..."
        />
      </div>
    </div>
  );
};

export default EditorWindow;

================
File: src/components/windows/ExplorerWindow.jsx
================
import React, { useState } from 'react';
import { FolderOpen, Code } from 'lucide-react';

const ExplorerWindow = ({ nodeId, onCommand }) => {
  const [command, setCommand] = useState('');
  
  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && command.trim()) {
      onCommand(command.trim());
      setCommand('');
    }
  };

  return (
    <div className="p-4 flex flex-col h-full bg-white">
      <div className="flex-1">
        {/* File tree structure */}
        <div className="flex items-center gap-2 text-gray-700 hover:bg-gray-100 p-2 rounded cursor-pointer">
          <FolderOpen size={16} />
          <span>src/</span>
        </div>
        <div className="flex items-center gap-2 text-gray-700 hover:bg-gray-100 p-2 rounded cursor-pointer ml-4">
          <Code size={16} />
          <span>main.js</span>
        </div>
      </div>

      {/* Command input */}
      <div className="mt-2 flex items-center gap-2">
        <span className="text-gray-400">$</span>
        <input
          type="text"
          value={command}
          onChange={(e) => setCommand(e.target.value)}
          onKeyDown={handleKeyDown}
          className="flex-1 bg-gray-100 px-2 py-1 rounded text-sm focus:outline-none"
          placeholder="Type a command..."
        />
      </div>
    </div>
  );
};

export default ExplorerWindow;

================
File: src/components/windows/index.js
================
import TerminalWindow from './TerminalWindow';
import ExplorerWindow from './ExplorerWindow';
import EditorWindow from './EditorWindow';
import PreviewWindow from './PreviewWindow';
import withCommandHandling from '../../hocs/withCommandHandling';

// Create enhanced versions of each window component by wrapping them with the HOC
export const EnhancedTerminalWindow = withCommandHandling(TerminalWindow);
export const EnhancedExplorerWindow = withCommandHandling(ExplorerWindow);
export const EnhancedEditorWindow = withCommandHandling(EditorWindow);
export const EnhancedPreviewWindow = withCommandHandling(PreviewWindow);

// Also export the base components in case they're needed
export { TerminalWindow, ExplorerWindow, EditorWindow, PreviewWindow };

================
File: src/components/windows/PreviewWindow.jsx
================
import React, { useState } from 'react';

const PreviewWindow = ({ nodeId, onCommand }) => {
  const [command, setCommand] = useState('');
  
  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && command.trim()) {
      onCommand(command.trim());
      setCommand('');
    }
  };

  return (
    <div className="p-4 h-full flex flex-col bg-white">
      <div className="flex-1">
        <h1 className="text-2xl font-bold">Preview Window</h1>
        <p className="mt-2 text-gray-600">
          Live preview of your content will appear here.
        </p>
      </div>

      {/* Command input */}
      <div className="mt-2 flex items-center gap-2">
        <span className="text-gray-400">$</span>
        <input
          type="text"
          value={command}
          onChange={(e) => setCommand(e.target.value)}
          onKeyDown={handleKeyDown}
          className="flex-1 bg-gray-100 px-2 py-1 rounded text-sm focus:outline-none"
          placeholder="Type a command..."
        />
      </div>
    </div>
  );
};

export default PreviewWindow;

================
File: src/components/windows/TerminalWindow.jsx
================
import React, { useState, useEffect, useRef } from 'react';
import { WINDOW_TYPES } from '../../utils/windowTypes';

const TerminalWindow = ({ onCommand, isActive, nodeId, transformWindow }) => {
  // Refs for managing focus and scrolling
  const terminalRef = useRef(null);
  const inputRef = useRef(null);

  // Terminal state
  const [history, setHistory] = useState([
    'Welcome to the Terminal! Type "help" for available commands.'
  ]);
  const [commandHistory, setCommandHistory] = useState([]);
  const [currentInput, setCurrentInput] = useState('');
  const [historyIndex, setHistoryIndex] = useState(-1);

  // Auto-focus when terminal becomes active
  useEffect(() => {
    if (isActive) {
      inputRef.current?.focus();
    }
  }, [isActive]);

  // Auto-scroll to bottom when new output is added
  useEffect(() => {
    if (terminalRef.current) {
      terminalRef.current.scrollTop = terminalRef.current.scrollHeight;
    }
  }, [history]);

  const handleTerminalClick = () => {
    inputRef.current?.focus();
  };

  const executeCommand = (command) => {
    setHistory(prev => [...prev, `$ ${command}`]);
    setCommandHistory(prev => [...prev, command]);
  
    const cmd = command.toLowerCase();
  
    if (Object.keys(WINDOW_TYPES).some(type => type.toLowerCase() === cmd)) {
      const requestedType = WINDOW_TYPES[cmd.toUpperCase()];
      transformWindow(nodeId, requestedType);
      return;
    }
  
    let response;
    switch (cmd) {
      case 'help':
        response = [
          'Available commands:',
          '  explorer     - Transform into file explorer',
          '  editor       - Transform into code editor',
          '  terminal     - Transform into terminal',
          '  preview      - Transform into preview window',
          '  help         - Show this help message',
          '  clear        - Clear terminal output',
          '',
          'Keyboard shortcuts:',
          '  Ctrl + Enter       - Split vertically',
          '  Ctrl + Shift + Enter - Split horizontally',
          '  Ctrl + Backspace   - Close window',
          '  /                  - Focus command bar'
        ].join('\n');
        break;
  
      case 'clear':
        setHistory(['Terminal cleared']);
        return;
  
      case 'version':
        response = 'SLUMNET Terminal v1.0.0';
        break;
  
      default:
        response = `Unknown command: ${command}`;
    }
  
    setHistory(prev => [...prev, response]);
  };

  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && currentInput.trim()) {
      executeCommand(currentInput.trim());
      setCurrentInput('');
      setHistoryIndex(-1);
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      if (historyIndex < commandHistory.length - 1) {
        const newIndex = historyIndex + 1;
        setHistoryIndex(newIndex);
        setCurrentInput(commandHistory[commandHistory.length - 1 - newIndex] || '');
      }
    } else if (e.key === 'ArrowDown') {
      e.preventDefault();
      if (historyIndex > -1) {
        const newIndex = historyIndex - 1;
        setHistoryIndex(newIndex);
        setCurrentInput(newIndex === -1 ? '' : commandHistory[commandHistory.length - 1 - newIndex] || '');
      }
    }
  };

  return (
    <div 
      className="p-4 bg-stone-900 text-teal-400 font-mono text-sm h-full flex flex-col"
      onClick={handleTerminalClick}
    >
      <div ref={terminalRef} className="flex-1 overflow-auto whitespace-pre-wrap">
        {history.map((line, i) => (
          <div key={i}>{line}</div>
        ))}
      </div>

      <div className="flex items-center mt-2">
        <span className="mr-2">$</span>
        <input
          ref={inputRef}
          type="text"
          value={currentInput}
          onChange={(e) => setCurrentInput(e.target.value)}
          onKeyDown={handleKeyDown}
          className="flex-1 bg-transparent outline-none text-teal-400"
          autoFocus
        />
      </div>
    </div>
  );
};

export default TerminalWindow;

================
File: src/hocs/withCommandHandling.jsx
================
import React from 'react';
import { WINDOW_TYPES } from '../utils/windowTypes';

/**
 * Higher-Order Component that adds command handling capabilities to window components.
 * This HOC provides a standardized way to handle commands across different window types,
 * particularly focusing on window transformation commands.
 *
 * @param {React.Component} WrappedComponent - The window component to enhance with command handling
 * @returns {React.Component} - A new component with command handling capabilities
 */
const withCommandHandling = (WrappedComponent) => {
  // Return a new component that includes the command handling functionality
  return function WithCommandHandling({ 
    transformWindow, // Function to change window type
    nodeId,         // Unique identifier for the window
    ...props        // All other props passed to the window
  }) {
    /**
     * Handles commands entered in the window.
     * Currently supports window transformation commands (e.g., 'terminal', 'editor', etc.)
     * Can be extended to handle other command types in the future.
     *
     * @param {string} command - The command string to process
     * @returns {boolean} - Whether the command was handled
     */
    const handleCommand = (command) => {
      // Convert command to lowercase for case-insensitive comparison
      const cmd = command.toLowerCase();
      
      // Check if the command matches any window type
      // This allows commands like 'terminal', 'editor', 'explorer', 'preview'
      const isWindowTypeCommand = Object.keys(WINDOW_TYPES).some(
        type => type.toLowerCase() === cmd
      );

      if (isWindowTypeCommand) {
        // Get the actual window type constant from our types enum
        const requestedType = WINDOW_TYPES[cmd.toUpperCase()];
        
        // Log the transformation request for debugging
        console.log(`Transforming window ${nodeId} to ${requestedType}`);
        
        // Execute the transformation
        transformWindow(nodeId, requestedType);
        
        // Return true to indicate the command was handled
        return true;
      }
      
      // Return false if the command wasn't handled by this HOC
      // This allows the wrapped component to handle other commands if needed
      return false;
    };
    
    // Render the wrapped component with both the original props
    // and our new command handler
    return (
      <WrappedComponent 
        {...props} 
        transformWindow={transformWindow}
        nodeId={nodeId}
        onCommand={handleCommand}
      />
    );
  };
};

export default withCommandHandling;

================
File: src/hooks/useKeyboardShortcuts.js
================
import { useEffect } from 'react';
import { WINDOW_TYPES } from '../utils/windowTypes';

/**
 * A custom hook that manages keyboard shortcuts for window operations.
 * This hook centralizes all keyboard-related logic for the window manager.
 * 
 * @param {Object} handlers - Object containing callback functions for various window operations
 * @param {Function} handlers.onSplitVertical - Handler for vertical split command
 * @param {Function} handlers.onSplitHorizontal - Handler for horizontal split command
 * @param {Function} handlers.onClose - Handler for window close command
 * @param {Function} handlers.createNewWindow - Handler for creating new windows
 * @param {boolean} hasActiveWindow - Whether there is currently an active window
 * @param {boolean} hasRootNode - Whether there is a root node in the tree
 */
export const useKeyboardShortcuts = ({
  onSplitVertical,
  onSplitHorizontal,
  onClose,
  createNewWindow,
  hasActiveWindow,
  hasRootNode
}) => {
  useEffect(() => {
    // Handler for keyboard events
    const handleKeyDown = (e) => {
      // Only handle ctrl/cmd key combinations
      if (!e.ctrlKey && !e.metaKey) return;

      if (e.key === 'Enter') {
        e.preventDefault();
        
        if (e.shiftKey) {
          // Ctrl+Shift+Enter: Horizontal split
          if (hasActiveWindow) {
            onSplitHorizontal();
          } else {
            createNewWindow(WINDOW_TYPES.TERMINAL);
          }
        } else {
          // Ctrl+Enter: Vertical split
          if (hasActiveWindow) {
            onSplitVertical();
          } else {
            createNewWindow(WINDOW_TYPES.TERMINAL);
          }
        }
      } else if (e.key === 'Backspace') {
        // Only allow closing if we have an active window and root node
        if (hasActiveWindow && hasRootNode) {
          e.preventDefault();
          onClose();
        }
      }
    };

    // Add event listener for keyboard shortcuts
    window.addEventListener('keydown', handleKeyDown);
    
    // Clean up event listener on unmount
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [
    onSplitVertical,
    onSplitHorizontal,
    onClose,
    createNewWindow,
    hasActiveWindow,
    hasRootNode
  ]);
};

================
File: src/hooks/useWindowManager.js
================
import { useState, useCallback, useEffect, useReducer } from 'react';
import { Node } from '../models/Node';
import { WINDOW_TYPES } from '../utils/windowTypes';
import { 
  splitNodeById, 
  removeNodeById, 
  findNodeById, 
  findAllWindowIds,
  updateSplitRatio,
} from '../utils/treeUtils';
import { getWindowBounds } from '../utils/windowUtils';

export const useWindowManager = ({ defaultLayout = null, onChange } = {}) => {
  
  // Workspace state
  const [workspaces, setWorkspaces] = useState([
    { id: 1, name: 'Main', root: defaultLayout, activeNodeId: null, terminalStates: {} },
    { id: 2, name: 'Code', root: null, activeNodeId: null, terminalStates: {} },
    { id: 3, name: 'Terminal', root: null, activeNodeId: null, terminalStates: {} },
    { id: 4, name: 'Preview', root: null, activeNodeId: null, terminalStates: {} }
  ]);
  const [currentWorkspaceIndex, setCurrentWorkspaceIndex] = useState(0);

  // Get current workspace data directly from workspaces array
  const currentWorkspace = workspaces[currentWorkspaceIndex];
  const rootNode = currentWorkspace.root;
  const activeNodeId = currentWorkspace.activeNodeId;
  const terminalStates = currentWorkspace.terminalStates;

  // Add logging to track workspace values
  console.log('useWindowManager state:', {
    workspaces,
    currentWorkspaceIndex,
    workspaceCount: workspaces.length
  });

  // Create setActiveNodeId function that updates the workspace
  const setActiveNodeId = useCallback((nodeId) => {
    setWorkspaces(prev => {
      const updated = [...prev];
      updated[currentWorkspaceIndex] = {
        ...updated[currentWorkspaceIndex],
        activeNodeId: nodeId
      };
      return updated;
    });
  }, [currentWorkspaceIndex]);

  // Update workspace state
  const updateWorkspace = useCallback((updater) => {
    setWorkspaces(prev => {
      const updated = [...prev];
      if (typeof updater === 'function') {
        updated[currentWorkspaceIndex] = {
          ...updated[currentWorkspaceIndex],
          ...updater(updated[currentWorkspaceIndex])
        };
      } else {
        updated[currentWorkspaceIndex] = {
          ...updated[currentWorkspaceIndex],
          ...updater
        };
      }
      return updated;
    });
  }, [currentWorkspaceIndex]);

  const switchWorkspace = useCallback((direction) => {
    setCurrentWorkspaceIndex(prev => {
      let newIndex;
      if (direction === 'right') {
        newIndex = (prev + 1) % workspaces.length;
      } else {
        newIndex = prev - 1;
        if (newIndex < 0) newIndex = workspaces.length - 1;
      }
      return newIndex;
    });
  }, [workspaces.length]);

  useEffect(() => {
    const handleWorkspaceKeys = (e) => {
      if (e.ctrlKey && e.altKey) {
        switch (e.key) {
          case 'ArrowRight':
            e.preventDefault();
            switchWorkspace('right');
            break;
          case 'ArrowLeft':
            e.preventDefault();
            switchWorkspace('left');
            break;
          // Removed 'n' key handler for creating new workspaces
        }
      }
    };

    window.addEventListener('keydown', handleWorkspaceKeys);
    return () => window.removeEventListener('keydown', handleWorkspaceKeys);
  }, [switchWorkspace]);

  const workspaceCount = workspaces.length;


  // Your existing window navigation functions
  const navigateToWindow = useCallback((direction) => {
    if (!activeNodeId || !rootNode) return;
  
    const allWindows = getWindowBounds(rootNode);
    const activeWindow = allWindows.find(w => w.id === activeNodeId);
    if (!activeWindow) return;
  
    const adjacentWindows = allWindows.filter(w => {
      if (w.id === activeNodeId) return false;
  
      const bounds = w.bounds;
      const activeBounds = activeWindow.bounds;
  
      const hasVerticalOverlap = () => 
        !(bounds.bottom < activeBounds.top || bounds.top > activeBounds.bottom);
  
      const horizontalOverlap = () => 
        !(bounds.right < activeBounds.left || bounds.left > activeBounds.right);
  
      const tolerance = 0.01;
  
      switch (direction) {
        case 'up':
          return hasVerticalOverlap() &&
                 Math.abs(bounds.bottom - activeBounds.top) < tolerance;
        case 'down':
          return hasVerticalOverlap() &&
                 Math.abs(bounds.top - activeBounds.bottom) < tolerance;
        case 'left':
          return horizontalOverlap() &&
                 Math.abs(bounds.right - activeBounds.left) < tolerance;
        case 'right':
          return horizontalOverlap() &&
                 Math.abs(bounds.left - activeBounds.right) < tolerance;
        default:
          return false;
      }
    });
  
    if (adjacentWindows.length === 0) return;
  
    let nextWindow;
    switch (direction) {
      case 'left':
        nextWindow = adjacentWindows.sort((a, b) => 
          a.bounds.centerX !== b.bounds.centerX
            ? b.bounds.centerX - a.bounds.centerX
            : a.bounds.centerY - b.bounds.centerY
        )[0];
        break;
      
      case 'right':
        nextWindow = adjacentWindows.sort((a, b) => 
          a.bounds.centerX !== b.bounds.centerX
            ? a.bounds.centerX - b.bounds.centerX
            : a.bounds.centerY - b.bounds.centerY
        )[0];
        break;
      
      case 'up':
        nextWindow = adjacentWindows.sort((a, b) => 
          a.bounds.centerY !== b.bounds.centerY
            ? b.bounds.centerY - a.bounds.centerY
            : a.bounds.centerX - b.bounds.centerX
        )[0];
        break;
      
      case 'down':
        nextWindow = adjacentWindows.sort((a, b) => 
          a.bounds.centerY !== b.bounds.centerY
            ? a.bounds.centerY - b.bounds.centerY
            : a.bounds.centerX - b.bounds.centerX
        )[0];
        break;
    }
  
    if (nextWindow) {
      setActiveNodeId(nextWindow.id);
    }
  }, [activeNodeId, rootNode, setActiveNodeId]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (!e.ctrlKey) return;
  
      switch (e.key) {
        case 'ArrowLeft':
          e.preventDefault();
          navigateToWindow('left');
          break;
        case 'ArrowRight':
          e.preventDefault();
          navigateToWindow('right');
          break;
        case 'ArrowUp':
          e.preventDefault();
          navigateToWindow('up');
          break;
        case 'ArrowDown':
          e.preventDefault();
          navigateToWindow('down');
          break;
      }
    };
  
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [navigateToWindow]);

  const createNewWindow = useCallback((windowType) => {
    const newNode = Node.createWindow(Date.now(), windowType || WINDOW_TYPES.TERMINAL);
    
    if (windowType === WINDOW_TYPES.TERMINAL) {
      updateWorkspace(workspace => ({
        ...workspace,
        terminalStates: {
          ...workspace.terminalStates,
          [newNode.id]: {
            history: ['Welcome to the Terminal! Type "help" for available commands.'],
            commandHistory: []
          }
        }
      }));
    }
    
    if (!rootNode) {
      updateWorkspace({
        root: newNode,
        activeNodeId: newNode.id
      });
      return;
    }
    
    if (!activeNodeId) {
      updateWorkspace({
        root: newNode,
        activeNodeId: newNode.id
      });
      return;
    }
    
    splitWindow(activeNodeId, 'vertical', newNode);
    setActiveNodeId(newNode.id);
  }, [rootNode, activeNodeId, updateWorkspace, setActiveNodeId]);

  const splitWindow = useCallback((nodeId, direction, newWindow = null) => {
    if (!newWindow) {
      newWindow = Node.createWindow(Date.now(), WINDOW_TYPES.TERMINAL);
    }
  
    updateWorkspace(workspace => ({
      ...workspace,
      root: splitNodeById(workspace.root, nodeId, direction, newWindow)
    }));
  }, [updateWorkspace]);

  const closeWindow = useCallback((nodeId) => {
    if (rootNode.type === 'window' && rootNode.id === nodeId) {
      updateWorkspace({
        root: null,
        activeNodeId: null
      });
      return;
    }

    const newRoot = JSON.parse(JSON.stringify(rootNode));
    const result = removeNodeById(newRoot, nodeId);
    
    if (activeNodeId === nodeId && result) {
      const nextWindowId = findAllWindowIds(result)[0] || null;
      updateWorkspace({
        root: result,
        activeNodeId: nextWindowId
      });
    } else {
      updateWorkspace({
        root: result
      });
    }
  }, [rootNode, activeNodeId, updateWorkspace]);

  const transformWindow = useCallback((nodeId, newType) => {
    const newRoot = JSON.parse(JSON.stringify(rootNode));
    
    const updateNodeInTree = (node) => {
      if (!node) return null;
      
      if (node.type === 'window' && node.id === nodeId) {
        node.windowType = newType;
        return true;
      }
      
      if (node.type === 'split') {
        return updateNodeInTree(node.first) || updateNodeInTree(node.second);
      }
      
      return false;
    };
    
    const updated = updateNodeInTree(newRoot);
    if (updated) {
      updateWorkspace({
        root: newRoot
      });
    }
  }, [rootNode, updateWorkspace]);

  const handleCommand = useCallback((command) => {
    const parts = command.split(' ');
    const cmd = parts[0].toLowerCase();

    switch (cmd) {
      case 'split':
        if (activeNodeId) {
          const direction = parts[1] === 'vertical' ? 'vertical' : 'horizontal';
          splitWindow(activeNodeId, direction);
        }
        break;
      case 'close':
        if (activeNodeId) {
          closeWindow(activeNodeId);
        }
        break;
    }
  }, [activeNodeId, splitWindow, closeWindow]);

  const wsCount = Number(workspaces.length);
  const wsIndex = Number(currentWorkspaceIndex);

  return {
    rootNode,
    activeNodeId,
    setActiveNodeId,
    terminalStates,
    createNewWindow,
    splitWindow,
    closeWindow,
    transformWindow,
    handleCommand,
    navigateToWindow,
    hasActiveWindow: Boolean(activeNodeId),
    hasRootNode: Boolean(rootNode),
    currentWorkspaceIndex: wsIndex,
    workspaceCount: wsCount,
    switchWorkspace
  };
};

================
File: src/index.html
================
// index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Window Manager</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

================
File: src/main.jsx
================
// src/main.jsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './styles.css'
import './app.css'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)

================
File: src/models/Node.js
================
/**
 * Node class representing a window or split in the window management system.
 * Forms the foundation of our tree-based window layout structure.
 */
export class Node {
  constructor(id, type) {
    this.id = id;
    this.type = type;
    this.windowType = null;
    this.direction = null;
    this.first = null;
    this.second = null;
    this.splitRatio = 0.5;
    this.minimumSize = 20;
    this.state = null;
  }

  static createWindow(id, windowType, state = null) {
    const node = new Node(id, 'window');
    node.windowType = windowType;
    node.state = state;
    return node;
  }

  static createSplit(direction, first, second, ratio = 0.5) {
    const node = new Node(Date.now(), 'split');
    node.direction = direction;
    node.first = first;
    node.second = second;
    node.splitRatio = ratio;
    return node;
  }
}

================
File: src/styles.css
================
@import "tailwindcss";

@tailwind base;
@tailwind components;
@tailwind utilities;

html, body, #root {
  width: 100%;
  height: 100vh;
  margin: 0;
  padding: 0;
  overflow: hidden;
}

.window-container {
  position: absolute;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.window-content {
  flex: 1;
  overflow: auto;
}

.resize-handle {
  position: absolute;
  z-index: 10;
  background-color: transparent;
  transition: background-color 0.2s;
}

.resize-handle:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

.resize-handle.horizontal {
  cursor: col-resize;
  width: 4px;
  height: 100%;
}

.resize-handle.vertical {
  cursor: row-resize;
  width: 100%;
  height: 4px;
}

================
File: src/styles/main.css
================
/* This imports all of Tailwind's utility classes */
@import "tailwindcss";

/* You can add any custom CSS below this line */

================
File: src/utils/treeUtils.js
================
import { Node } from '../models/Node';

/**
 * Splits a window by ID, ensuring only the target window is affected
 * @param {Node} node - Current node in the tree
 * @param {string} targetId - ID of the window to split
 * @param {string} direction - Split direction ('vertical' or 'horizontal')
 * @param {Node} newWindow - New window to insert
 * @returns {Node} Updated tree structure
 */
export const findFirstWindowId = (node) => {
  if (!node) return null;
  if (node.type === 'window') return node.id;
  return findFirstWindowId(node.first) || findFirstWindowId(node.second);
};

/**
 * Creates a new split by ID, inserting a new window at the specified location
 */
export const splitNodeById = (node, targetId, direction, newWindow) => {
    if (!node) return null;
  
    // If this is the node we want to split
    if (node.id === targetId && node.type === 'window') {
      // Create a new split with the current window and new window
      return Node.createSplit(direction, node, newWindow);
    }
  
    // If this is a split node, recursively check its children
    if (node.type === 'split') {
      // Check if target is in first child
      if (findNodeById(node.first, targetId)) {
        return {
          ...node,
          first: splitNodeById(node.first, targetId, direction, newWindow)
        };
      }
      
      // Check if target is in second child
      if (findNodeById(node.second, targetId)) {
        return {
          ...node,
          second: splitNodeById(node.second, targetId, direction, newWindow)
        };
      }
    }
  
    // If we haven't found the target node, return the original node unchanged
    return node;
  };

export const removeNodeById = (node, targetId) => {
  if (!node) return null;

  if (node.type === 'split') {
    if (node.first.id === targetId) {
      return node.second;
    }
    if (node.second.id === targetId) {
      return node.first;
    }

    const firstResult = removeNodeById(node.first, targetId);
    if (firstResult !== node.first) {
      node.first = firstResult;
      return node;
    }

    const secondResult = removeNodeById(node.second, targetId);
    if (secondResult !== node.second) {
      node.second = secondResult;
      return node;
    }
  }

  return node;
};

export const findNodeById = (node, targetId) => {
  if (!node) return null;
  
  if (node.id === targetId && node.type === 'window') return node;
  
  if (node.type === 'split') {
    const firstResult = findNodeById(node.first, targetId);
    if (firstResult) return firstResult;
    
    const secondResult = findNodeById(node.second, targetId);
    if (secondResult) return secondResult;
  }
  
  return null;
};

export const findAllWindowIds = (node) => {
  if (!node) return [];
  if (node.type === 'window') return [node.id];
  return [...findAllWindowIds(node.first), ...findAllWindowIds(node.second)];
};

export const updateSplitRatio = (node, splitId, newRatio) => {
  if (!node) return;

  if (node.type === 'split' && node.id === splitId) {
    node.splitRatio = Math.max(0.2, Math.min(0.8, newRatio));
    return;
  }

  if (node.type === 'split') {
    updateSplitRatio(node.first, splitId, newRatio);
    updateSplitRatio(node.second, splitId, newRatio);
  }
};

================
File: src/utils/windowTypes.js
================
import { FolderOpen, Code, Terminal as TerminalIcon, Eye } from 'lucide-react';
import { 
  EnhancedExplorerWindow,
  EnhancedEditorWindow,
  EnhancedTerminalWindow,
  EnhancedPreviewWindow
} from '../components/windows';

export const WINDOW_TYPES = {
  EXPLORER: 'explorer',
  EDITOR: 'editor',
  TERMINAL: 'terminal',
  PREVIEW: 'preview'
};

export const WINDOW_CONTENT = {
  [WINDOW_TYPES.EXPLORER]: {
    title: 'File Explorer',
    icon: FolderOpen,
    component: EnhancedExplorerWindow
  },
  [WINDOW_TYPES.EDITOR]: {
    title: 'Code Editor',
    icon: Code,
    component: EnhancedEditorWindow
  },
  [WINDOW_TYPES.TERMINAL]: {
    title: 'Terminal',
    icon: TerminalIcon,
    component: EnhancedTerminalWindow
  },
  [WINDOW_TYPES.PREVIEW]: {
    title: 'Preview',
    icon: Eye,
    component: EnhancedPreviewWindow
  }
};

================
File: src/utils/windowUtils.js
================
/**
 * Contains utility functions for window-specific calculations and operations.
 * These functions focus on spatial relationships and window bounds rather than
 * tree structure manipulation.
 */

/**
 * Calculates the bounds of windows in the tree. Each window gets its position
 * and size as percentages of the available space.
 * 
 * @param {Node} node - The node to calculate bounds for
 * @param {Object} available - The available space in percentages
 * @returns {Array} Array of objects containing window IDs and their bounds
 */
export const getWindowBounds = (node, available = { x: 0, y: 0, width: 100, height: 100 }) => {
    if (node.type === 'window') {
      return [{
        id: node.id,
        bounds: {
          left: available.x,
          top: available.y,
          right: available.x + available.width,
          bottom: available.y + available.height,
          width: available.width,
          height: available.height,
          centerX: available.x + (available.width / 2),
          centerY: available.y + (available.height / 2)
        }
      }];
    }
  
    // For split nodes, recursively get bounds of children
    const bounds = [];
    
    if (node.direction === 'horizontal') {
      const firstHalf = {
        x: available.x,
        y: available.y,
        width: available.width * node.splitRatio,
        height: available.height
      };
      const secondHalf = {
        x: available.x + (available.width * node.splitRatio),
        y: available.y,
        width: available.width * (1 - node.splitRatio),
        height: available.height
      };
      bounds.push(...getWindowBounds(node.first, firstHalf));
      bounds.push(...getWindowBounds(node.second, secondHalf));
    } else {
      const firstHalf = {
        x: available.x,
        y: available.y,
        width: available.width,
        height: available.height * node.splitRatio
      };
      const secondHalf = {
        x: available.x,
        y: available.y + (available.height * node.splitRatio),
        width: available.width,
        height: available.height * (1 - node.splitRatio)
      };
      bounds.push(...getWindowBounds(node.first, firstHalf));
      bounds.push(...getWindowBounds(node.second, secondHalf));
    }
  
    return bounds;
  };
  
  /**
   * Determines if two windows are adjacent in a specific direction.
   * Uses a small tolerance value to account for floating-point calculations.
   * 
   * @param {Object} window1 - First window with bounds
   * @param {Object} window2 - Second window with bounds
   * @param {string} direction - Direction to check ('left', 'right', 'up', 'down')
   * @returns {boolean} Whether the windows are adjacent
   */
  export const areWindowsAdjacent = (window1, window2, direction) => {
    const tolerance = 0.01; // 1% tolerance for floating point comparisons
    
    switch (direction) {
      case 'left':
        return Math.abs(window1.bounds.left - window2.bounds.right) < tolerance &&
               !(window1.bounds.bottom < window2.bounds.top || window1.bounds.top > window2.bounds.bottom);
      case 'right':
        return Math.abs(window1.bounds.right - window2.bounds.left) < tolerance &&
               !(window1.bounds.bottom < window2.bounds.top || window1.bounds.top > window2.bounds.bottom);
      case 'up':
        return Math.abs(window1.bounds.top - window2.bounds.bottom) < tolerance &&
               !(window1.bounds.right < window2.bounds.left || window1.bounds.left > window2.bounds.right);
      case 'down':
        return Math.abs(window1.bounds.bottom - window2.bounds.top) < tolerance &&
               !(window1.bounds.right < window2.bounds.left || window1.bounds.left > window2.bounds.right);
      default:
        return false;
    }
  };
  
  /**
   * Finds the next window in a specified direction from the active window.
   * 
   * @param {Node} rootNode - The root node of the window tree
   * @param {string} activeNodeId - ID of the currently active window
   * @param {string} direction - Direction to look for the next window
   * @returns {string|null} ID of the next window, or null if none found
   */
  export const findNextWindow = (rootNode, activeNodeId, direction) => {
    const allWindows = getWindowBounds(rootNode);
    const activeWindow = allWindows.find(w => w.id === activeNodeId);
    if (!activeWindow) return null;
  
    const adjacentWindows = allWindows.filter(w => 
      w.id !== activeNodeId && areWindowsAdjacent(activeWindow, w, direction)
    );
  
    if (adjacentWindows.length === 0) return null;
  
    // Sort adjacent windows based on position and direction
    let nextWindow;
    switch (direction) {
      case 'left':
        nextWindow = adjacentWindows.sort((a, b) => 
          a.bounds.centerX !== b.bounds.centerX
            ? b.bounds.centerX - a.bounds.centerX
            : a.bounds.centerY - b.bounds.centerY
        )[0];
        break;
      case 'right':
        nextWindow = adjacentWindows.sort((a, b) => 
          a.bounds.centerX !== b.bounds.centerX
            ? a.bounds.centerX - b.bounds.centerX
            : a.bounds.centerY - b.bounds.centerY
        )[0];
        break;
      case 'up':
        nextWindow = adjacentWindows.sort((a, b) => 
          a.bounds.centerY !== b.bounds.centerY
            ? b.bounds.centerY - a.bounds.centerY
            : a.bounds.centerX - b.bounds.centerX
        )[0];
        break;
      case 'down':
        nextWindow = adjacentWindows.sort((a, b) => 
          a.bounds.centerY !== b.bounds.centerY
            ? a.bounds.centerY - b.bounds.centerY
            : a.bounds.centerX - b.bounds.centerX
        )[0];
        break;
    }
  
    return nextWindow?.id || null;
  };

================
File: vite.config.js
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'

// This configuration sets up Vite with both React and Tailwind CSS support
export default defineConfig({
  plugins: [
    // The React plugin enables JSX processing and Fast Refresh
    react(),
    // The Tailwind plugin handles utility class generation
    tailwindcss(),
  ],
})



================================================================
End of Codebase
================================================================
