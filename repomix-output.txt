This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.env.development
.git_disabled/COMMIT_EDITMSG
.git_disabled/config
.git_disabled/description
.git_disabled/HEAD
.git_disabled/hooks/applypatch-msg.sample
.git_disabled/hooks/commit-msg.sample
.git_disabled/hooks/fsmonitor-watchman.sample
.git_disabled/hooks/post-update.sample
.git_disabled/hooks/pre-applypatch.sample
.git_disabled/hooks/pre-commit.sample
.git_disabled/hooks/pre-merge-commit.sample
.git_disabled/hooks/pre-push.sample
.git_disabled/hooks/pre-rebase.sample
.git_disabled/hooks/pre-receive.sample
.git_disabled/hooks/prepare-commit-msg.sample
.git_disabled/hooks/push-to-checkout.sample
.git_disabled/hooks/sendemail-validate.sample
.git_disabled/hooks/update.sample
.git_disabled/info/exclude
.git_disabled/refs/heads/master
.github/workflows/deploy.yml
.gitignore
cache-busting-documentation.md
canvas-documentation.md
canvas-editor-documentation.md
canvas-explorer-patch.js
canvas-fix-guide.md
eslint.config.js
example.canvas
fix-indexeddb-canvas-issue.js
index.html
indexeddb-implementation-guide.txt
jsoncanvas-main/_config.yml
jsoncanvas-main/.gitignore
jsoncanvas-main/.layouts/404.html
jsoncanvas-main/.layouts/canvas.html
jsoncanvas-main/.layouts/docs.html
jsoncanvas-main/.layouts/head.html
jsoncanvas-main/.layouts/nav.html
jsoncanvas-main/404.md
jsoncanvas-main/assets/canvas.js
jsoncanvas-main/assets/icon.svg
jsoncanvas-main/assets/prism.js
jsoncanvas-main/assets/style.css
jsoncanvas-main/CNAME
jsoncanvas-main/docs/apps.md
jsoncanvas-main/Gemfile
jsoncanvas-main/LICENSE
jsoncanvas-main/logo.svg
jsoncanvas-main/readme.md
jsoncanvas-main/sample.canvas
jsoncanvas-main/spec/1.0.md
move-mode-documentation.txt
package.json
public/agooba_favicon.svg
public/markdown_test/README.md
public/sample.canvas
public/vite.svg
README.md
reset-indexeddb.js
resize-mode-documentation.txt
src/App.css
src/App.jsx
src/assets/react.svg
src/assets/SVG/emptyState.svg
src/components/auth/AuthScreen.jsx
src/components/auth/index.js
src/components/auth/Login.jsx
src/components/auth/Register.jsx
src/components/CommandBar.jsx
src/components/EmptyState.jsx
src/components/WindowManager.jsx
src/components/windows/AdminWindow.jsx
src/components/windows/AudioWindow.jsx
src/components/windows/CanvasPreview.jsx
src/components/windows/CanvasWindow.jsx
src/components/windows/ChatWindow.jsx
src/components/windows/DiceRollGif.jsx
src/components/windows/explorer/api/fileOperations.js
src/components/windows/explorer/components/canvas/CanvasContainer.jsx
src/components/windows/explorer/components/canvas/CanvasEditor.jsx
src/components/windows/explorer/components/canvas/TextNode.jsx
src/components/windows/explorer/components/CanvasEditor.jsx
src/components/windows/explorer/components/CommandInput.jsx
src/components/windows/explorer/components/dialogs/FileDialogs.jsx
src/components/windows/explorer/components/FileContent.jsx
src/components/windows/explorer/components/FileTree.jsx
src/components/windows/explorer/components/MapEditor.jsx
src/components/windows/explorer/components/nodes/index.js
src/components/windows/explorer/components/nodes/TextNode.jsx
src/components/windows/explorer/components/StorageStats.jsx
src/components/windows/explorer/ExplorerWindow.jsx
src/components/windows/explorer/README.md
src/components/windows/explorer/state/useExplorerState.js
src/components/windows/explorer/utils/canvasUtils.js
src/components/windows/explorer/utils/fileUtils.js
src/components/windows/explorer/utils/markdownUtils.js
src/components/windows/ExplorerWindow-fix.jsx
src/components/windows/ExplorerWindow.css
src/components/windows/ExplorerWindow.jsx
src/components/windows/index.js
src/components/windows/mapeditor/components/OpacitySlider.jsx
src/components/windows/mapeditor/LayerPanel.jsx
src/components/windows/mapeditor/MapCanvas.jsx
src/components/windows/mapeditor/MapPropertiesPanel.jsx
src/components/windows/mapeditor/MapToolbar.jsx
src/components/windows/mapeditor/README.md
src/components/windows/mapeditor/styles/RangeSlider.css
src/components/windows/mapeditor/TilePalette.jsx
src/components/windows/mapeditor/TilesetSelector.jsx
src/components/windows/mapeditor/utils/mapUtils.js
src/components/windows/mapeditor/utils/tileRegistry.js
src/components/windows/MapEditorWindow.jsx
src/components/windows/TerminalWindow.jsx
src/config/api.js
src/context/ActiveUsersContext.jsx
src/context/AnnouncementContext.jsx
src/context/AuthContext.jsx
src/context/PartyContext.jsx
src/context/WindowStateContext.jsx
src/context/WorkspaceContext.jsx
src/db/db-config.js
src/db/db-operations.js
src/db/db.js
src/hocs/withCommandHandling.jsx
src/hocs/withCommandInput.jsx
src/hocs/withWindowState.jsx
src/hooks/swapWindows.js
src/hooks/useForceUpdate.js
src/hooks/useKeyboardShortcuts.js
src/hooks/useWindowManager.js
src/index.html
src/main.jsx
src/models/Node.js
src/repomix-output.txt
src/services/indexedDBService.js
src/styles.css
src/styles/main.css
src/utils/cacheManager.js
src/utils/canvasNodeTypes.js
src/utils/commandAliases.js
src/utils/constants.js
src/utils/debugLogger.js
src/utils/diceUtils.js
src/utils/globalPolyfill.js
src/utils/terminal/command-system-documentation.md
src/utils/terminal/Command.js
src/utils/terminal/commandLoader.js
src/utils/terminal/commands/admin/AdminCommand.js
src/utils/terminal/commands/admin/AnnouncementCommand.js
src/utils/terminal/commands/admin/DebugCommand.js
src/utils/terminal/commands/core/ClearCommand.js
src/utils/terminal/commands/core/HelpCommand.js
src/utils/terminal/commands/core/VersionCommand.js
src/utils/terminal/commands/vtt/LegacyPartyCommands.js
src/utils/terminal/commands/vtt/PartyCommand.js
src/utils/terminal/commands/vtt/RollCommand.js
src/utils/terminal/commands/window/ChatCommand.js
src/utils/terminal/commands/window/ExplorerCommand.js
src/utils/terminal/commands/window/TerminalCommand.js
src/utils/terminal/commands/window/WindowCommand.js
src/utils/terminal/executor.js
src/utils/terminal/parser/parser.js
src/utils/terminal/parser/tokenizer.js
src/utils/terminal/registry.js
src/utils/treeUtils.js
src/utils/windowSizeConstants.js
src/utils/windowTypes.js
src/utils/windowUtils.js
vite.config.js

================================================================
Files
================================================================

================
File: .env.development
================
VITE_API_BASE_URL=http://45.45.239.125:3001/api
VITE_SOCKET_URL=http://45.45.239.125:3001

================
File: .git_disabled/COMMIT_EDITMSG
================
Initial commit

================
File: .git_disabled/config
================
[core]
	repositoryformatversion = 0
	filemode = false
	bare = false
	logallrefupdates = true
	symlinks = false
	ignorecase = true

================
File: .git_disabled/description
================
Unnamed repository; edit this file 'description' to name the repository.

================
File: .git_disabled/HEAD
================
ref: refs/heads/master

================
File: .git_disabled/hooks/applypatch-msg.sample
================
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:

================
File: .git_disabled/hooks/commit-msg.sample
================
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}

================
File: .git_disabled/hooks/fsmonitor-watchman.sample
================
#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 2) and last update token
# formatted as a string and outputs to stdout a new update token and
# all files that have been modified since the update token. Paths must
# be relative to the root of the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $last_update_token) = @ARGV;

# Uncomment for debugging
# print STDERR "$0 $version $last_update_token\n";

# Check the hook interface version
if ($version ne 2) {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree = get_working_dir();

my $retry = 1;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

launch_watchman();

sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}
}

sub output_result {
	my ($clockid, @files) = @_;

	# Uncomment for debugging watchman output
	# open (my $fh, ">", ".git/watchman-output.out");
	# binmode $fh, ":utf8";
	# print $fh "$clockid\n@files\n";
	# close $fh;

	binmode STDOUT, ":utf8";
	print $clockid;
	print "\0";
	local $, = "\0";
	print @files;
}

sub watchman_clock {
	my $response = qx/watchman clock "$git_work_tree"/;
	die "Failed to get clock id on '$git_work_tree'.\n" .
		"Falling back to scanning...\n" if $? != 0;

	return $json_pkg->new->utf8->decode($response);
}

sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	or die "open2() failed: $!\n" .
	"Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	my $last_update_line = "";
	if (substr($last_update_token, 0, 1) eq "c") {
		$last_update_token = "\"$last_update_token\"";
		$last_update_line = qq[\n"since": $last_update_token,];
	}
	my $query = <<"	END";
		["query", "$git_work_tree", {$last_update_line
			"fields": ["name"],
			"expression": ["not", ["dirname", ".git"]]
		}]
	END

	# Uncomment for debugging the watchman query
	# open (my $fh, ">", ".git/watchman-query.json");
	# print $fh $query;
	# close $fh;

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	# Uncomment for debugging the watch response
	# open ($fh, ">", ".git/watchman-response.json");
	# print $fh $response;
	# close $fh;

	die "Watchman: command returned no output.\n" .
	"Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	"Falling back to scanning...\n" unless $response =~ /^\{/;

	return $json_pkg->new->utf8->decode($response);
}

sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry--;
		my $response = qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		# Uncomment for debugging watchman output
		# open (my $fh, ">", ".git/watchman-output.out");
		# close $fh;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};

		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		output_result($o->{clock}, ("/"));
		$last_update_token = $o->{clock};

		eval { launch_watchman() };
		return 0;
	}

	die "Watchman: $error.\n" .
	"Falling back to scanning...\n" if $error;

	return 1;
}

sub get_working_dir {
	my $working_dir;
	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}

	return $working_dir;
}

================
File: .git_disabled/hooks/post-update.sample
================
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info

================
File: .git_disabled/hooks/pre-applypatch.sample
================
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:

================
File: .git_disabled/hooks/pre-commit.sample
================
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --type=bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --

================
File: .git_disabled/hooks/pre-merge-commit.sample
================
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:

================
File: .git_disabled/hooks/pre-push.sample
================
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

while read local_ref local_oid remote_ref remote_oid
do
	if test "$local_oid" = "$zero"
	then
		# Handle delete
		:
	else
		if test "$remote_oid" = "$zero"
		then
			# New branch, examine all commits
			range="$local_oid"
		else
			# Update to existing branch, examine new commits
			range="$remote_oid..$local_oid"
		fi

		# Check for WIP commit
		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
		if test -n "$commit"
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0

================
File: .git_disabled/hooks/pre-rebase.sample
================
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END

================
File: .git_disabled/hooks/pre-receive.sample
================
#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi

================
File: .git_disabled/hooks/prepare-commit-msg.sample
================
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi

================
File: .git_disabled/hooks/push-to-checkout.sample
================
#!/bin/sh

# An example hook script to update a checked-out tree on a git push.
#
# This hook is invoked by git-receive-pack(1) when it reacts to git
# push and updates reference(s) in its repository, and when the push
# tries to update the branch that is currently checked out and the
# receive.denyCurrentBranch configuration variable is set to
# updateInstead.
#
# By default, such a push is refused if the working tree and the index
# of the remote repository has any difference from the currently
# checked out commit; when both the working tree and the index match
# the current commit, they are updated to match the newly pushed tip
# of the branch. This hook is to be used to override the default
# behaviour; however the code below reimplements the default behaviour
# as a starting point for convenient modification.
#
# The hook receives the commit with which the tip of the current
# branch is going to be updated:
commit=$1

# It can exit with a non-zero status to refuse the push (when it does
# so, it must not modify the index or the working tree).
die () {
	echo >&2 "$*"
	exit 1
}

# Or it can make any necessary changes to the working tree and to the
# index to bring them to the desired state when the tip of the current
# branch is updated to the new commit, and exit with a zero status.
#
# For example, the hook can simply run git read-tree -u -m HEAD "$1"
# in order to emulate git fetch that is run in the reverse direction
# with git push, as the two-tree form of git read-tree -u -m is
# essentially the same as git switch or git checkout that switches
# branches while keeping the local changes in the working tree that do
# not interfere with the difference between the branches.

# The below is a more-or-less exact translation to shell of the C code
# for the default behaviour for git's push-to-checkout hook defined in
# the push_to_deploy() function in builtin/receive-pack.c.
#
# Note that the hook will be executed from the repository directory,
# not from the working tree, so if you want to perform operations on
# the working tree, you will have to adapt your code accordingly, e.g.
# by adding "cd .." or using relative paths.

if ! git update-index -q --ignore-submodules --refresh
then
	die "Up-to-date check failed"
fi

if ! git diff-files --quiet --ignore-submodules --
then
	die "Working directory has unstaged changes"
fi

# This is a rough translation of:
#
#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
if git cat-file -e HEAD 2>/dev/null
then
	head=HEAD
else
	head=$(git hash-object -t tree --stdin </dev/null)
fi

if ! git diff-index --quiet --cached --ignore-submodules $head --
then
	die "Working directory has staged changes"
fi

if ! git read-tree -u -m "$commit"
then
	die "Could not update working tree to new HEAD"
fi

================
File: .git_disabled/hooks/sendemail-validate.sample
================
#!/bin/sh

# An example hook script to validate a patch (and/or patch series) before
# sending it via email.
#
# The hook should exit with non-zero status after issuing an appropriate
# message if it wants to prevent the email(s) from being sent.
#
# To enable this hook, rename this file to "sendemail-validate".
#
# By default, it will only check that the patch(es) can be applied on top of
# the default upstream branch without conflicts in a secondary worktree. After
# validation (successful or not) of the last patch of a series, the worktree
# will be deleted.
#
# The following config variables can be set to change the default remote and
# remote ref that are used to apply the patches against:
#
#   sendemail.validateRemote (default: origin)
#   sendemail.validateRemoteRef (default: HEAD)
#
# Replace the TODO placeholders with appropriate checks according to your
# needs.

validate_cover_letter () {
	file="$1"
	# TODO: Replace with appropriate checks (e.g. spell checking).
	true
}

validate_patch () {
	file="$1"
	# Ensure that the patch applies without conflicts.
	git am -3 "$file" || return
	# TODO: Replace with appropriate checks for this patch
	# (e.g. checkpatch.pl).
	true
}

validate_series () {
	# TODO: Replace with appropriate checks for the whole series
	# (e.g. quick build, coding style checks, etc.).
	true
}

# main -------------------------------------------------------------------------

if test "$GIT_SENDEMAIL_FILE_COUNTER" = 1
then
	remote=$(git config --default origin --get sendemail.validateRemote) &&
	ref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&
	worktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&
	git worktree add -fd --checkout "$worktree" "refs/remotes/$remote/$ref" &&
	git config --replace-all sendemail.validateWorktree "$worktree"
else
	worktree=$(git config --get sendemail.validateWorktree)
fi || {
	echo "sendemail-validate: error: failed to prepare worktree" >&2
	exit 1
}

unset GIT_DIR GIT_WORK_TREE
cd "$worktree" &&

if grep -q "^diff --git " "$1"
then
	validate_patch "$1"
else
	validate_cover_letter "$1"
fi &&

if test "$GIT_SENDEMAIL_FILE_COUNTER" = "$GIT_SENDEMAIL_FILE_TOTAL"
then
	git config --unset-all sendemail.validateWorktree &&
	trap 'git worktree remove -ff "$worktree"' EXIT &&
	validate_series
fi

================
File: .git_disabled/hooks/update.sample
================
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --type=bool hooks.allowunannotated)
allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0

================
File: .git_disabled/info/exclude
================
# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~

================
File: .git_disabled/refs/heads/master
================
c1ae64f6e95b0e8b3693241e4b425b28768fe423

================
File: .github/workflows/deploy.yml
================
name: Deploy to Production

on:
  push:
    branches: [ master ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
        
    - name: Install dependencies
      run: npm ci
      
    - name: Create production environment file
      run: |
        echo "VITE_API_BASE_URL=/api" > .env.production
        echo "VITE_SOCKET_URL=" >> .env.production
      
    - name: Build project
      run: npm run build

    - name: Debug Secrets
      run: |
        if [ -n "${{ secrets.SSH_PRIVATE_KEY }}" ]; then
          echo "SSH_PRIVATE_KEY is set"
        else
          echo "SSH_PRIVATE_KEY is not set"
        fi
        
        if [ -n "${{ secrets.SERVER_USERNAME }}" ]; then
          echo "SERVER_USERNAME is set"
        else
          echo "SERVER_USERNAME is not set"
        fi
      
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        
        # Add known hosts
        ssh-keyscan -p 8190 -H 45.45.239.125 >> ~/.ssh/known_hosts
        
        # Create SSH config
        echo "Host deployment-server" > ~/.ssh/config
        echo "    HostName 45.45.239.125" >> ~/.ssh/config
        echo "    Port 8190" >> ~/.ssh/config
        echo "    User ${{ secrets.SERVER_USERNAME }}" >> ~/.ssh/config
        echo "    IdentityFile ~/.ssh/id_rsa" >> ~/.ssh/config
        echo "    StrictHostKeyChecking yes" >> ~/.ssh/config
        
    - name: Deploy with SSH
      run: |
        # Test SSH connection
        ssh deployment-server "echo SSH connection successful"
        
        # Create remote directory
        ssh deployment-server "mkdir -p /var/www/public_site"
        
        # Clear old files
        ssh deployment-server "rm -rf /var/www/public_site/*"
        
        # Copy files
        scp -r dist/* deployment-server:/var/www/public_site/
        
        # Set cache control headers for index.html
        ssh deployment-server "echo 'Cache-Control: no-cache, no-store, must-revalidate' > /var/www/public_site/.htaccess"
        ssh deployment-server "echo 'Pragma: no-cache' >> /var/www/public_site/.htaccess"
        ssh deployment-server "echo 'Expires: 0' >> /var/www/public_site/.htaccess"
        
        # Set long-term caching for hashed assets
        ssh deployment-server "echo '<FilesMatch \"\.([0-9a-f]{8,})\.((js|css|jpg|jpeg|png|gif|webp|svg|woff2))$\">' >> /var/www/public_site/.htaccess"
        ssh deployment-server "echo '  Header set Cache-Control \"public, max-age=31536000, immutable\"' >> /var/www/public_site/.htaccess"
        ssh deployment-server "echo '</FilesMatch>' >> /var/www/public_site/.htaccess"

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
.aider*

================
File: cache-busting-documentation.md
================
# Cache Busting Implementation

This document explains the changes implemented to prevent the white screen issue that users were experiencing after application updates until they manually cleared their browser cache.

## Problem

When pushing updates to the application with `git push`, users were seeing a white screen until they cleared their browser cache. This occurred because:

1. The browser cached JavaScript, CSS, and other assets
2. After a deployment, the server had new code but users' browsers were still loading old cached files
3. This version mismatch between the HTML and cached assets caused the application to break, resulting in a white screen

## Solution Overview

The solution implements a comprehensive cache busting strategy through three complementary approaches:

1. **Content Hashing in Build Process**: Ensures each unique file version has a unique filename
2. **Cache Control Headers**: Proper HTTP caching directives for both cached and non-cached resources
3. **Client-Side Cache Management**: JavaScript utility to detect version changes and clear caches

## Implementation Details

### 1. Vite Build Configuration (`vite.config.js`)

Added content hashing to all asset filenames to force cache invalidation:

```javascript
build: {
  // ... existing config ...
  
  // Enable content hashing in filenames for cache busting
  assetsDir: 'assets',
  sourcemap: true,
  manifest: true,
  // Use content hashing to force cache invalidation when files change
  chunkFileNames: 'assets/js/[name]-[hash].js',
  entryFileNames: 'assets/js/[name]-[hash].js',
  assetFileNames: 'assets/[ext]/[name]-[hash].[ext]'
}
```

This ensures that whenever a file changes, its filename also changes, forcing browsers to download the new version instead of using the cached one.

### 2. Cache Control Headers

#### HTML Meta Tags (`index.html`)

Added cache control meta tags to the main HTML file:

```html
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />
```

These tags instruct browsers not to cache the main HTML file, ensuring users always get the latest version with references to the current asset files.

#### Server Configuration (`.htaccess` in CI/CD Pipeline)

Modified the GitHub Actions workflow to create an `.htaccess` file with proper cache headers:

```
# No caching for index.html and other non-hashed files
Cache-Control: no-cache, no-store, must-revalidate
Pragma: no-cache
Expires: 0

# Long-term caching for hashed assets (1 year)
<FilesMatch "\.([0-9a-f]{8,})\.((js|css|jpg|jpeg|png|gif|webp|svg|woff2))$">
  Header set Cache-Control "public, max-age=31536000, immutable"
</FilesMatch>
```

### 3. Client-Side Cache Manager (`cacheManager.js`)

Created a utility to handle cache invalidation on the client side:

```javascript
// Key features:
// - Stores a version identifier in localStorage
// - Compares stored version with current version on app load
// - Clears browser caches and service workers when version changes
// - Provides methods for forced reload if needed
```

This utility serves as an additional layer of protection, ensuring that any cached resources are cleared when the application is updated.

## How It Works Together

1. When you build and deploy a new version:
   - Content hashing generates new filenames for changed assets
   - CI/CD pipeline deploys the files and sets up proper cache headers

2. When a user visits the app after an update:
   - The browser downloads the HTML file (not cached due to cache-control headers)
   - The HTML references the new hashed asset files
   - The client-side cache manager detects any version change and clears caches

## Benefits

- **No More White Screens**: Users will always get a functioning application
- **Optimal Performance**: Long-term caching for assets that rarely change
- **No Manual Cache Clearing**: The system handles cache invalidation automatically
- **Graceful Updates**: Version transitions happen smoothly without user intervention

## Testing

To test these changes:
1. Deploy a new version of the application
2. Visit the application in a browser without clearing cache
3. The application should load correctly without showing a white screen
4. Check the browser's network tab to verify that:
   - The main HTML file is freshly loaded (not from cache)
   - Hashed assets are either loaded from cache or downloaded as needed

================
File: canvas-documentation.md
================
# Canvas Window Documentation

The Canvas Window is a powerful tool for creating and editing interactive node-based diagrams, similar to Obsidian Canvas. It allows you to create, connect, and organize nodes in a visual workspace.

## Features

- **Interactive Canvas**: Pan and zoom to navigate the workspace
- **Node Types**: Create text nodes and group nodes
- **Connections**: Create connections between nodes
- **Drag and Drop**: Easily create new nodes by dragging from the panel
- **Selection**: Select and manipulate multiple nodes at once
- **Save/Load**: Save and load canvas files in `.canvas` format
- **Persistence**: Canvas state is automatically saved between sessions

## Getting Started

1. Open a Canvas window from the command bar or menu
2. Load an existing canvas file with the `load` command
3. Create nodes by dragging from the panel or using the toolbar buttons
4. Connect nodes by clicking and dragging from one node to another
5. Save your work with the `save` command

## Commands

The Canvas window supports the following commands:

- `save`: Save the current canvas to the current file path
- `load [path]`: Load a canvas from the specified file path (e.g., `load /public/sample.canvas`)
- `new-text`: Create a new text node
- `new-group`: Create a new group node
- `delete`: Delete selected elements

## Node Types

### Text Nodes

Text nodes contain plain text content. They are useful for adding notes, descriptions, or any textual information to your canvas.

To create a text node:
- Click the "Text" button in the toolbar
- Use the `new-text` command
- Drag the "Text Node" item from the panel

### Group Nodes

Group nodes are containers that can visually group related nodes together. They have a label and a background color.

To create a group node:
- Click the "Group" button in the toolbar
- Use the `new-group` command
- Drag the "Group Node" item from the panel

## Working with Nodes

### Selecting Nodes

- Click on a node to select it
- Hold Shift and click to select multiple nodes
- Click and drag in empty space to create a selection box

### Moving Nodes

- Click and drag a selected node to move it
- When multiple nodes are selected, moving one will move all selected nodes

### Editing Nodes

- For text nodes, you can edit the text content when creating the node
- For group nodes, you can set the label and color when creating the node

### Connecting Nodes

To create a connection between nodes:
1. Click on a node (the source)
2. Drag to another node (the target)
3. Release to create the connection

### Deleting Elements

To delete nodes or connections:
1. Select the elements you want to delete
2. Press the Delete key or use the `delete` command
3. Alternatively, click the "Delete" button in the toolbar when elements are selected

## Canvas Files

Canvas files use the `.canvas` extension and are stored in JSON format. They contain:

- A list of nodes with their positions, types, and data
- A list of edges (connections) between nodes

Example canvas files:
- `/public/sample.canvas`: A sample canvas with various node types and connections
- `/example.canvas`: The example canvas provided with the application

## Tips and Tricks

- Use the minimap in the bottom-right corner to navigate large canvases
- The controls in the bottom-left allow you to zoom in/out and fit the view
- You can use the mouse wheel to zoom in and out
- Hold the middle mouse button or space+left mouse button to pan the canvas
- Use groups to organize related nodes and reduce visual clutter
- Save your work frequently using the `save` command

## Keyboard Shortcuts

- Delete: Delete selected elements
- Ctrl+A: Select all elements
- Ctrl+C: Copy selected elements
- Ctrl+V: Paste copied elements
- Ctrl+Z: Undo
- Ctrl+Y: Redo
- Ctrl+S: Save (when implemented)
- +: Zoom in
- -: Zoom out
- 0: Reset zoom
- Arrow keys: Move selected nodes

================
File: canvas-editor-documentation.md
================
# Canvas Editor

The Canvas Editor is an Obsidian-style node-based editor that allows you to create, edit, and connect text nodes with arrows. This editor is integrated into the file explorer for `.canvas` files.

## Getting Started

1. Create a new `.canvas` file in the file explorer or open an existing one
2. The Canvas Editor will automatically open when you select a `.canvas` file
3. You'll see a blank canvas or the previously saved content

## Features

### Creating Nodes

There are two ways to create new text nodes:

1. **Using the toolbar**:
   - Click the "Add Node" button in the toolbar
   - Enter your text in the popup dialog
   - Click "Create" to add the node to the canvas

2. **Using drag and drop**:
   - Find the "Drag to create" panel in the top-left corner
   - Drag the "Text Node" item onto the canvas
   - Drop it where you want the node to appear

### Editing Nodes

There are two ways to edit nodes:

1. **Using the toolbar**:
   - Click once on a node to select it
   - Click the "Edit" button that appears in the toolbar
   - A text area will appear, allowing you to modify the content

2. **Using the node's edit button**:
   - Hover over any node to reveal an edit button in its top-right corner
   - Click the edit button to enter edit mode

When editing:
- Press **Ctrl+Enter** or click outside the node to save your changes
- Press **Escape** to cancel editing

### Connecting Nodes

Nodes have connection handles that are visible on all four sides (top, right, bottom, left):

1. Look for the teal circular dots on each node
2. Click and drag from any handle to another node's handle 
3. Release to create a connection arrow
4. Connections can flow in any direction between nodes
5. You can have multiple connections between the same nodes

Note: The connection handles are currently always visible for better usability while this feature is being developed.

### Managing Elements

- **Select** elements by clicking on them
- **Delete** selected elements using the "Delete" button in the toolbar
- **Move** nodes by dragging them around the canvas
- **Pan** the canvas by dragging in empty space
- **Zoom** using the scroll wheel or the controls in the bottom-right

### Saving Your Work

- Your canvas is automatically saved as you work
- You can manually save by clicking the "Save" button in the toolbar

## Tips

- Use the minimap in the bottom-right to navigate large canvases
- Press "Delete" on your keyboard to remove selected elements
- Hold Shift while selecting to select multiple elements
- Hover over nodes to reveal the edit button in the top-right corner

## Example Usage

Try opening the `sample.canvas` file to see an example of what you can create with the Canvas Editor.

================
File: canvas-explorer-patch.js
================
// ===== CANVAS EXPLORER PATCH =====
// This file contains the necessary changes to make canvas files work with the Explorer window.
// Apply these changes manually to the ExplorerWindow.jsx file.

// 1. Make sure the Box icon is imported in the Lucide React imports:
// import { 
//   ..., Box
// } from 'lucide-react';

// 2. Make sure CanvasPreview is imported:
// import CanvasPreview from './CanvasPreview';

// 3. In the getFileIcon function, add this line to recognize canvas files:
if (fileName.endsWith('.canvas')) return <Box size={16} className="mr-2" />;

// 4. Modify the handleFileSelect function to handle canvas files:
const handleFileSelect = (file) => {
  // If it's a directory, handle it differently
  if (file.type === 'directory') {
    handleFolderSelect(file);
    return;
  }
  
  setSelectedFile(file);
  
  // We don't change the current path when selecting a file
  // This prevents the file tree from reloading unnecessarily
  
  // Reset edit mode when selecting a new file
  if (editMode) {
    setEditMode(false);
  }
  
  // If it's a markdown or canvas file, fetch its content and show preview
  if (file.name.endsWith('.md') || file.name.endsWith('.canvas')) {
    if (file.isPublic) {
      // Fetch public file content
      fetchPublicFileContent(file.path);
    } else {
      // Fetch private file content (admin only)
      fetchFileContent(file.path);
    }
    setShowPreview(true);
  } else {
    setFileContent('');
    setShowPreview(false);
  }
};

// 5. In the Content area section (look for "Content area - either editor or preview"),
// Add this block to handle Canvas files after the isContentLoading check:
{isContentLoading ? (
  <div className="flex-1 flex items-center justify-center">
    <span className="text-teal-300">Loading content...</span>
  </div>
) : selectedFile && selectedFile.name.endsWith('.canvas') ? (
  // Canvas preview mode
  <div className="flex-1 overflow-hidden">
    <CanvasPreview fileContent={fileContent} />
  </div>
) : editMode && selectedFile.name.endsWith('.md') && isAdmin ? (
  // Editor mode - only for markdown files and admin users
  // ... (existing editor code)

================
File: canvas-fix-guide.md
================
# Canvas State Loading Error Fix Guide

## The Issue

You're experiencing the following error when opening a canvas file:

```
Failed to load canvas state for window 1742238849976 from IndexedDB: NotFoundError: Failed to execute 'transaction' on 'IDBDatabase': One of the specified object stores was not found.
    at db-operations.js:36:28
    at new Promise (<anonymous>)
    at getData (db-operations.js:35:10)
    at async loadCanvasState (CanvasWindow.jsx:95:28)
```

There's also a warning about React Flow node types:

```
[React Flow]: It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.
```

## Root Cause Analysis

### IndexedDB Error

This error occurs when trying to access an object store in IndexedDB that doesn't exist. This typically happens when:

1. The database schema has changed between versions
2. The database has become corrupted
3. There's a mismatch between the expected schema and the actual one

In this case, the `CANVAS_STATES` store in IndexedDB that's used to save the state of canvas windows cannot be found, which causes the error.

### React Flow Warning

The second issue is a performance warning from React Flow. When you create new object references (like `nodeTypes` or `edgeTypes`) on each render, it can cause unnecessary re-renders. React Flow is suggesting to either:

1. Define the nodeTypes object outside the component
2. Use memoization (via `useMemo`) to prevent recreating the object on each render

## Solution

We've implemented a two-part solution:

### 1. IndexedDB Reset Button

A reset button has been added to the application (in the bottom right corner) that will:
- Delete all IndexedDB databases associated with the application
- Reload the page to create fresh databases with the correct schema

This button is added via the `reset-indexeddb.js` script, which is already included in your `index.html`.

### 2. Canvas Fix

To fix the React Flow warning and improve canvas support, the following changes have been implemented:

- Created a shared `canvasNodeTypes.js` utility that exports the node types
- Updated both `CanvasWindow.jsx` and `CanvasPreview.jsx` to use this shared object
- Added proper canvas file support to the `ExplorerWindow.jsx` component to view canvas files

## How to Fix the Issue

1. Launch your application in the browser
2. Look for the red "Reset IndexedDB" button in the bottom right corner
3. Click the button and confirm the reset when prompted
4. The page will reload with a fresh IndexedDB database with the correct schema
5. Canvas files should now load correctly without the error

## Prevention

To prevent this issue in the future:

1. When making changes to the database schema, consider adding version migration logic
2. Use consistent imports for shared objects like nodeTypes
3. Consider adding a version field to your database to track schema changes

## Technical Details

The core issue was that the `CANVAS_STATES` object store either:
1. Never existed in the current database
2. Was deleted or renamed at some point
3. The database connection failed to include it in the transaction

The error happens at this point in the code:

```javascript
// In db-operations.js
export const getData = (storeName, id) => {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction([storeName], 'readonly'); // <-- Error happens here
    // ...
  });
}
```

By resetting the IndexedDB database, we allow the application to recreate all object stores with the latest schema, resolving the issue.

================
File: eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import react from 'eslint-plugin-react'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'

export default [
  { ignores: ['dist'] },
  {
    files: ['**/*.{js,jsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    settings: { react: { version: '18.3' } },
    plugins: {
      react,
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...js.configs.recommended.rules,
      ...react.configs.recommended.rules,
      ...react.configs['jsx-runtime'].rules,
      ...reactHooks.configs.recommended.rules,
      'react/jsx-no-target-blank': 'off',
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
]

================
File: example.canvas
================
{
  "name": "Example Canvas",
  "nodes": [
    {
      "id": "node-1",
      "type": "text",
      "position": {
        "x": 100,
        "y": 100
      },
      "data": {
        "text": "# Example Canvas\n\nThis is a demonstration of the Canvas Editor.\n\nDouble-click this node to edit its content."
      }
    },
    {
      "id": "node-2",
      "type": "text",
      "position": {
        "x": 500,
        "y": 100
      },
      "data": {
        "text": "## Creating Nodes\n\nYou can create new nodes by clicking the 'Add Node' button in the toolbar."
      }
    },
    {
      "id": "node-3",
      "type": "text",
      "position": {
        "x": 300,
        "y": 300
      },
      "data": {
        "text": "## Connecting Nodes\n\nClick on a node, then drag from a connection point to another node to create an arrow connection."
      }
    },
    {
      "id": "node-4",
      "type": "text",
      "position": {
        "x": 500,
        "y": 400
      },
      "data": {
        "text": "## Moving Nodes\n\nClick and drag nodes to reposition them on the canvas."
      }
    }
  ],
  "edges": [
    {
      "id": "edge-1",
      "source": "node-1",
      "target": "node-2",
      "type": "default",
      "style": {
        "stroke": "#14b8a6"
      }
    },
    {
      "id": "edge-2",
      "source": "node-1",
      "target": "node-3",
      "type": "default",
      "style": {
        "stroke": "#14b8a6"
      }
    },
    {
      "id": "edge-3",
      "source": "node-3",
      "target": "node-4",
      "type": "default",
      "style": {
        "stroke": "#14b8a6"
      }
    }
  ],
  "version": "1.0",
  "metadata": {
    "created": "2025-04-16T13:20:00.000Z",
    "modified": "2025-04-16T13:20:00.000Z"
  }
}

================
File: fix-indexeddb-canvas-issue.js
================
/**
 * CANVAS FILE & INDEXEDDB ISSUE FIX
 * 
 * This script contains all the necessary fixes to resolve:
 * 1. The IndexedDB error with canvas files
 * 2. The issue with canvas files not displaying properly in Explorer
 * 
 * How to use this script:
 * 1. Run this script using Node.js
 * 2. It will verify the required changes and apply the fixes if needed
 * 3. For a full manual fix, follow the instructions in canvas-fix-guide.md
 */

const fs = require('fs');
const path = require('path');

// Config
const rootDir = __dirname;
const fixes = [
  {
    name: "Canvas Window node types import",
    file: "src/components/windows/CanvasWindow.jsx",
    test: (content) => content.includes("import nodeTypes from '../../utils/canvasNodeTypes';"),
    message: " CanvasWindow.jsx already has the shared nodeTypes import"
  },
  {
    name: "Canvas Preview node types import",
    file: "src/components/windows/CanvasPreview.jsx",
    test: (content) => content.includes("import nodeTypes from '../../utils/canvasNodeTypes';"),
    message: " CanvasPreview.jsx already has the shared nodeTypes import"
  },
  {
    name: "IndexedDB reset button in index.html",
    file: "index.html",
    test: (content) => content.includes('src="/reset-indexeddb.js"'),
    message: " reset-indexeddb.js script is properly included in index.html"
  },
  {
    name: "Explorer Window canvas support",
    file: "src/components/windows/ExplorerWindow.jsx",
    test: (content) => content.includes("if (fileName.endsWith('.canvas'))"),
    message: " ExplorerWindow.jsx already has canvas file support"
  }
];

// Main function to check all fixes
function checkAllFixes() {
  console.log(" Checking for canvas and IndexedDB related issues...\n");
  
  let allFixed = true;
  let missingFixes = [];
  
  // Check all fixes
  for (const fix of fixes) {
    const filePath = path.join(rootDir, fix.file);
    
    try {
      const fileContent = fs.readFileSync(filePath, 'utf8');
      const isFixed = fix.test(fileContent);
      
      if (isFixed) {
        console.log(fix.message);
      } else {
        console.log(` ${fix.name} needs to be fixed`);
        allFixed = false;
        missingFixes.push(fix);
      }
    } catch (err) {
      console.log(` Error reading ${fix.file}: ${err.message}`);
      allFixed = false;
    }
  }
  
  console.log("\n");
  
  if (allFixed) {
    console.log(" All code fixes have been applied!");
    console.log("\n To fully resolve the IndexedDB issue:")
    console.log("1. Open the application in your browser");
    console.log("2. Click the red 'Reset IndexedDB' button in the bottom right");
    console.log("3. Confirm the reset when prompted");
    console.log("4. The page will reload with a fresh database schema");
  } else {
    console.log(" There are issues that need to be fixed.");
    console.log("\nPlease review the canvas-fix-guide.md file for detailed instructions on fixing these issues.");
    console.log("\nThe following files need updates:");
    
    missingFixes.forEach(fix => {
      console.log(`- ${fix.file}`);
    });
  }
}

// Add Explorer Window canvas support function
function addExplorerWindowCanvasSupport() {
  const filePath = path.join(rootDir, "src/components/windows/ExplorerWindow.jsx");
  
  try {
    let content = fs.readFileSync(filePath, 'utf8');
    
    // Add Box icon import if needed
    if (!content.includes("Box") && content.includes("lucide-react")) {
      content = content.replace(
        /{([^}]*)}/,
        "{\n  $1,\n  Box\n}"
      );
    }
    
    // Add canvas file icon detection
    if (!content.includes("if (fileName.endsWith('.canvas'))")) {
      content = content.replace(
        /const getFileIcon = \(fileName\) => {([^}]*?)return <File size={16} className="mr-2" \/>;/,
        `const getFileIcon = (fileName) => {$1if (fileName.endsWith('.canvas')) return <Box size={16} className="mr-2" />;\n    return <File size={16} className="mr-2" />;`
      );
    }
    
    // Add canvas handling in file selection
    if (!content.includes("if (file.name.endsWith('.md') || file.name.endsWith('.canvas'))") &&
        content.includes("if (file.name.endsWith('.md'))")) {
      content = content.replace(
        /if \(file\.name\.endsWith\('\.md'\)\) {/g,
        "if (file.name.endsWith('.md') || file.name.endsWith('.canvas')) {"
      );
    }
    
    // Add canvas preview in the content area
    if (!content.includes("selectedFile && selectedFile.name.endsWith('.canvas')")) {
      content = content.replace(
        /isContentLoading \? \([\s\S]*?\) : editMode && selectedFile\.name\.endsWith\('\.md'\) && isAdmin \? \(/,
        `isContentLoading ? (\n        <div className="flex-1 flex items-center justify-center">\n          <span className="text-teal-300">Loading content...</span>\n        </div>\n      ) : selectedFile && selectedFile.name.endsWith('.canvas') ? (\n        // Canvas preview mode\n        <div className="flex-1 overflow-hidden">\n          <CanvasPreview fileContent={fileContent} />\n        </div>\n      ) : editMode && selectedFile.name.endsWith('.md') && isAdmin ? (`
      );
    }
    
    fs.writeFileSync(filePath, content, 'utf8');
    console.log(" ExplorerWindow.jsx updated with canvas file support");
  } catch (err) {
    console.log(` Error updating ExplorerWindow.jsx: ${err.message}`);
  }
}

// Run the fix process
checkAllFixes();

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/agooba_favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>SLUMNET</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

================
File: indexeddb-implementation-guide.txt
================
# IndexedDB Implementation Guide for Window Manager

## Table of Contents
1. Introduction to IndexedDB
2. Why IndexedDB for Window Manager
3. Setting Up IndexedDB
4. Implementation Plan for Window Manager
5. Code Examples
6. Testing and Debugging
7. Best Practices
8. Troubleshooting

## 1. Introduction to IndexedDB

IndexedDB is a low-level API for client-side storage of significant amounts of structured data, including files/blobs. It's a NoSQL database that works with JavaScript objects and allows for high-performance searches using indexes.

Key features:
- Stores JavaScript objects (including complex nested objects)
- Transactional database operations
- Asynchronous API (doesn't block the main thread)
- Much larger storage capacity than localStorage
- Works offline
- Follows same-origin policy (data is tied to the domain)

## 2. Why IndexedDB for Window Manager

The window manager application needs to persist complex window layout structures across page refreshes. IndexedDB is ideal for this because:

1. **Complex Data Structures**: The window layout tree is a complex nested structure that IndexedDB can store natively
2. **Performance**: IndexedDB can handle larger amounts of data than localStorage without performance issues
3. **Storage Limits**: IndexedDB typically has a much higher storage limit (generally 50-100MB or more)
4. **Async Operations**: Saving window state won't block the UI thread
5. **Structured Queries**: Can efficiently query for specific workspaces or window configurations

## 3. Setting Up IndexedDB

### Basic Setup

```javascript
// db-config.js
const DB_NAME = 'WindowManagerDB';
const DB_VERSION = 1;
const STORES = {
  WORKSPACES: 'workspaces',
  WINDOW_STATES: 'windowStates'
};

export { DB_NAME, DB_VERSION, STORES };
```

### Database Initialization

```javascript
// db.js
import { DB_NAME, DB_VERSION, STORES } from './db-config';

export const initDB = () => {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);
    
    request.onerror = (event) => {
      console.error('IndexedDB error:', event.target.error);
      reject('Error opening IndexedDB');
    };
    
    request.onsuccess = (event) => {
      const db = event.target.result;
      console.log('IndexedDB opened successfully');
      resolve(db);
    };
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      
      // Create object stores
      if (!db.objectStoreNames.contains(STORES.WORKSPACES)) {
        db.createObjectStore(STORES.WORKSPACES, { keyPath: 'id' });
      }
      
      if (!db.objectStoreNames.contains(STORES.WINDOW_STATES)) {
        db.createObjectStore(STORES.WINDOW_STATES, { keyPath: 'id' });
      }
    };
  });
};
```

### Basic CRUD Operations

```javascript
// db-operations.js
import { DB_NAME, STORES } from './db-config';

// Get database connection
const getDB = () => {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME);
    request.onerror = (event) => reject(event.target.error);
    request.onsuccess = (event) => resolve(event.target.result);
  });
};

// Save data to a store
export const saveData = async (storeName, data) => {
  const db = await getDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readwrite');
    const store = transaction.objectStore(storeName);
    const request = store.put(data);
    
    request.onerror = (event) => reject(event.target.error);
    request.onsuccess = (event) => resolve(event.target.result);
    
    // Close the database when the transaction is complete
    transaction.oncomplete = () => db.close();
  });
};

// Get data from a store
export const getData = async (storeName, id) => {
  const db = await getDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readonly');
    const store = transaction.objectStore(storeName);
    const request = store.get(id);
    
    request.onerror = (event) => reject(event.target.error);
    request.onsuccess = (event) => resolve(request.result);
    
    // Close the database when the transaction is complete
    transaction.oncomplete = () => db.close();
  });
};

// Delete data from a store
export const deleteData = async (storeName, id) => {
  const db = await getDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readwrite');
    const store = transaction.objectStore(storeName);
    const request = store.delete(id);
    
    request.onerror = (event) => reject(event.target.error);
    request.onsuccess = (event) => resolve();
    
    // Close the database when the transaction is complete
    transaction.oncomplete = () => db.close();
  });
};

// Get all data from a store
export const getAllData = async (storeName) => {
  const db = await getDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readonly');
    const store = transaction.objectStore(storeName);
    const request = store.getAll();
    
    request.onerror = (event) => reject(event.target.error);
    request.onsuccess = (event) => resolve(request.result);
    
    // Close the database when the transaction is complete
    transaction.oncomplete = () => db.close();
  });
};
```

## 4. Implementation Plan for Window Manager

### Step 1: Create IndexedDB Service

Create a dedicated service for IndexedDB operations specific to the window manager:

```javascript
// services/indexedDBService.js
import { initDB } from '../db';
import { saveData, getData, getAllData, deleteData } from '../db-operations';
import { STORES } from '../db-config';

// Initialize the database when the service is first imported
let dbInitialized = false;
const ensureDBInitialized = async () => {
  if (!dbInitialized) {
    await initDB();
    dbInitialized = true;
  }
};

// Workspace operations
export const saveWorkspace = async (workspace) => {
  await ensureDBInitialized();
  return saveData(STORES.WORKSPACES, workspace);
};

export const getWorkspace = async (id) => {
  await ensureDBInitialized();
  return getData(STORES.WORKSPACES, id);
};

export const getAllWorkspaces = async () => {
  await ensureDBInitialized();
  return getAllData(STORES.WORKSPACES);
};

export const deleteWorkspace = async (id) => {
  await ensureDBInitialized();
  return deleteData(STORES.WORKSPACES, id);
};

// Window state operations
export const saveWindowState = async (windowState) => {
  await ensureDBInitialized();
  return saveData(STORES.WINDOW_STATES, windowState);
};

export const getWindowState = async (id) => {
  await ensureDBInitialized();
  return getData(STORES.WINDOW_STATES, id);
};

export const getAllWindowStates = async () => {
  await ensureDBInitialized();
  return getAllData(STORES.WINDOW_STATES);
};

export const deleteWindowState = async (id) => {
  await ensureDBInitialized();
  return deleteData(STORES.WINDOW_STATES, id);
};

// Save all workspaces at once (for bulk operations)
export const saveAllWorkspaces = async (workspaces) => {
  await ensureDBInitialized();
  const db = await getDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(STORES.WORKSPACES, 'readwrite');
    const store = transaction.objectStore(STORES.WORKSPACES);
    
    // Clear existing data
    store.clear();
    
    // Add all workspaces
    workspaces.forEach(workspace => {
      store.add(workspace);
    });
    
    transaction.onerror = (event) => reject(event.target.error);
    transaction.oncomplete = () => {
      db.close();
      resolve();
    };
  });
};
```

### Step 2: Modify WindowStateContext to Use IndexedDB

Replace localStorage with IndexedDB in the WindowStateContext:

```javascript
// context/WindowStateContext.jsx (modified)
import React, { createContext, useContext, useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { 
  saveWindowState, 
  getWindowState, 
  getAllWindowStates, 
  deleteWindowState 
} from '../services/indexedDBService';

// Create context
const WindowStateContext = createContext();

// Initial state with different content types
const initialState = {
  windowStates: {}
};

// Context provider component
export function WindowStateProvider({ children }) {
  // Use a ref to store the state to avoid re-renders
  const stateRef = useRef(initialState);
  
  // Use useState just to trigger re-renders when needed
  const [, forceUpdate] = useState({});
  
  // Add a ref to track if we should update IndexedDB
  const isInitialMount = useRef(true);
  const saveTimeoutRef = useRef(null);

  // Load initial state from IndexedDB once on mount
  useEffect(() => {
    const loadFromIndexedDB = async () => {
      try {
        const windowStates = await getAllWindowStates();
        if (windowStates && windowStates.length > 0) {
          // Convert array to object with windowId as key
          const windowStatesObj = windowStates.reduce((acc, state) => {
            acc[state.id] = {
              type: state.type,
              content: state.content
            };
            return acc;
          }, {});
          
          // Update the state ref directly
          stateRef.current = {
            ...stateRef.current,
            windowStates: windowStatesObj
          };
          
          // Force a re-render
          forceUpdate({});
        }
        // Mark initial load as complete
        isInitialMount.current = false;
      } catch (error) {
        console.error('Failed to load window states from IndexedDB:', error);
        isInitialMount.current = false;
      }
    };
    
    loadFromIndexedDB();
  }, []); // Empty dependency array means this runs once on mount

  // Save to IndexedDB with debounce
  const saveToIndexedDB = useCallback(() => {
    // Skip saving on initial load
    if (isInitialMount.current) {
      return;
    }
    
    // Clear any existing timeout
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
    }
    
    // Set a new timeout to save the state after a delay
    saveTimeoutRef.current = setTimeout(async () => {
      try {
        // Convert window states object to array of objects with id
        const windowStates = Object.entries(stateRef.current.windowStates).map(
          ([id, state]) => ({
            id,
            type: state.type,
            content: state.content
          })
        );
        
        // Save each window state individually
        for (const state of windowStates) {
          await saveWindowState(state);
        }
      } catch (error) {
        console.error('Failed to save window states to IndexedDB:', error);
      }
    }, 500); // 500ms debounce
  }, []);

  // Action creators
  const setWindowState = useCallback((windowId, windowType, content) => {
    // Update the state ref directly
    stateRef.current = {
      ...stateRef.current,
      windowStates: {
        ...stateRef.current.windowStates,
        [windowId]: {
          type: windowType,
          content
        }
      }
    };
    
    // Save to IndexedDB
    saveToIndexedDB();
    
    // Force a re-render
    forceUpdate({});
  }, [saveToIndexedDB]);

  const removeWindowState = useCallback((windowId) => {
    // Create a new state object
    const newState = {
      ...stateRef.current,
      windowStates: { ...stateRef.current.windowStates }
    };
    
    // Delete the window state
    delete newState.windowStates[windowId];
    
    // Update the state ref
    stateRef.current = newState;
    
    // Delete from IndexedDB
    deleteWindowState(windowId).catch(error => {
      console.error('Failed to delete window state from IndexedDB:', error);
    });
    
    // Force a re-render
    forceUpdate({});
  }, []);

  const getWindowStateFromRef = useCallback((windowId) => {
    return stateRef.current.windowStates[windowId] || null;
  }, []);

  // Create a stable context value
  const contextValue = useMemo(() => ({
    windowStates: stateRef.current.windowStates,
    setWindowState,
    removeWindowState,
    getWindowState: getWindowStateFromRef
  }), [setWindowState, removeWindowState, getWindowStateFromRef]);

  return (
    <WindowStateContext.Provider value={contextValue}>
      {children}
    </WindowStateContext.Provider>
  );
}

// Custom hook to use the window state context
export function useWindowState() {
  const context = useContext(WindowStateContext);
  if (!context) {
    throw new Error('useWindowState must be used within a WindowStateProvider');
  }
  return context;
}
```

### Step 3: Create a WorkspaceContext to Persist Window Layout

Create a new context to manage workspace persistence:

```javascript
// context/WorkspaceContext.jsx
import React, { createContext, useContext, useState, useEffect, useCallback, useMemo } from 'react';
import { 
  saveWorkspace, 
  getWorkspace, 
  getAllWorkspaces, 
  saveAllWorkspaces 
} from '../services/indexedDBService';

// Create context
const WorkspaceContext = createContext();

// Initial workspaces
const initialWorkspaces = [
  { id: 1, name: 'Main', root: null, activeNodeId: null, terminalStates: {} },
  { id: 2, name: 'Code', root: null, activeNodeId: null, terminalStates: {} },
  { id: 3, name: 'Terminal', root: null, activeNodeId: null, terminalStates: {} },
  { id: 4, name: 'Preview', root: null, activeNodeId: null, terminalStates: {} }
];

export function WorkspaceProvider({ children }) {
  const [workspaces, setWorkspaces] = useState(initialWorkspaces);
  const [currentWorkspaceIndex, setCurrentWorkspaceIndex] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  
  // Load workspaces from IndexedDB on mount
  useEffect(() => {
    const loadWorkspaces = async () => {
      try {
        setIsLoading(true);
        const savedWorkspaces = await getAllWorkspaces();
        
        if (savedWorkspaces && savedWorkspaces.length > 0) {
          setWorkspaces(savedWorkspaces);
        }
      } catch (error) {
        console.error('Failed to load workspaces from IndexedDB:', error);
      } finally {
        setIsLoading(false);
      }
    };
    
    loadWorkspaces();
  }, []);
  
  // Save workspaces to IndexedDB whenever they change
  useEffect(() => {
    if (isLoading) return; // Skip saving during initial load
    
    const saveWorkspaces = async () => {
      try {
        await saveAllWorkspaces(workspaces);
      } catch (error) {
        console.error('Failed to save workspaces to IndexedDB:', error);
      }
    };
    
    const timeoutId = setTimeout(saveWorkspaces, 500); // Debounce
    return () => clearTimeout(timeoutId);
  }, [workspaces, isLoading]);
  
  // Update a specific workspace
  const updateWorkspace = useCallback((index, updater) => {
    setWorkspaces(prev => {
      const updated = [...prev];
      if (typeof updater === 'function') {
        updated[index] = {
          ...updated[index],
          ...updater(updated[index])
        };
      } else {
        updated[index] = {
          ...updated[index],
          ...updater
        };
      }
      return updated;
    });
  }, []);
  
  // Switch to a different workspace
  const switchWorkspace = useCallback((target) => {
    if (typeof target === 'number' && target >= 0 && target < workspaces.length) {
      setCurrentWorkspaceIndex(target);
    } else if (target === 'right' || target === 'left') {
      setCurrentWorkspaceIndex(prev => {
        const newIndex = target === 'right' 
          ? (prev + 1) % workspaces.length 
          : prev - 1 < 0 ? workspaces.length - 1 : prev - 1;
        return newIndex;
      });
    }
  }, [workspaces.length]);
  
  // Context value
  const value = useMemo(() => ({
    workspaces,
    currentWorkspaceIndex,
    currentWorkspace: workspaces[currentWorkspaceIndex],
    updateWorkspace,
    switchWorkspace,
    isLoading
  }), [workspaces, currentWorkspaceIndex, updateWorkspace, switchWorkspace, isLoading]);
  
  return (
    <WorkspaceContext.Provider value={value}>
      {children}
    </WorkspaceContext.Provider>
  );
}

// Custom hook to use the workspace context
export function useWorkspace() {
  const context = useContext(WorkspaceContext);
  if (!context) {
    throw new Error('useWorkspace must be used within a WorkspaceProvider');
  }
  return context;
}
```

### Step 4: Modify useWindowManager to Use WorkspaceContext

Update the useWindowManager hook to use the WorkspaceContext:

```javascript
// hooks/useWindowManager.js (modified)
import { useCallback, useState, useEffect, useRef } from 'react';
import { Node } from '../models/Node';
import { WINDOW_TYPES } from '../utils/windowTypes';
import { 
  splitNodeById, 
  removeNodeById, 
  findNodeById, 
  findAllWindowIds,
  updateSplitRatio,
} from '../utils/treeUtils';
import { getWindowBounds } from '../utils/windowUtils';
import { useWindowState } from '../context/WindowStateContext';
import { useWorkspace } from '../context/WorkspaceContext';
import { 
  MIN_WINDOW_WIDTH_PX, 
  MIN_WINDOW_HEIGHT_PX 
} from '../utils/windowSizeConstants';

export const useWindowManager = ({ defaultLayout = null, onFlashBorder = null } = {}) => {
  // Get workspace state from context
  const { 
    currentWorkspace, 
    currentWorkspaceIndex, 
    updateWorkspace, 
    switchWorkspace 
  } = useWorkspace();
  
  // Extract current workspace data
  const rootNode = currentWorkspace.root;
  const activeNodeId = currentWorkspace.activeNodeId;
  const terminalStates = currentWorkspace.terminalStates;
  
  // Local state for resize and move modes
  const [isResizeMode, setIsResizeMode] = useState(false);
  const [isMoveMode, setIsMoveMode] = useState(false);
  const [moveSourceWindowId, setMoveSourceWindowId] = useState(null);

  // Create setActiveNodeId function that updates the workspace
  const setActiveNodeId = useCallback((nodeId) => {
    updateWorkspace(currentWorkspaceIndex, {
      activeNodeId: nodeId
    });
  }, [currentWorkspaceIndex, updateWorkspace]);

  // Get window state management functions
  const { getWindowState, setWindowState, removeWindowState } = useWindowState();

  // Rest of the hook implementation remains largely the same,
  // but replace all instances of setWorkspaces with updateWorkspace
  // and use currentWorkspace instead of workspaces[currentWorkspaceIndex]
  
  // For example, the createNewWindow function would be updated like this:
  const createNewWindow = useCallback((windowType) => {
    const newNode = Node.createWindow(Date.now(), windowType || WINDOW_TYPES.TERMINAL);
    
    // Initialize window state based on window type
    const initialContent = {};
    
    if (windowType === WINDOW_TYPES.TERMINAL) {
      // Initialize terminal state
      initialContent.history = ['Welcome to the Terminal! Type "help" for available commands.'];
      initialContent.commandHistory = [];
      
      updateWorkspace(currentWorkspaceIndex, workspace => ({
        ...workspace,
        terminalStates: {
          ...workspace.terminalStates,
          [newNode.id]: {
            history: initialContent.history,
            commandHistory: initialContent.commandHistory
          }
        }
      }));
    } else if (windowType === WINDOW_TYPES.EDITOR) {
      // Initialize editor state with default content
      initialContent.text = `function hello() {\n  console.log("Hello, World!");\n}\n\n// Call the function\nhello();`;
    } else if (windowType === WINDOW_TYPES.EXPLORER) {
      // Initialize explorer state
      initialContent.currentPath = '/';
      initialContent.selectedItem = null;
    }
    
    // Set the initial window state
    setWindowState(newNode.id, newNode.windowType, initialContent);
    
    if (!rootNode) {
      // First window, always allowed
      updateWorkspace(currentWorkspaceIndex, {
        root: newNode,
        activeNodeId: newNode.id
      });
      return;
    }
    
    // Rest of the function remains the same...
  }, [rootNode, activeNodeId, currentWorkspaceIndex, updateWorkspace, setActiveNodeId, setWindowState]);

  // Similarly update other functions that modify workspace state...

  return {
    rootNode,
    activeNodeId,
    setActiveNodeId,
    terminalStates,
    updateTerminalState,
    createNewWindow,
    splitWindow,
    closeWindow,
    transformWindow,
    handleCommand,
    navigateToWindow,
    hasActiveWindow: Boolean(activeNodeId),
    hasRootNode: Boolean(rootNode),
    currentWorkspaceIndex,
    workspaceCount: 4,
    switchWorkspace,
    isResizeMode,
    setIsResizeMode,
    resizeActiveWindow,
    isMoveMode,
    setIsMoveMode,
    moveSourceWindowId,
    setMoveSourceWindowId,
    swapWindows
  };
};
```

### Step 5: Update App.jsx to Include WorkspaceProvider

```javascript
// main.jsx (modified)
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './styles.css'
import './App.css'
import { WindowStateProvider } from './context/WindowStateContext'
import { AuthProvider } from './context/AuthContext'
import { WorkspaceProvider } from './context/WorkspaceContext'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <AuthProvider>
      <WindowStateProvider>
        <WorkspaceProvider>
          <App />
        </WorkspaceProvider>
      </WindowStateProvider>
    </AuthProvider>
  </React.StrictMode>,
)
```

## 5. Code Examples

### Example: Handling Large Objects

When dealing with large objects, consider serializing/deserializing them:

```javascript
// Serialize before saving
const serializedData = JSON.stringify(complexObject);
await saveData(STORES.WORKSPACES, { id: 'workspace1', data: serializedData });

// Deserialize after loading
const result = await getData(STORES.WORKSPACES, 'workspace1');
const complexObject = JSON.parse(result.data);
```

### Example: Using Transactions for Multiple Operations

```javascript
const performBatchOperations = async () => {
  const db = await getDB();
  const transaction = db.transaction([STORES.WORKSPACES, STORES.WINDOW_STATES], 'readwrite');
  
  // Get object stores
  const workspaceStore = transaction.objectStore(STORES.WORKSPACES);
  const windowStateStore = transaction.objectStore(STORES.WINDOW_STATES);
  
  // Perform operations
  workspaceStore.put({ id: 'workspace1', name: 'Main Workspace' });
  windowStateStore.put({ id: 'window1', type: 'terminal', content: { history: [] } });
  
  // Return a promise that resolves when the transaction completes
  return new Promise((resolve, reject) => {
    transaction.oncomplete = () => {
      db.close();
      resolve();
    };
    transaction.onerror = (event) => {
      db.close();
      reject(event.target.error);
    };
  });
};
```

### Example: Using Indexes for Efficient Queries

```javascript
// During database initialization
request.onupgradeneeded = (event) => {
  const db = event.target.result;
  
  // Create object store with indexes
  const windowStore = db.createObjectStore(STORES.WINDOW_STATES, { keyPath: 'id' });
  windowStore.createIndex('byType', 'type', { unique: false });
};

// Query using an index
const getWindowsByType = async (type) => {
  const db = await getDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(STORES.WINDOW_STATES, 'readonly');
    const store = transaction.objectStore(STORES.WINDOW_STATES);
    const index = store.index('byType');
    const request = index.getAll(type);
    
    request.onerror = (event) => reject(event.target.error);
    request.onsuccess = (event) => resolve(request.result);
    
    transaction.oncomplete = () => db.close();
  });
};
```

## 6. Testing and Debugging

### Testing IndexedDB Implementation

1. **Browser DevTools**: Use the Application tab to inspect IndexedDB databases
2. **Console Logging**: Add strategic console logs for debugging
3. **Manual Testing**: Test page refreshes, logging in/out, and browser restarts

### Debugging Common Issues

1. **Version Mismatch**: If schema changes, increment DB_VERSION
2. **Transaction Timing**: Ensure transactions complete before closing the database
3. **Error Handling**: Always include error handlers for IndexedDB operations

## 7. Best Practices

1. **Use Promises**: Wrap IndexedDB's callback-based API in Promises for cleaner code
2. **Implement Versioning**: Use the version parameter to handle database schema upgrades
3. **Debounce Saves**: Avoid excessive writes by debouncing save operations
4. **Close Connections**: Always close database connections after transactions complete
5. **Handle Errors**: Implement robust error handling for all IndexedDB operations
6. **Consider Data Size**: Be mindful of the amount of data stored, especially for complex window layouts
7. **Implement Migrations**: Plan for data migrations when changing database schema

## 8. Troubleshooting

### Common Errors and Solutions

1. **"QuotaExceededError"**
   - Solution: Reduce the amount of data stored or request more storage using the Storage API

2. **"VersionError"**
   - Solution: Close all other tabs using the database before upgrading

3. **"InvalidStateError"**
   - Solution: Ensure you're not trying to use a closed database connection

4. **"TransactionInactiveError"**
   - Solution: Complete all operations before the transaction completes

5. **"DataCloneError"**
   - Solution: Ensure all objects being stored are cloneable (no functions, DOM nodes, etc.)

### Recovery Strategies

1. **Implement a fallback to localStorage** for critical data
2. **Add a "Reset Database" feature** for users to clear corrupted data
3. **Implement data validation** before saving to prevent corrupted states
4. **Create periodic backups** of important window layouts

## Implementation Checklist

1. [ ] Set up basic IndexedDB configuration
2. [ ] Create database initialization code
3. [ ] Implement CRUD operations for workspaces and window states
4. [ ] Create WorkspaceContext for managing workspace persistence
5. [ ] Modify WindowStateContext to use IndexedDB instead of localStorage
6. [ ] Update useWindowManager to use the new context
7. [ ] Update App.jsx to include the WorkspaceProvider
8. [ ] Test persistence across page refreshes
9. [ ] Test persistence across logout/login
10. [ ] Implement error handling and recovery strategies

================
File: jsoncanvas-main/_config.yml
================
name:                'JSON Canvas'
title:               'JSON Canvas'
url:                 'https://jsoncanvas.org'
description:         'An open file format for infinite canvas data.'
exclude:             ['.obsidian']

github:              [metadata]

baseurl:             ''

layouts_dir:         .layouts
includes_dir:        .layouts

use_html_extension:  false

permalink:           pretty
relative_permalinks: false

defaults:
  - scope:
      path: "**/*"
    values:
      layout: "canvas"
  - scope:
      path: "spec/**/*.md"
    values:
      layout: "docs"
  - scope:
      path: "docs/**/*.md"
    values:
      layout: "docs"

================
File: jsoncanvas-main/.gitignore
================
_site
.sass-cache
.jekyll-cache
.jekyll-metadata
.obsidian
vendor
.DS_Store

================
File: jsoncanvas-main/.layouts/404.html
================
<!DOCTYPE html>
<html lang="en">
{% include head.html %}
  <body id="home" style="--scale: 1; --pan-x: 0px; --pan-y: 0px;">

  <div id="container">

    <div id="canvas-container">

      <svg id="canvas-edges">
        <defs>
          <marker id="arrowhead" markerWidth="10" markerHeight="8" 
          refX="5" refY="4" orient="auto">
            <polygon points="0 0, 10 4, 0 8"/>
          </marker>
        </defs>
        <g id="edge-paths">
        </g>
      </svg>

      <div id="canvas-nodes">
        <node id="logo" class="node node-file" data-node-type="file" data-node-file="logo.svg" style="left: 36px; top: 48px;">
            <div class="node-name">logo.svg</div>
            <img width="160" height="60" src="/logo.svg" alt="JSON Feed" />
        </node>

        <node id="readme" class="node node-link" data-node-type="file" data-node-file="readme.md" style="left: 36px; top: 240px;">
          <div class="node-name">404</div>
          {{ content }}
        </node>

        <node id="nav" class="node node-text" data-node-type="text" style="left: 336px; top: 36px;">
          <div class="node-name"></div>
          <div class="node-text-content">
            <p>Learn more:</p>
            <ul>
              <li><a href="/docs/apps">Apps</a></li>
              <li><a href="/spec/1.0">Spec</a></li>
              <li><a href="https://github.com/obsidianmd/jsoncanvas">GitHub</a></li>
            </ul>
          </div>
        </node>
      </div>

      <div id="output" class="theme-dark hidden">
        <div class="code-header">
          <span class="language">JSON&nbsp;Canvas</span>
          <span class="close-output"></span>
        </div>
        <div id="output-code">
          <pre><code class="language-json" id="positionsOutput"></code></pre>
        </div>
         <div class="code-footer">
          <button class="button-copy">Copy code</button>
          <button class="button-download">Download file</button>
        </div>
      </div>

      <div id="controls">
        <div id="zoom-controls">
          <button id="toggle-output">Toggle output</button>
          <button id="zoom-out">Zoom out</button>
          <button id="zoom-in">Zoom in</button>
          <button id="zoom-reset">Reset</button>
        </div>
      </div>
    </div>

  </div>

  <script>
    let edges = [
      {
        id: "edge-logo-nav",
        fromNode: "logo",
        fromSide: "right",
        fromEnd: "none",
        toNode: "nav",
        toSide: "left",
        toEnd: "arrow",
      },
    ];
  </script>

  <script src="/assets/canvas.js"></script>
  <script src="/assets/prism.js"></script>
  </body>
</html>

================
File: jsoncanvas-main/.layouts/canvas.html
================
<!DOCTYPE html>
<html lang="en">
{% include head.html %}
  <body id="home" style="--scale: 1; --pan-x: 0px; --pan-y: 0px;">

  <div id="container">

    <div id="canvas-container">

      <svg id="canvas-edges">
        <defs>
          <marker id="arrowhead" markerWidth="10" markerHeight="8" 
          refX="5" refY="4" orient="auto">
            <polygon points="0 0, 10 4, 0 8"/>
          </marker>
        </defs>
        <g id="edge-paths">
        </g>
      </svg>

      <div id="canvas-nodes">
        <node id="spec" class="node node-link" data-node-type="file" data-node-file="spec/1.0.md" style="left: 600px; top: 140px;">
          <div class="node-name">spec/1.0</div>
          <iframe
            width="100%"
            height="100%"
            src="/spec/1.0?hidenav=true">
          </iframe>
        </node>

        <node id="readme" class="node node-link" data-node-type="file" data-node-file="readme.md" style="left: 36px; top: 240px;">
          <div class="node-name">readme</div>
          {{ content }}
        </node>

        <node id="nav" class="node node-text" data-node-type="text" style="left: 336px; top: 36px;">
          <div class="node-name"></div>
          <div class="node-text-content">
            <p>Learn more:</p>
            <ul>
              <li><a href="/docs/apps">Apps</a></li>
              <li><a href="/spec/1.0">Spec</a></li>
              <li><a href="https://github.com/obsidianmd/jsoncanvas">GitHub</a></li>
            </ul>
          </div>
        </node>
        
        <node id="logo" class="node node-file" data-node-type="file" data-node-file="logo.svg" style="left: 36px; top: 48px;">
            <div class="node-name">logo.svg</div>
            <img width="160" height="60" src="/logo.svg" alt="JSON Feed" />
        </node>
      </div>

      <div id="output" class="theme-dark hidden">
        <div class="code-header">
          <span class="language">JSON&nbsp;Canvas</span>
          <span class="close-output"></span>
        </div>
        <div id="output-code">
          <pre><code class="language-json" id="positionsOutput"></code></pre>
        </div>
         <div class="code-footer">
          <button class="button-copy">Copy code</button>
          <button class="button-download">Download file</button>
        </div>
      </div>

      <div id="controls">
        <div id="zoom-controls">
          <button id="toggle-output">Toggle output</button>
          <button id="zoom-out">Zoom out</button>
          <button id="zoom-in">Zoom in</button>
          <button id="zoom-reset">Reset</button>
        </div>
      </div>
    </div>

  </div>

  <script>
    let edges = [
      {
        id: "edge-readme-spec",
        fromNode: "readme",
        fromSide: "right",
        fromEnd: "none",
        toNode: "spec",
        toSide: "left",
        toEnd: "arrow",
      },
      {
        id: "edge-logo-nav",
        fromNode: "logo",
        fromSide: "right",
        fromEnd: "none",
        toNode: "nav",
        toSide: "left",
        toEnd: "arrow",
      },
    ];
  </script>

  <script src="/assets/canvas.js"></script>
  <script src="/assets/prism.js"></script>
  </body>
</html>

================
File: jsoncanvas-main/.layouts/docs.html
================
<!DOCTYPE html>
<html lang="en">
{% include head.html %}
  <body>

    {% include nav.html %}

    <div class="page">
        {{ content }}
    </div>

    <script>
      document.addEventListener("DOMContentLoaded", function() {
          const urlParams = new URLSearchParams(window.location.search);
          const hideNav = urlParams.get('hidenav');
          if(hideNav === 'true') {
              document.body.classList.add('hidenav');
          }
      });
      document.addEventListener('DOMContentLoaded', function() {
        const links = document.querySelectorAll('a');
        links.forEach(link => {
          const url = new URL(link.href);
          if (url.hostname !== window.location.hostname) {
            link.target = '_blank';
            link.rel = 'noopener noreferrer';
          }
        });
      });
    </script>
  </body>
</html>

================
File: jsoncanvas-main/.layouts/head.html
================
<head>
    <meta charset="UTF-8">
    <title>{{ site.title }}  {{ page.title }}</title>

    <meta name="viewport"            content="width=device-width, initial-scale=1.0">
    <meta name="description"         content="{% if page.content -%}{{ page.content | markdownify | strip_html | strip_newlines | truncate: 160 }}{% else -%}{{ site.description }}{% endif -%}">
    <meta name="author"              content="{{ site.name }}">

    <link rel="canonical"            href="{{ site.url }}{{ page.url }}">
    <link rel="icon"                 href="{{ site.url }}/favicon.ico" sizes="32x32">
    <link rel="icon"                 href="{{ site.url }}/assets/icon.svg"    type="image/svg+xml">
    <link rel="apple-touch-icon"     href="{{ site.url }}/assets/apple-touch-icon.png">
    <link rel="stylesheet"           href="{{ site.url }}/assets/style.css"  type="text/css">

    <meta property="og:site_name"    content="{{ site.title }}">
    <meta property="og:url"          content="{{ site.url }}{{ page.url }}">
    <meta property="og:title"        content="{{ site.title }}">
    <meta property="og:description"  content="{% if page.content -%}{{ page.content | markdownify | strip_html | strip_newlines | truncate: 160 }}{% else -%}{{ site.description }}{% endif -%}">
    <meta property="og:type"         content="{% if page.title -%}article{% else -%}website{% endif -%}">
    <meta property="og:image"        content="{{ site.url }}/assets/card.png">

    <meta name="twitter:card"        content="summary_large_image">
    <meta name="twitter:image"       content="{{ site.url }}/assets/card.png">
    <meta name="twitter:title"       content="{{ site.title }}">
    <meta name="twitter:description" content="{% if page.content -%}{{ page.content | markdownify | strip_html | strip_newlines | truncate: 160 }}{% else -%}{{ site.description }}{% endif -%}">
  </head>

================
File: jsoncanvas-main/.layouts/nav.html
================
<div id="navbar">
      <nav>
        <a href="/" id="logo"><img width="120" height="44" src="/logo.svg" alt="JSON Feed" /></a>
        <a href="/docs/apps" class="link">Apps</a>
        <a href="/spec/1.0" class="link">Spec</a>
        <a href="https://github.com/obsidianmd/jsoncanvas" class="link">GitHub</a>
      </nav>

      <hr>
    </div>

================
File: jsoncanvas-main/404.md
================
---
title: Not found
permalink: /404.html
layout: 404
---

<div class="container">
  <svg width="96" height="96" viewBox="0 0 128 128" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M-4.36441e-06 102.115C-1.95401e-06 88.3294 11.1757 77.1537 24.9615 77.1538V77.1538C38.7474 77.1538 49.9231 88.3294 49.9231 102.115V102.115C49.9231 115.901 38.7474 127.077 24.9615 127.077V127.077C11.1757 127.077 -6.77481e-06 115.901 -4.36441e-06 102.115V102.115Z" fill="var(--color-ax-1)"/>
  <path d="M77.1538 24.9615C77.1538 11.1757 88.3295 1.95401e-06 102.115 4.36441e-06V4.36441e-06C115.901 6.77481e-06 127.077 11.1757 127.077 24.9615V24.9615C127.077 38.7474 115.901 49.9231 102.115 49.9231V49.9231C88.3295 49.9231 77.1538 38.7474 77.1538 24.9615V24.9615Z" fill="var(--color-ax-1)"/>
  <path fill-rule="evenodd" clip-rule="evenodd" d="M63.5386 104.102C63.5385 81.6995 81.699 63.539 104.101 63.539H113.462V82.2601H104.101C92.0384 82.2601 82.2597 92.0389 82.2597 104.102L82.2598 113.462L63.5386 113.462L63.5386 104.102Z" fill="var(--color-ax-1)"/>
  </svg>

  <h1>404</h1>

  <p>Whoops. You've found an unknown part of this infinite canvas. <a href="/">Head back home</a>.</p>
</div>

================
File: jsoncanvas-main/assets/canvas.js
================
// Initial state of the canvas
let scale, panOffsetX, panOffsetY;

const ZOOM_SPEED = 0.1;
const minScale = 0.35;
const maxScale = 1.25;
const container = document.getElementById('canvas-nodes');

let isDragging = false;
let isSpacePressed = false;
let isPanning = false;

let startX = 0;
let startY = 0;
let lastTouchX = 0;
let lastTouchY = 0;
let touchStartPanX = 0;
let touchStartPanY = 0;

function adjustCanvasToViewport() {
  const nodes = document.querySelectorAll('.node');
  let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

  nodes.forEach(node => {
    const x = parseInt(node.style.left, 10);
    const y = parseInt(node.style.top, 10);
    const width = node.offsetWidth;
    const height = node.offsetHeight;

    minX = Math.min(minX, x);
    maxX = Math.max(maxX, x + width);
    minY = Math.min(minY, y);
    maxY = Math.max(maxY, y + height);
  });

  const boundingBoxWidth = maxX - minX;
  const boundingBoxHeight = maxY - minY;
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;

  const scaleX = viewportWidth / (boundingBoxWidth + 80);
  const scaleY = viewportHeight / (boundingBoxHeight + 80);
  scale = Math.min(scaleX, scaleY, 1); // Ensure the scale is not more than 1

  panOffsetX = (viewportWidth - boundingBoxWidth * scale) / 2 - minX * scale;
  panOffsetY = (viewportHeight - boundingBoxHeight * scale) / 2 - minY * scale;

  // Apply the calculated scale and pan offsets
  applyPanAndZoom();

  document.getElementById('canvas-nodes').style.opacity = 1;
  document.getElementById('canvas-edges').style.opacity = 1;
}

document.addEventListener('DOMContentLoaded', adjustCanvasToViewport);

// Zoom
window.addEventListener('wheel', (e) => {
    if (e.ctrlKey || e.metaKey) {
        if (e.deltaY > 0) {
            scale = Math.max(scale - ZOOM_SPEED, minScale);
        } else {
            scale = Math.min(scale + ZOOM_SPEED, maxScale);
        }

        document.body.style.setProperty('--scale', scale);
        e.preventDefault();
    }
}, {passive: false});

// Buttons
document.getElementById('zoom-in').addEventListener('click', function() {
    scale = Math.min(scale + ZOOM_SPEED, maxScale);
    document.body.style.setProperty('--scale', scale);
});

document.getElementById('zoom-out').addEventListener('click', function() {
    scale = Math.max(scale - ZOOM_SPEED, minScale);
    document.body.style.setProperty('--scale', scale);
});

document.getElementById('zoom-reset').addEventListener('click', function() {
  adjustCanvasToViewport();
});

document.getElementById('toggle-output').addEventListener('click', function() {
  const output = document.getElementById('output');
  output.classList.toggle('hidden');
});

document.querySelector('.close-output').addEventListener('click', function() {
  const output = document.getElementById('output');
  output.classList.toggle('hidden');
});

document.querySelector('.button-copy').addEventListener('click', function() {
  const positionsOutput = document.getElementById('positionsOutput').textContent;
  navigator.clipboard.writeText(positionsOutput).catch(err => {
    console.error('Error copying canvas data: ', err);
  });
});

document.querySelector('.button-download').addEventListener('click', function() {
  const positionsOutput = document.getElementById('positionsOutput').textContent;
  const blob = new Blob([positionsOutput], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'sample.canvas';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
});

// Very simplified Markdown conversion
function htmlToMarkdown(html) {
  let markdown = html.replace(/<br\s*[\/]?>/gi, "\n");
  markdown = markdown.replace(/<a href="([^"]+)">([^<]+)<\/a>/gi, "[$2]($1)");
  markdown = markdown.replace(/<ul>/gi, "\n\n").replace(/<\/ul>/gi, "\n\n").replace(/<li>/gi, "- ").replace(/<\/li>/gi, "\n");
  markdown = markdown.replace(/<[^>]+>/g, '');
  markdown = markdown.replace(/\n\s*-\s+/g, "\n- ");
  markdown = markdown.trim().replace(/\n{3,}/g, "\n\n");
  return markdown;
}

document.addEventListener('DOMContentLoaded', function() {
  const links = document.querySelectorAll('a');
  links.forEach(link => {
    const url = new URL(link.href);
    if (url.hostname !== window.location.hostname) {
      link.target = '_blank';
      link.rel = 'noopener noreferrer';
    }
  });
});

function prepareForSerialization() {
  document.querySelectorAll('a').forEach(link => {
      if (link.hasAttribute('target') && link.target === '_blank') {
          link.removeAttribute('target');
          link.removeAttribute('rel');
      }
  });
}

// Serialize canvas data
function updateCanvasData() {
  prepareForSerialization();
  const nodes = Array.from(document.querySelectorAll('.node')).map(node => {
      const nodeObject = {
          id: node.id,
          type: node.getAttribute('data-node-type'),
          x: parseInt(node.style.left, 10),
          y: parseInt(node.style.top, 10),
          width: node.offsetWidth,
          height: node.offsetHeight,
      };

      const fileAttribute = node.getAttribute('data-node-file');
      if (fileAttribute) {
          nodeObject.file = fileAttribute;
      }

      if (nodeObject.type === 'text') {
          const textContent = node.querySelector('.node-text-content').innerHTML;
          nodeObject.text = htmlToMarkdown(textContent);
      }


      return nodeObject;
  });

  const canvasData = {
    nodes: nodes,
    edges: edges,
  };

  const positionsOutput = document.getElementById('positionsOutput');
  positionsOutput.textContent = JSON.stringify(canvasData, null, 2);

  Prism.highlightElement(positionsOutput);
}

function getAnchorPoint(node, side) {
  const x = parseInt(node.style.left, 10);
  const y = parseInt(node.style.top, 10);
  const width = node.offsetWidth;
  const height = node.offsetHeight;

  switch (side) {
    case 'top':
      return { x: x + width / 2, y: y };
    case 'right':
      return { x: x + width, y: y + height / 2 };
    case 'bottom':
      return { x: x + width / 2, y: y + height };
    case 'left':
      return { x: x, y: y + height / 2 };
    default: // center or unspecified case
      return { x: x + width / 2, y: y + height / 2 };
  }
}

function drawEdges() {
  const svgContainer = document.getElementById('edge-paths');
  svgContainer.innerHTML = ''; // Clear existing edges for redraw

  edges.forEach(edge => {
    const fromNode = document.getElementById(edge.fromNode);
    const toNode = document.getElementById(edge.toNode);

    if (fromNode && toNode) {
      const fromPoint = getAnchorPoint(fromNode, edge.fromSide);
      const toPoint = getAnchorPoint(toNode, edge.toSide);

      const curveTightness = 0.75;
      const controlPointX1 = fromPoint.x + (toPoint.x - fromPoint.x) * curveTightness;
      const controlPointX2 = fromPoint.x + (toPoint.x - fromPoint.x) * (1 - curveTightness);
      const controlPointY1 = fromPoint.y;
      const controlPointY2 = toPoint.y;

      const d = `M ${fromPoint.x} ${fromPoint.y} C ${controlPointX1} ${controlPointY1}, ${controlPointX2} ${controlPointY2}, ${toPoint.x} ${toPoint.y}`;

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('d', d);
      path.setAttribute('stroke', 'black');
      path.setAttribute('fill', 'none');
      if (edge.toEnd === 'arrow') {
        path.setAttribute('marker-end', 'url(#arrowhead)');
      }

      svgContainer.appendChild(path);
    }
  });
}

// Drag nodes
document.querySelectorAll('.node .node-name').forEach(nodeName => {
  nodeName.addEventListener('mousedown', function(e) {
    if (isSpacePressed) return;
    
    isDragging = true;
    startX = e.clientX;
    startY = e.clientY;
    selectedElement = this.parentElement;
    selectedElement.classList.add('is-dragging');
  });
});

window.addEventListener('mousemove', function(e) {
  if (!isDragging || !selectedElement) return;
  
  const dx = (e.clientX - startX) / scale;
  const dy = (e.clientY - startY) / scale;

  selectedElement.style.left = `${parseInt(selectedElement.style.left, 10) + dx}px`;
  selectedElement.style.top = `${parseInt(selectedElement.style.top, 10) + dy}px`;

  startX = e.clientX;
  startY = e.clientY;

  drawEdges();
});

window.addEventListener('mouseup', function() {
  if (isDragging && selectedElement) {
    selectedElement.classList.remove('is-dragging');
    isDragging = false;
    selectedElement = null;
    updateCanvasData();
    drawEdges();
  }
});

// Panning
window.addEventListener('keydown', function(e) {
  if (e.code === 'Space') {
    e.preventDefault();
    isSpacePressed = true;
    document.body.classList.add('will-pan');
  }
});

window.addEventListener('keyup', function(e) {
  if (e.code === 'Space') {
    isSpacePressed = false;
    document.body.classList.remove('will-pan');
  }
});

window.addEventListener('mousedown', function(e) {
  if (isSpacePressed && !isDragging) {
    isPanning = true;
    document.body.style.cursor = 'grabbing';
    panStartX = e.clientX - panOffsetX;
    panStartY = e.clientY - panOffsetY;
  }
});

window.addEventListener('mousemove', function(e) {
  if (isPanning) {
    panOffsetX = e.clientX - panStartX;
    panOffsetY = e.clientY - panStartY;

    document.body.style.setProperty('--pan-x', `${panOffsetX}px`);
    document.body.style.setProperty('--pan-y', `${panOffsetY}px`);
  }
});

window.addEventListener('mouseup', function() {
  if (isPanning) {
    isPanning = false;
    document.body.style.cursor = '';
  }
});

// Touch-based devices 
let initialDistance = null;

document.addEventListener('gesturestart', function(e){ e.preventDefault(); });

document.getElementById('canvas-container').addEventListener('touchstart', function(e) {
  if (e.touches.length === 1) { // Single touch for panning
    isPanning = true;
    const touch = e.touches[0];
    touchStartPanX = touch.pageX - panOffsetX;
    touchStartPanY = touch.pageY - panOffsetY;
    lastTouchX = touch.pageX;
    lastTouchY = touch.pageY;
  } else if (e.touches.length === 2) { // Two-finger touch for zooming
    e.preventDefault(); // Prevent page zoom
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    initialDistance = Math.sqrt((touch2.pageX - touch1.pageX) ** 2 + (touch2.pageY - touch1.pageY) ** 2);
  }
}, { passive: false });

// Touch move for panning and zooming
document.getElementById('canvas-container').addEventListener('touchmove', function(e) {
  if (e.touches.length === 1 && isPanning) {
    const touch = e.touches[0];
    const dx = touch.pageX - lastTouchX;
    const dy = touch.pageY - lastTouchY;
    panOffsetX += dx;
    panOffsetY += dy;
    lastTouchX = touch.pageX;
    lastTouchY = touch.pageY;
    applyPanAndZoom();
    drawEdges();
  } else if (e.touches.length === 2) { // Adjust for zooming
    e.preventDefault();
    const touch1 = e.touches[0];
    const touch2 = e.touches[1];
    const distance = Math.sqrt((touch2.pageX - touch1.pageX) ** 2 + (touch2.pageY - touch1.pageY) ** 2);
    const scaleChange = distance / initialDistance;
    scale = Math.min(Math.max(minScale, scale * scaleChange), maxScale); // Apply and limit scale
    document.body.style.setProperty('--scale', scale);
    initialDistance = distance;
    applyPanAndZoom();
  }
}, { passive: false });

document.getElementById('canvas-container').addEventListener('touchend', function(e) {
  if (isPanning) {
    isPanning = false;
  }
  if (e.touches.length < 2) {
    initialDistance = null; // Reset zoom tracking on lifting one finger
  }
});

// Activate node on touch
document.querySelectorAll('.node .node-name').forEach(nodeName => {
  nodeName.addEventListener('touchstart', function(e) {
    // Prevent activating multiple nodes simultaneously
    deactivateAllNodes();
    const node = this.parentElement;
    node.classList.add('is-active');
    // Prepare for potential drag
    isDragging = false;
    const touch = e.touches[0];
    startX = touch.pageX;
    startY = touch.pageY;
    selectedElement = node;
    e.stopPropagation();
  }, {passive: true});
});

// Deactivate nodes when tapping outside
document.addEventListener('touchstart', function(e) {
  if (!e.target.closest('.node')) {
    deactivateAllNodes();
  }
});

function deactivateAllNodes() {
  document.querySelectorAll('.node').forEach(node => {
    node.classList.remove('is-active');
  });
}

// Handling dragging for an activated node
document.addEventListener('touchmove', function(e) {
  if (isDragging && selectedElement && selectedElement.classList.contains('is-active')) {
    const touch = e.touches[0];
    const dx = (touch.pageX - startX) / scale;
    const dy = (touch.pageY - startY) / scale;
    selectedElement.style.left = `${parseInt(selectedElement.style.left, 10) + dx}px`;
    selectedElement.style.top = `${parseInt(selectedElement.style.top, 10) + dy}px`;

    // Update startX and startY for the next move event
    startX = touch.pageX;
    startY = touch.pageY;

    // Call drawEdges to update edge positions based on the new node positions
    drawEdges();

    e.preventDefault(); // Prevent default to avoid scrolling and other touch actions
  }
}, { passive: false });

// Determine if dragging should start
document.addEventListener('touchmove', function(e) {
  if (selectedElement && !isDragging) {
    const touch = e.touches[0];
    if (Math.abs(touch.pageX - startX) > 10 || Math.abs(touch.pageY - startY) > 10) {
      isDragging = true; // Start dragging if moved beyond threshold
    }
  }
}, {passive: true});

// End dragging
document.addEventListener('touchend', function() {
  if (isDragging && selectedElement) {
    selectedElement.classList.remove('is-dragging');
    isDragging = false;
    selectedElement = null;
  }
});

function applyPanAndZoom() {
  document.body.style.setProperty('--scale', scale);
  document.body.style.setProperty('--pan-x', `${panOffsetX}px`);
  document.body.style.setProperty('--pan-y', `${panOffsetY}px`);
}

// Prevent the whole page from zooming on pinch
document.addEventListener('gesturestart', function(e) {
  e.preventDefault();
});

document.addEventListener('gesturechange', function(e) {
  e.preventDefault();
});

drawEdges();
updateCanvasData();

================
File: jsoncanvas-main/assets/icon.svg
================
<svg width="1024" height="1024" viewBox="0 0 1024 1024" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_33_23)">
<rect width="1024" height="1024" fill="#8B0A5F"/>
<path d="M157.538 748.306C157.538 668.55 222.192 603.896 301.948 603.896C381.703 603.896 446.358 668.55 446.358 748.306C446.358 828.062 381.703 892.716 301.948 892.716C222.192 892.716 157.538 828.062 157.538 748.306Z" fill="white"/>
<path d="M603.9 301.948C603.9 222.192 668.555 157.537 748.31 157.538C828.066 157.538 892.72 222.192 892.72 301.948C892.72 381.703 828.066 446.358 748.31 446.358C668.555 446.358 603.9 381.703 603.9 301.948Z" fill="white"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M813.95 579.283C813.95 708.886 708.886 813.95 579.283 813.95L525.129 813.95L525.129 705.642L579.283 705.642C649.069 705.642 705.642 649.069 705.642 579.283L705.642 525.13L813.95 525.13L813.95 579.283Z" fill="white"/>
</g>
<defs>
<clipPath id="clip0_33_23">
<rect width="1024" height="1024" rx="196" fill="white"/>
</clipPath>
</defs>
</svg>

================
File: jsoncanvas-main/assets/prism.js
================
/* PrismJS 1.29.0
https://prismjs.com/download.html#themes=prism&languages=clike+javascript+json */
var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(e){var n=/(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i,t=0,r={},a={manual:e.Prism&&e.Prism.manual,disableWorkerMessageHandler:e.Prism&&e.Prism.disableWorkerMessageHandler,util:{encode:function e(n){return n instanceof i?new i(n.type,e(n.content),n.alias):Array.isArray(n)?n.map(e):n.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).slice(8,-1)},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function e(n,t){var r,i;switch(t=t||{},a.util.type(n)){case"Object":if(i=a.util.objId(n),t[i])return t[i];for(var l in r={},t[i]=r,n)n.hasOwnProperty(l)&&(r[l]=e(n[l],t));return r;case"Array":return i=a.util.objId(n),t[i]?t[i]:(r=[],t[i]=r,n.forEach((function(n,a){r[a]=e(n,t)})),r);default:return n}},getLanguage:function(e){for(;e;){var t=n.exec(e.className);if(t)return t[1].toLowerCase();e=e.parentElement}return"none"},setLanguage:function(e,t){e.className=e.className.replace(RegExp(n,"gi"),""),e.classList.add("language-"+t)},currentScript:function(){if("undefined"==typeof document)return null;if("currentScript"in document)return document.currentScript;try{throw new Error}catch(r){var e=(/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(r.stack)||[])[1];if(e){var n=document.getElementsByTagName("script");for(var t in n)if(n[t].src==e)return n[t]}return null}},isActive:function(e,n,t){for(var r="no-"+n;e;){var a=e.classList;if(a.contains(n))return!0;if(a.contains(r))return!1;e=e.parentElement}return!!t}},languages:{plain:r,plaintext:r,text:r,txt:r,extend:function(e,n){var t=a.util.clone(a.languages[e]);for(var r in n)t[r]=n[r];return t},insertBefore:function(e,n,t,r){var i=(r=r||a.languages)[e],l={};for(var o in i)if(i.hasOwnProperty(o)){if(o==n)for(var s in t)t.hasOwnProperty(s)&&(l[s]=t[s]);t.hasOwnProperty(o)||(l[o]=i[o])}var u=r[e];return r[e]=l,a.languages.DFS(a.languages,(function(n,t){t===u&&n!=e&&(this[n]=l)})),l},DFS:function e(n,t,r,i){i=i||{};var l=a.util.objId;for(var o in n)if(n.hasOwnProperty(o)){t.call(n,o,n[o],r||o);var s=n[o],u=a.util.type(s);"Object"!==u||i[l(s)]?"Array"!==u||i[l(s)]||(i[l(s)]=!0,e(s,t,o,i)):(i[l(s)]=!0,e(s,t,null,i))}}},plugins:{},highlightAll:function(e,n){a.highlightAllUnder(document,e,n)},highlightAllUnder:function(e,n,t){var r={callback:t,container:e,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};a.hooks.run("before-highlightall",r),r.elements=Array.prototype.slice.apply(r.container.querySelectorAll(r.selector)),a.hooks.run("before-all-elements-highlight",r);for(var i,l=0;i=r.elements[l++];)a.highlightElement(i,!0===n,r.callback)},highlightElement:function(n,t,r){var i=a.util.getLanguage(n),l=a.languages[i];a.util.setLanguage(n,i);var o=n.parentElement;o&&"pre"===o.nodeName.toLowerCase()&&a.util.setLanguage(o,i);var s={element:n,language:i,grammar:l,code:n.textContent};function u(e){s.highlightedCode=e,a.hooks.run("before-insert",s),s.element.innerHTML=s.highlightedCode,a.hooks.run("after-highlight",s),a.hooks.run("complete",s),r&&r.call(s.element)}if(a.hooks.run("before-sanity-check",s),(o=s.element.parentElement)&&"pre"===o.nodeName.toLowerCase()&&!o.hasAttribute("tabindex")&&o.setAttribute("tabindex","0"),!s.code)return a.hooks.run("complete",s),void(r&&r.call(s.element));if(a.hooks.run("before-highlight",s),s.grammar)if(t&&e.Worker){var c=new Worker(a.filename);c.onmessage=function(e){u(e.data)},c.postMessage(JSON.stringify({language:s.language,code:s.code,immediateClose:!0}))}else u(a.highlight(s.code,s.grammar,s.language));else u(a.util.encode(s.code))},highlight:function(e,n,t){var r={code:e,grammar:n,language:t};if(a.hooks.run("before-tokenize",r),!r.grammar)throw new Error('The language "'+r.language+'" has no grammar.');return r.tokens=a.tokenize(r.code,r.grammar),a.hooks.run("after-tokenize",r),i.stringify(a.util.encode(r.tokens),r.language)},tokenize:function(e,n){var t=n.rest;if(t){for(var r in t)n[r]=t[r];delete n.rest}var a=new s;return u(a,a.head,e),o(e,a,n,a.head,0),function(e){for(var n=[],t=e.head.next;t!==e.tail;)n.push(t.value),t=t.next;return n}(a)},hooks:{all:{},add:function(e,n){var t=a.hooks.all;t[e]=t[e]||[],t[e].push(n)},run:function(e,n){var t=a.hooks.all[e];if(t&&t.length)for(var r,i=0;r=t[i++];)r(n)}},Token:i};function i(e,n,t,r){this.type=e,this.content=n,this.alias=t,this.length=0|(r||"").length}function l(e,n,t,r){e.lastIndex=n;var a=e.exec(t);if(a&&r&&a[1]){var i=a[1].length;a.index+=i,a[0]=a[0].slice(i)}return a}function o(e,n,t,r,s,g){for(var f in t)if(t.hasOwnProperty(f)&&t[f]){var h=t[f];h=Array.isArray(h)?h:[h];for(var d=0;d<h.length;++d){if(g&&g.cause==f+","+d)return;var v=h[d],p=v.inside,m=!!v.lookbehind,y=!!v.greedy,k=v.alias;if(y&&!v.pattern.global){var x=v.pattern.toString().match(/[imsuy]*$/)[0];v.pattern=RegExp(v.pattern.source,x+"g")}for(var b=v.pattern||v,w=r.next,A=s;w!==n.tail&&!(g&&A>=g.reach);A+=w.value.length,w=w.next){var E=w.value;if(n.length>e.length)return;if(!(E instanceof i)){var P,L=1;if(y){if(!(P=l(b,A,e,m))||P.index>=e.length)break;var S=P.index,O=P.index+P[0].length,j=A;for(j+=w.value.length;S>=j;)j+=(w=w.next).value.length;if(A=j-=w.value.length,w.value instanceof i)continue;for(var C=w;C!==n.tail&&(j<O||"string"==typeof C.value);C=C.next)L++,j+=C.value.length;L--,E=e.slice(A,j),P.index-=A}else if(!(P=l(b,0,E,m)))continue;S=P.index;var N=P[0],_=E.slice(0,S),M=E.slice(S+N.length),W=A+E.length;g&&W>g.reach&&(g.reach=W);var z=w.prev;if(_&&(z=u(n,z,_),A+=_.length),c(n,z,L),w=u(n,z,new i(f,p?a.tokenize(N,p):N,k,N)),M&&u(n,w,M),L>1){var I={cause:f+","+d,reach:W};o(e,n,t,w.prev,A,I),g&&I.reach>g.reach&&(g.reach=I.reach)}}}}}}function s(){var e={value:null,prev:null,next:null},n={value:null,prev:e,next:null};e.next=n,this.head=e,this.tail=n,this.length=0}function u(e,n,t){var r=n.next,a={value:t,prev:n,next:r};return n.next=a,r.prev=a,e.length++,a}function c(e,n,t){for(var r=n.next,a=0;a<t&&r!==e.tail;a++)r=r.next;n.next=r,r.prev=n,e.length-=a}if(e.Prism=a,i.stringify=function e(n,t){if("string"==typeof n)return n;if(Array.isArray(n)){var r="";return n.forEach((function(n){r+=e(n,t)})),r}var i={type:n.type,content:e(n.content,t),tag:"span",classes:["token",n.type],attributes:{},language:t},l=n.alias;l&&(Array.isArray(l)?Array.prototype.push.apply(i.classes,l):i.classes.push(l)),a.hooks.run("wrap",i);var o="";for(var s in i.attributes)o+=" "+s+'="'+(i.attributes[s]||"").replace(/"/g,"&quot;")+'"';return"<"+i.tag+' class="'+i.classes.join(" ")+'"'+o+">"+i.content+"</"+i.tag+">"},!e.document)return e.addEventListener?(a.disableWorkerMessageHandler||e.addEventListener("message",(function(n){var t=JSON.parse(n.data),r=t.language,i=t.code,l=t.immediateClose;e.postMessage(a.highlight(i,a.languages[r],r)),l&&e.close()}),!1),a):a;var g=a.util.currentScript();function f(){a.manual||a.highlightAll()}if(g&&(a.filename=g.src,g.hasAttribute("data-manual")&&(a.manual=!0)),!a.manual){var h=document.readyState;"loading"===h||"interactive"===h&&g&&g.defer?document.addEventListener("DOMContentLoaded",f):window.requestAnimationFrame?window.requestAnimationFrame(f):window.setTimeout(f,16)}return a}(_self);"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0,greedy:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,boolean:/\b(?:false|true)\b/,function:/\b\w+(?=\()/,number:/\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,punctuation:/[{}[\];(),.:]/};
Prism.languages.javascript=Prism.languages.extend("clike",{"class-name":[Prism.languages.clike["class-name"],{pattern:/(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,lookbehind:!0}],keyword:[{pattern:/((?:^|\})\s*)catch\b/,lookbehind:!0},{pattern:/(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,lookbehind:!0}],function:/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,number:{pattern:RegExp("(^|[^\\w$])(?:NaN|Infinity|0[bB][01]+(?:_[01]+)*n?|0[oO][0-7]+(?:_[0-7]+)*n?|0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?|\\d+(?:_\\d+)*n|(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?)(?![\\w$])"),lookbehind:!0},operator:/--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/}),Prism.languages.javascript["class-name"][0].pattern=/(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/,Prism.languages.insertBefore("javascript","keyword",{regex:{pattern:RegExp("((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/(?:(?:\\[(?:[^\\]\\\\\r\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\r\n])+/[dgimyus]{0,7}|(?:\\[(?:[^[\\]\\\\\r\n]|\\\\.|\\[(?:[^[\\]\\\\\r\n]|\\\\.|\\[(?:[^[\\]\\\\\r\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\r\n])+/[dgimyus]{0,7}v[dgimyus]{0,7})(?=(?:\\s|/\\*(?:[^*]|\\*(?!/))*\\*/)*(?:$|[\r\n,.;:})\\]]|//))"),lookbehind:!0,greedy:!0,inside:{"regex-source":{pattern:/^(\/)[\s\S]+(?=\/[a-z]*$)/,lookbehind:!0,alias:"language-regex",inside:Prism.languages.regex},"regex-delimiter":/^\/|\/$/,"regex-flags":/^[a-z]+$/}},"function-variable":{pattern:/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,alias:"function"},parameter:[{pattern:/(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,lookbehind:!0,inside:Prism.languages.javascript},{pattern:/(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,lookbehind:!0,inside:Prism.languages.javascript},{pattern:/(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,lookbehind:!0,inside:Prism.languages.javascript},{pattern:/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,lookbehind:!0,inside:Prism.languages.javascript}],constant:/\b[A-Z](?:[A-Z_]|\dx?)*\b/}),Prism.languages.insertBefore("javascript","string",{hashbang:{pattern:/^#!.*/,greedy:!0,alias:"comment"},"template-string":{pattern:/`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,greedy:!0,inside:{"template-punctuation":{pattern:/^`|`$/,alias:"string"},interpolation:{pattern:/((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,lookbehind:!0,inside:{"interpolation-punctuation":{pattern:/^\$\{|\}$/,alias:"punctuation"},rest:Prism.languages.javascript}},string:/[\s\S]+/}},"string-property":{pattern:/((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,lookbehind:!0,greedy:!0,alias:"property"}}),Prism.languages.insertBefore("javascript","operator",{"literal-property":{pattern:/((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,lookbehind:!0,alias:"property"}}),Prism.languages.markup&&(Prism.languages.markup.tag.addInlined("script","javascript"),Prism.languages.markup.tag.addAttribute("on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)","javascript")),Prism.languages.js=Prism.languages.javascript;
Prism.languages.json={property:{pattern:/(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,lookbehind:!0,greedy:!0},string:{pattern:/(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,lookbehind:!0,greedy:!0},comment:{pattern:/\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,greedy:!0},number:/-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,punctuation:/[{}[\],]/,operator:/:/,boolean:/\b(?:false|true)\b/,null:{pattern:/\bnull\b/,alias:"keyword"}},Prism.languages.webmanifest=Prism.languages.json;

================
File: jsoncanvas-main/assets/style.css
================
:root {
  --font-content: -apple-system, BlinkMacSystemFont, "Inter", "IBM Plex Sans", Segoe UI, Helvetica, Arial, sans-serif;
  --font-mono: ui-monospace, SFMono-Regular, "Cascadia Code", "Roboto Mono", "Source Code Pro", "DejaVu Sans Mono", "Liberation Mono", "Consolas", Menlo, Monaco, monospace;
  --font-small: 0.875em;
  --font-smaller: 0.8em;
  --wrap-wide: 1000px;
  --wrap-normal: 37em;
  --line-height: 1.5;

  --color-bg-1: #fff;
  --color-bg-2: #fafafa;
  --color-tx-1: #3F062D;
  --color-tx-2: #999;
  --color-ui-1: #ddd;
  --color-ui-2: #bbb;
  --color-ui-3: #5E0641;
  --color-ax-1: #8B0A5F;

  --color-selection: rgba(139,10,95,0.15);
}

.theme-dark {
  --color-bg-1: #1e0516;
  --color-bg-2: #140310;
  --color-tx-1: #fff;
  --color-tx-2: #a28397;
  --color-ui-1: #3F062D;
  --color-ui-2: #68154C;
  --color-ui-3: #b40e7a;
  --color-ax-1: #8B0A5F;

  --color-selection: rgba(139,10,95,0.5);
}

*, *:before, *:after {
  box-sizing:inherit;}

::selection {
  background: var(--color-selection);
}

::-moz-selection {
  background: var(--color-selection);
}

html, body {
  touch-action: manipulation;
}

html {
  box-sizing: border-box;
  width: 100%;
  height: 100%;
  font-size: 62.5%;
}

body {
  color-scheme: light dark;
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizeLegibility;
  background-color: var(--color-bg-1);
  font-family: var(--font-content);
  margin: 0 auto 0 auto;
  line-height: var(--line-height);
  padding: 0;
  font-size: 1.6rem;
  color: var(--color-tx-1);
}

/* Canvas area */
#home {
  overflow: hidden;
}
#container {
  touch-action: none;
  display: flex;
  flex: 1;
  flex-direction: row;
  height: 100%;
  width: 100%;
  position: fixed;
  top: 0;
  left: 0;
}
#canvas-container {
  width: 100%;
  height: 100%;
  padding: 0;
  position: relative;
  background-color: var(--color-bg-2);
  background-image: radial-gradient(var(--color-ui-1) calc(var(--scale)*0.5px + 0.5px), transparent 0);
  background-size: calc(var(--scale) * 20px) calc(var(--scale) * 20px);
  overflow: hidden;
  background-position: calc(var(--pan-x) - 19px) calc(var(--pan-y) - 19px);
}
#canvas-edges,
#canvas-nodes {
  opacity: 0;
  transform: translate(var(--pan-x), var(--pan-y)) scale(var(--scale));
  transform-origin: left top;
}
#canvas-edges {
  z-index: 150;
  pointer-events: none;
  user-select: none;
  overflow:visible;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
#canvas-edges path {
  stroke: var(--color-ui-3);
  stroke-width: 2;
  fill: none;
}
#arrowhead {
  fill: var(--color-ui-3);
}
.will-pan {
  cursor: grab;
}

/* Canvas output pane */
#output.hidden {
  transform: translateX(120%);
}
#output {
  position: fixed;
  height: 92vh;
  top: 1rem;
  right: 1rem;
  bottom: auto;
  border-radius: 12px;
  color: var(--color-tx-1);
  background-color: var(--color-bg-1);
  border: 1px solid var(--color-ui-1);
  box-shadow: 0 5px 15px rgba(0,0,0,0.2);;
  z-index: 0;
  width: 24em;
  max-width: 40%;
  display: flex;
  flex-direction: column;
  transition: transform 200ms;
}
#output p {
  font-size: 90%;
  line-height: 1.3;
  padding-right: 0.5em;
}
#output-code {
  color-scheme: dark;
  flex-grow: 1;
  width: 100%;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  padding: 1rem;
  border-top: 1px solid var(--color-ui-1);
  border-bottom: 1px solid var(--color-ui-1);
}
#output pre {
  color-scheme: dark;
  width: 100%;
  padding: 0.5em;
  margin: 0;
}
.code-footer,
.code-header {
  font-size: 80%;
  font-weight: 500;
  padding: 0;
  display: flex;
  align-items: center;
  color: var(--color-tx-2);
  gap: 8px;
  padding: 1rem;
}
.code-footer {
  justify-content: center;
}
.code-header .language {
  flex-grow: 1;
}
.close-output {
  font-weight: 300;
  cursor: pointer;
  user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
  font-size: 24px;
  line-height: 0;
  display: flex;
  align-items: center;
  margin-top: -4px;
}
.close-output:hover {
  color: var(--color-tx-1);
}

/* Pages */
.page {
  padding: 36px 36px 48px;
  max-width: 48em;
  margin: 0 auto;
}
nav {
  padding: 24px 36px;
  max-width: 48em;
  margin: 0 auto;
  display: flex;
  align-items: center;
  gap: 4px;
}
nav #logo {
  flex-grow: 1;
}
nav .link {
  color: var(--color-ax-1);
  text-decoration: none;
  padding: 0.25em 0.5em;
  border-radius: 6px;
}
nav .link:hover {
  color: var(--color-bg-1);
  background-color: var(--color-ax-1);
}
.hidenav #navbar {
 display: none;
}

/* Specific nodes */
#logo {
  border-radius: 8px;
  line-height: 0;
  z-index: 100;
  padding: 4px 12px 4px 4px;
}
#logo .node-name {
  top: -1.25em;
  padding-left: 4px;
}
#nav {
  z-index: 90;
  white-space: nowrap;
  padding-right: 48px;
}
#readme {
  width: 480px;
  padding: 36px;
  z-index: 80;
}
#spec {
  width: 480px;
  height: 480px;
  z-index: 70;
}


/* General node styling */
.node {
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  position: absolute;
  display: block;
}
.node.is-active {
  box-shadow:
    0 0 0 2px var(--color-ui-3);
}
.node.is-dragging {
  cursor: grabbing;
  box-shadow:
    0 0 0 2px var(--color-ui-3),
    0 5px 15px rgba(0,0,0,0.2);
}
.node.is-dragging iframe {
  pointer-events: none;
}
.node:hover .node-name {
  opacity: 1;
  color: var(--color-tx-1);
  border-radius: 8px 8px 0 0;
}
.node-name {
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  cursor: grab;
  opacity: 1;
  position: absolute;
  height: 2.25em;
  padding: 0.25em 0.5em;
  width: 100%;
  top: -2.25em;
  left: 0;
  color: var(--color-ui-2);
  font-size: calc(var(--font-smaller) * 1/var(--scale));
  -ms-user-select: none;
  -webkit-user-select: none;
  user-select: none;
}
.node.is-dragging .node-name {
  cursor: grabbing;
}
.node-link,
.node-text {
  background-color: var(--color-bg-1);
  border-radius: 8px;
  box-shadow: 0 0 0 2px var(--color-ui-1);
}
.node-file img {
  -webkit-user-drag: none;
  -moz-user-drag: none;
  -o-user-drag: none;
  user-drag: none;
}
.node-text-content {
  padding: 12px 24px;
}

/* Canvas controls */
#controls {
  position: fixed;
  bottom: 1rem;
  right: 1rem;
  z-index: 100;
  display: flex;
  align-items: center;
  gap: 6px;
  -ms-user-select: none;
  -webkit-user-select: none;
  user-select: none;
}

/* Page content */
h1 {
  line-height: 1.1;
  margin-top: 0.25em;
}
h2 {
  line-height: 1.2;
  margin-bottom: 0em;
  margin-top: 1.5em;
}
h2 + p {
  margin-top: 0.5em;
}

ul + h2,
ul + h3,
p + h2,
p + h3 {
  margin-top: 1.5em;
}

h2 + h3 {
  margin-top: 0.75em;
}

a {
  font-weight: 600;
  color: var(--color-tx-1);
  text-decoration: underline;
}
small {
  color: var(--color-tx-2);
}
small a {
  font-weight: 400;
  color: var(--color-tx-2);
}
hr {
  margin: 0;
  border: 0;
  height: 1px;
  background-color: var(--color-ui-1);
}
iframe {
  -webkit-appearance: none;
  border: none;
  outline: none;
  margin: 0;
  vertical-align: bottom;
  border-radius: 8px;
}
img {
  vertical-align: bottom;
}
code {
  -webkit-appearance: none;
  font-family: var(--font-mono);
  cursor: text;
}
pre {
  -webkit-appearance: none;
  font-family: var(--font-mono);
  background-color: transparent;
  border-radius: 4px;
  padding: 0;
  font-size: 85%;
  cursor: text;
}
pre:active,
pre:focus {
  outline: none;
  border: none;
}
pre code {
  color: var(--color-tx-2);
  background-color: transparent;
  border: none;
  padding: 0;
  font-size: inherit;
}
code {
  font-family: var(--font-mono);
  background-color: var(--color-bg-2);
  border: 1px solid var(--color-ui-1);
  border-radius: 4px;
  padding: 0 0.2em;
  font-size: 85%;
}
ul {
  padding-inline-start: 2em;
}
li::marker {
  color: var(--color-tx-2);
}

table {
  margin-top: 1.5em;
  margin-bottom: 2.5em;
  border-collapse:collapse;
  border-spacing:0;
}
tr {
  border-bottom: 1px solid var(--color-ui-1);
}
td {
  padding: 0.5em 1em 0.5em 0;
  line-height: 1.3;
}
th:not(:last-child) {
  padding-right: 1em;
}
td:last-child {
  padding-right: 0;
}
th {
  text-align: left;
  font-weight: 600;
  padding: 0 1em 0.5em 0;
}

button {
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  -ms-user-select: none;
  -webkit-user-select: none;
  user-select: none;
  cursor: pointer;
  font-family: var(--font-content);
  background: var(--color-bg-1);
  outline: none;
  border: 1px solid var(--color-ui-1);
  padding: 4px 8px;
  color: var(--color-tx-1);
  border-radius: 4px;
  font-weight: 500;
}
button:hover {
  border-color: var(--color-ui-2);
}
.theme-dark button {
  background-color: var(--color-ui-1);
  color: var(--color-tx-2);
  border: 1px solid var(--color-ui-2);
}
.theme-dark button:hover {
  color: var(--color-tx-1);
  border: 1px solid var(--color-ui-3);
}

@media (max-width: 800px) {
  body:not(.hidenav) nav {
    padding: 24px;
    gap: 0;
  }
  body:not(.hidenav) .page {
    padding: 24px 24px 48px 24px;
  }
  #controls {
    bottom: 0;
    right: 0;
    left: 0;
    padding: 1rem;
    border-top: 1px solid var(--color-ui-1);
    width: 100%;
    background-color: var(--color-bg-1);
    justify-content: center;
    height: 48px;
  }
  #output {
    border-radius: 0;
    border: none;
    left: 0;
    top: 0;
    z-index: 200;
    width: 100vw;
    height: calc(100% - 48px);
    transition: none;
    max-width: 100vw;
    box-shadow: none;
  }
  #output-code {
    padding: 1rem 1rem 6rem;
  }
  .code-footer {

  }
}

/* PrismJS 1.29.0
https://prismjs.com/download.html#themes=prism&languages=json */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
  text-align: left;
  white-space: pre-wrap;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;

  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
  overflow: auto;
  overflow-x: hidden;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
  color: slategray;
}

.token.punctuation {
  color: var(--color-tx-2);
}

.token.namespace {
  opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.constant,
.token.symbol,
.token.deleted {
  color: #f8aa59;
}

.token.number {
  color: #ee529d;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
  color: #fe7568;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
  color: var(--color-tx-2);
}

.token.atrule,
.token.attr-value,
.token.keyword {
  color: #07a;
}

.token.function,
.token.class-name {
  color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
  color: #e90;
}

.token.important,
.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}

.token.entity {
  cursor: help;
}

================
File: jsoncanvas-main/CNAME
================
jsoncanvas.org

================
File: jsoncanvas-main/docs/apps.md
================
# Apps and tools

JSON Canvas is supported by the following apps and tools. If you would like to add an app or tool to this list, please submit a pull request on [GitHub](https://github.com/obsidianmd/jsoncanvas).

## Apps

| Name                                            | Storage | Import | Export |
| ----------------------------------------------- | :-----: | :----: | :----: |
| [Obsidian](https://obsidian.md/)                |        |       |       |
| [Kinopio](https://kinopio.club/)                |         |       |       |
| [Flowchart Fun](https://flowchart.fun/)         |         |       |       |
| [hi-canvas](https://hi-canvas.marknoteapp.com/) |         |       |       |
| [OrgPad](https://orgpad.info/)                  |         |       |       |

## Tools

To convert from other formats to JSON Canvas:

- [Heptabase to JSON Canvas](https://github.com/link-ding/Heptabase-Export)

To convert from JSON Canvas to other formats:

- [Mermaid](https://alexwiench.github.io/json-canvas-to-mermaid-demo/)
- [Property Graph Exchange Format](https://www.npmjs.org/package/pgraphs)

## Libraries

- [C single-header library](https://github.com/ossldossl/jsonCanvas)
- [Dart library](https://pub.dev/packages/json_canvas/)
- [Go library](https://github.com/supersonicpineapple/go-jsoncanvas)
- [Python library](https://pypi.org/project/PyJSONCanvas/)
- [React library](https://github.com/Digital-Tvilling/react-jsoncanvas)
- [Ruby library](https://github.com/ongaeshi/json_canvas)
- [Rust crate](https://crates.io/crates/jsoncanvas)
- [TypeScript library](https://npmjs.com/package/@trbn/jsoncanvas)
- [Rehype Rendering Library (inline)](https://github.com/lovettbarron/rehype-jsoncanvas)
- [Vue library](https://github.com/wujieli0207/vue-json-canvas)

================
File: jsoncanvas-main/Gemfile
================
source "https://rubygems.org"

gem "github-pages", group: :jekyll_plugins
# If you have any plugins, put them here!
group :jekyll_plugins do
  gem "jekyll-feed", "~> 0.12"
end

gem "webrick", "~> 1.8"

================
File: jsoncanvas-main/LICENSE
================
MIT License

Copyright (c) 2024 Obsidian.md

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: jsoncanvas-main/logo.svg
================
<svg width="163" height="60" viewBox="0 0 163 60" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M161.814 42.1702H157.484C157.461 41.9032 157.368 41.6731 157.203 41.4799C157.038 41.2867 156.825 41.139 156.564 41.0367C156.308 40.9287 156.024 40.8748 155.711 40.8748C155.308 40.8748 154.961 40.9486 154.672 41.0964C154.382 41.2441 154.24 41.4543 154.246 41.727C154.24 41.9202 154.322 42.0992 154.493 42.264C154.669 42.4287 155.007 42.5566 155.507 42.6475L158.166 43.1248C159.507 43.3691 160.504 43.781 161.158 44.3606C161.817 44.9344 162.149 45.7043 162.155 46.6702C162.149 47.602 161.871 48.4117 161.319 49.0992C160.774 49.781 160.027 50.3094 159.078 50.6844C158.135 51.0537 157.058 51.2384 155.848 51.2384C153.848 51.2384 152.283 50.8293 151.152 50.0111C150.027 49.193 149.399 48.1134 149.268 46.7725H153.939C154.001 47.1873 154.206 47.5083 154.552 47.7356C154.905 47.9572 155.348 48.0679 155.882 48.0679C156.314 48.0679 156.669 47.9941 156.947 47.8464C157.231 47.6986 157.376 47.4884 157.382 47.2157C157.376 46.9657 157.251 46.7668 157.007 46.6191C156.768 46.4714 156.393 46.352 155.882 46.2611L153.564 45.852C152.229 45.6191 151.229 45.1759 150.564 44.5225C149.899 43.8691 149.569 43.0282 149.575 41.9998C149.569 41.0907 149.808 40.3208 150.291 39.6901C150.78 39.0537 151.476 38.5708 152.379 38.2412C153.288 37.906 154.365 37.7384 155.609 37.7384C157.501 37.7384 158.993 38.1304 160.084 38.9145C161.18 39.6986 161.757 40.7839 161.814 42.1702Z" fill="#8B0A5F"/>
<path d="M139.796 51.2043C138.961 51.2043 138.222 51.068 137.58 50.7952C136.944 50.5168 136.444 50.0964 136.08 49.5339C135.716 48.9714 135.535 48.2554 135.535 47.3861C135.535 46.6702 135.657 46.0594 135.901 45.5537C136.145 45.0424 136.486 44.6248 136.924 44.3009C137.361 43.977 137.87 43.7299 138.449 43.5594C139.035 43.389 139.665 43.2782 140.341 43.227C141.074 43.1702 141.663 43.102 142.106 43.0225C142.555 42.9373 142.878 42.8208 143.077 42.6731C143.276 42.5197 143.376 42.3179 143.376 42.0679V42.0339C143.376 41.693 143.245 41.4316 142.984 41.2498C142.722 41.0679 142.387 40.977 141.978 40.977C141.529 40.977 141.163 41.0765 140.878 41.2753C140.6 41.4685 140.432 41.7668 140.376 42.1702H136.046C136.103 41.3748 136.356 40.6418 136.805 39.9714C137.259 39.2952 137.921 38.7554 138.79 38.352C139.66 37.9429 140.745 37.7384 142.046 37.7384C142.984 37.7384 143.824 37.8492 144.569 38.0708C145.313 38.2867 145.947 38.5907 146.469 38.9827C146.992 39.3691 147.39 39.8236 147.663 40.3464C147.941 40.8634 148.08 41.4259 148.08 42.0339V50.9998H143.682V49.1589H143.58C143.319 49.6475 143.001 50.0424 142.626 50.3435C142.256 50.6447 141.833 50.8634 141.356 50.9998C140.884 51.1361 140.364 51.2043 139.796 51.2043ZM141.33 48.2384C141.688 48.2384 142.023 48.1645 142.336 48.0168C142.654 47.8691 142.913 47.656 143.111 47.3776C143.31 47.0992 143.41 46.7611 143.41 46.3634V45.2725C143.285 45.3236 143.151 45.3719 143.009 45.4174C142.873 45.4628 142.725 45.5055 142.566 45.5452C142.413 45.585 142.248 45.6219 142.072 45.656C141.901 45.6901 141.722 45.7214 141.535 45.7498C141.171 45.8066 140.873 45.9003 140.64 46.031C140.413 46.156 140.242 46.3123 140.128 46.4998C140.02 46.6816 139.966 46.8861 139.966 47.1134C139.966 47.477 140.094 47.7554 140.35 47.9486C140.606 48.1418 140.932 48.2384 141.33 48.2384Z" fill="#8B0A5F"/>
<path d="M135.618 37.9089L131.221 50.9998H125.766L121.368 37.9089H126.311L128.425 46.568H128.561L130.675 37.9089H135.618Z" fill="#8B0A5F"/>
<path d="M112.563 43.6361V50.9998H107.858V37.9089H112.324V40.3975H112.46C112.744 39.5679 113.244 38.9174 113.96 38.4458C114.682 37.9742 115.523 37.7384 116.483 37.7384C117.409 37.7384 118.213 37.9515 118.895 38.3776C119.582 38.7981 120.114 39.3776 120.489 40.1162C120.869 40.8549 121.057 41.6986 121.051 42.6475V50.9998H116.347V43.6361C116.352 42.9884 116.188 42.4799 115.852 42.1106C115.523 41.7412 115.063 41.5566 114.472 41.5566C114.085 41.5566 113.747 41.6418 113.457 41.8123C113.173 41.977 112.955 42.2157 112.801 42.5282C112.648 42.835 112.568 43.2043 112.563 43.6361Z" fill="#8B0A5F"/>
<path d="M97.8063 51.2043C96.9711 51.2043 96.2324 51.068 95.5904 50.7952C94.954 50.5168 94.454 50.0964 94.0904 49.5339C93.7267 48.9714 93.5449 48.2554 93.5449 47.3861C93.5449 46.6702 93.6671 46.0594 93.9114 45.5537C94.1557 45.0424 94.4966 44.6248 94.9341 44.3009C95.3716 43.977 95.8801 43.7299 96.4597 43.5594C97.0449 43.389 97.6756 43.2782 98.3517 43.227C99.0847 43.1702 99.6728 43.102 100.116 43.0225C100.565 42.9373 100.889 42.8208 101.088 42.6731C101.286 42.5197 101.386 42.3179 101.386 42.0679V42.0339C101.386 41.693 101.255 41.4316 100.994 41.2498C100.732 41.0679 100.397 40.977 99.9881 40.977C99.5392 40.977 99.1728 41.0765 98.8887 41.2753C98.6103 41.4685 98.4426 41.7668 98.3858 42.1702H94.0563C94.1131 41.3748 94.3659 40.6418 94.8148 39.9714C95.2694 39.2952 95.9313 38.7554 96.8006 38.352C97.6699 37.9429 98.7551 37.7384 100.056 37.7384C100.994 37.7384 101.835 37.8492 102.579 38.0708C103.323 38.2867 103.957 38.5907 104.48 38.9827C105.002 39.3691 105.4 39.8236 105.673 40.3464C105.951 40.8634 106.09 41.4259 106.09 42.0339V50.9998H101.693V49.1589H101.59C101.329 49.6475 101.011 50.0424 100.636 50.3435C100.267 50.6447 99.8432 50.8634 99.3659 50.9998C98.8944 51.1361 98.3745 51.2043 97.8063 51.2043ZM99.3404 48.2384C99.6983 48.2384 100.034 48.1645 100.346 48.0168C100.664 47.8691 100.923 47.656 101.122 47.3776C101.32 47.0992 101.42 46.7611 101.42 46.3634V45.2725C101.295 45.3236 101.161 45.3719 101.019 45.4174C100.883 45.4628 100.735 45.5055 100.576 45.5452C100.423 45.585 100.258 45.6219 100.082 45.656C99.9114 45.6901 99.7324 45.7214 99.5449 45.7498C99.1813 45.8066 98.883 45.9003 98.65 46.031C98.4228 46.156 98.2523 46.3123 98.1387 46.4998C98.0307 46.6816 97.9767 46.8861 97.9767 47.1134C97.9767 47.477 98.1046 47.7554 98.3603 47.9486C98.6159 48.1418 98.9426 48.2384 99.3404 48.2384Z" fill="#8B0A5F"/>
<path d="M92.4205 40.0908H87.6137C87.5796 39.6931 87.4887 39.3323 87.341 39.0084C87.1989 38.6845 87.0001 38.4061 86.7444 38.1732C86.4944 37.9345 86.1904 37.7527 85.8325 37.6277C85.4745 37.497 85.0682 37.4317 84.6137 37.4317C83.8182 37.4317 83.145 37.6249 82.5938 38.0112C82.0484 38.3976 81.6336 38.9516 81.3495 39.6732C81.0711 40.3948 80.9319 41.2612 80.9319 42.2726C80.9319 43.3408 81.0739 44.2357 81.358 44.9573C81.6478 45.6732 82.0654 46.213 82.6109 46.5766C83.1563 46.9345 83.8126 47.1135 84.5796 47.1135C85.0171 47.1135 85.4092 47.0595 85.7557 46.9516C86.1023 46.838 86.4035 46.676 86.6592 46.4658C86.9148 46.2556 87.1222 46.0027 87.2813 45.7073C87.4461 45.4061 87.5569 45.0681 87.6137 44.6931L92.4205 44.7272C92.3637 45.4658 92.1563 46.2186 91.7984 46.9857C91.4404 47.747 90.9319 48.4516 90.2728 49.0993C89.6194 49.7414 88.8097 50.2584 87.8438 50.6505C86.8779 51.0425 85.7557 51.2385 84.4773 51.2385C82.8751 51.2385 81.4376 50.8948 80.1648 50.2073C78.8978 49.5198 77.895 48.5084 77.1563 47.1732C76.4234 45.838 76.0569 44.2044 76.0569 42.2726C76.0569 40.3294 76.4319 38.6931 77.1819 37.3635C77.9319 36.0283 78.9432 35.0198 80.216 34.338C81.4887 33.6505 82.9092 33.3067 84.4773 33.3067C85.5796 33.3067 86.5938 33.4573 87.52 33.7584C88.4461 34.0595 89.2586 34.4999 89.9575 35.0794C90.6563 35.6533 91.2188 36.3607 91.645 37.2016C92.0711 38.0425 92.3296 39.0056 92.4205 40.0908Z" fill="#8B0A5F"/>
<path d="M138.983 9.54547V27H135.028L128.721 17.8296H128.619V27H123.88V9.54547H127.903L134.108 18.6818H134.244V9.54547H138.983Z" fill="#8B0A5F"/>
<path d="M122.168 18.2726C122.168 20.2158 121.79 21.855 121.034 23.1902C120.279 24.5198 119.259 25.5283 117.975 26.2158C116.691 26.8976 115.259 27.2385 113.679 27.2385C112.088 27.2385 110.651 26.8948 109.367 26.2073C108.088 25.5141 107.071 24.5027 106.316 23.1732C105.566 21.838 105.191 20.2044 105.191 18.2726C105.191 16.3294 105.566 14.6931 106.316 13.3635C107.071 12.0283 108.088 11.0198 109.367 10.338C110.651 9.65045 112.088 9.3067 113.679 9.3067C115.259 9.3067 116.691 9.65045 117.975 10.338C119.259 11.0198 120.279 12.0283 121.034 13.3635C121.79 14.6931 122.168 16.3294 122.168 18.2726ZM117.293 18.2726C117.293 17.2272 117.154 16.3465 116.875 15.6306C116.602 14.909 116.196 14.3635 115.656 13.9942C115.122 13.6192 114.463 13.4317 113.679 13.4317C112.895 13.4317 112.233 13.6192 111.693 13.9942C111.159 14.3635 110.753 14.909 110.475 15.6306C110.202 16.3465 110.066 17.2272 110.066 18.2726C110.066 19.3181 110.202 20.2016 110.475 20.9232C110.753 21.6391 111.159 22.1845 111.693 22.5595C112.233 22.9289 112.895 23.1135 113.679 23.1135C114.463 23.1135 115.122 22.9289 115.656 22.5595C116.196 22.1845 116.602 21.6391 116.875 20.9232C117.154 20.2016 117.293 19.3181 117.293 18.2726Z" fill="#8B0A5F"/>
<path d="M99.1634 14.9999C99.118 14.4317 98.9049 13.9885 98.5242 13.6703C98.1492 13.3522 97.5782 13.1931 96.8112 13.1931C96.3225 13.1931 95.922 13.2527 95.6095 13.372C95.3026 13.4857 95.0754 13.6419 94.9276 13.8408C94.7799 14.0397 94.7032 14.2669 94.6975 14.5226C94.6862 14.7328 94.7231 14.9232 94.8083 15.0936C94.8992 15.2584 95.0413 15.409 95.2345 15.5453C95.4276 15.676 95.6748 15.7953 95.9759 15.9033C96.2771 16.0112 96.635 16.1078 97.0498 16.1931L98.4816 16.4999C99.4475 16.7044 100.274 16.9743 100.962 17.3095C101.649 17.6448 102.212 18.0397 102.649 18.4942C103.087 18.9431 103.408 19.4487 103.612 20.0112C103.823 20.5737 103.93 21.1874 103.936 21.8522C103.93 22.9999 103.644 23.9715 103.075 24.7669C102.507 25.5624 101.695 26.1675 100.638 26.5823C99.5867 26.997 98.3225 27.2044 96.8452 27.2044C95.3282 27.2044 94.0043 26.98 92.8737 26.5311C91.7487 26.0823 90.8737 25.3919 90.2487 24.4601C89.6293 23.5226 89.3168 22.3237 89.3112 20.8635H93.8112C93.8396 21.3976 93.9731 21.8465 94.2117 22.2101C94.4504 22.5737 94.7856 22.8493 95.2174 23.0368C95.6549 23.2243 96.1748 23.3181 96.7771 23.3181C97.2827 23.3181 97.706 23.2556 98.047 23.1306C98.3879 23.0056 98.6464 22.8323 98.8225 22.6107C98.9987 22.3891 99.0896 22.1362 99.0952 21.8522C99.0896 21.5851 99.0015 21.3522 98.831 21.1533C98.6663 20.9487 98.3935 20.7669 98.0129 20.6078C97.6322 20.4431 97.118 20.2897 96.4702 20.1476L94.7316 19.7726C93.1862 19.4374 91.9674 18.8777 91.0754 18.0936C90.189 17.3039 89.7487 16.2272 89.7543 14.8635C89.7487 13.7556 90.0441 12.7868 90.6407 11.9573C91.243 11.122 92.0754 10.4715 93.1379 10.0056C94.206 9.53966 95.4305 9.3067 96.8112 9.3067C98.2202 9.3067 99.439 9.5425 100.467 10.0141C101.496 10.4857 102.288 11.1505 102.845 12.0084C103.408 12.8607 103.692 13.8578 103.698 14.9999H99.1634Z" fill="#8B0A5F"/>
<path d="M83.3181 9.54547H87.9886V21.5114C87.9829 22.6477 87.696 23.6477 87.1278 24.5114C86.5653 25.3693 85.7869 26.0398 84.7926 26.5227C83.8039 27 82.6647 27.2387 81.3749 27.2387C80.2556 27.2387 79.2329 27.0455 78.3068 26.6591C77.3806 26.2671 76.642 25.6534 76.0909 24.8182C75.5397 23.9773 75.267 22.8864 75.2727 21.5455H80.0113C80.0284 21.983 80.1022 22.3523 80.2329 22.6534C80.3693 22.9546 80.5568 23.1818 80.7954 23.3352C81.0397 23.483 81.3352 23.5568 81.6818 23.5568C82.034 23.5568 82.3295 23.4801 82.5681 23.3267C82.8124 23.1733 82.9971 22.946 83.1221 22.6449C83.2471 22.3381 83.3124 21.9602 83.3181 21.5114V9.54547Z" fill="#8B0A5F"/>
<path d="M5 60C2.23858 60 -9.78513e-08 57.7614 -2.18557e-07 55L-2.40413e-06 5C-2.52483e-06 2.23858 2.23857 -9.78513e-08 5 -2.18557e-07L55 -2.40413e-06C57.7614 -2.52483e-06 60 2.23857 60 5L60 55C60 57.7614 57.7614 60 55 60L5 60Z" fill="#8B0A5F"/>
<path d="M9.23071 43.8461C9.23071 39.1729 13.0191 35.3846 17.6923 35.3846V35.3846C22.3654 35.3846 26.1538 39.1729 26.1538 43.8461V43.8461C26.1538 48.5193 22.3654 52.3077 17.6922 52.3077V52.3077C13.0191 52.3077 9.23071 48.5193 9.23071 43.8461V43.8461Z" fill="white"/>
<path d="M35.3845 17.6924C35.3845 13.0192 39.1729 9.23084 43.8461 9.23084V9.23084C48.5192 9.23084 52.3076 13.0192 52.3076 17.6924V17.6924C52.3076 22.3656 48.5192 26.1539 43.8461 26.1539V26.1539C39.1729 26.1539 35.3845 22.3655 35.3845 17.6924V17.6924Z" fill="white"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M47.6924 33.9422C47.6924 41.5362 41.5363 47.6923 33.9424 47.6923L30.7693 47.6923L30.7693 41.3461L33.9424 41.3461C38.0314 41.3461 41.3462 38.0313 41.3462 33.9423L41.3462 30.7692L47.6924 30.7692L47.6924 33.9422Z" fill="white"/>
</svg>

================
File: jsoncanvas-main/readme.md
================
# An open file format for infinite canvas data.

Infinite canvas tools are a way to view and organize information spatially, like a digital whiteboard. Infinite canvases encourage freedom and exploration, and have become a popular interface pattern across many apps.

The JSON Canvas format was created to provide longevity, readability, interoperability, and extensibility to data created with infinite canvas apps. The format is designed to be easy to parse and give users [ownership over their data](https://stephango.com/file-over-app). JSON Canvas files use the `.canvas` extension. 

JSON Canvas was originally created for [Obsidian](https://obsidian.md/blog/json-canvas/). JSON Canvas can be implemented freely as an import, export, and storage format for any [app or tool](/docs/apps.md). This site, and all the resources associated with JSON Canvas are [open source](https://github.com/obsidianmd/jsoncanvas) under the MIT license.

================
File: jsoncanvas-main/sample.canvas
================
{
	"nodes":[
		{"id":"754a8ef995f366bc","type":"group","x":-300,"y":-460,"width":610,"height":200,"label":"JSON Canvas"},
		{"id":"8132d4d894c80022","type":"file","file":"readme.md","x":-280,"y":-200,"width":570,"height":560,"color":"6"},
		{"id":"7efdbbe0c4742315","type":"file","file":"_site/logo.svg","x":-280,"y":-440,"width":217,"height":80},
		{"id":"59e896bc8da20699","type":"text","text":"Learn more:\n\n- [Apps](/docs/apps.md)\n- [Spec](spec/1.0.md)\n- [Github](https://github.com/obsidianmd/jsoncanvas)","x":40,"y":-440,"width":250,"height":160},
		{"id":"0ba565e7f30e0652","type":"file","file":"spec/1.0.md","x":360,"y":-400,"width":400,"height":400}
	],
	"edges":[
		{"id":"6fa11ab87f90b8af","fromNode":"7efdbbe0c4742315","fromSide":"right","toNode":"59e896bc8da20699","toSide":"left"}
	]
}

================
File: jsoncanvas-main/spec/1.0.md
================
# JSON Canvas Spec

<small>Version 1.0  2024-03-11</small>

## Top level

The top level of JSON Canvas contains two arrays:

- `nodes` (optional, array of nodes)
- `edges` (optional, array of edges)

## Nodes

Nodes are objects within the canvas. Nodes may be text, files, links, or groups.

Nodes are placed in the array in ascending order by z-index. The first node in the array should be displayed below all other nodes, and the last node in the array should be displayed on top of all other nodes.

### Generic node

All nodes include the following attributes:

- `id` (required, string) is a unique ID for the node.
- `type` (required, string) is the node type.
  - `text`
  - `file`
  - `link`
  - `group`
- `x` (required, integer) is the `x` position of the node in pixels.
- `y` (required, integer) is the `y` position of the node in pixels.
- `width` (required, integer) is the width of the node in pixels.
- `height` (required, integer) is the height of the node in pixels.
- `color` (optional, `canvasColor`) is the color of the node, see the Color section.

### Text type nodes

Text type nodes store text. Along with generic node attributes, text nodes include the following attribute:

- `text` (required, string) in plain text with Markdown syntax.

### File type nodes

File type nodes reference other files or attachments, such as images, videos, etc. Along with generic node attributes, file nodes include the following attributes:

- `file` (required, string) is the path to the file within the system.
- `subpath` (optional, string) is a subpath that may link to a heading or a block. Always starts with a `#`.

### Link type nodes

Link type nodes reference a URL. Along with generic node attributes, link nodes include the following attribute:

- `url` (required, string)

### Group type nodes

Group type nodes are used as a visual container for nodes within it. Along with generic node attributes, group nodes include the following attributes:

- `label` (optional, string) is a text label for the group.
- `background` (optional, string) is the path to the background image.
- `backgroundStyle` (optional, string) is the rendering style of the background image. Valid values:
  - `cover` fills the entire width and height of the node.
  - `ratio` maintains the aspect ratio of the background image.
  - `repeat` repeats the image as a pattern in both x/y directions.

## Edges

Edges are lines that connect one node to another.

- `id` (required, string) is a unique ID for the edge.
- `fromNode` (required, string) is the node `id` where the connection starts.
- `fromSide` (optional, string) is the side where this edge starts. Valid values:
  - `top`
  - `right`
  - `bottom`
  - `left`
- `fromEnd` (optional, string) is the shape of the endpoint at the edge start. Defaults to `none` if not specified. Valid values:
  - `none`
  - `arrow`
- `toNode` (required, string) is the node `id` where the connection ends.
- `toSide` (optional, string) is the side where this edge ends. Valid values:
  - `top`
  - `right`
  - `bottom`
  - `left`
- `toEnd`  (optional, string) is the shape of the endpoint at the edge end. Defaults to `arrow` if not specified. Valid values:
  - `none`
  - `arrow`
- `color` (optional, `canvasColor`) is the color of the line, see the Color section.
- `label` (optional, string) is a text label for the edge.


## Color

The `canvasColor` type is used to encode color data for nodes and edges. Colors attributes expect a string. Colors can be specified in hex format e.g. `"#FF0000"`, or using one of the preset colors, e.g. `"1"` for red. Six preset colors exist, mapped to the following numbers:

- `"1"` red
- `"2"` orange
- `"3"` yellow
- `"4"` green
- `"5"` cyan
- `"6"` purple

Specific values for the preset colors are intentionally not defined so that applications can tailor the presets to their specific brand colors or color scheme.

================
File: move-mode-documentation.txt
================
# File Drag-and-Drop Functionality

This document describes the drag-and-drop functionality implemented in the ExplorerWindow component, which allows users to move files and folders by dragging and dropping them.

## Overview

The drag-and-drop functionality enables admin users to move files and folders within the file explorer by dragging them to a different folder. This provides a more intuitive and user-friendly way to organize files compared to using commands or buttons.

## Implementation Details

### Frontend (ExplorerWindow.jsx)

1. **State Variables**:
   - `draggedItem`: Tracks the item being dragged
   - `dropTarget`: Tracks the folder where the item can be dropped
   - `isMoving`: Indicates if a move operation is in progress

2. **Event Handlers**:
   - `handleDragStart`: Triggered when a user starts dragging a file or folder
   - `handleDragOver`: Triggered when a dragged item is over a potential drop target
   - `handleDragLeave`: Triggered when a dragged item leaves a potential drop target
   - `handleDrop`: Triggered when a dragged item is dropped on a valid target

3. **Visual Feedback**:
   - CSS classes provide visual feedback during drag operations:
     - `.dragging`: Applied to the item being dragged
     - `.drop-target`: Applied to folders that can accept the dragged item

4. **Restrictions**:
   - Only admin users can drag and drop files
   - Files can only be dropped into directories
   - Files cannot be dropped onto themselves
   - Files cannot be dropped into their current parent directory

### Backend (server-files.js)

The backend supports file movement through the `/api/files/move` endpoint, which:

1. Validates source and destination paths
2. Handles both public and private files
3. Prevents invalid operations (e.g., moving from public to private folders)
4. Checks for name conflicts at the destination
5. Performs the actual file move operation using Node.js fs.renameSync

## CSS Styling

Custom CSS styles in ExplorerWindow.css provide visual feedback during drag operations:

```css
[draggable] {
  cursor: grab;
}

[draggable]:active {
  cursor: grabbing;
}

.drop-target {
  background-color: rgba(20, 184, 166, 0.2) !important;
  border: 2px dashed rgb(20, 184, 166) !important;
  border-radius: 0.25rem;
}

.dragging {
  opacity: 0.5;
  background-color: rgba(20, 184, 166, 0.1);
}
```

## Usage

1. Admin users can drag any file or folder by clicking and holding on it
2. While dragging, folders will highlight when hovered over to indicate they are valid drop targets
3. Dropping the file or folder into a highlighted folder will move it to that location
4. The file tree will automatically refresh to show the updated file structure

## Error Handling

The implementation includes comprehensive error handling:

1. Client-side validation prevents invalid drop operations
2. Server-side validation ensures the move operation is valid
3. Error messages are displayed to the user if a move operation fails
4. The UI state is reset if an error occurs during the move operation

## Future Enhancements

Potential future enhancements to the drag-and-drop functionality:

1. Multi-select and drag multiple files at once
2. Copy files with a modifier key (e.g., Ctrl+drag)
3. Drag files from the file explorer to other components (e.g., editor)
4. Drag files from outside the application into the file explorer

================
File: package.json
================
{
  "name": "window-manager",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@tailwindcss/typography": "^0.5.16",
    "@tailwindcss/vite": "^4.0.6",
    "axios": "^1.8.1",
    "buffer": "^6.0.3",
    "events": "^3.3.0",
    "jszip": "^3.10.1",
    "lucide-react": "^0.475.0",
    "path-browserify": "^1.0.1",
    "process-nextick-args": "^2.0.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "reactflow": "^11.11.4",
    "showdown": "^2.1.0",
    "simple-peer": "^9.11.1",
    "socket.io-client": "^4.8.1",
    "stream-browserify": "^3.0.0",
    "tailwindcss": "^4.0.6"
  },
  "devDependencies": {
    "@eslint/js": "^9.19.0",
    "@types/react": "^19.0.8",
    "@types/react-dom": "^19.0.3",
    "@vitejs/plugin-react": "^1.3.2",
    "eslint": "^9.19.0",
    "eslint-plugin-react": "^7.37.4",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.18",
    "global": "^4.4.0",
    "globals": "^15.14.0",
    "process": "^0.11.10",
    "vite": "^6.1.0",
    "vite-compatible-readable-stream": "^3.6.1",
    "vite-plugin-node-polyfills": "^0.23.0"
  }
}

================
File: public/agooba_favicon.svg
================
<?xml version="1.0" encoding="UTF-8"?>
<svg id="Layer_2" data-name="Layer 2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 855.46 855.46">
  <defs>
    <style>
      .cls-1 {
        stroke: #fff;
        stroke-miterlimit: 10;
        stroke-width: 4px;
      }

      .cls-1, .cls-2 {
        fill: #00d5be;
      }
    </style>
  </defs>
  <g id="Layer_1-2" data-name="Layer 1-2">
    <g>
      <g>
        <g>
          <polygon class="cls-2" points="162.5 726.45 159.81 729.46 156.85 726.77 159.53 723.8 162.5 726.45"/>
          <path class="cls-2" d="M262.38,791.47l-1.64,3.65c-1.24-.52-2.45-1.08-3.65-1.68l1.68-3.61c1.2.56,2.41,1.12,3.61,1.64h0Z"/>
          <rect class="cls-2" x="172.91" y="737.62" width="4.02" height="4.02" transform="translate(-510.37 410.94) rotate(-51.07)"/>
          <path class="cls-2" d="M226.96,773.18l-2.01,3.49c-1.16-.68-2.33-1.36-3.49-2.05l2.09-3.45c1.12.68,2.29,1.36,3.41,2.01Z"/>
          <polygon class="cls-2" points="210 762.75 207.83 766.12 204.46 763.87 206.67 760.54 210 762.75"/>
          <path class="cls-2" d="M244.45,782.81l-1.85,3.53c-1.2-.6-2.37-1.2-3.57-1.85l1.89-3.57c1.16.64,2.37,1.24,3.53,1.89h0Z"/>
          <rect class="cls-2" x="188.78" y="749.84" width="4.02" height="4.02" transform="translate(-529.26 463.4) rotate(-53.93)"/>
          <polygon class="cls-2" points="280.75 799.29 279.27 803.02 275.54 801.5 277.02 797.81 280.75 799.29"/>
          <polygon class="cls-2" points="376.99 823.96 376.46 827.97 372.49 827.41 373.05 823.44 376.99 823.96"/>
          <polygon class="cls-2" points="396.8 826.01 396.48 830.02 392.47 829.66 392.83 825.69 396.8 826.01"/>
          <polygon class="cls-2" points="416.7 827.05 416.58 831.06 412.57 830.9 412.73 826.93 416.7 827.05"/>
          <path class="cls-2" d="M299.45,806.11l-1.28,3.81c-1.28-.44-2.53-.84-3.81-1.28l1.32-3.81c1.24.44,2.53.88,3.77,1.28Z"/>
          <path class="cls-2" d="M318.46,812.05l-1.08,3.85c-1.28-.36-2.57-.72-3.85-1.12l1.12-3.85c1.28.4,2.57.76,3.81,1.12Z"/>
          <path class="cls-2" d="M337.8,816.98l-.92,3.93c-1.32-.32-2.61-.64-3.93-.92l.96-3.93c1.28.32,2.57.64,3.89.92Z"/>
          <polygon class="cls-2" points="357.29 820.95 356.61 824.92 352.64 824.2 353.36 820.27 357.29 820.95"/>
          <polygon class="cls-2" points="86.21 635.11 82.76 637.2 80.71 633.75 84.16 631.7 86.21 635.11"/>
          <polygon class="cls-2" points="45.61 544.54 41.8 545.7 40.64 541.85 44.49 540.73 45.61 544.54"/>
          <path class="cls-2" d="M59.13,581.96l-3.69,1.56c-.52-1.24-1.04-2.49-1.56-3.73l3.73-1.52c.48,1.24,1,2.49,1.52,3.69Z"/>
          <path class="cls-2" d="M35.95,505.91l-3.93.8c-.28-1.32-.52-2.65-.76-3.97l3.93-.72c.24,1.28.48,2.61.76,3.89Z"/>
          <path class="cls-2" d="M51.91,563.43l-3.77,1.32c-.48-1.24-.92-2.49-1.36-3.77l3.81-1.32c.44,1.24.88,2.49,1.32,3.77Z"/>
          <polygon class="cls-2" points="147.94 712.85 145.13 715.7 142.29 712.89 145.25 710.2 147.94 712.85"/>
          <path class="cls-2" d="M28.69,446.66l-3.97.2c-.08-1.36-.12-2.69-.2-4.05l4.01-.12c.04,1.32.12,2.65.16,3.97h0Z"/>
          <path class="cls-2" d="M30.13,466.52l-3.97.4c-.16-1.36-.28-2.69-.4-4.01l4.01-.36c.12,1.32.24,2.65.36,3.97Z"/>
          <polygon class="cls-2" points="32.54 486.29 28.57 486.85 28 482.88 31.98 482.36 32.54 486.29"/>
          <path class="cls-2" d="M40.32,525.32l-3.89,1c-.32-1.32-.64-2.61-.96-3.93l3.89-.92c.32,1.28.64,2.57.96,3.85Z"/>
          <path class="cls-2" d="M120.91,683.61l-3.05,2.57c-.88-1.04-1.72-2.09-2.57-3.13l3.09-2.53c.84,1.04,1.68,2.05,2.53,3.09Z"/>
          <path class="cls-2" d="M134.06,698.57l-2.93,2.69c-.92-.96-1.81-1.97-2.73-2.97l2.97-2.69c.92,1,1.81,1.97,2.69,2.97h0Z"/>
          <path class="cls-2" d="M67.27,600.13l-3.65,1.72c-.56-1.2-1.12-2.41-1.68-3.65l3.61-1.68c.56,1.2,1.12,2.41,1.72,3.61h0Z"/>
          <path class="cls-2" d="M108.55,668l-3.21,2.41c-.8-1.04-1.6-2.13-2.41-3.21l3.25-2.37c.76,1.04,1.56,2.13,2.37,3.17h0Z"/>
          <polygon class="cls-2" points="76.3 617.86 72.77 619.79 70.89 616.22 74.42 614.37 76.3 617.86"/>
          <path class="cls-2" d="M436.71,831.1c-1.32.04-2.69.04-4.01.08l-.08-4.01c1.32-.04,2.69-.04,4.01-.08l.08,4.01Z"/>
          <polygon class="cls-2" points="96.96 651.84 93.63 654.08 91.42 650.75 94.75 648.55 96.96 651.84"/>
          <polygon class="cls-2" points="826.65 448.83 830.66 449.03 830.42 453.04 826.41 452.8 826.65 448.83"/>
          <polygon class="cls-2" points="790.83 603.94 789.06 607.55 785.45 605.75 787.22 602.18 790.83 603.94"/>
          <polygon class="cls-2" points="781.56 621.83 779.64 625.36 776.11 623.4 778.07 619.91 781.56 621.83"/>
          <path class="cls-2" d="M799.17,585.61c-.52,1.24-1.08,2.49-1.6,3.69l-3.69-1.6c.56-1.2,1.08-2.45,1.6-3.65l3.69,1.56Z"/>
          <path class="cls-2" d="M806.55,566.88c-.44,1.28-.92,2.53-1.4,3.77l-3.73-1.4c.44-1.24.92-2.49,1.36-3.73l3.77,1.36Z"/>
          <path class="cls-2" d="M748.63,672.42c-.84,1.04-1.64,2.13-2.49,3.17l-3.17-2.45c.84-1.04,1.64-2.13,2.45-3.17l3.21,2.45h0Z"/>
          <rect class="cls-2" x="766.65" y="637.81" width="4.02" height="4.02" transform="translate(-180.94 953.63) rotate(-58.06)"/>
          <path class="cls-2" d="M760.46,656.09c-.76,1.12-1.52,2.21-2.33,3.33l-3.29-2.33c.8-1.08,1.52-2.17,2.29-3.25l3.33,2.25Z"/>
          <polygon class="cls-2" points="28.25 426.73 24.23 426.73 24.27 422.71 28.29 422.75 28.25 426.73"/>
          <path class="cls-2" d="M735.99,688.1c-.88,1.04-1.77,2.05-2.65,3.09l-3.01-2.65c.84-1,1.72-2.01,2.57-3.05l3.09,2.61Z"/>
          <polygon class="cls-2" points="825.12 468.68 829.1 469.08 828.69 473.1 824.68 472.65 825.12 468.68"/>
          <rect class="cls-2" x="827.14" y="428.89" width="4.01" height="4.01" transform="translate(390.02 1255.71) rotate(-89.43)"/>
          <path class="cls-2" d="M819.07,508.03l3.97.8-.84,3.97-3.93-.84c.28-1.32.56-2.61.8-3.93h0Z"/>
          <polygon class="cls-2" points="818.51 528.45 817.46 532.34 813.61 531.34 814.62 527.45 818.51 528.45"/>
          <path class="cls-2" d="M813.01,547.83c-.4,1.28-.8,2.57-1.2,3.85l-3.81-1.24c.4-1.24.8-2.53,1.2-3.81l3.81,1.2Z"/>
          <rect class="cls-2" x="822.26" y="488.73" width="4.02" height="4.02" transform="translate(208.31 1226.17) rotate(-80.82)"/>
          <polygon class="cls-2" points="722.6 703.14 719.83 706.07 716.94 703.3 719.67 700.41 722.6 703.14"/>
          <path class="cls-2" d="M535.95,816.5c-1.28.36-2.57.68-3.89,1.04l-1-3.89c1.28-.32,2.57-.68,3.81-1.04l1.08,3.89Z"/>
          <polygon class="cls-2" points="555.21 810.64 551.36 811.89 550.15 808.08 553.92 806.83 555.21 810.64"/>
          <path class="cls-2" d="M574.1,803.82l-3.73,1.44-1.4-3.77c1.2-.44,2.45-.92,3.69-1.4l1.44,3.73h0Z"/>
          <path class="cls-2" d="M496.72,825.28c-1.32.24-2.65.44-3.97.68l-.64-3.97c1.32-.2,2.61-.44,3.93-.64l.68,3.93h0Z"/>
          <path class="cls-2" d="M516.46,821.39c-1.32.28-2.61.56-3.93.84l-.84-3.93c1.28-.28,2.61-.56,3.89-.84l.88,3.93Z"/>
          <polygon class="cls-2" points="476.83 828.21 472.81 828.69 472.37 824.68 476.34 824.24 476.83 828.21"/>
          <path class="cls-2" d="M592.67,796.08c-1.24.52-2.45,1.08-3.69,1.6l-1.6-3.65c1.24-.56,2.45-1.08,3.65-1.6l1.64,3.65h0Z"/>
          <polygon class="cls-2" points="662.27 756.09 659.02 758.42 656.69 755.13 659.94 752.84 662.27 756.09"/>
          <path class="cls-2" d="M693.72,731.14c-1,.88-2.01,1.76-3.01,2.65l-2.65-3.05c1-.88,2.01-1.76,3.01-2.61l2.65,3.01h0Z"/>
          <polygon class="cls-2" points="678.31 744.02 675.14 746.5 672.7 743.33 675.82 740.89 678.31 744.02"/>
          <polygon class="cls-2" points="708.52 717.5 705.63 720.27 702.86 717.38 705.71 714.61 708.52 717.5"/>
          <polygon class="cls-2" points="645.66 767.4 642.25 769.53 640.12 766.16 643.49 764.03 645.66 767.4"/>
          <path class="cls-2" d="M456.81,830.18c-1.32.08-2.69.16-4.01.24l-.24-4.01c1.32-.08,2.65-.16,3.97-.24l.28,4.01Z"/>
          <path class="cls-2" d="M628.49,777.83c-1.16.68-2.33,1.32-3.53,1.97l-1.93-3.49c1.12-.64,2.29-1.28,3.45-1.97l2.01,3.49Z"/>
          <path class="cls-2" d="M610.8,787.42c-1.2.6-2.41,1.2-3.57,1.81l-1.81-3.61c1.16-.6,2.37-1.16,3.53-1.76l1.85,3.57h0Z"/>
          <path class="cls-2" d="M815.22,330.29l3.89-.96c.32,1.28.64,2.61.96,3.89l-3.93.92c-.28-1.28-.6-2.57-.92-3.85h0Z"/>
          <polygon class="cls-2" points="803.62 292.23 807.39 290.86 808.76 294.63 804.95 295.96 803.62 292.23"/>
          <polygon class="cls-2" points="809.88 311.12 813.73 309.96 814.9 313.81 811.04 314.93 809.88 311.12"/>
          <polygon class="cls-2" points="819.55 349.75 823.52 348.95 824.24 352.92 820.31 353.64 819.55 349.75"/>
          <polygon class="cls-2" points="822.96 369.36 826.93 368.76 827.49 372.77 823.52 373.29 822.96 369.36"/>
          <rect class="cls-2" x="779.97" y="236.54" width="4" height="4" transform="translate(-20.15 396.58) rotate(-28.11)"/>
          <path class="cls-2" d="M788.3,255.52l3.61-1.77c.6,1.2,1.16,2.41,1.72,3.65l-3.65,1.68c-.56-1.2-1.12-2.41-1.68-3.57h0Z"/>
          <path class="cls-2" d="M769.37,220.51l3.45-2.09c.68,1.16,1.36,2.29,2.05,3.45l-3.45,2.05c-.68-1.12-1.36-2.29-2.05-3.41Z"/>
          <path class="cls-2" d="M796.44,273.66l3.69-1.52c.52,1.2,1,2.45,1.52,3.69l-3.73,1.52c-.48-1.24-1-2.45-1.48-3.69h0Z"/>
          <polygon class="cls-2" points="497.97 34.42 498.65 30.49 502.62 31.21 501.9 35.14 497.97 34.42"/>
          <path class="cls-2" d="M438.56,28.41l.12-4.01c1.32,0,2.65.08,4.01.12l-.16,4.01c-1.32-.04-2.65-.12-3.97-.12Z"/>
          <polygon class="cls-2" points="458.45 29.41 458.74 25.44 462.75 25.76 462.43 29.73 458.45 29.41"/>
          <polygon class="cls-2" points="478.27 31.41 478.75 27.44 482.76 27.96 482.2 31.94 478.27 31.41"/>
          <path class="cls-2" d="M826.77,409l4.01-.2c.08,1.36.12,2.69.16,4.05l-4.01.12c-.04-1.32-.08-2.65-.16-3.97h0Z"/>
          <polygon class="cls-2" points="28.81 406.83 24.8 406.63 25.04 402.62 29.05 402.86 28.81 406.83"/>
          <path class="cls-2" d="M517.5,38.39l.88-3.89c1.28.28,2.61.6,3.93.92l-.96,3.89c-1.28-.32-2.57-.6-3.85-.92Z"/>
          <path class="cls-2" d="M825.37,389.14l3.97-.4c.12,1.32.24,2.69.36,4.01l-3.97.32c-.12-1.28-.24-2.61-.36-3.93h0Z"/>
          <path class="cls-2" d="M610.84,72.57l1.81-3.57c1.2.6,2.41,1.24,3.61,1.85l-1.89,3.57c-1.2-.64-2.37-1.24-3.53-1.85h0Z"/>
          <path class="cls-2" d="M628.29,82.12l2.01-3.45c1.16.68,2.33,1.36,3.49,2.05l-2.05,3.45c-1.12-.68-2.29-1.36-3.45-2.05Z"/>
          <polygon class="cls-2" points="645.3 92.59 647.47 89.22 650.83 91.42 648.63 94.79 645.3 92.59"/>
          <path class="cls-2" d="M574.54,56.08l1.44-3.73c1.28.48,2.53,1,3.77,1.48l-1.52,3.73c-1.24-.48-2.45-1-3.69-1.48Z"/>
          <path class="cls-2" d="M758.62,203.78l3.33-2.25c.72,1.08,1.48,2.21,2.25,3.33l-3.37,2.21c-.72-1.12-1.44-2.21-2.21-3.29h0Z"/>
          <rect class="cls-2" x="556.3" y="45.97" width="4.02" height="4.02" transform="translate(334.67 561.79) rotate(-71.39)"/>
          <polygon class="cls-2" points="661.71 103.86 664.07 100.61 667.32 103.02 664.95 106.22 661.71 103.86"/>
          <polygon class="cls-2" points="592.87 63.87 594.56 60.22 598.21 61.9 596.52 65.51 592.87 63.87"/>
          <polygon class="cls-2" points="734.67 172.01 737.76 169.44 740.33 172.53 737.2 175.1 734.67 172.01"/>
          <path class="cls-2" d="M721.55,157.05l2.93-2.73c.92,1,1.81,1.97,2.73,2.97l-3.01,2.69c-.88-.96-1.77-1.97-2.65-2.93h0Z"/>
          <polygon class="cls-2" points="677.59 115.97 680.08 112.84 683.21 115.37 680.68 118.5 677.59 115.97"/>
          <rect class="cls-2" x="747.84" y="185.98" width="4.01" height="4.01" transform="translate(37.18 487.5) rotate(-36.87)"/>
          <polygon class="cls-2" points="692.79 128.85 695.48 125.84 698.49 128.53 695.76 131.5 692.79 128.85"/>
          <path class="cls-2" d="M710.2,145.25c-.92-.96-1.89-1.89-2.85-2.81l2.81-2.89c.96.96,1.93,1.89,2.89,2.85l.28.28-2.85,2.85-.28-.28h0Z"/>
          <polygon class="cls-2" points="536.79 43.37 537.88 39.48 541.73 40.6 540.6 44.45 536.79 43.37"/>
          <path class="cls-2" d="M64.55,251.67c.6-1.2,1.16-2.41,1.76-3.61l3.61,1.8c-.6,1.16-1.16,2.37-1.76,3.57l-3.61-1.77h0Z"/>
          <path class="cls-2" d="M73.77,233.78c.64-1.16,1.32-2.33,1.97-3.53l3.49,1.97c-.64,1.16-1.28,2.33-1.93,3.49l-3.53-1.93h0Z"/>
          <polygon class="cls-2" points="94.91 199.53 97.2 196.2 100.49 198.48 98.2 201.77 94.91 199.53"/>
          <rect class="cls-2" x="147.65" y="136.12" width="4" height="4" transform="translate(-53.96 141.94) rotate(-43.78)"/>
          <path class="cls-2" d="M132.7,152.47c.92-1,1.85-1.97,2.77-2.93l2.93,2.73c-.92.96-1.85,1.97-2.73,2.93l-2.97-2.73Z"/>
          <polygon class="cls-2" points="106.71 183.2 109.19 179.99 112.36 182.48 109.91 185.65 106.71 183.2"/>
          <path class="cls-2" d="M119.34,167.52c.88-1.04,1.72-2.09,2.61-3.09l3.05,2.61c-.88,1-1.72,2.05-2.61,3.05l-3.05-2.57Z"/>
          <path class="cls-2" d="M83.92,216.37c.68-1.12,1.4-2.29,2.13-3.41l3.41,2.13c-.72,1.12-1.44,2.29-2.13,3.41l-3.41-2.13Z"/>
          <path class="cls-2" d="M418.54,24.35c1.36-.04,2.69-.08,4.01-.08l.08,4.01c-1.32,0-2.69.04-4.01.08l-.08-4.01Z"/>
          <path class="cls-2" d="M36.35,347.58l-3.93-.8c.24-1.32.52-2.65.8-3.93l3.93.84c-.28,1.28-.56,2.61-.8,3.89h0Z"/>
          <path class="cls-2" d="M56.24,270c.52-1.2,1.04-2.45,1.56-3.69l3.69,1.6c-.52,1.2-1.04,2.45-1.56,3.65l-3.69-1.56Z"/>
          <polygon class="cls-2" points="30.33 386.97 26.32 386.53 26.76 382.56 30.77 383 30.33 386.97"/>
          <path class="cls-2" d="M48.82,288.74c.48-1.24.92-2.53,1.4-3.77l3.77,1.4c-.48,1.24-.92,2.49-1.4,3.73l-3.77-1.36h0Z"/>
          <polygon class="cls-2" points="36.91 327.17 37.91 323.27 41.8 324.32 40.8 328.17 36.91 327.17"/>
          <path class="cls-2" d="M42.41,307.79c.4-1.28.8-2.53,1.2-3.81l3.81,1.2c-.4,1.28-.8,2.53-1.2,3.81l-3.81-1.2Z"/>
          <polygon class="cls-2" points="32.86 367.2 28.89 366.6 29.49 362.62 33.46 363.27 32.86 367.2"/>
          <polygon class="cls-2" points="319.3 39 323.19 37.95 324.2 41.8 320.39 42.89 319.3 39"/>
          <path class="cls-2" d="M338.8,34.1c1.32-.28,2.61-.6,3.93-.88l.84,3.93c-1.28.28-2.61.56-3.89.84l-.88-3.89h0Z"/>
          <polygon class="cls-2" points="300.05 44.85 303.9 43.61 305.1 47.42 301.33 48.66 300.05 44.85"/>
          <polygon class="cls-2" points="358.53 30.17 362.5 29.53 363.15 33.46 359.22 34.14 358.53 30.17"/>
          <path class="cls-2" d="M161.58,124.44c1-.88,2.01-1.77,3.05-2.65l2.61,3.05c-1,.88-2.01,1.77-3.01,2.61l-2.65-3.01h0Z"/>
          <polygon class="cls-2" points="378.43 27.24 382.44 26.76 382.88 30.77 378.91 31.21 378.43 27.24"/>
          <polygon class="cls-2" points="281.16 51.67 284.89 50.27 286.33 54 282.6 55.44 281.16 51.67"/>
          <path class="cls-2" d="M398.45,25.28c1.32-.08,2.69-.16,4.01-.24l.24,3.97c-1.32.08-2.65.2-3.97.28l-.28-4.01Z"/>
          <polygon class="cls-2" points="262.62 59.45 266.27 57.81 267.88 61.5 264.23 63.1 262.62 59.45"/>
          <path class="cls-2" d="M176.98,111.56c1.04-.84,2.09-1.68,3.17-2.49l2.45,3.17c-1.04.8-2.09,1.6-3.13,2.45l-2.49-3.13h0Z"/>
          <path class="cls-2" d="M209.64,88.17c1.12-.76,2.25-1.44,3.37-2.17l2.17,3.37c-1.12.72-2.25,1.44-3.37,2.17l-2.17-3.37Z"/>
          <path class="cls-2" d="M193.03,99.45c1.08-.76,2.17-1.56,3.25-2.33l2.33,3.29c-1.08.76-2.17,1.52-3.25,2.29l-2.33-3.25Z"/>
          <path class="cls-2" d="M244.49,68.12c1.16-.6,2.37-1.2,3.57-1.8l1.76,3.61c-1.16.56-2.33,1.16-3.53,1.76l-1.8-3.57Z"/>
          <path class="cls-2" d="M226.8,77.7c1.16-.68,2.33-1.32,3.49-2.01l1.97,3.53c-1.16.64-2.29,1.28-3.45,1.97l-2.01-3.49h0Z"/>
          <path class="cls-2" d="M737.72,202.5l-191.58-139.19h-118.29l-.12-.08-.12.08h-118.29l-.52.36L117.74,202.5l-.2.6-73.01,224.63.2.6,73.01,224.63.52.36,191.06,138.83h118.37l.04.04.04-.04h118.37l191.58-139.19.2-.64,73.01-224.59-.2-.64-73.01-224.59h0ZM635.35,140.53l-35.14,48.01-64.3-46.73h0c.17-.41.29-.84.4-1.28h99.04ZM319.14,140.53c.11.46.24.91.42,1.34l-64.32,46.71-35.14-48.05h99.04ZM121.47,436.33c.25.02.48.07.73.07.23,0,.44-.05.66-.07h0l26.43,81.4-60.81,20.1,32.97-101.48v-.02h.02ZM220.1,714.93l35.14-48.05,64.31,46.71c-.18.43-.31.88-.42,1.34h-99.03,0ZM536.31,714.93c-.11-.46-.24-.91-.42-1.34l64.31-46.71,35.14,48.05h-99.04,0ZM733.97,419.09c-.21-.01-.41-.06-.62-.06-.26,0-.51.05-.76.08v-.04l-26.45-81.35,60.77-20.1-32.93,101.44v.03h-.01ZM674.53,253.4l26.55,81.79-18.25,6.02c-12.8-38.03-34.34-73.77-64.62-104.01-9.39-9.39-19.33-17.97-29.76-25.75l12.64-17.29,64.74,47.05h0c-.48,1.08-.76,2.27-.76,3.53,0,4.8,3.89,8.69,8.69,8.69.26,0,.5-.05.76-.08l.02.05h-.01ZM597.83,191.79l-12.64,17.29c-44.89-32.49-98.56-50.26-155-50.74l-.48-.36v-17.45h89.72c.91,3.82,4.33,6.67,8.43,6.67,2.16,0,4.11-.82,5.63-2.12l.03.03,64.3,46.69h.01ZM425.71,140.53v17.49l-.4.32c-56.44.48-110.15,18.21-155.08,50.74l-12.64-17.29,64.3-46.69.03-.02c1.52,1.3,3.47,2.12,5.63,2.12,4.1,0,7.52-2.85,8.43-6.67h89.73ZM190.39,244.48c0-1.19-.24-2.33-.68-3.36l64.64-46.96,12.64,17.29c-10.43,7.78-20.38,16.37-29.76,25.75-30.29,30.24-51.83,65.99-64.62,104.01l-18.25-6.06,26.63-82.03v-.03c.25.02.47.07.71.07,4.8,0,8.69-3.89,8.69-8.69h0ZM130.89,427.73c0-3.16-1.7-5.9-4.22-7.42v-.03l26.44-81.31,18.25,6.06c-17.25,53.71-17.21,111.75,0,165.42l-18.25,6.02-26.43-81.31h0c2.52-1.54,4.22-4.27,4.22-7.43h0ZM180.99,602.31l-26.68-82.03,18.33-6.06c12.8,38.03,34.34,73.77,64.58,104.01,9.39,9.39,19.33,17.97,29.76,25.79l-12.64,17.25-64.63-46.95c.43-1.03.67-2.16.67-3.34,0-4.8-3.89-8.69-8.69-8.69-.24,0-.46.05-.7.07l-.02-.05h.02ZM257.61,663.64l12.64-17.25h.04c44.89,32.49,98.56,50.22,154.96,50.7l.48.36v17.49h-89.71c-.91-3.83-4.33-6.69-8.44-6.69-2.17,0-4.12.82-5.64,2.13h-.02l-64.3-46.75h-.01ZM429.73,714.94v-17.49l.48-.36c35.1-.28,69.15-7.3,100.68-20.34,19.13-7.9,37.3-18.09,54.27-30.37h.04l12.64,17.25-64.3,46.73-.02.02c-1.52-1.31-3.48-2.13-5.64-2.13-4.11,0-7.53,2.86-8.44,6.69h-89.71ZM665.07,610.71c0,1.26.28,2.46.77,3.54h-.01l-64.74,47.02-12.64-17.25c10.43-7.82,20.38-16.41,29.76-25.79,30.24-30.24,51.79-65.99,64.58-104.01l18.33,6.06-26.59,81.79v.03c-.27-.02-.51-.08-.77-.08-4.8,0-8.69,3.89-8.69,8.69ZM429.73,162.95l66.19,48.1,2.77,2.01,2.77,2.01,51.83,37.67,3.25,2.37,52.11,37.83,2.77,2.05,2.77,1.97,63.38,46.05,1.97,1.44-.76,2.37-24.23,74.49-1.04,3.21-1.04,3.25-21.18,65.22-1.24,3.77-21.38,65.78-1.04,3.21-1.04,3.29-22.46,69.03-.76,2.37h-311.19l-.76-2.37-22.42-69.03-1.08-3.29-1.04-3.25-21.38-65.74-1.2-3.77-21.18-65.22-1.08-3.25-1.04-3.29-24.19-74.37-.76-2.41,1.97-1.44,63.34-46.01,2.81-2.01,2.73-2.01,52.11-37.87,3.25-2.37,51.87-37.67,2.73-2.01,2.77-2.01,66.19-48.1.88-.64h2.25l.88.64h-.1ZM425.72,692.52l-66.15-48.1h136.34l-66.19,48.1-.84.6h-2.33l-.84-.6h0ZM654.56,434.19l24.19,74.45.76,2.37-2.01,1.44-63.34,46.05,19.66-60.49,1.24-3.81,19.49-60.01h.01ZM176.74,508.64l24.19-74.41,19.45,59.97,1.24,3.81,19.66,60.45-63.34-46.01-1.97-1.44.76-2.33v-.04h0ZM299.81,249.47l-3.25,2.37-47.61,34.62,22.42-69.03.76-2.37h75.09l-47.41,34.42h0ZM508.28,215.05h75.05l.76,2.37,22.46,69.03-47.65-34.62-3.25-2.37-47.37-34.42h0ZM677.52,517.42c-12.8,35.78-33.49,69.36-62.09,97.96-8.7,8.7-17.89,16.73-27.52,23.99l24.15-74.37,65.46-47.57h0ZM581.05,644.42c-42.36,30.12-92.46,47.01-145.17,48.58l66.83-48.58h78.34ZM419.6,693c-52.71-1.56-102.81-18.45-145.17-48.58h78.34l66.83,48.58ZM240.06,615.38c-28.6-28.6-49.3-62.13-62.05-97.92l65.42,47.53,24.15,74.37c-9.63-7.26-18.81-15.28-27.52-23.99h0ZM173.83,350.76l24.99,76.98-24.99,76.98c-15.12-50.1-15.12-103.85,0-153.95h0ZM178,338c12.76-35.78,33.45-69.35,62.05-97.96,8.7-8.7,17.93-16.73,27.56-23.99l-24.19,74.41-65.42,47.53h0ZM274.35,211.04c42.36-30.12,92.5-47.05,145.29-48.62l-66.87,48.62h-78.42ZM435.88,162.42c52.75,1.56,102.89,18.49,145.25,48.62h-78.38l-66.87-48.62h0ZM587.87,216.05c9.63,7.26,18.85,15.28,27.56,23.99,28.6,28.6,49.3,62.17,62.09,98l-65.46-47.57-24.19-74.41h0ZM681.69,504.78l-25.03-77.06,25.03-77.06c15.12,50.14,15.12,103.93,0,154.11h0ZM702.35,338.99l26.43,81.35v.02c-2.45,1.54-4.1,4.24-4.1,7.36s1.65,5.82,4.1,7.35l-26.43,81.39-18.25-6.02c17.21-53.67,17.25-111.71.04-165.42l18.21-6.02h0ZM734,436.34l32.97,101.48-60.81-20.14,26.43-81.35v-.02c.27.02.51.08.78.08.21,0,.41-.05.62-.06h0ZM765.77,541.64l-86.2,62.62c-.38-.34-.77-.65-1.21-.92h0l26.55-81.83,60.85,20.14h.01ZM669.34,618.13h0l-30.69,94.47-35.18-48.1,64.78-47.09.04-.03c.33.27.68.52,1.04.74h.01ZM519.88,720.3l-90.13,65.46v-66.83h89.71c.11.46.24.92.42,1.35h0v.02ZM425.74,785.76l-90.13-65.46h0c.18-.45.31-.9.42-1.36h89.71v66.83h0ZM216.83,712.59l-30.61-94.22h0c.41-.26.79-.55,1.15-.86l.02.02,64.62,46.97-35.18,48.1h0ZM89.71,541.63l60.85-20.14,26.63,82.03v.03c-.39.24-.75.52-1.11.82h-.02l-86.36-62.75h.01ZM121.48,419.05l-32.97-101.44,60.81,20.1-26.43,81.35v.03c-.23-.02-.44-.07-.66-.07-.25,0-.48.05-.73.07v-.04h-.02ZM89.71,313.75l86.32-62.7.05-.04c.35.3.73.59,1.13.83l-.02.05-26.63,81.99-60.85-20.14h0ZM186.22,237.05l30.6-94.22,35.18,48.06-64.62,46.97-.03.02c-.36-.3-.73-.58-1.13-.83ZM335.6,135.13l90.13-65.5v66.87h-89.71c-.11-.47-.24-.93-.42-1.37ZM429.74,69.63l90.13,65.5c-.18.44-.31.9-.42,1.37h-89.71v-66.87h0ZM638.65,142.84l30.69,94.43v.02c-.35.22-.69.46-1.01.72l-.03-.02-64.82-47.09,35.18-48.06h0ZM765.77,313.76l-60.85,20.14-26.55-81.79v-.02c.44-.28.84-.59,1.23-.94,0,0,.01,0,.01,0l86.16,62.62h0ZM806.72,427.72l-35.66,109.71-33.21-102.29v-.02c2.51-1.52,4.21-4.26,4.21-7.42s-1.7-5.9-4.22-7.42v-.03l33.22-102.25,35.66,109.71h0ZM734.32,650.47l-92.14,66.95-.64-.84,31.61-97.23v-.02c.22.02.42.06.63.06,4.8,0,8.69-3.89,8.69-8.69,0-1.12-.23-2.17-.61-3.15l86.96-63.17-34.5,106.1h0ZM433.31,788.14l88.93-64.62h.02c1.52,1.29,3.47,2.11,5.63,2.11,4.1,0,7.52-2.85,8.43-6.68h101.97l.64.84-94.06,68.35h-111.56ZM216.54,719.79l.64-.84h101.97c.91,3.83,4.33,6.68,8.43,6.68,2.16,0,4.11-.82,5.63-2.12h.02l88.93,64.63h-111.51l-94.1-68.35h0ZM86.7,544.42l87,63.18h0c-.43,1.05-.68,2.18-.68,3.37,0,4.8,3.89,8.69,8.69,8.69.23,0,.45-.05.68-.07v.04l31.54,96.95-.64.84-92.14-66.95-34.46-106.06h.01ZM48.79,427.73l35.62-109.67,33.25,102.25v.03c-2.47,1.53-4.14,4.25-4.14,7.38s1.67,5.85,4.14,7.38v.02l-33.26,102.29-35.62-109.67h.01ZM121.15,204.98l92.14-66.95.64.84-31.53,96.95v.02c-.24-.02-.46-.07-.69-.07-4.8,0-8.69,3.89-8.69,8.69,0,1.19.24,2.32.67,3.36l-87,63.18s34.46-106.02,34.46-106.02ZM422.15,67.32l-88.93,64.62h0c-1.52-1.31-3.48-2.13-5.64-2.13-4.11,0-7.54,2.86-8.44,6.7h-101.96l-.64-.84,94.1-68.35h111.51ZM638.92,135.67l-.64.84h-101.96c-.9-3.84-4.33-6.7-8.44-6.7-2.14,0-4.08.81-5.6,2.09h0l-88.93-64.59h111.51l94.06,68.35h0ZM734.31,204.98l34.46,106.02-86.91-63.13c.38-.98.61-2.03.61-3.14,0-4.8-3.89-8.69-8.69-8.69-.21,0-.41.05-.62.06v-.04l-31.62-97.19.64-.84,92.14,66.95h-.01Z"/>
        </g>
        <path class="cls-2" d="M427.73,855.46c-114.25,0-221.66-44.49-302.45-125.28C44.49,649.39,0,541.98,0,427.73S44.49,206.07,125.28,125.28C206.07,44.49,313.48,0,427.73,0s221.66,44.49,302.45,125.28c80.79,80.79,125.28,188.2,125.28,302.45s-44.49,221.66-125.28,302.45-188.2,125.28-302.45,125.28h0ZM427.73,5.24C194.76,5.23,5.23,194.76,5.23,427.73s189.53,422.49,422.49,422.49,422.49-189.53,422.49-422.49S660.69,5.23,427.73,5.23h0Z"/>
      </g>
      <g>
        <polygon class="cls-1" points="401.06 270.63 472.12 278.65 485.24 295.86 431.92 323.05 381.86 285.65 401.06 270.63"/>
        <polygon class="cls-1" points="309.7 311.09 440.44 334.95 534.13 308.7 546.85 343.7 430.75 356.83 295.4 344.99 309.7 311.09"/>
        <polygon class="cls-1" points="294.34 377.22 432.01 366.63 552.66 380.84 561.12 414.38 434.49 386.23 305.45 409.6 294.34 377.22"/>
        <polygon class="cls-1" points="433.55 396.53 449.98 412.48 450.76 485.65 433.55 584.82 421.13 548.65 410.86 426.31 433.55 396.53"/>
      </g>
    </g>
  </g>
</svg>

================
File: public/markdown_test/README.md
================
# Public Markdown Files

This is a demonstration of the public markdown files feature. This file is stored in the public folder and can be read by all users, but only edited by administrators.

## Features

- **Public Access**: All users can read markdown files in this folder
- **Admin Editing**: Only administrators can edit these files
- **Markdown Support**: Full markdown formatting is supported

## How to Use

1. Open the Explorer window
2. Navigate to the Public tab
3. Select a markdown file to view
4. If you're an admin, you can click the "Edit" button to make changes

## Markdown Examples

### Text Formatting

You can use **bold**, *italic*, or ~~strikethrough~~ text.

### Lists

Unordered list:
- Item 1
- Item 2
- Item 3

Ordered list:
1. First item
2. Second item
3. Third item

### Code

Inline code: `const example = "Hello World";`

Code block:
```javascript
function greet(name) {
  return `Hello, ${name}!`;
}

console.log(greet("User"));
```

### Tables

| Name | Role | Department |
|------|------|------------|
| John | Developer | Engineering |
| Sarah | Designer | UX/UI |
| Mike | Manager | Operations |

### Links and Images

[Link to documentation](https://www.markdownguide.org/)

![Image placeholder](https://via.placeholder.com/150)

## Contributing

If you're an administrator, you can edit this file to add more information or create new markdown files in the public folder.

================
File: public/sample.canvas
================
{
  "name": "Sample Canvas",
  "nodes": [
    {
      "id": "node-1",
      "type": "text",
      "position": {
        "x": 100,
        "y": 100
      },
      "data": {
        "text": "Welcome to Canvas Editor!\n\nThis is a text node. You can edit it by clicking the 'Add Node' button above."
      }
    },
    {
      "id": "node-2",
      "type": "text",
      "position": {
        "x": 400,
        "y": 300
      },
      "data": {
        "text": "You can connect nodes with arrows.\n\nTry selecting this node and dragging from a connection point to another node."
      }
    },
    {
      "id": "node-3",
      "type": "text",
      "position": {
        "x": 150,
        "y": 400
      },
      "data": {
        "text": "Drag nodes around to reposition them.\n\nYou can also delete selected nodes or connections."
      }
    }
  ],
  "edges": [
    {
      "id": "edge-1",
      "source": "node-1",
      "target": "node-2",
      "type": "default",
      "style": {
        "stroke": "#14b8a6"
      }
    }
  ],
  "version": "1.0",
  "metadata": {
    "created": "2025-04-16T13:20:00.000Z",
    "modified": "2025-04-16T13:20:00.000Z"
  }
}

================
File: public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: README.md
================
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

================
File: reset-indexeddb.js
================
// Reset button for IndexedDB databases
(() => {
  // Wait for DOM to be ready
  document.addEventListener('DOMContentLoaded', () => {
    // Create a button element with styles
    const resetButton = document.createElement('button');
    resetButton.innerText = 'Reset IndexedDB';
    resetButton.style.position = 'fixed';
    resetButton.style.bottom = '20px';
    resetButton.style.right = '20px';
    resetButton.style.padding = '10px 15px';
    resetButton.style.backgroundColor = '#e53e3e';
    resetButton.style.color = 'white';
    resetButton.style.border = 'none';
    resetButton.style.borderRadius = '4px';
    resetButton.style.fontWeight = 'bold';
    resetButton.style.zIndex = '9999';
    resetButton.style.cursor = 'pointer';
    resetButton.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.2)';

    // Add hover effect
    resetButton.addEventListener('mouseover', () => {
      resetButton.style.backgroundColor = '#c53030';
    });
    resetButton.addEventListener('mouseout', () => {
      resetButton.style.backgroundColor = '#e53e3e';
    });

    // Add click handler
    resetButton.addEventListener('click', async () => {
      if (confirm('This will reset the IndexedDB database and refresh the page. This should fix canvas state loading errors. Continue?')) {
        try {
          // Get all IndexedDB databases
          const databases = await indexedDB.databases();
          
          // Delete each database
          for (const db of databases) {
            console.log(`Deleting IndexedDB database: ${db.name}`);
            indexedDB.deleteDatabase(db.name);
          }
          
          // Reload the page
          alert('IndexedDB reset successful. The page will now reload.');
          window.location.reload();
        } catch (error) {
          console.error('Error resetting IndexedDB:', error);
          alert(`Error resetting IndexedDB: ${error.message}`);
        }
      }
    });

    // Add button to the page
    document.body.appendChild(resetButton);
  });
})();

================
File: resize-mode-documentation.txt
================
# Window Manager - Resize Mode Documentation

## Overview

Resize Mode is a feature in the Window Manager application that allows users to adjust the size of windows using keyboard shortcuts. This document provides a comprehensive explanation of how Resize Mode works, its implementation details, and how it can be customized.

## User Guide

### Activating Resize Mode

- Press `Ctrl+Q` to toggle Resize Mode on/off
- When Resize Mode is active, the border of the active window changes from teal to yellow
- A debug message "Resize mode: true/false" is logged to the console when toggled

### Using Resize Mode

Once Resize Mode is active:

1. Use arrow keys to resize the active window:
   - `Left Arrow`: Shrink the window horizontally (decrease width)
   - `Right Arrow`: Grow the window horizontally (increase width)
   - `Up Arrow`: Shrink the window vertically (decrease height)
   - `Down Arrow`: Grow the window vertically (increase height)

2. The resize operation affects the active window and its adjacent windows
3. Each key press adjusts the size by 5% (0.05) in the corresponding direction
4. Window sizes are constrained between 10% and 90% to prevent windows from becoming too small

### Exiting Resize Mode

- Press `Ctrl+Q` again to exit Resize Mode
- The active window's border will return to teal color

## Technical Implementation

### Core Components

Resize Mode is implemented across several files:

1. `useWindowManager.js`: Contains the core resize state and logic
2. `useKeyboardShortcuts.js`: Handles keyboard events for resize mode
3. `WindowManager.jsx`: Renders windows with different border colors based on state
4. `Node.js`: Defines the window/split node structure with splitRatio property
5. `treeUtils.js`: Contains utility functions for tree manipulation
6. `windowUtils.js`: Calculates window bounds based on tree structure

### State Management

The resize mode state is managed in the `useWindowManager` hook:

```javascript
// From useWindowManager.js
const [isResizeMode, setIsResizeMode] = useState(false);

// Debug logging for resize mode
useEffect(() => {
  console.log('Resize mode:', isResizeMode);
}, [isResizeMode]);

// Exported in the return object
return {
  // ... other properties
  isResizeMode,
  setIsResizeMode,
  resizeActiveWindow
};
```

### Keyboard Shortcuts

Keyboard shortcuts for resize mode are handled in the `useKeyboardShortcuts` hook:

```javascript
// From useKeyboardShortcuts.js
// Handle resize mode toggle
if (e.ctrlKey && e.key === 'q') {
  e.preventDefault();
  setIsResizeMode(!isResizeMode);
  return;
}

// Handle resize mode arrow keys
if (isResizeMode && !e.ctrlKey) {
  switch (e.key) {
    case 'ArrowLeft':
      e.preventDefault();
      resizeActiveWindow('left');
      break;
    case 'ArrowRight':
      e.preventDefault();
      resizeActiveWindow('right');
      break;
    case 'ArrowUp':
      e.preventDefault();
      resizeActiveWindow('up');
      break;
    case 'ArrowDown':
      e.preventDefault();
      resizeActiveWindow('down');
      break;
  }
  return;
}
```

### Visual Feedback

The `WindowManager.jsx` component provides visual feedback for resize mode:

```javascript
// From WindowManager.jsx
<div
  className={`absolute overflow-hidden border-2 ${
    isActive ? (isResizeMode ? 'border-yellow-500' : 'border-teal-500') : 'border-stone-600'
  }`}
  // ... other props
>
```

## Resize Algorithm

The core resize functionality is implemented in the `resizeActiveWindow` function in `useWindowManager.js`:

```javascript
const resizeActiveWindow = useCallback((direction) => {
  if (!activeNodeId || !rootNode || !isResizeMode) return;

  // Get the window bounds to determine the active window's position on screen
  const allWindows = getWindowBounds(rootNode);
  const activeWindow = allWindows.find(w => w.id === activeNodeId);
  if (!activeWindow) return;
  
  updateWorkspace(workspace => {
    const newRoot = JSON.parse(JSON.stringify(workspace.root));
    
    // Helper function to find all affected splits
    const findAffectedSplits = (node, targetId) => {
      if (!node) return [];
      
      const splits = [];
      if (node.type === 'split') {
        const targetInFirst = findNodeById(node.first, targetId);
        const targetInSecond = findNodeById(node.second, targetId);
        
        if (targetInFirst || targetInSecond) {
          // Add this split if it matches our resize direction
          if ((direction === 'left' || direction === 'right') && node.direction === 'horizontal') {
            splits.push({ node, targetInFirst: !!targetInFirst });
          }
          if ((direction === 'up' || direction === 'down') && node.direction === 'vertical') {
            splits.push({ node, targetInFirst: !!targetInFirst });
          }
        }
        
        splits.push(...findAffectedSplits(node.first, targetId));
        splits.push(...findAffectedSplits(node.second, targetId));
      }
      
      return splits;
    };

    const affectedSplits = findAffectedSplits(newRoot, activeNodeId);
    const resizeStep = 0.05;

    // Apply resize to all affected splits with position-aware logic
    affectedSplits.forEach(({ node, targetInFirst }) => {
      // For horizontal splits, adjust behavior based on window position
      if (node.direction === 'horizontal') {
        switch (direction) {
          case 'left': // Should always shrink width regardless of position
            if (targetInFirst) {
              // First child (left side): decrease ratio to shrink
              node.splitRatio = Math.max(0.1, node.splitRatio - resizeStep);
            } else {
              // Second child (right side): increase ratio to shrink
              node.splitRatio = Math.min(0.9, node.splitRatio + resizeStep);
            }
            break;
            
          case 'right': // Should always grow width regardless of position
            if (targetInFirst) {
              // First child (left side): increase ratio to grow
              node.splitRatio = Math.min(0.9, node.splitRatio + resizeStep);
            } else {
              // Second child (right side): decrease ratio to grow
              node.splitRatio = Math.max(0.1, node.splitRatio - resizeStep);
            }
            break;
        }
      } else {
        // For vertical splits, keep original behavior
        switch (direction) {
          case 'up': // Shrink height
            if (targetInFirst) {
              node.splitRatio = Math.max(0.1, node.splitRatio - resizeStep);
            } else {
              node.splitRatio = Math.min(0.9, node.splitRatio + resizeStep);
            }
            break;
            
          case 'down': // Grow height
            if (targetInFirst) {
              node.splitRatio = Math.min(0.9, node.splitRatio + resizeStep);
            } else {
              node.splitRatio = Math.max(0.1, node.splitRatio - resizeStep);
            }
            break;
        }
      }
    });

    return { ...workspace, root: newRoot };
  });
}, [activeNodeId, rootNode, isResizeMode, updateWorkspace]);
```

### How the Algorithm Works

1. **Detecting Window Position in Tree Structure**:
   - The algorithm determines if the active window is in the second child of a split
   - For horizontal splits, it identifies windows on the right side of the screen
   - For vertical splits, it identifies windows on the bottom side of the screen
   - This is a stable way to identify window positions that doesn't change as windows resize
   - For windows on the right side, horizontal resize directions are inverted
   - For windows on the bottom side, vertical resize directions are inverted

2. **Finding Affected Splits**:
   - The algorithm traverses the window tree to find all split nodes that affect the active window
   - It only considers splits that match the resize direction (horizontal splits for left/right, vertical splits for up/down)
   - It tracks whether the active window is in the first or second child of each split

3. **Applying Resize**:
   - For each affected split, the algorithm adjusts the `splitRatio` property
   - The adjustment depends on:
     - The effective direction (after potential inversion for right-side windows)
     - Whether the active window is in the first or second child of the split
   - The resize step is fixed at 0.05 (5%) per key press
   - The splitRatio is constrained between 0.1 (10%) and 0.9 (90%)

4. **Window Tree Structure**:
   - The window tree consists of nested split and window nodes
   - Split nodes have a direction (horizontal/vertical) and a splitRatio
   - The splitRatio determines how space is divided between the first and second child
   - Window nodes represent actual windows with content

### Intuitive Resize Controls

The resize algorithm has been designed to provide intuitive controls:

- Left arrow key always shrinks a window horizontally
- Right arrow key always grows a window horizontally
- Up arrow key always shrinks a window vertically
- Down arrow key always grows a window vertically

This behavior is consistent regardless of whether the window is on the left or right side of the screen. For windows on the right side of the screen, the horizontal controls are automatically inverted internally to maintain this intuitive behavior.

## Customization Options

To customize the resize functionality, you can modify the following:

1. **Resize Step Size**:
   - Change the `resizeStep` value in `resizeActiveWindow` function (default: 0.05)
   ```javascript
   const resizeStep = 0.05; // Change this value to adjust resize speed
   ```

2. **Minimum/Maximum Window Size**:
   - Adjust the constraints in the resize logic (default: 0.1 to 0.9)
   ```javascript
   node.splitRatio = Math.max(0.1, node.splitRatio - resizeStep); // Change 0.1 to adjust minimum size
   node.splitRatio = Math.min(0.9, node.splitRatio + resizeStep); // Change 0.9 to adjust maximum size
   ```

3. **Keyboard Shortcut**:
   - Modify the key detection in `useKeyboardShortcuts.js`
   ```javascript
   if (e.ctrlKey && e.key === 'q') { // Change 'q' to another key
     e.preventDefault();
     setIsResizeMode(!isResizeMode);
     return;
   }
   ```

4. **Visual Feedback**:
   - Change the border colors in `WindowManager.jsx`
   ```javascript
   isActive ? (isResizeMode ? 'border-yellow-500' : 'border-teal-500') : 'border-stone-600'
   // Change 'border-yellow-500' to another color for resize mode
   ```

## Advanced Modifications

For more advanced modifications to the resize functionality:

1. **Adding Mouse Resize Support**:
   - The `WindowManager.jsx` already includes mouse resize functionality through the `handleResizeStart`, `handleResizeMove`, and `handleResizeEnd` functions
   - This allows users to drag the dividers between windows to resize them

2. **Adding Resize Indicators**:
   - You could add visual indicators showing the current size percentage when in resize mode
   - This would require adding a state variable to track the current size and rendering it in the UI

3. **Implementing Snap-to-Grid**:
   - Modify the resize algorithm to snap to predefined grid positions
   - This would make it easier to create evenly sized layouts

4. **Adding Presets**:
   - Implement preset layouts that users can switch between
   - This could include equal splits, golden ratio splits, etc.

## Troubleshooting

Common issues with resize mode:

1. **Resize Not Working**:
   - Ensure resize mode is active (yellow border)
   - Check that the window has an active split in the direction you're trying to resize
   - Verify keyboard events are being captured (not intercepted by browser or OS)

2. **Unexpected Resize Behavior**:
   - Complex window layouts may have multiple splits affecting a window
   - The algorithm tries to find all relevant splits, but may not behave as expected in all cases
   - Try simplifying your layout if you encounter issues

3. **Performance Issues**:
   - The resize algorithm creates a deep copy of the window tree on each key press
   - This could cause performance issues with very complex layouts
   - Consider optimizing the update logic for better performance

================
File: src/App.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

#root {
  width: 100%;
  height: 100%;
}

================
File: src/App.jsx
================
import React, { useState, useCallback } from 'react';
import { WindowManager } from './components/WindowManager';
import { CommandBar } from './components/CommandBar';
import { EmptyState } from './components/EmptyState';
import { AuthScreen } from './components/auth';
import { useWindowManager } from './hooks/useWindowManager';
import { useKeyboardShortcuts } from './hooks/useKeyboardShortcuts';
import { useAuth } from './context/AuthContext';
import { ActiveUsersProvider } from './context/ActiveUsersContext';
import { WINDOW_CONTENT, WINDOW_TYPES } from './utils/windowTypes';

/**
 * Main application component that composes our window management system.
 * This component is intentionally kept simple, delegating most functionality
 * to specialized components and hooks.
 */
function App() {
  const { isAuthenticated, loading, user, logout } = useAuth();
  
  // State for tracking which windows are currently flashing
  const [flashingWindowIds, setFlashingWindowIds] = useState(new Set());
  
  // Function to flash a window's border red
  const flashWindowBorder = useCallback((windowId) => {
    setFlashingWindowIds(prev => {
      const newSet = new Set(prev);
      newSet.add(windowId);
      return newSet;
    });
    
    // Remove the window from flashing state after 500ms
    setTimeout(() => {
      setFlashingWindowIds(prev => {
        const newSet = new Set(prev);
        newSet.delete(windowId);
        return newSet;
      });
    }, 200);
  }, []);
  
  // Call all hooks at the top level, before any conditional returns
  const {
    rootNode,
    activeNodeId,
    setActiveNodeId,
    createNewWindow,
    splitWindow,
    closeWindow,
    transformWindow,
    handleCommand,
    handleResizeStart,
    handleResizeMove,
    handleResizeEnd,
    hasActiveWindow,
    hasRootNode,
    currentWorkspaceIndex,
    switchWorkspace,
    isResizeMode,
    isMoveMode,
    setIsResizeMode,
    resizeActiveWindow,
    moveSourceWindowId
  } = useWindowManager({
    onFlashBorder: flashWindowBorder
  });

  // Set up keyboard shortcuts - always call this hook, even if we'll return early
  // But don't include move mode props to avoid conflicts with WindowManager
  useKeyboardShortcuts({
    onSplitVertical: () => splitWindow(activeNodeId, 'vertical'),
    onSplitHorizontal: () => splitWindow(activeNodeId, 'horizontal'),
    onClose: () => closeWindow(activeNodeId),
    createNewWindow,
    hasActiveWindow,
    hasRootNode,
    isResizeMode,
    isMoveMode,
    setIsResizeMode,
    resizeActiveWindow,
    activeNodeId
  });
  
  // If authentication is still loading, show a loading screen
  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-stone-900">
        <div className="text-teal-500 text-2xl font-mono">Loading...</div>
      </div>
    );
  }
  
// If not authenticated, show the auth screen
  if (!isAuthenticated) {
    return <AuthScreen />;
  }

  // Define component to render based on whether we have a root node
  const renderContent = () => {
    if (!rootNode) {
      return <EmptyState />;
    }

    // Render the window tree with all necessary props
    return (
      <WindowTreeRenderer
        node={rootNode}
        activeNodeId={activeNodeId}
        setActiveNodeId={setActiveNodeId}
        transformWindow={transformWindow}
        onResizeStart={handleResizeStart}
        onResizeMove={handleResizeMove}
        onResizeEnd={handleResizeEnd}
        isResizeMode={isResizeMode} // Pass isResizeMode to WindowTreeRenderer
        isMoveMode={isMoveMode}
        moveSourceWindowId={moveSourceWindowId} // Pass moveSourceWindowId to WindowTreeRenderer
        flashingWindowIds={flashingWindowIds} // Pass flashingWindowIds to WindowTreeRenderer
      />
    );
  };

  return (
    <ActiveUsersProvider>
      <div className="w-full h-screen flex flex-col">
        {/* Global command bar with user info */}
        <CommandBar 
          onCommand={handleCommand}
          currentWorkspaceIndex={currentWorkspaceIndex}
          switchWorkspace={switchWorkspace}
          user={user}
          onLogout={logout}
        />
        
        {/* Main content area */}
        <div className="flex-1 relative">
          {renderContent()}
        </div>
      </div>
    </ActiveUsersProvider>
  );
}

/**
 * Renders the window tree recursively. This component is kept within App.jsx
 * since it's tightly coupled with the WindowManager's functionality.
 */
const WindowTreeRenderer = ({
  node,
  depth = 0,
  available = { x: 0, y: 0, width: 100, height: 100 },
  activeNodeId,
  setActiveNodeId,
  transformWindow,
  onResizeStart,
  onResizeMove,
  onResizeEnd,
  isResizeMode, // Add isResizeMode prop
  isMoveMode,
  moveSourceWindowId,
  flashingWindowIds
}) => {
  if (node.type === 'window') {
    const windowContent = WINDOW_CONTENT[node.windowType];
    
    // Check if window content exists (window type might have been removed)
    if (!windowContent) {
      console.warn(`Window type "${node.windowType}" is no longer supported`);
      return (
        <div
          className="absolute overflow-hidden border-1 border-red-500"
          style={{
            left: `${available.x}%`,
            top: `${available.y}%`,
            width: `${available.width}%`,
            height: `${available.height}%`,
          }}
          onClick={() => setActiveNodeId(node.id)}
        >
          <div className="flex h-full items-center justify-center bg-stone-800 text-red-400 p-4 text-center">
            <div>
              <p className="font-bold mb-2">Unsupported Window Type</p>
              <p className="text-sm">Window type "{node.windowType}" is no longer available</p>
              <button 
                className="mt-4 px-3 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs text-teal-400"
                onClick={(e) => {
                  e.stopPropagation();
                  // Convert to terminal window
                  transformWindow(node.id, WINDOW_TYPES.TERMINAL);
                }}
              >
                Convert to Terminal
              </button>
            </div>
          </div>
        </div>
      );
    }
    
    const Component = windowContent.component;
    const isActive = node.id === activeNodeId;
    // Check if this is the first selected window in move mode
    const isFirstSelectedWindow = isMoveMode && moveSourceWindowId === node.id;
    // Check if this window is currently flashing
    const isFlashing = flashingWindowIds.has(node.id);

    return (
      <div
        className={`absolute overflow-hidden border-1 ${
          isFlashing ? 'border-red-600' : 
          isFirstSelectedWindow 
            ? 'border-blue-300' 
            : isActive 
              ? isResizeMode 
                ? 'border-yellow-500'
                : isMoveMode
                  ? 'border-blue-500'
                  : 'border-teal-500'
              : 'border-stone-600'
        } $`}
        style={{
          left: `${available.x}%`,
          top: `${available.y}%`,
          width: `${available.width}%`,
          height: `${available.height}%`,
        }}
        onClick={() => setActiveNodeId(node.id)}
      >
        <Component
          key={`window-${node.id}-${node.windowType}`}
          isActive={isActive}
          nodeId={node.id}
          transformWindow={transformWindow}
        />
      </div>
    );
  }

  // Handle split nodes...
  let firstDimensions, secondDimensions;
  if (node.direction === 'horizontal') {
    firstDimensions = {
      x: available.x,
      y: available.y,
      width: available.width * node.splitRatio,
      height: available.height
    };
    secondDimensions = {
      x: available.x + (available.width * node.splitRatio),
      y: available.y,
      width: available.width * (1 - node.splitRatio),
      height: available.height
    };
  } else {
    firstDimensions = {
      x: available.x,
      y: available.y,
      width: available.width,
      height: available.height * node.splitRatio
    };
    secondDimensions = {
      x: available.x,
      y: available.y + (available.height * node.splitRatio),
      width: available.width,
      height: available.height * (1 - node.splitRatio)
    };
  }

  return (
    <>
      <WindowTreeRenderer
        node={node.first}
        depth={depth + 1}
        available={firstDimensions}
        activeNodeId={activeNodeId}
        setActiveNodeId={setActiveNodeId}
        transformWindow={transformWindow}
        onResizeStart={onResizeStart}
        onResizeMove={onResizeMove}
        onResizeEnd={onResizeEnd}
        isResizeMode={isResizeMode} // Pass down isResizeMode
        isMoveMode={isMoveMode} // Pass down isMoveMode
        moveSourceWindowId={moveSourceWindowId} // Pass down moveSourceWindowId
        flashingWindowIds={flashingWindowIds} // Pass down flashingWindowIds
      />
      
      <div
        className={`absolute z-10 ${
          node.direction === 'horizontal' 
            ? 'w-1 cursor-col-resize hover:bg-teal-500' 
            : 'h-1 cursor-row-resize hover:bg-teal-500'
        }`}
        style={{
          left: node.direction === 'horizontal' ? `${available.x + (available.width * node.splitRatio)}%` : `${available.x}%`,
          top: node.direction === 'horizontal' ? `${available.y}%` : `${available.y + (available.height * node.splitRatio)}%`,
          height: node.direction === 'horizontal' ? `${available.height}%` : '2px',
          width: node.direction === 'horizontal' ? '2px' : `${available.width}%`,
        }}
        onMouseDown={(e) => onResizeStart(e, node)}
      />
      
      <WindowTreeRenderer
        node={node.second}
        depth={depth + 1}
        available={secondDimensions}
        activeNodeId={activeNodeId}
        setActiveNodeId={setActiveNodeId}
        transformWindow={transformWindow}
        onResizeStart={onResizeStart}
        onResizeMove={onResizeMove}
        onResizeEnd={onResizeEnd}
        isResizeMode={isResizeMode} // Pass down isResizeMode
        isMoveMode={isMoveMode} // Pass down isMoveMode
        moveSourceWindowId={moveSourceWindowId} // Pass down moveSourceWindowId
        flashingWindowIds={flashingWindowIds} // Pass down flashingWindowIds
      />
    </>
  );
};

export default App;

================
File: src/assets/react.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================
File: src/assets/SVG/emptyState.svg
================
<?xml version="1.0" encoding="UTF-8"?>
<svg id="Layer_2" data-name="Layer 2" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1781 1145.9">
  <defs>
    <style>
      .cls-1, .cls-2 {
        fill: none;
        stroke: #48c0b2;
        stroke-miterlimit: 10;
      }

      .cls-2 {
        stroke-width: 3px;
      }

      .cls-3 {
        clip-path: url(#clippath);
      }
    </style>
    <clipPath id="clippath">
      <polyline class="cls-1" points="270.6 1145.4 .5 1145.4 .5 .5 1780.5 .5 1780.5 1145.4 270.6 1145.4"/>
    </clipPath>
  </defs>
  <g id="Layer_1-2" data-name="Layer 1">
    <g>
      <g class="cls-3">
        <path class="cls-2" d="M1029.18,973.3c-1.01-7.48-1.99-14.93-2.93-22.34M1044.76,1073.01c1.48,8.41,3.02,16.87,4.6,25.35,2.18,11.57,4.39,23.05,6.69,34.42M1056.05,1132.78v.03M1029.72,972.17l9.78,59.68M982,1151.26c13.28,18.04,34.44,25.19,50.69,18.7,11.91-4.77,17.69-15.46,19.61-19.55M1217.44,708.86c.02-.74.07-1.44.12-2.11.05-.58.1-1.12.17-1.61.93-6.9,3.48-6.88,4.77-14.78,2.69-16.44-6.71-26.62-1.32-32.23,1.75-1.82,4-2.04,6.02-2.45,1.77-.36,3.35-.88,4.27-2.69,1.32-2.64-.39-4.74-.82-11.84-.26-4.19.14-6.95.24-8.56.84-12.18-3.72-37.43-7.1-53.92-.55-2.68-1.06-5.13-1.53-7.26M1211.99,522.22c-2.45-14.09-2.63-17.86-6.16-24.45M1196.66,484.67c-3.5-4.44-9.15-11.86-19.34-25.98-14.91-20.68-15.39-22.33-20.4-26.89-14.95-13.63-23.29-10.35-45.73-24.06-17.35-10.59-13.64-13.32-33.58-27.04-26.08-17.95-45.17-22.03-44.24-29.17.98-7.48,22.53-7.31,25.17-18.88,1.2-5.23-2.13-10.09-3.81-12.58-9.61-14.16-17.61-29.36-26.74-43.83-2.49-3.95-5.06-7.84-7.77-11.65-16.66-23.34-26.02-44-30.13-53.2-7.71-17.25-5.34-16.44-18.12-49.2-14.71-37.72-20.82-46.4-26.12-52.72-10.14-12.08-20.56-19.24-29.17-25.17-12.84-8.84-20.03-13.66-30.03-14.29-9.64-.62-17.93,2.9-31.16,11.43-26.53,17.09-41.13,26.51-52.92,45.48-8.29,13.37-12.96,35.99-22.31,81.24-5.34,25.88-4.14,25.07-6.57,30.31-1.44,3.09-3.21,6.26-5.18,9.46-3.02,4.84-6.56,9.71-10.31,14.43-12.77,16.11-27.83,30.29-32.12,34.32-1.24,1.15-4.56,4.26-6.25,9.34-.14.45-2.76,8.73,1.08,16.47,5.56,11.19,19.1,10.18,19.61,15.24.55,5.66-16.25,9.7-45.48,23.44-21.18,9.95-31.95,15.14-41.77,24.88-7.69,7.65-8.68,11.45-16.9,16.7-4.58,2.92-7.52,3.81-29.82,12.1-13.92,5.17-15.08,5.68-17.04,7.24-8.82,7.07-9.71,16.46-13.45,26.03-6.8,17.47-18.09,22.98-27.73,33.84-9.85,11.09-10.64,19.48-15.41,50.76M1097.89,709.58c-7.45-10.83-12.61-19.96-17.04-31.52-5.23-13.68-5.1-25.4-9.44-25.74-1.49-.12-2.75,1.13-8.44,10.74-1.03,1.75-2.21,3.78-3.57,6.13-4.99,8.63-7.89,13.87-9.64,17.21M1110.05,726.36c1.97,2.63,4.05,5.39,6.26,8.32,2.59,3.45,5.65,7.43,9.18,11.88M706.52,665.13c-5.59-9.99-8.25-15.34-10.43-17.92-1.27-1.53-2.39-2.09-3.84-2.06-.58.02-1.13.12-1.68.31-6.97,2.4-11.34,18.55-17.09,34.2M613.79,672.74c13.47-6.56,26.87-14.26,37.86-23.37,24.39-20.25,34.08-45.2,36.93-53.44.6-1.73,1.15-3.45,1.65-5.13,4.55-15.36,5.13-28.88,4.86-38.04M1062.96,663.06c-10,4.63-17.62,9.58-23.22,13.8M795.98,693.24c-3.57-1.63-7.52-3.47-11.93-5.46-.48-.21-.94-.43-1.41-.62M696.09,647.22c3.81,2.32,9.35,5.63,16.18,9.39,3.64,2.01,6.92,3.74,9.95,5.29M1203.78,571.06c6.04,2.69,12.68,5.25,20.01,7.6h.02M1160.75,541.54c-1.15-1.2-2.23-2.39-3.24-3.54-9.49-10.83-18.21-24.92-36.04-29.57-6.4-1.66-7.43-.41-20.46-.05-2.49.07-5.42.1-8.92.07-19.12-.15-33.41-.38-48.62-6.11-4.67-1.75-6.93-3.09-22.24-12.51-25.4-15.62-46.11-28.5-68.14-40.69-4.55-2.52-8.37-4.58-11.63-6.26-13.2-6.83-17.04-7.62-20.76-7.95-1.77-.15-3.48-.21-5.17-.17-16.53.39-29.31,9.76-43.74,19.01-63.15,40.45-111.87,49.35-130.57,49.53-14.52.12-23.32.21-32.42-5.39-6.16-3.81-11.94-9.92-15.77-7.91-2.08,1.08-1.54,3.48-5.71,10.3-1.9,3.09-2.9,4.67-4.72,6.14-1.25,1-3.64,2.59-10.16,3.72-6.04,1.05-10.74.86-11.1.84-11.57-.43-26.34,11.07-33.65,16.32-4.93,3.52-16.94,9.66-40.96,21.93-9.11,4.65-21.04,10.11-35.85,15.29M1101.01,508.39c-.53,1.06-1.39,2.66-2.57,4.5-2.33,3.62-3.84,4.89-5.01,6.73-2.33,3.64-2.13,7.57-1.99,11.15.21,5.65.38,10.28.46,14.16.17,6.98.1,11.51-.46,15.02-.57,3.57-2.73,7.5-6.74,13.44M967.14,541.29c1.17.14,2.4.31,3.69.53,1.44.24,5.22.7,10.71,2.28,5.51,1.58,12.73,4.27,21.12,8.97,6.88,3.84,19.37,10.74,30.61,24.02,14.74,17.42,14.31,30.41,21.97,30.89,4.99.31,10.86-8.05,22.6-24.75,2.69-3.84,4.98-7.05,6.85-9.85M938.31,526.87c-1.08-4.38-2.32-9.3-6.98-14.35-3.6-3.91-6.21-4.72-7.88-4.96-6.74-.96-12.53,5.54-13.21,6.32-.12.14-.24.27-.34.43M788,582.42c-1.92,1.6-3.76,3.12-5.42,4.53-4.87,4.1-8.36,7.05-8.48,7.16-10.9,9.2-11.81,15.6-16.35,16.17-3.02.38-5.27-1.87-6.57-2.95-29.43-24.39-44.14-36.57-48.24-45.66-1.25-2.78-3.02-6.35-6.68-8.39-.39-.22-.79-.39-1.18-.51-4.19-1.46-9.04,1.41-18.28,4.89-19.15,7.26-21.4,4.12-26.12,9.16-6.09,6.5-2.3,11.84-8.39,24.11-4.2,8.48-9.73,13.45-15.34,18.5-4.77,4.29-12.48,10.31-33.09,19.55-12.8,5.73-20.71,8.25-28.04,10.79-6.45,2.23-12.46,4.48-20.97,8.97-3.35,1.75-6.44,3.5-9.23,5.18M1091.9,544.92c2.76.98,7.19,2.51,12.68,4.29,12.42,4,14.29,4.08,16.46,6.44,4.48,4.89,1.12,9.75,4.05,19.82,2.4,8.27,7.14,13.52,11.53,18.36,7.46,8.24,15.17,12.29,26.03,17.86,10.07,5.18,10.78,4.2,22.58,10.16,8.12,4.08,14.72,7.41,22.03,13.01,5.3,4.07,12.73,10.67,19.94,20.8M1071.41,652.32c2.47-12.17,4.8-24.69,7-37.62.6-3.57,1.2-7.12,1.77-10.66,1.66-10.42,3.17-20.64,4.51-30.65v-.02M690.22,590.79c-.07,7.71-.1,15.48-.07,23.34.05,10.61.19,21.04.41,31.34v.02M1080.18,604.04c3.83,9.52,8.36,16.49,11.82,21.11,7.02,9.35,14.36,15.32,23.46,22.74,5.44,4.43,9.16,7.46,14.59,10.86,9.22,5.78,14.55,7.14,32.31,13.87,18.21,6.92,27.46,10.45,34.89,15.17,9.59,6.07,16.34,12.72,20.49,17.35M923.91,520.13c-.05-3.69-.21-7.83-.46-12.56-.33-6.11-.86-13.2-1.63-21.61-1.27-13.8-3.21-31.13-6.3-51.17M1027.99,276.24c-7.21-4.51-17.85-11.75-29.52-22.05-16.44-14.5-21.67-23.36-41.89-49.87-2.06-2.73-4.31-5.65-6.73-8.77-6.69-8.61-29.7-37.98-64.08-68.06-11.38-9.97-15.27-12.36-20.59-12.6-24.26-1.03-48.62,44.41-59.38,67.25-2.63,5.56-4.44,9.78-5.25,11.69-1.73,4.02-5.42,12.99-12.01,24.61-7.45,13.09-14.9,23.06-20.06,29.46M886.64,70.01c-1.18,1.68-3.91,5.58-7.43,10.57-8.34,11.86-10.16,14.36-11.72,18.6-1.24,3.31-2.63,8.56-2.3,15.72M852.13,375.95c29.5,11.43,40.5,16.54,59.68,15.24,7.6-.51,12.82-1.77,20.64-4.56,2.63-.94,5.56-2.06,8.99-3.38,7.62-2.92,17.66-6.83,32.24-12.06,25.38-9.1,46.26-15.62,59.67-19.65M852.11,375.93c-5.29-2.04-11.17-4.31-17.81-6.76-18.6-6.9-45.66-16.34-79.5-26.03M932.46,386.6c3-2.44,5.99-4.87,8.99-7.31,9.08-7.38,18.14-14.76,27.22-22.14,5.44-4.41,10.86-8.84,16.3-13.25,4.89-3.98,9.76-7.95,14.66-11.93M852.13,375.95s-.02,0-.02-.02c-14.69-10.5-29.38-20.99-44.09-31.49-9.15-6.54-18.31-13.09-27.47-19.63-2.39-1.7-4.79-3.41-7.17-5.11M805.81,182.15c.76,39.26,2.99,64.35,5.89,80.19,1.73,9.58,3.72,15.79,5.77,19.72,1.22,2.35,2.47,3.88,3.69,4.84.58.45,9.32,7.17,16.58,12.96,13.02,10.38,11.74,9.85,13.73,11.07,18.62,11.31,41.97,3.98,44.81,3.04,4.77-1.56,2.32-1.42,16.41-8.37,13.97-6.9,22.77-10.24,28.78-13.45,4.93-2.61,7.96-5.15,10.4-9.49,1.92-3.38,2.66-7.1,4.15-14.59,1.96-9.82,1.9-17.31,1.72-26.87-.27-14.16-.69-26.56-1.13-36.86M951.85,282.64c.14,14.31.43,25.81.84,34.97.02.5.03,1,.07,1.48.55,11.74,1.32,19.51,2.18,24.44.86,4.79,1.8,6.88,2.78,7.34.14.07,1.77.82,3.95,1.99,2.95,1.6,5.3,3.12,7,4.29M808.03,344.44c1.54-.79,3.62-2.15,5.25-4.44.55-.79.98-1.56,1.3-2.33.89-2.02,1.12-3.9,1.22-5.01.33-3.23.7-10.43,1.03-20.59,0-.31.02-.62.03-.94.24-8.08.46-17.93.6-29.05M816.85,311.11c-5.1.45-12.1,1.61-19.92,4.67-7.04,2.75-12.49,6.18-16.37,9.03M984.66,343.53c-1.7-3.59-5.65-10.71-13.64-16.59-7.26-5.34-14.41-7.16-18.26-7.84M1219.69,741.04c.55.12,1.12.26,1.68.43,4.74,1.39,9.11,4.26,10.11,3.04.57-.7-.55-2.15-1.9-6.09-.84-2.42-1.32-4.53-1.63-6.09M803.7,448.11c-32.14-.02-55.62-6.71-71.51-13.16-17.18-6.95-31.16-15.92-49.18-12.01-7.05,1.54-12.49,4.56-27.18,16.59-39.47,32.35-49.7,51.1-78.65,67.22-10.52,5.85-19.65,9.2-24.59,10.86M790.83,429.79c8.37.58,18.91.6,30.89-1.13,10.95-1.6,20.3-4.22,27.75-6.86M845.18,436.66c10.59-3.31,21.91-7.34,33.74-12.29,8.01-3.35,15.55-6.81,22.6-10.3M1085.7,452.69c-45.54.55-72.66-6.23-86.08-10.59-30.31-9.83-45.46-14.74-56.06-20.88-.41-.24-1.13-.65-2.11-1.17-1.9-.96-4.8-2.25-8.48-3.12-10.45-2.49-19.46.15-24.59,1.72-4.55,1.39-11.67,4.19-19.17,10.02M1142.62,457.84c-2.57-3.35-6.49-8.12-11.72-13.45-5.73-5.83-8.6-8.75-11.45-10-9.04-3.98-17.16,2.56-31.18,6.57-7.34,2.11-18.6,4.2-33.74,2.57M1108.68,415.21c9.51,6.06,16.47,10.64,22.12,14.5,3.67,2.51,6.07,4.2,9.92,4.91,5.56,1.01,8.6-1.05,12.8.72,3.41,1.42,5.44,4.48,6.64,6.95M1076.26,416.55c-8.15,1.44-20.23,2.71-34.51.77-11.65-1.6-17.85-4.41-26.17-6.49-11.53-2.87-28.56-4.7-51.62.76M1053.2,403.01c-20.27-.12-41.05.05-62.36.58-16.8.41-33.26,1.01-49.39,1.82-.63.02-1.27.05-1.89.09M1046.52,390.05c-5.97.17-15.05.41-26.12.57-14.23.21-22.63.15-26.89.19-11.74.12-28.95,1.25-52.07,6.09-.62.12-1.25.26-1.89.39M813.52,415.41c14.4-4.75,25.81-5.06,33.75-4.39,9.66.82,19.65,3.55,33.36.19,3.95-.96,7.09-2.16,9.16-3.05M884.84,399.58c-13.92-1.51-28.09-2.92-42.52-4.19-17.25-1.53-34.15-2.78-50.73-3.81M687.68,396.73c28.19,4.46,40.93.76,47.28-3.83,1.18-.84,4.62-3.48,9.92-6.28,7.58-4,14.47-5.89,19.07-6.86M749.08,484.43c-19,.62-29.4-4.72-35.47-10.11-5.89-5.23-8.53-11.26-13.35-10.86-5.73.46-6.14,9.34-14.48,18.1-5.97,6.26-13.3,8.79-27.99,13.85-7.95,2.75-19.13,5.99-33.03,8.08M1184.96,520.09c-1.39-.93-2.63-1.87-3.72-2.78-8.8-7.33-9.92-14.11-18.88-22.02-9.88-8.73-21.45-11.88-29.74-13.16M1038.73,719.52c.65-.12,1.32-.24,1.99-.38h.02M959.76,769.11c12.97-3.09,25.95-6.18,38.9-9.27M816.81,312.06h.02c20.18,5.95,30.96,15.02,37.12,22.5,4.17,5.08,8.31,12,17.35,15.44,5.23,2.01,9.78,1.97,18.1,1.92,8.68-.07,15.55-.12,22.89-3.24,6.42-2.75,8.68-5.9,16.39-12.78,3.28-2.93,7.52-6.5,12.77-10.43,3.35-2.51,7.09-5.15,11.24-7.84M814.58,337.66c9.25,3.31,16.63,7.02,22.02,10.06,12.34,6.98,21.24,14.48,23.25,16.22,7.48,6.38,6.95,7.28,10.86,9.34,2.23,1.17,6.49,3,25.55,2.87,11.79-.1,17.78-.17,21.93-2.11,6.32-2.92,7.95-6.61,15.07-13.73,2.15-2.15,4.86-4.65,8.19-7.38,3.69-2.97,8.15-6.19,13.49-9.39M836.87,202.14c-9.22-2.3-19.58,2.15-19.73,6.01-.26,6.83,31.34,16.77,34.9,11.15,2.13-3.36-4.43-14.5-15.17-17.16ZM835.42,182.7c-6.33-1.06-13.45,1.7-13.44,4,0,4.24,23.9,9.64,25.69,5.9,1.01-2.18-4.77-8.65-12.25-9.9ZM890.26,215.67c3.55,5.61,35.14-4.31,34.9-11.15-.15-3.86-10.52-8.31-19.73-6.01-10.74,2.68-17.3,13.8-15.17,17.16ZM894.64,188.96c1.77,3.74,25.67-1.66,25.69-5.89.02-2.32-7.1-5.06-13.44-4.02-7.5,1.25-13.28,7.74-12.25,9.9ZM482.05,567.99v.02M453.7,901.42l.02.02.15.14M404,611.9h.02M309.46,1053.08h.02M453.71,901.43c-1.73-7.83-4.94-18.17-11.26-29.16-3.55-6.18-7.36-11.31-10.9-15.43M267.4,1153.44c4.29-6.97,7.26-12.78,9.04-16.47,7.1-14.64,8.53-22.5,16.05-43.04,1.13-3.09,2.4-6.47,3.86-10.21,2.25-5.82,3.38-8.72,4.62-11.67,1.46-3.47,2.87-6.64,4.2-9.54,1.58-3.48,3.04-6.59,4.31-9.4v-.02c4.19-9.27,6.28-15.24,3.95-20.63-.34-.81-.82-1.65-1.24-2.75-.33-.84-.6-1.84-.77-3.07-.43-3.28.45-5.01,2.01-11.86,1.15-4.96,1.72-7.43,1.54-8.82-.27-2.32-1.05-3.64-1.92-5.25-.7-1.29-1.46-2.78-2.08-5.1-.79-2.99-.88-5.59-.77-7.4,0-.14,0-.26.02-.38M643.12,699.87c.7-3.83,1.06-7.48-.89-11.67-4.58-9.78-17.47-13.11-22.72-14.47-1.08-.29-2.08-.5-2.99-.65-1-.19-1.89-.29-2.73-.34-5.95-.46-8.96,1.37-18.4-.41-8.73-1.66-9.59-4-21.14-7.69-1.39-.45-2.95-.93-4.68-1.41-10.54-2.97-16.03-3.38-20.2-.6-.7.46-2.4,2.2-5.83,5.68-6.02,6.13-7.71,8.2-8.56,8.24h-.02c-.07,0-.14-.02-.21-.05-1.7-.84,4.63-9.35,1.96-19-.27-1.01-.72-2.18-1.08-3.59-.46-1.7-.79-3.72-.57-6.21.24-2.66.36-4.05,1.2-5.35.55-.84,1.25-1.44,2.11-1.87,2.93-1.54,7.64-1.22,13.32-1.82,3.86-.39,9.1-.77,13.52-2.06,3.98-1.15,7.31-3,8.37-6.28,1.75-5.37.43-13.14-3.71-15.38-2.49-1.34-4.63,1.27-5.83-.7-1.03-1.68-.67-5.71-.31-6.52,1.78-4.07,5.39-4.12,6.44-7.45.31-.98-.03-2.52-.76-5.58-1.46-6.28-2.28-9.58-4.77-10.69-1.8-.82-2.49.41-4.32,0-5.37-1.22-6.37-13.49-9.46-19.44-.91-1.73-1.99-2.93-3.4-3.17-.96-.15-6.62-.65-7.24-1.3-.05-.05-.1-.12-.1-.12-.19-.31-.15-.82-.79-3.6-.21-.82-.27-1.39-.29-1.73-.03-.31-.02-.45-.02-.45,1.73.26,3.48.51,5.22.77-.24-1.66-.65-3.66-1.41-5.82-.84-2.49-1.87-4.53-2.8-6.13-1.48-.63-2.95-1.27-4.43-1.92,0,0-1.01-3.23-2.71-8.37-1.56-4.8-3.69-11.29-6.13-18.4-.84-2.45-1.53-4.5-2.88-7.14,0,0-3.67-7.31-10.19-13.51-4.46-4.26-19.91-14.33-47.12-16.78-4.74-.43-9.82-.62-15.27-.51-3.52.07-8.56.19-14.38.58-19.84,1.32-48.62,5.89-55.91,22.89-1.27,2.97-10.69,26.87-12.2,34.92-.17.94-.86,5.11-1.03,6.14-.02.14-.03.22-.03.22-2.16.65-4.32,1.29-6.49,1.94-1.13,4.32-2.28,8.67-3.41,12.99,1.3-.22,2.59-.45,3.9-.67.6-.1,1.22-.21,1.82-.31.02,3.14-.86,4.68-1.89,5.49-1.68,1.34-3.29.27-6.02,1.51-2.11.96-3.28,2.54-4.74,4.53-.69.94-1.66,2.52-3.6,6.93-2.83,6.37-3.29,9.85-5.63,10.35-1.17.24-1.58-.5-2.71-.1-1.63.57-2.13,2.54-3.23,6.02-2.42,7.76-2.99,7.96-2.51,9.15,1.18,2.97,5.15,2.66,5.82,5.94.17.77.05,1.65-.19,3.41-.36,2.63-.57,4.1-1.61,5.03-1.39,1.2-2.75.1-4.43.89-1.36.65-1.9,2.09-3.31,10.06-1.12,6.3-1.12,7.46-.39,8.73.77,1.39,1.99,2.23,5.11,3.62.43.19.86.38,1.27.55,6.33,2.71,10.09,3.36,10.09,3.36,10.9,1.82,17.38.53,21.21,1.3,1.41.27,2.45.84,3.21,1.92.53.76.7,3.67,1.05,9.49.31,4.93.39,7.38.19,8.97-.93,7.21-4.91,12.58-7.36,15.41-.5.57-.93,1.03-1.25,1.39-1.73,1.87-2.59,2.8-3.23,3.04-.24.09-.48.15-.72.19-8.37,1.48-17.57-23.46-32.38-23.01-3.47.09-7.79,1.6-12.77,3.72-2.3.98-4.75,2.11-7.33,3.29-4.8,2.23-7.41,3.07-10.26,3.86-3.6,1-7.58,1.9-16.87,5.39-3.54,1.32-6.61,2.49-9.28,3.52-15.43,5.95-17.73,7.48-19.46,9.75-5.73,7.52-2.04,15.63-3.64,24.99-.03.27-.09.55-.14.82-1.03,5.11-2.97,6.5-7.28,13.78-2.93,4.94-8.49,14.33-12.08,25.45-2.39,7.36-3.9,15.5-3.19,23.6.88,10.18,4.48,11.65,7.02,18.76.72,2.02,1.36,4.51,1.82,7.77.88,6.19.22,10.54-.98,14.5-2.06,6.93-5.75,12.75-5.65,25.48.05,6.56,1,10.3,1.9,14.11,1,4.2,1.97,8.46,1.7,16.65-.33,10.16-2.01,9.04-3.91,24.42-2.01,16.23-1.49,28.57-.91,42.7.48,11.6,1.15,14,1.51,15.19.41,1.39,2.99,9.68,9.87,16.87,2.18,2.28,4.8,4.46,7.93,6.26.77.46,1.58.89,2.4,1.29,9.73,4.63,20.82,3.79,27.13,3.31,22.84-1.75,25.17-2.27,25.17-2.27,2.57-1.53,5.37-1.77,7.52-1.01,1.05.36,1.94.96,2.57,1.77,1.48,1.85,1.2,4.26,1.1,4.99M585.25,1000.59c-2.32.63-4.05,1.68-4.93,3.64-.7,1.56-.96,3.96-1.01,4.32-.29,2.15.29,4.93,1.61,10.45.82,3.4,1.7,5.83,2.11,7.88.17.81.27,1.53.27,2.25,0,.93-.17,1.82-.58,2.73-1.13,2.51-2.75,2.32-3.81,4.62-2.11,4.53,1.66,10.43,2.95,12.56.33.55.65,1.12.94,1.66.41.77.79,1.56,1.12,2.35M630.16,1163.78c-1.29-2.57-3.19-6.04-5.83-9.92-.72-1.06-1.37-1.97-1.84-2.61M535.6,541.08c-1.3-.26-2.59-.5-3.9-.76-1.82-.34-3.64-.7-5.46-1.05l3.02,12.87c.17.05.34.09.51.14,3.07.77,6.16,1.56,9.23,2.33M313.07,1000.71c13.95,1.75,25.67,2.99,34.63,3.91,2.32.24,6.23.6,10.45-1.2,5.59-2.4,8.41-7.17,9.04-8.13,3.67-5.61,19.19-13.47,67.82-23.97.22-.05.46-.1.7-.15M583.04,1026.88c-4.46,1.08-11.7,2.95-20.52,5.78-15.77,5.05-21.11,8.22-28.61,6.73-7.76-1.56-11.63-6.9-16.7-11.75-24.51-23.56-62.84-22.63-68.01-22.51-6.28.15-23.66.76-41.72,10.45-19.07,10.26-25.52,23.48-43.21,24.13-3.26.12-8.67-.82-19.49-2.81-13.78-2.54-24.97-5.22-32.57-7.17M309.48,1053.1c16.68,4.41,30,8.82,39.31,12.12,13.81,4.89,18.89,7.4,26.74,6.23,11.24-1.66,14.23-8.77,26.92-17.49,3.98-2.71,24.68-16.92,49.23-15.67,21.24,1.08,37.92,13.32,42.21,16.47,14.57,10.71,16.23,19.15,26.92,20.51,8.41,1.06,13.23-3.43,29.74-11.46,13.45-6.54,24.87-10.67,32.24-13.11M451.16,1171.94c25.83,0,47.33-18.53,51.94-43.02.6-3.17.91-6.47.91-9.83,0-29.19-23.66-52.85-52.85-52.85s-52.85,23.66-52.85,52.85c0,4.12.48,8.13,1.37,12,5.42,23.41,26.41,40.86,51.48,40.86ZM584.15,1064.7c-27.03,21.4-54.02,42.8-81.05,64.21M399.68,1131.08c-31.51-22.86-63-45.72-94.5-68.57M411.1,1194.24c-39.54-33.45-79.08-66.89-118.61-100.32M586.33,1100.48c-30.27,29.31-60.56,58.62-90.81,87.93M267.4,1153.44c41.89,67.85,116.18,108.21,194,104.92,104.39-4.43,162.27-85.18,168.76-94.57M388.4,949.48c11.67,6.4,24.3,12.58,37.92,18.31,2.9,1.22,5.8,2.4,8.68,3.52,10.23,4.03,20.34,7.52,30.29,10.55,44.65,13.57,86.09,17.8,120.02,18.17M589.4,905.48c-6.66-1.2-17.02-3.09-29.79-5.46-21.83-4.07-26.14-4.98-33.17-5.71-9.08-.94-22.14-1.56-38.32.34M473.43,897.93c-2.97,6.45-5.8,14.04-7.95,22.67-1.56,6.33-2.54,12.44-3.09,18.28-.81,8.24-.74,15.91-.19,22.81.62,7.83,1.84,14.66,3.09,20.16M601.4,937.56c-12.29-3.41-28.3-7.62-47.21-11.91-10.09-2.3-15.79-3.59-22.46-4.68-15.12-2.49-37.53-4.38-66.24-.36M594.21,961.94c-43.93-7.69-87.86-15.38-131.81-23.06h-.02M462.21,961.69c20.46,3.93,41.22,7.74,62.29,11.43,21.42,3.76,42.58,7.28,63.51,10.59M387.03,741.45c-10.45,4.8-24.01,12.61-36.65,25.07-6.04,5.95-9.7,10.85-15.36,18.41-8.49,11.31-9.68,15.12-10.18,18.02-1.3,7.93,2.04,14,3.86,18.89,3.07,8.22,5.9,21.52,4.26,43.43M541.44,705.39c4.65-6.85,6.9-11.1,6.57-13.99-.31-2.75-1.78-5.34-4.2-7.71-2.3-2.3-5.44-4.41-9.25-6.35-1.1-.55-2.25-1.1-3.45-1.61-6.45-2.87-14.38-5.29-23.03-7.26-17.19-3.96-37.29-6.16-54.78-6.4h-.93c-19.01-.21-36.24,1.87-51.28,4.94-14.64,3-27.18,6.93-37.22,10.64M358.68,682.28c-1.42,1.56-3.23,4.03-3.84,7.33-.03.17-.07.33-.07.5-1.2,7.88,5.22,14.79,11.46,22.41.67.82,1.32,1.61,1.92,2.37,14.93,18.64,11.67,20.49,18.88,26.56,10.83,9.15,19.63,5.18,62.86,5.89,36.26.58,48.34,3.67,59.1-2.25,1.3-.7,2.61-1.56,3.91-2.57,2.27-1.75,4.51-4.17,7.31-7.72,2.32-2.93,5.01-6.62,8.41-11.34.7-.98,1.44-2.01,2.21-3.09.5-.7,1-1.37,1.48-2.04,2.09-2.92,3.98-5.56,5.66-7.95,1.29-1.8,2.44-3.45,3.45-4.96M508.99,745.09c.55,1.01,1.17,2.13,1.85,3.33,2.81,4.99,6.64,11.5,11.48,18.95.94,1.44,1.92,2.93,2.93,4.44,14.16,21.07,17.97,21.79,20.9,31.95,4.99,17.31.34,37.31-.6,41.39-.38,1.6-1.84,7.64-3.12,15.94-.24,1.54-.45,2.97-.65,4.31-1.25,8.46-1.68,13.02-.1,15.41.62.94,1.37,1.63,2.23,2.15,5.42,3.28,15.34-.57,27.37,5.01,5.99,2.78,10.07,7.84,18.12,17.52.31.38.63.77.96,1.17,5.18,6.25,9.76,11.75,13.28,17.52M374.31,629.97c.22,9.11,3.11,13.66,5.73,16.11,1.15,1.08,5.08,3.33,12.97,7.84,3.48,2.01,5.94,3.36,7.31,5.78.19.31.34.65.48,1.01.94,2.37.63,4.72.27,6.21M531.33,630.62c.88,7.04-.69,11.33-2.76,14.07-3.4,4.46-8.67,5.47-13.18,7.04-3.11,1.08-5.87,2.42-7.41,5.32-.33.6-.57,1.22-.74,1.85-.88,3.11-.15,6.52.88,9.39M404,611.9c.09,2.42.46,5.42,1.12,9.27,1.72,10.02,2.99,16.83,4.91,21.62,1.2,2.95,2.64,5.13,4.6,6.81,1.8,1.56,7,2.75,17.38,5.13,10.33,2.37,15.5,3.55,20.39,3.52h.02c8.61-.07,15.1-2.3,20.7-4.22,7.79-2.68,11.69-4,14.76-6.93.91-.86,1.9-1.9,3.45-5.46,1.53-3.45,3.55-9.32,6.5-19.72,1.13-3.95,1.94-7,2.49-9.46,1.2-5.51,1.01-7.93-.38-10.19-2.25-3.67-6.38-4.93-9.58-5.82-18.33-5.18-27.51-7.77-39.45-7.74-1.29,0-19.77.22-36.65,7.65-2.54,1.13-5.97,2.81-8.27,6.42-1.46,2.27-2.15,4.8-1.97,9.11ZM384.27,629.58c-4.19-.14-7.45-.09-9.97.1v.02c-5.92.45-7.81,1.61-8.13,2.85-.17.63.1,1.15.38,3.93.22,2.28.26,4.15.26,5.39M538.37,641.23v-.76c-.02-1.12-.02-2.57.03-4.27.1-3.04.1-3.57.03-3.9-.02-.05-.03-.09-.03-.1-.14-.45-1.1-1.24-7.05-1.8-2.95-.29-7.12-.51-13.02-.63M400.33,659.71c1.01-3.19,1.94-7.07,2.45-11.55.36-3.09.45-5.9.39-8.41M502.57,635.65c0,.12.02.22.03.34.21,2.88.57,6.04,1.17,9.37.91,5.11,2.16,9.64,3.47,13.54v.02M566.27,636.7c-.05,0-.1,0-.17-.02-.27-.02-.58-.05-.89-.09-2.42-.26-5.73-.89-9.4-2.45-2.2-.94-3.62-1.56-5.23-2.95-.86-.76-2.59-2.63-6.09-10.54-1.15-2.61-1.85-4.63-2.11-5.44-1.48-4.32-8.97-25.71-14.83-43.52-.09-.27-.17-.53-.26-.79-.15-.46-.29-.91-.45-1.36-1.63-5.01-2.8-8.77-3.66-11.6-2.81-9.28-2.28-8.79-3.16-9.94-6.64-8.7-18.07-12.03-66.62-11.75-58.12.34-65.83,5.39-70.72,10.93-1.49,1.7-2.81,6.64-4.27,12.84-1.75,7.45-3.71,16.7-6.38,24.21-5.11,14.41-12.39,28.09-16.27,42.88-.36,1.39-1.3,4.86-4.31,6.83-1.46.96-2.73,1.12-7.07,1.78-1.92.31-4.99.79-8.89,1.46M436.93,477.14c.02,15.91.05,31.82.07,47.72h30.07c-.17-15.99-.33-31.99-.5-47.98M404,611.9c-3.81.07-6.59.45-8.27.74-1.15.19-2.11.43-3.21.79-1.73.58-2.81,1.29-3.72,1.82-.51.31-1.03.6-1.61.91-1.01.53-2.23,1.1-4.08,1.73l-.74.27c-.12,2.52.05,7.31,2.16,11.27.38.72.82,1.42,1.36,2.08,1.82,2.27,3.55,2.54,10.57,5.41,1.84.76,4.1,1.7,6.73,2.83,2.08.89,4.36,1.9,6.85,3.04.21.09.39.19.6.27M491.57,641.78s.02,0,.02-.02c2.15-1.42,5.59-3.5,10.11-5.41.31-.14.62-.26.91-.36,6.57-2.69,11.7-3.54,14.59-5.35.45-.26.82-.55,1.13-.88.57-.53.96-1.15,1.2-1.89.39-1.18.96-4.14.98-7.31,0-.94-.03-1.73-.07-2.3l-.72-.51c-.26-.1-.51-.22-.76-.33-.77-.34-1.48-.65-2.09-.96-.89-.41-1.65-.81-2.27-1.12-2.32-1.2-2.92-1.66-4.43-2.01-.82-.21-1.49-.33-3.91-.51-1.51-.1-3.54-.24-5.95-.36M378.41,560.03c1.15,11.57,2.76,23.75,4.96,36.45,1.17,6.78,2.45,13.33,3.81,19.68M516.87,616.47c.6-2.27,1.46-5.68,2.27-9.87,1.82-9.66,1.87-15.99,2.61-28.54.27-4.77.72-11.67,1.44-20.11M361.63,554.84l11.89-3c.07,0,2.92-12.66,2.92-12.66-2.9.58-5.78,1.15-8.67,1.73-.38.07-.76.15-1.13.22M543.91,882.95c-8.8-1.15-16.22-1.51-21.67-1.63-21.83-.43-26.07,3.21-27.53,4.43-.84.7-1.46,1.37-1.94,2.02-1.87,2.47-1.82,4.67-4.65,6.88-.31.24-.65.5-1.05.74-2.18,1.39-4,1.75-13.64,2.54-.46.05-.93.09-1.42.12-13.06,1.03-14.93.91-17.3,2.76-.31.24-.6.5-.84.76-2.92,2.9-2.45,6.38-4.98,11.31-3.24,6.3-7.84,8.13-18.7,14.67-12.78,7.72-34.22,21.93-41.79,21.93-.76,0-1.36-.14-1.82-.43-.21-.12-.91-.63-1.92-.91-.34-.1-.72-.15-1.13-.17-2.51-.1-4.43,1.78-4.79,2.09-2.25,1.97-19.63,9.94-72.21,31.39M541.78,865.4c-9.22-3.74-16.92-5.25-22.26-5.92-15.55-1.97-23.34-2.97-30.44-1.46-1.37.29-4.82,1.12-8.46.24-1.06-.26-2.15-.65-3.19-1.25-1.32-.74-1.78-1.36-2.63-2.01-4.6-3.59-10-.38-19.89,0-10.33.41-17.8-2.56-22.51,1.22-.19.15-.46.38-.84.63-.26.19-.58.38-.96.57-4.46,2.18-9.73-.27-11.02-.82-1.85-.79-11.93-.6-31.99-.19-20.11.43-31.85.86-37.19,6.44-.21.21-.53.57-1.01,1.05-.17.15-.34.34-.55.53-.67.63-1.44,1.3-1.75,1.54-1.89,1.36-5.46-.12-5.94-.31-1.73-.69-4.62-.74-8.2-.38-8.92.93-22.24,4.53-32.98,7.62-15.07,4.34-22.6,6.5-24.59,7.6-10.02,5.49-16.61,13.16-21.31,20.4M254.05,900.9c-2.47,3.76-4.43,7.43-6.13,10.61-2.92,5.53-5.18,11.03-6.9,16.42-3.14,9.75-4.53,19.03-4.99,27.11-.45,7.53-.12,14.02.34,18.83M492.77,887.78c-1.12-5.73-3.12-12.82-6.86-20.39-1.7-3.43-3.5-6.47-5.29-9.13M351.8,873.55c-7.5.67-16.58,1.51-26.91,2.56-12.84,1.29-17.56,1.87-23.99,3.69-4.46,1.29-8.01,2.68-16.2,6.35-7.71,3.47-18.16,8.36-30.63,14.76h-.02M356.4,888.84c-7.58,1.66-18.76,4.15-32.31,7.36-17.42,4.12-20.92,5.2-22.91,5.83-9.28,2.95-13.97,5.27-33.96,14.26-5.97,2.68-15,6.71-26.19,11.63M365.08,911.39c-43.02,14.55-86.04,29.1-129.05,43.66M244.3,980.13c21.83-7.22,44.36-15.2,67.53-24.04,21.78-8.31,42.66-16.82,62.62-25.4M349.4,863.89c.72,3.12,1.53,6.35,2.42,9.66,1.3,4.93,2.83,10.02,4.58,15.29.84,2.49,1.72,5.01,2.66,7.57,1.9,5.22,3.93,10.21,6.02,14.98,3,6.9,6.18,13.33,9.37,19.31,3.41,6.35,6.85,12.17,10.21,17.45M368.15,714.88c-2.57.53-5.17,1.06-7.77,1.63-2.42.51-4.86,1.05-7.31,1.6-.96.21-1.9.41-2.87.63-6.21,1.41-12.32,2.87-18.29,4.36-.02-.02-.02,0-.02,0-2.4.58-4.79,1.2-7.16,1.8M228.11,858.05h.02c15.22-7.17,27.83-11.69,36.67-14.5,11.12-3.55,18.09-5.03,22.91-11.67,4.08-5.59,2.42-9.1,4.63-21.5.34-1.92.76-3.81,1.3-5.71,2.45-8.63,7.29-17.78,17.57-33.07,1.61-2.39,2.97-4.29,3.86-5.49M331.91,723.09c-6.44-7.28-15.22-15.99-26.75-24.39-1.73-1.27-3.54-2.52-5.39-3.78-10.91-7.29-21.28-12.36-29.98-15.87M353.05,718.06c-7.02-8.46-16.23-18.19-27.97-27.85-10.36-8.53-20.39-15.08-29.14-20.06M354.75,690.1c-5.87-5.85-13.85-12.65-24.23-18.79-6.04-3.57-11.81-6.26-16.99-8.32M348.67,730.69c-7.62-2.02-15.6-3.96-23.94-5.78-12.49-2.71-25.76-5.15-39.74-7.12-9.08-1.27-17.9-2.27-26.43-3.04-4.02-.38-7.98-.69-11.86-.96M305.16,698.7c-7.53,1.58-15.98,3.79-25,6.95-8.05,2.8-15.26,5.89-21.55,8.94M336.83,747.8c-10.69-3.64-38.94-12.34-63.44-8.31-2.28.38-9.04,1.61-17.49,3.93-12.17,3.33-21.91,7.31-28.71,10.42M231.02,796.19c7.41-6.26,32.95-27.03,55.77-29.72,17.66-2.08,22.46-1.2,22.46-1.2,2.01.22,3.96.53,5.82.84,6.78,1.12,12.41,2.23,14.88-.89.55-.69.46-.96,1.17-3.47.6-2.16,2.32-8.1,5.71-13.95.67-1.13,1.39-2.28,2.18-3.38,2.59-3.59,5.17-6.38,5.17-6.38,2.21-2.4,4.84-4.86,4.55-7.4-.02-.1-.03-.22-.05-.33-.02-.14-.05-.24-.07-.31M293.4,804.6c-8.44-.43-20.22-.12-33.74,3.17-11.62,2.83-20.99,7.02-27.8,10.69M348.67,730.69l.05-.05c3.88-4.7,7.77-9.4,11.65-14.12.03-.03.07-.09.1-.12M574.25,664.64c-5.2,2.15-11.26,5.13-17.64,9.28-5.03,3.29-9.28,6.66-12.8,9.78M595.39,672.32c-9.11,4.34-19,9.63-29.31,16.03-9.2,5.71-17.38,11.48-24.64,17.04l-.02.02M528.62,723.45c.72.07,1.54.15,2.47.26,2.52.24,5.77.58,9.54,1.01.88.1,1.7.19,2.44.27,6.02.7,8,1,10.97,1.1,7.24.22,12.6-.93,14.93-1.37,6.04-1.12,19.82-2.76,51.67-5.22M616.52,673.08c-14.21,8.67-29.02,18.45-44.17,29.45-1.12.81-2.25,1.63-3.38,2.45-9.11,6.69-17.73,13.37-25.9,20.01l-.02.02M572.33,702.53h.02M559.05,770.89c-.45,9.56-.91,16.95-1.24,21.66-.43,6.33-.94,12.73,1.96,14.17,2.08,1.03,6.5-.17,8.24,1.24.72.58,1.37,1.34,1.37,1.34.31.36.67.81,1.1,1.49,2.61,4.17,2.68,8.19,2.81,15.07.29,14.81.34,16.03,1.6,17.49,2.45,2.87,5.66,2.35,13.47,3.83,4.36,0,8.13.91,11.31,2.09s5.71,2.64,7.58,3.72c1.89,1.1,4.39,2.75,7.43,4.91M520.21,734.79c1.1,1.32,2.08,2.63,2.95,3.9.51.72.98,1.42,1.41,2.11,2.59,4.15,4.14,7.89,5.1,10.91.1.31.19.6.27.89,2.11,7.09,1.58,11.33,4.51,14.26.26.24.53.48.84.72,1.61,1.2,2.9,1.32,14.07,2.37,5.56.51,3.21.51,9.68.94.48.03,1,.07,1.58.1,9.1.57,27.34,4.63,43.26,10.91,4.53,1.78,8.84,3.74,12.92,5.82M603.17,747.04c-10.12-1.48-18.45-1.01-32.35.24-1.68.15-3.45.33-5.32.5-9.15.86-21.28,2.28-35.56,4.82M629.1,828.71c-4.99-3.23-10.55-6.37-16.71-9.18-17.66-8.08-33.65-10.69-44.38-11.57M424.34,568.4c3.93.81,8.29,1.51,12.87,2.01,4.43.48,9.06.79,13.71.82h.02c.36.02.74.02,1.1.02h.46c4.56,0,9.11-.26,13.47-.7,5.87-.57,11.38-1.48,16.08-2.52v-.02c9.15-2.02,15.29-4.62,15.17-6.5-.15-2.08-7.79-3.33-16.73-4.08-4.75-.41-9.88-.67-14.43-.84-6.85-.26-12.41-.31-13.49-.31h-.89c-3.78-.02-9.13.02-14.84.21-4.84.12-9.94.36-14.55.74M422.28,557.21c-8.79.7-15.8,1.9-15.96,3.9-.15,2.09,7.29,5.1,18.02,7.29M482.03,567.99h.02s.04-.04.06-.06M436.83,556.53s-.03.07-.05.11M466.17,557.03c-.04-.11-.08-.23-.12-.34l-.02-.02M465.97,570.49c.11-.29.21-.57.3-.84M451.69,556.32s-.05.07-.08.11M452.5,571.09c-.03-.06-.09-.18-.16-.34M1425.55,888.82l.07-.19M1165.74,535.26l.02.02M1497.52,1015c-.29-.05-.55-.03-.74.1-.15.12-.22.27-.26.33-.72,1.49-5.85,7.05-14.88,19.92-2.83,4.05-5.25,7.64-7.19,10.59-.69,1.05-2.54,3.88-4.99,7.77-2.85,4.55-6.68,10.78-11.15,18.58-.07.1-.1.19-.12.29-.26,1.1.07,2.16.22,2.59.02.05.03.09.05.12.58,1.24,1.68,1.9,2.92,2.61,2.61,1.46,3.91,2.2,5.15,2.63,2.52.89,3.71,18.5.31,78.75-.05.84-.1,1.7-.15,2.56M1497.56,1015.02c.63.12,1.44.58,2.11,1,1.44.86,1.58,1.25,2.15,1.2.89-.07,1.78-1.17,1.66-2.01-.07-.45-.39-.6-1.82-1.75-.91-.76-1.36-1.15-1.56-1.41M1553.53,1039.37c.41-.98.89-2.09,1.46-3.38,3.31-7.55,4.96-11.33,7.31-14.09.5-.58,1.96-2.21,1.56-3.84-.02-.07-.03-.14-.07-.19-.21-.62-.65-1.15-1.12-1.44-1.72-1.08-4.03.69-7.33,1.94-6.76,2.56-13.76,1.39-18.38,1.77-.09.02-.6.05-1.29.05-.46-.02-.79-.02-1.13-.09-.65-.12-1.15-.41-1.48-.65-13.51-9.18-15.48-10.93-15.48-10.93-1.03-.91-2.47-2.23-4.39-2.18-.09.02-.22.02-.43.05-.46.12-1.29.41-2.92,1.3-3.6,1.96-4.36,3.16-5.73,2.83-1.29-.31-1.56-1.48-2.57-1.32-.24.03-.48.15-.7.31-.65.5-1.12,1.41-.98,2.13.02.1.07.22.21.39M1553.53,1039.39c-1.13,2.76-1.58,4.55-1.08,6.25.82,2.76,3.74,4.53,9.54,7.96,4.96,2.93,7.43,4.41,9.64,4.58,3.24.26,6.37-1.13,14.84-8.97,9.97-9.22,17.3-18.17,22.82-25.23,2.11-2.69,4.2-5.54,6.4-8.73,5.94-8.63,4.14-7.04,11.69-19.07.19-.31,2.33-3.72,4.34-8.63,1.32-3.24,1.99-4.91,1.84-6.45-.09-.86-.5-3.21-8.6-9.54-4.96-3.86-7.6-5.89-10.54-6.13-.12,0-.26-.02-.38-.02-.72-.02-3.26-.02-8.08,3.07-8.87,5.7-12.46,13.51-15.62,14.93-.5.24-1,.29-1.51.15-1.18-.33-1.78-1.58-1.84-1.7-.5-1.08-.36-2.59,2.75-7.89,2.61-4.44,3.31-4.77,3.5-6.52.09-1-.62-2.81-2.04-6.38-2.01-5.08-2.93-6.47-4.02-7.64-.82-.91-1.54-1.46-2.61-2.25-6.06-4.51-9.3-6.45-9.3-6.45-9.39-5.61-12.92-7.43-14.48-8.85M1560.79,935.86c-.67-.6-.98-1.13-1.22-1.87-.45-1.34-.43-3.86-.39-8.91.03-3.66-.86-5.73.17-7,.03-.07.1-.14.17-.21.96-.93,2.95-1.36,4.19-1.63,1.42-.31,2.01-.21,2.51-.72.91-.93.46-2.71.14-4.12-1.73-7.62-.74-9.64-2.4-10.45-.96-.48-1.48.12-6.21,1.73-5.47,1.85-6.62,1.65-7.4,2.99-1.24,2.13.89,4.08.07,6.32-.07.14-.12.29-.21.43-.82,1.53-2.16,1.05-6.92,3.33-4.14,1.99-4.75,2.78-6.47,2.73-.77-.02-1.44-.21-2.09-.51M1534.67,917.93c-1.18-.58-2.28-1.61-3.72-2.87-2.54-2.2-6.93-5.1-15.72-10.93-1.08-.72-2.99-2.49-6.06-3.54-1.61-.55-2.99-.76-4.03-.89-1.97-.27-3.21-.22-7.45-.1-5.54.17-5.53.14-5.68.22-2.78,1.53-3.78,6.13-6.02,9.82-.29.48-.89,1.41-1.66,1.65-.14.05-.27.07-.41.07-.15,0-.27-.03-.33-.05-3.79-1.13-3.79-1.92-15.31-5.49-.82-.26-3.11-.94-3.35-2.35-.02-.1-.03-.19-.03-.29-.02-1.75,2.61-2.83,2.61-4.91-.02-1.8-2.06-2.32-9.13-7.1-1.68-1.15-4.58-3.16-8.82-4.96-2.2-.94-2.97-1.06-3.74-.82-1.51.46-2.81,2.45-5.35,6.38-.5.79-1.01,1.6-1.92,1.82-.91.21-1.53-.34-2.97-1.15,0,0-3.59-2.04-8.24-3.28-.41-.1-.65-.17-1.15-.33-.21-.07-.39-.14-.57-.19-1.15-.39-1.41-.58-1.51-.67-.63-.53-.81-1.27-.91-1.61-.5-1.9-1.73-3.62-3.07-6.09-1.36-2.47-2.81-5.66-3.79-10.52-.48-2.44-.65-4.5-.65-6.19,0-4.44,1.18-6.5,1.18-6.5v-.02s.02-.07.02-.07c0-.07,1.96-11.84,2.44-16.15.46-4.1.22-7.1-.09-11.27-.15-2.16-.58-6.64-1.85-12.32-1.8-7.96-3.21-9.1-4.79-15.84-.98-4.24-.51-4.19-1.72-13.99-.07-.5-.12-.98-.17-1.46-1.42-11.43-2.27-17.45-4.82-22.5-3.29-6.56-7.5-10.23-8.72-11.26-3.31-2.76-6.35-4.22-7.36-4.67-5.94-2.69-9.25-1.8-16.71-2.57-.51-.03-1.06-.1-1.63-.17-4.74-.58-12.06-1.56-19.46-5.78-1.2-.69-5.06-2.9-7.76-5.59-1.77-1.77-3.02-3.76-2.69-5.66.46-2.64,3.69-3.41,7.4-5.58,5.99-3.47,10-10.3,17.8-23.82,6.52-11.31,9.78-16.97,11.03-21.42,4.03-14.17,1.39-26.46,6.57-34.58.62-1,1.36-1.9,2.23-2.76.93-.88,2.18-1.9,3.38-3.91,1.7-2.85,1.54-4.82,2.18-16.11.21-3.74.41-6.81,1.46-10.4.51-1.73,1.24-3.6,1.24-3.6,1.22-3.23,2.42-5.41,2.73-6.02,4.03-7.88-.36-24.87-.79-26.46-.53-2.02-.94-3.16-1.03-4.02-.05-.55.02-.98.26-1.44,2.54-5.1,18.04-1.97,23.48-1.05,29.12,4.94,66.21-2.93,89.84-16.41,10.07-5.75,18.81-14.72,36.28-32.66,21-21.57,34.85-40.77,33.53-41.97-1.94-1.78-32.93,37.96-77.93,52.6-5.61,1.82-13.71,4.39-24.69,4.98-11.14.6-13.2-1.49-45.41-6.56-16.85-2.64-25.28-3.96-30.27-3.86-2.63.07-7.26-.33-16.53-1.08-2.51-.21-4.77-.41-7.33-1.49v-.02c-.14-.03-.26-.09-.39-.15-4.67-2.09-7.16-5.66-8.17-6.98-3.83-5.01-9.59-7.69-21.14-13.06-17.9-8.34-44.94-11.51-67.15-3.45-5.49,2.01-11.89,4.32-18.21,10.07-7.16,6.52-6.14,10.06-11.81,13.16-.1.05-.21.1-.29.15-7.09,3.72-10.42-1.2-26.17.63-5.34.63-8.96,1.66-11.65,1.77-1.75.09-3.12-.22-4.34-1.27-.36-.31-.69-.65-.94-1.05-1.65-2.3-1.58-5.82-1.39-10.38.12-3.05.31-7.14.51-11.75.58-12.25,1.32-28.19,1.32-38.3,0-3.47-.09-7.09-.88-7.21-1.18-.17-3.24,7.64-5.15,14.96-1.7,6.57-3.17,12.36-4.46,17.45-5.08,19.97-7.58,29.57-11.7,35.42-.34.48-.69.93-1.05,1.36-1.17,1.41-2.49,2.59-4.02,3.67-3.67,2.59-5.73,2.59-10.21,6.52-1.18,1.03-2.56,2.23-3.93,3.64-1.8,1.77-3.6,3.86-5.01,6.26-1.7,2.92-2.83,6.32-2.64,10.19.36,8.01,6.09,14.88,11.98,17.95.72.38,1.25.6,1.82.84,6.64,2.73,12.05,2.06,19.72,1.29,2.49-.24,5.23-.5,8.34-.65,1.46-.07,2.73-.1,3.83-.1,6.42-.05,8.27.76,16.56.34.63-.03,1.29-.03,1.92,0,3.36.07,6.73.65,10.02.12,1.48-.22,3.83-.7,4.82.5.26.31.39.72.45,1.13.1.93-.22,1.9-.33,2.23,0,.02.21,6.81.6,20.39.6,19.68,1.25,17.52,1.08,26.53-.03,1.34-.07,2.93-.03,4.84,0,1.89.09,4.08.29,6.64.57,6.78.89,10.31,3.14,13.99,2.76,4.56,5.18,3.96,5.9,7.36.81,3.83-2.08,5.42-1.68,11.58.1,1.73.45,3.5.67,4.44.1.46.17.74.17.74.55,2.09,1.08,3.19,1.36,4.03,1.03,3.05-.34,6.09-2.69,11.12-3.21,6.9-7.07,11.27-8.61,12.94-2.59,2.78-4.86,4.55-5.73,5.22-1.82,1.37-3.28,2.47-4.75,3.26-.55.29-1.1.55-1.68.76-2.71.98-4.74.55-7.19-.17-.21-.07-.41-.12-.62-.19-2.61-.79-5.77-1.8-10.69-1.89-5.61-.1-8.41,1.1-9.16,1.44-3.86,1.75-5.65,4.43-7.09,5.95-2.68,2.85-5.95,3.64-9.83,3.83-5.27.24-11.62-.63-18.95,1-10.4,2.32-17.06,8.39-26.7,17.21-3.81,3.48-6.78,6.74-9.52,10.16-2.59,3.23-4.96,6.61-7.69,10.43-5.2,7.31-10.18,14.35-14.55,23.06M1037.38,947.99c-.07.33-.12.62-.17.89-.14.82-.98,5.37-2.68,10.55-1.61,4.91-2.73,8.31-4.8,12.73-.17.36-.36.74-.55,1.13-1.27,2.63-2.9,5.65-5.15,9.52-8.99,15.55-18.45,51.76-4.19,70.77,1.17,1.54.09-.22,20.51,15.92,1.17.93,2.64,2.09,4.41,3.48.53.41,1.1.86,1.7,1.32,3.14,2.44,7.04,5.44,11.6,8.85M1110.77,1115.17c4.6,1.84,8.94,4.34,13.54,6.23,1.1.45,3.57,1.46,4.82,3.86.5.91.69,1.82.74,2.75.05,1.17-.1,2.39-.22,3.72-.33,3.71.38,7.43.46,11.14.1,5.1,39.16,27.49,155.66,83.3M1285.79,1226.16l1.39.67M1441.59,936.46c.03.22.07.43.1.65,1.97,13.01,2.3,20.52,2.15,25.12-.03,1.24-.21,5.97.24,12.22.14,1.94.34,4.05.67,6.37.72,5.3,1.72,9.66,2.51,12.7.45,1.66.82,2.97,1.01,3.59.05.19.1.33.1.34,5.32,17.56,7.4,43.73,7.4,43.73.09.98.21,2.63.34,4.75v.02M1163.18,1030.88c1.48-.72,3.16-1.9,3.6-3.71.43-1.75-.43-3.62-3.04-6.52-1.08-1.2-2.47-2.57-4.2-4.2-7.26-6.81-8.32-6.47-11.34-9.66-2.61-2.76-3.26-4.55-9.71-20.52M1130.75,970.49c-.36-.22-.72-.34-1.12-.38-3.45-.34-7.02,4.82-8.44,8.44-.5,1.24-2.02,5.15-.5,8.94,1.12,2.73,2.85,2.97,5.56,6.5,2.39,3.12,3.26,5.82,3.86,7.24,1.41,3.36,4.07,6.04,7.45,8.67,6.95,5.39,16.95,10.55,25.62,20.97,5.94,7.17,9.64,14.88,14.21,14.04.98-.19,1.78-.72,2.59-1.34M1369.71,1165.93c-103.48-69.21-173-116.26-178.07-121.26-.58-.58-3.24-3.48-6.76-3.38-2.18.07-3.52,1.25-4.84,2.25M1137.6,966.42c1.3-.88,2.37-1.65,3.19-2.28,22.24-16.89,34.56-47.33,36.21-64.47.21-2.11.48-6.5,3.21-11.1,3.12-5.25,7.09-6.83,13.35-11.74,0,0,3.26-2.54,12.56-12.24,25.14-26.19,27.82-56.77,27.82-56.77,1.36-15.48-1.94-30.37-7.84-42.71-3.62-7.65-8.25-14.33-13.39-19.55-.79-.79-2.39-2.42-4.6-4.32-4.94-4.22-12.94-9.78-21.74-10.31-5.8-.34-10.81.81-10.81.81-4.74,1.08-6.5,2.52-12.06,4.34-5.42,1.77-9.35,2.23-11.26,2.57-4.75.84-12.12,3.57-24.04,11.22-3.12,2.01-6.57,4.38-10.38,7.12M1226.93,708.46c3.78,1.99,9.03,4.93,15.03,8.89,21.69,14.29,33.72,28.98,55.19,44.94,0,0,4.36,3.24,15.55,9.44,10.26,5.68,12.65,5.97,14.84,5.53,4.93-1.01,7.71-5.49,12.39-13.02,3.64-5.87,3.43-8.1,3.05-9.34-.88-2.88-3.29-2.63-5.15-5.95-2.28-4.1-1.06-8.92-.15-12.54.51-2.06,1.56-5.22,3.86-8.68M1430.97,1165.07c-.07-.67-.14-1.32-.21-1.99-.14-1.48-.29-2.97-.45-4.44-1.36-13.63-2.75-27.23-4.12-40.86M1410.79,785.45c-.03.15-.05.33-.09.48-1.32,7.21-2.37,13.59-3.21,19-2.78,17.85-2.11,18.09-3.9,24.47-2.27,8.15-4.29,11.24-4.96,18.96-.1,1.3-.15,2.54-.15,3.69-.07,3.96.34,6.9.53,8.27.38,2.81,1.54,15.98,3.26,35.09,3.05,33.94,7.79,86.68,12.84,133.65,1.24,11.6,3.02,27.71,5.39,47.26.74,6.07,1.53,12.48,2.37,19.19M1398.47,852.05c-1.65-.65-3.54-1.36-5.63-2.06-5.18-1.77-11.7-3.6-19.29-4.86-4.29-.7-7.5-1-10.95-1.06-6.07-.15-12.85.39-27.41.58-21.61.27-32.74-.62-41.96.05-4.7.34-8.92,1.1-13.78,2.61-1.99.62-8.56,2.75-15.68,5.18-1.61.55-3.02,1.03-4.26,1.46-9.95,3.47-9.2,3.55-15.65,5.54-1.82.57-1.9.63-2.2.79-7.36,3.88-6.74,18.31-6.28,26.99,1.39,26.58,1.68,53.2,3.05,79.78.6,11.7.51,13.8-.74,16.82-4.31,10.45-15.56,14.05-52.12,28.38-8.7,3.41-16.15,6.25-21.85,8.39M1259.52,853.97v-.02c-1.22-8.51-3.04-20.64-5.53-35.23-3.4-20.09-4.68-25.04-5.78-28.71-1.15-3.86-4.19-13.85-9.95-24.64-1.82-3.41-3.93-6.93-6.33-10.35-3.76-5.34-7.91-9.97-12.24-13.99-14-13.06-29.7-19.65-39.02-22.84M1293.24,844.7c-2.73-17.57-6.9-38.44-13.54-61.57-2.09-7.28-3.84-12.78-5.32-16.99-1.89-5.41-3.29-8.68-4.31-10.78-.45-.91-.81-1.61-1.12-2.16-5.61-10.36-18.89-29.65-50.9-44.15-.15-.09-.31-.15-.46-.22M1392.84,849.99c-1.6-18.69-3.33-35.28-4.98-49.41-1.6-13.83-2.93-23.61-6.92-36.04-2.68-8.36-5.65-15.05-7.86-19.6M1362.6,844.05c-.55-18.64-1.99-34.27-3.36-46.04-1.44-12.29-2.64-22.19-5.8-35.23-.19-.77-.38-1.54-.57-2.3-2.81-11.15-6.02-20.35-8.63-27.1l-.15-.41M1135,948.57c12.54-10.02,17.73-19.63,19.96-24.78,3.45-7.98,5.78-17.01,5.78-17.01,2.08-8.03,2.15-11.75,4.41-18.77,2.08-6.42,4.63-11.38,6.45-14.53M1116.15,866.2c12.25,6.97,20.76,5.92,24.09,5.23,4.44-.91,7.55-2.78,21.73-13.28,17.42-12.92,26.14-19.37,29.67-22.67,8.61-8.03,23-23.9,33.77-51.64M1247.2,671.16c10.9,23.58,19.92,30.79,26.34,32.81,1.56.48,6.11,1.65,11.79,4.68,5.83,3.12,7.65,5.42,12.22,8.44,7.89,5.23,15.48,6.98,19.22,7.81,13.49,2.95,25.38-.24,32.18-2.76M1333.05,668.89c3.04,1.77,7.41-4.27,14.55-3.14,4.08.65,4.99,3,7.12,2.28,3.93-1.36,4.75-10.78,3.33-17.73-.27-1.41-2.85-14.02-9.39-15.07-7.12-1.13-14.84,12.1-16.82,22.39-.34,1.75-1.84,9.49,1.2,11.26ZM1302.3,611.82c-.05.6,3.31,1.25,18.81,3.86,22.65,3.83,24.35,3.91,26.68,3.88,6.11-.1,4.77-.91,24.64-3.84,11.48-1.7,17.14-2.21,17.13-2.92-.03-.91-9.22-1.7-17.04-1.82-12.22-.17-17.59,1.39-20.2-2.04-.39-.51-.94-3.26-2.06-8.75-1.3-6.49-1.6-8.31-2.16-8.32-.86,0-1.68,4.12-2.54,8.51-1.41,7.14-.79,7.38-1.61,8.56-2.63,3.76-9.37,1.82-23.05,1.56-8.25-.15-18.53.33-18.6,1.32ZM1165.76,535.28c-.45,1.66-1,4.48.22,5.37,1.97,1.44,7.34-3.05,8.24-3.81,2.78-2.33,7.09-6.9,9.7-15.39M1191.55,571.13c1.82-.81,3.76-1.89,5.42-3.31,1.73-1.44,3.19-3.26,3.98-5.53.45-1.3.53-2.35.57-2.75.41-4.48,1.87-15.65,4.07-31.59.36-2.56.72-5.25,1.12-8.05M1297.55,717.1c.36-5.46.48-10.28.48-14.31.02-4.14,0-6.23-.36-7.72-1.68-7.02-6.09-7.71-6.26-13.27-.02-.53.43-3.05,1.32-8.08.94-5.29,1-4.99.98-5.34-.07-4.94-8.8-9.66-36.5-21.5-2.92-1.25-7.02-3-10.91-7-4.27-4.39-6.25-9.37-7.22-12.73M1385.98,641.04c-.57.43-1.1.86-1.63,1.29-11.63,9.4-13.99,16.11-13.71,20.7.14,2.59,1.32,7.52-.22,13.69-.36,1.48-.88,3.05-1.53,6.19-.55,2.66-.84,4.74-1.24,7.69-.27,1.99-.6,4.62-.91,7.72M1237.56,573.15c1.12-.29,2.76-.84,4.56-1.87,6.07-3.47,8.37-9.35,12-19.05,2.71-7.24,3.45-11.81,4.89-20.94.53-3.35,1.42-9.7-1.03-10.98-.38-.21-.72-.21-3.24-.29-2.27-.09-4.02-.15-4.93-.21M1395.4,569.72c-.02-.21-.05-.41-.07-.63-1.12-9.87-3.9-22.91-10.91-36.64-2.37-4.63-4.91-8.75-7.45-12.36M1219.62,961.19c-2.59-10-5.63-20.47-9.16-31.37-3.19-9.76-6.52-19.01-9.9-27.75M1211.9,956.13c-1.78-3.76-4-7.83-6.76-12.06-4.8-7.38-9.94-13.2-14.47-17.62M1170.65,935.86c5.8,8.1,11.09,14.16,14.71,18.09,7.38,7.98,12.05,11.63,24.37,23.65,5.71,5.56,10.23,10.16,13.04,13.02M1179.57,963.13c6.44,5.15,10.67,10.04,13.37,13.56,3.26,4.27,4.8,7.29,8.82,11.05,4.03,3.74,8.1,5.95,10.86,7.22M1193.08,1001.48c-1.72-3.93-3.78-8.15-6.26-12.54-3.43-6.04-6.98-11.26-10.38-15.68M1279.7,761.42s.02.02.03.03c1.92,1.73,3.81,3.36,5.66,4.91,7.71,6.42,14.67,11.17,20.11,14.59,19.41,12.17,24.92,10.5,26.55,9.9,5.95-2.23,9.37-8.96,13.27-16.65,2.75-5.42,4.24-10.24,5.06-13.52M1320.96,824.62c-2.76-4.36-5.65-8.79-8.68-13.27-6.42-9.47-12.89-18.31-19.31-26.55M1195.98,884.7c5.75-.93,16.68-3.59,25.57-12.54,5.44-5.49,7.77-10.97,11.82-20.51,2.02-4.75,6.4-15.89,8.68-31.13,1.18-7.88,2.09-18.72.98-31.61M1050.25,1010.88c-3.45,5.73-6.85,13.25-5.9,20.18.19,1.34.53,2.66,1.08,3.95,1.8,4.27,5.29,7.02,9.95,9.23M1180.03,1043.54s-.03.03-.05.03c-6.97,6.49-14.53,14.57-21.81,24.51-16.3,22.26-24.23,44.27-28.3,59.92,0,.02-.02.03-.02.05M1485.95,987.87c.07.1.14.21.19.33.5,1.06-.12,1.9-.74,4.14-.76,2.69-1.22,4.36-.46,5.61.82,1.32,2.52,1.22,2.57,2.35.03.69-.38,1.44-1,1.72-.12.05-.29.1-.65.05-.38-.03-.98-.21-2.01-.58-1.72-.65-2.02-.94-2.59-.79-.88.24-1.61,1.3-1.42,2.02.14.51.7.67,1.61,1.17.69.39,1.65,1.05,2.66,2.09-.03.03-.24.34-.27.39-7.57,11.15-15.82,22.96-15.96,23.13-1.39,2.02-3.12,4.56-5.15,7.53-1.84,2.73-3.91,5.82-6.18,9.2-.21.33-.43.63-.63.96,0,0-.17.26-.46.69-.88,1.32-2.83,4.29-4.65,7.09-4.27,6.56-8.68,13.02-13.14,19.46-4.87,7.05-9.83,14.07-14.79,21.07-13.93,19.75-27.83,39.54-39.92,60.44-.41.7-1.96,3.45-4.02,3.45-1.68,0-2.35-1.85-3.83-1.65-.96.12-1.34,1.01-3.33,4.55-.93,1.63-1.61,2.78-2.08,3.64-.77,1.42-.94,2.02-.67,2.71.53,1.32,2.06,1.48,2.25,2.9.14,1.01-.5,1.87-.79,2.25-8.63,11.45-17.81,23.68-24.13,35.3v.02c-6.44,11.81-8.72,14.09-16.32,24.16-.91,1.2-1.9,2.52-2.99,3.98-.26.36-.6.82-1.2,1.29-2.37,1.84-4.51.43-7,1.68-1.29.65-2.13,2.04-3.78,4.82-1.56,2.63-2.35,3.95-2.42,5.23-.22,4.22,5.08,7.58,9.1,10.12,4.08,2.61,6.33,4.03,9.16,3.47,2.28-.46,4.03-2.4,7.57-6.28,1.44-1.6,2.04-2.51,2.18-3.69.24-1.96-.79-4.19-1.36-4.79-.02-.03-.07-.09-.12-.17-.41-.74.46-1.92.74-2.3,2.15-2.99,30.85-45.7,32-47.43,8.03-12,12.06-17.98,12.06-18.02.05-.19.24-.98.77-1.15,1.15-.38,2.21,2.59,3.9,2.59,1.32,0,1.65-1.82,4.43-5.54,2.25-3,3.36-3.6,3.14-4.84-.31-1.68-2.59-1.73-3.31-3.6-.82-2.18,1.24-4.84,1.82-5.63.55-.72,1.68-2.32,3.35-4.7,5.01-7.14,14.88-21.36,28.11-40.53,8.56-12.41,18.55-26.89,29.58-42.85.81-1.2,1.65-2.42,2.49-3.64M1460.15,947.15c-.26.53-.88.72-1.34,1.61-1.54,2.99-.55,6.35.12,8.53,3.19,10.31,4.79,15.48,6.14,16.8,1.37,1.34,4.63,3.17,11.14,6.88.46.26,2.51,1.41,4.93,3.12,1.75,1.24,1.01.88,3.28,2.54.89.65,1.29.91,1.53,1.22M1425.58,888.84h-.03v-.02c-2.08-.67-5.39-1.48-9.34-1-5.44.65-12.3,3.71-12.34,7.12,0,.1,0,.21.02.31.15,1.27,1.42,2.21,4.53,4.65,10.43,8.22,17.47,11.45,17.09,15.27-.09.81-.48,1.65-1.18,3.12-1.37,2.9-2.66,3.72-2.44,5.18.17,1.25,1.2,2.06,2.08,2.71,8.58,6.5,10.83,7.83,12.01,8.34.12.05.55.19,1.1.45,1.15.53,2.04,1.13,2.71,1.65l.19.12c.81.43,1.36.45,1.72.36.07-.02.14-.03.21-.07.69-.29.74-1,1.75-2.25.58-.72.88-1.08,1.2-1.24.07-.03.15-.05.22-.07,1.49-.31,3.79,2.9,7.69,6.23,4.56,3.86,7.79,5.15,7.48,7.1-.02.1-.03.19-.07.27M1455.34,1044.67c.03,1.06.09,2.15.12,3.21M1484.12,1005.98c4.46,3.02,8.94,6.01,13.4,9.03.02,0,.02.02.03.02M1500.09,1012.05s-.02,0-.02-.02c-4.74-3.31-9.47-6.64-14.21-9.95M1500.85,1009.51c-4.44-3.07-8.89-6.14-13.33-9.22M1485.94,987.86s.02,0,.02.02c8.94,6.18,17.88,12.36,26.82,18.52,0,.02.02.02.02.02M1460.15,947.15s.02-.03.03-.05c8.05-11.94,16.11-23.87,24.14-35.81M1445.08,933.49l19.82-30.32M1563.79,1017.87c3.57-.27,6.13-1.34,7.84-2.32,1.1-.62,2.83-1.77,9.46-10.33,3.38-4.38,4.53-6.13,5.15-7.12,3.28-5.22,3.84-7.69,4.07-8.84.43-2.45.26-4.53.05-5.85M1553.53,1039.37v.02c.39,1.41,1.25,3.55,3.07,4.24,2.75,1.03,6.13-1.87,7.96-3.54,12.63-11.5,26.29-31.13,26.29-31.13,11.57-16.61,14.93-19.77,19.15-30,2.27-5.51,3.62-10.26,4.43-13.54M1550.41,911.99c2.95,1.97,5.9,3.93,8.87,5.89M1534.67,917.93s.03.02.05.03c8.7,5.97,17.37,11.94,26.07,17.9,0,.02.02.02.02.02M1398.88,787.71c-1.96-2.42-4.58-5.22-6.02-4.58-1.77.77-.81,6.32-.24,10.86.77,6.19,1.41,15.29.48,27.01M1437.66,1074.43c-2.2-.07-4.67-.03-7.34.22-3.54.33-6.66.93-9.3,1.61M1455.67,1074.91s.09,0,.12.02c.89.09,1.75.17,2.63.26M1274.79,733.83c-2.18-6.26-5.18-13.47-9.34-21.18-4.41-8.13-9.08-14.9-13.35-20.32M1289.76,749.1c-1.03-2.39-2.54-6.14-4.03-10.93-1.34-4.34-1.61-6.13-2.73-9.42-1-2.95-2.73-7.21-5.78-12.13M1328.03,738.02c-.74,1.87-1.94,4.7-3.69,8.03-2.63,4.99-3.95,6.32-4.99,9.01-1.08,2.8-1.89,7.12-.15,13.52M1419.15,1003.16c5.06-1.37,7.95-3.64,9.66-5.54,1.39-1.53,1.94-2.75,4.1-5.3,2.13-2.52,4.14-4.36,5.54-5.56M1415.68,973.73c-.65-8.72-1.06-15.8-1.32-20.51-.76-13.49-.72-17.76-1.82-24.85-1.27-8.24-3.21-14.76-4.58-18.81M1430.25,1163.13c-10.71-1.61-21.43-3.21-32.16-4.82M1330.05,1233.27c-14.76-2.37-29.5-4.74-44.26-7.1h-.02M1466.84,1159.29c-12.18-.22-24.33-.45-36.52-.65h-.02M619.21,791.71c.46-.69.91-1.36,1.34-2.02,7.72-11.63,13.44-21.31,17.38-28.33.46-.81.93-1.61,1.41-2.44,1.82-3.11,3.91-6.47,7.07-11.5.72-1.15,1.51-2.4,2.37-3.76,2.39-3.76,4.22-6.61,5.75-8.8,2.83-4.05,4.63-5.9,6.88-7.17.34-.22.7-.39,1.08-.58,7.86-3.76,16.11-1.1,17.69-.57.91.31,1.73.65,2.47,1.03,2.32,1.15,3.98,2.59,5.85,4.34,1.75,1.65,3.69,3.57,6.52,5.77,6.42,4.99,10.95,6.4,20.56,10.55,2.21.96,4,1.75,5.54,2.47,5.34,2.51,7.72,4.02,14.31,7.46,3.57,1.87,8.37,4.31,15.53,7.77,1,.48,2.01.96,3,1.46,23.39,11.27,46.52,22.12,66.93,26.79,11.34,2.61,22.17,4.08,22.17,4.08,6.78.93,9.13.98,13.56,1.48.79.09,1.63.19,2.57.33,12.89,1.73,18.07,4.08,28.13,6.35,10.76,2.4,18.5,2.8,32.33,3.47,6.8.33,13.99.69,21.79.58,9.25-.12,19.39-.88,30.85-3.04,7.86-1.48,20.37-3.93,35.26-10.67,14.43-6.54,23.9-13.87,28.26-17.13,4.79-3.59,10.57-7.64,17.57-12.08l1.13-.72c4.74-2.97,10-6.11,15.89-9.39,9.73-5.42,21.14-11.24,34.48-17.31M663.3,1069.47c4.63,9.88,6.18,18.34,6.61,24.69.79,11.21-1.58,19.91,2.57,22.27,3.83,2.18,8.8-3.5,13.27-.86.67.39,1.13.84,1.46,1.37,1.39,2.13.82,5.25,3.91,8.8,3.43,3.91,6.69,3,12.61,6.95,3.98,2.63,6.59,5.73,8.19,7.98M967.83,1086.75c6.83,1.42,10.43.03,12.48-1.58,4.15-3.28,3.35-8.63,8.56-12.41,2.73-1.97,5.29-.53,6.86-2.57,1.85-2.42.55-6.26.17-7.48-3.91-12.9,8.51-25.72,6.81-50.45-.74-10.73-3.35-12.39-1.85-20.42,1.51-8.13,5.49-13.33,10.71-20.4,3.69-5.03,8.65-11.86,14.67-20.47,2.39-3.43,4.94-7.12,7.65-11.1M658.35,720.41c-1.42-.09-3.17-.12-5.2-.03-2.44.12-5.27.43-8.36,1.13-2.13.46-4.36,1.12-6.68,1.99-3.52,1.34-6.57,2.99-9.22,4.72-5.41,3.52-8.99,7.38-10.95,9.75M657.7,695.58c-.72,4.2-1.22,9.71-.57,15.99.07.65.15,1.3.24,1.97.31,2.18.76,4.43,1.41,6.74.72,2.68,1.61,5.11,2.56,7.28M657.14,711.57c-2.56-.03-5.63.12-9.06.7-2.23.36-4.26.86-6.06,1.41-1.22.38-2.35.76-3.36,1.15M694.63,702.96c-2.97-2.3-6.38-4.72-10.28-7.07-3.09-1.87-6.07-3.47-8.87-4.8M682.65,727.56c5.41-3.59,11.12-7.67,16.99-12.29,1.25-.96,2.51-1.97,3.78-3,3.93-3.21,7.62-6.42,11.07-9.56,2.66-2.42,5.18-4.8,7.55-7.14M727.7,702c-6.4,4.51-12.94,9.28-19.58,14.35-.86.65-1.7,1.29-2.54,1.96-5.83,4.46-11.45,8.92-16.83,13.35M668.2,693.33c2.59,3.5,6.5,7.98,12.08,12.2,7.36,5.54,14.53,8.32,19.36,9.75M692.38,686.16c2.51,2.73,5.73,5.82,9.73,8.85.43.33.86.65,1.3.98,3.96,2.92,7.76,5.1,11.07,6.73h.02M702.11,695.01c1-.79,2.11-1.78,3.23-2.97,1.58-1.72,2.76-3.38,3.64-4.82M694.63,669.66c7.36,9.03,13.97,11.63,18.65,12.34,1.22.19,2.25.22,3.21.24,2.59.03,4.56-.24,7.79,1.08,6.11,2.52,6.02,6.38,12.41,9.11,2.71,1.13,5.66,1.37,11.57,1.85,6.92.55,10.59.19,13.27.27,5.41.19,13.01,2.39,22.38,11.5M722.04,668.81c1.13,2.95,2.76,5.92,4.96,6.07,2.18.15,2.92-2.63,5.85-3.29,4-.91,6.3,3.38,9.85,3.43,1.24.02,2.76-.48,4.53-2.23,1.96-1.92,4.2-5.35,6.76-11.27M854.82,686.16c1.56,1.94,3.6,4.19,6.25,6.42,3.35,2.81,6.59,4.72,9.22,5.99M849.75,691.08c4.8,5.35,9.46,8.03,12.78,9.47,4.68,2.04,7.67,2.06,15.67,4.43,5.11,1.53,9.18,3.09,11.77,4.15M876.28,711.57c-4.48.81-10.12,2.25-16.3,4.96-4.94,2.18-9.03,4.63-12.24,6.86M960.46,691.08c-6.06,2.75-12.42,5.9-19.01,9.49-2.21,1.22-4.46,2.47-6.73,3.79-8.46,4.91-16.17,9.94-23.13,14.93-3.91,2.78-7.6,5.56-11.05,8.27M935.93,713.2c1.51-.27,3.38-.69,5.53-1.3,5.05-1.44,11.53-4.05,18.09-8.84,8.12-5.9,12.92-12.66,15.5-16.9M930.5,757.44c4.26.17,7.89-.19,10.95-.81,2.92-.58,5.29-1.41,7.17-2.2,8.32-3.48,8.49-7.1,19.7-12.63,6.37-3.14,8.82-3.21,13.61-6.76,1.39-1.03,2.64-2.09,3.74-3.16,2.52-2.44,4.36-4.86,5.63-6.76M987.6,711.57c10.93-.5,14.79-3.59,16.27-6.37.72-1.34.86-2.57,1.03-5.2.14-1.77.29-4.17.67-7.65.41-3.66.84-6.66,1.15-8.63M928.22,791.9c3.07-1.72,7.55-3.98,13.23-6.02.81-.27,1.63-.55,2.47-.82,6.73-2.18,9.56-2.18,15.41-3.64,12.75-3.17,21.9-8.77,25.69-11.14,3.76-2.35,8.55-5.71,13.64-10.43,2.16-1.99,4.39-4.24,6.62-6.76M727.7,716.82c1.48.41,3.17.93,5.06,1.54,3.78,1.25,8.32,2.93,13.35,5.18,9.16,4.07,15.31,7.96,18.41,9.83,8.01,4.84,20.39,11.09,38.95,16.56M705.56,718.28l.02.02c5.68,5.01,13.73,11.6,24.02,18.45.43.29.84.57,1.27.86,1.54,1,3.12,1.99,4.75,3,18.14,11.22,32.83,16.59,61.43,26.89,23.94,8.61,38.13,13.64,58.88,17.78,32.07,6.4,46.99,4.1,50.95,3.41,14.83-2.54,26.55-7.98,34.56-12.6.94-.55,1.84-1.08,2.68-1.6M938.41,803.24c.89-.34,1.9-.72,3.04-1.1,2.99-1,6.8-2.01,11.24-2.54,5.53-.65,9.13-.26,11.34-.21,6.19.12,12.7-2.39,32.76-19.07,6.86-5.7,15.36-13.09,24.78-22.17M1023.55,725.13c4.84-1.63,9.92-3.48,15.19-5.61.67-.26,1.34-.53,2.02-.81,2.78-1.15,5.61-2.37,8.48-3.66,11.07-5.01,20.87-10.31,29.4-15.46M1049.27,685.71c-5.23,2.68-10.69,5.66-16.3,9.01-8.12,4.84-15.46,9.78-22.05,14.6M1048.64,693.86c-1.1.88-2.15,1.66-3.14,2.37-1.96,1.37-3.69,2.42-5.03,3.19-3.5,1.99-5.37,2.61-8.56,4.72-2.83,1.85-4.91,3.71-6.21,4.99M772.99,657.17c-.31,4.96.02,12.27,3.41,20.01,1.68,3.83,3.83,7.14,6.25,9.99,5.58,6.57,12.58,10.74,18.5,13.32,5.94,2.59,10.78,3.59,11.98,3.81M801.15,700.49c.94-.7,2.28-1.75,3.76-3.21,2.73-2.66,5.92-6.68,8-12.2,2.04-5.41,2.27-10.23,2.15-13.27M997.15,697.52c-.6-2.54-1.41-5.49-2.56-8.68-2.27-6.3-5.83-13.54-11.57-20.47-.05-.07-.1-.12-.15-.19-8.25-9.9-13.13-9.71-20.76-19.48-3.04-3.9-4.72-7.07-5.95-10.24-2.45-6.35-3.07-12.66-8.84-24.47-.89-1.84-1.78-3.64-2.64-5.37-.38-.76-.76-1.49-1.13-2.23-.69-1.34-1.39-2.64-2.09-3.91-1.27-2.32-2.59-4.53-4.03-6.62-.93-1.39-1.9-2.71-2.95-4-2.93-3.62-6.35-6.85-10.62-9.63-5.85-3.81-12.06-6.01-19.44-7.53-6.56-1.37-14.04-2.25-23-3.28-7.12-.82-12.06-.96-15.84-.86-13.4.38-23.39,2.99-26.55,3.86-3.86,1.06-12.39,3.66-22.26,8.99-.58.31-1.15.62-1.68.91-.69.38-1.34.72-1.96,1.06-4.74,2.61-7.34,4.29-8.79,6.59-2.51,4-1.82,12.05-.34,28.01.62,6.61,1.24,11.36-.29,17.8-.86,3.62-1.58,4.38-2.78,8.36-.57,1.89-2.04,7.16-2.35,19.27-.17,6.5-.02,15.24,1.27,25.69M815.08,584.31c.12,1.12.24,2.2.34,3.24,1.08,10.79.91,18,.48,22.82-.46,5.22-.31,8.25,0,14.33.09,1.82.26,4.17,1.06,7.07.94,3.29,2.27,5.68,3.21,7.28,7.74,12.96,14,20.34,16.13,22.7.51.57.79.84.79.84,11.63,11.89,21.86,22.34,37.03,23.77,7.91.76,15.15-1.99,27.82-7.65,1.82-.82,3.74-1.7,5.8-2.63,11.38-5.15,20.11-9.46,26.32-19.05,2.8-4.31,4.56-8.91,5.56-12.08.65-2.06.98-3.5,1.06-3.88.36-1.68.58-3.12.76-4.56.31-3,.36-6.06.86-11.34.65-6.98,1.61-12.68,2.35-16.56M868.88,617.24c3.95,1.06,7.24,1.41,9.35,1.53.94.05,1.63.05,2.04.05,1.2,0,4.1-.05,7.91-.77,3.81-.7,8.55-2.09,13.4-4.74,1.9-1.03,3.83-2.09,5.42-3.23,2.23-1.6,3.84-3.4,3.96-5.61.21-3.81-4.05-6.98-7.81-9.25-.89-.55-1.75-1.05-2.52-1.48-4.86-2.78-9.59-4.1-13.45-4.77-2.95-.5-5.39-.62-6.95-.67-.5-.02-1.05-.03-1.65-.03-2.68-.02-6.19.17-10.18,1-2.95.6-6.16,1.54-9.47,3-5.46,2.37-12.18,5.32-12.41,9.78-.22,4.75,7.05,8.58,12.29,11.31,3.35,1.75,6.59,2.95,9.52,3.74.17.07.36.1.53.14ZM868.47,589.46h-.02c-.88.82-6.45,6.19-6.11,14.66.29,7.22,4.72,11.77,6.01,12.99.09.07.15.14.21.19M888.17,617.93c.77-.76,4.75-4.79,5.66-11.24.15-.96.22-1.96.21-3.02-.02-.65-.05-1.29-.15-1.9-.86-7.46-5.89-11.91-6.71-12.63M878.69,503.22c-.07.17-.15.34-.22.53-.79,1.77-2.01,4.14-3.88,6.69-5.06,6.9-8.6,6.49-10.59,11.15-1.32,3.05-.31,4.43.57,15.7.19,2.39.31,4.53.39,6.38.09,1.78.14,3.29.17,4.46M966.75,633.97c-.21-7.72-1.97-13.3-3.48-16.9-.96-2.3-1.77-3.64-2.76-5.22-1.3-2.01-2.93-4.41-5.68-9.66-2.76-5.27-4.67-9.64-6.44-13.68-2.13-4.86-3.81-9.11-5.1-12.48M877.29,613.22c.14.63.53.79.82,1.94.12.53.15.96.27.96s.21-.43.39-.98c.38-1.18.63-1.27.77-1.85.27-1.08-.57-1.41-.69-2.76,0-.05-.02-.1,0-.14-.1-1.49.91-1.68.98-3.47.07-1.63-.77-1.8-.69-3.52.09-1.48.72-1.51.77-2.95.07-1.77-.96-1.96-.82-3.55.17-1.97,1.32-2.75.94-3.71-.22-.53-.69-.45-1.1-1.32-.22-.5-.26-.93-.39-.93-.14.02-.15.45-.34.94-.38,1.01-.98,1.08-1.18,1.66-.38,1.05,1.17,1.66,1.41,3.31.22,1.49-1.17,1.84-1.1,3.55.03,1.41,1.01,1.49,1.1,2.88.1,1.6-1.1,1.85-1.15,3.57-.07,1.73,1.13,2.01.89,3.62-.02.14-.05.26-.09.38-.27,1.05-1.03,1.37-.81,2.35ZM847.74,862.39c.69-3.78,1.36-7.58,1.99-11.41,2.57-15.43,4.75-31.18,6.49-47.26.14-1.32.27-2.64.41-3.98M858.93,828.3c.93,4.75,2.11,9.85,3.64,15.19,1.06,3.69,2.18,7.17,3.36,10.49,1.2,3.41,2.44,6.62,3.71,9.64M703.09,811.17c.84,5.82,3.62,22.7,11.46,38.37,5.71,11.39,14.12,22.15,26.43,27.56,7.81,3.43,17.38,4.77,26.12,5.99,19.41,2.73,34.99,1.17,44.31.17,7.4-.79,17.23-2.23,28.69-5.1M849.75,1103.59c.22-68.78,3.17-105.81,6.13-127.19.46-3.35,1.84-12.9,2.85-26.08,1.92-25.23,1.17-45.9.21-59.51M783.37,898.09c-2.42,6.25-5.58,15.48-8.13,26.96-3.33,14.96-4.91,22.53-1.29,27.83,4.2,6.16,12.73,7.33,27.83,9.42,10.3,1.42,13.56.41,22.26,2.57,7.98,1.97,14.12,5.05,17.98,7.28M867.28,973.87c3.57-1.82,8.97-4.14,15.84-5.58,7.1-1.48,11.63-1.13,15.84-1.29,2.49-.09,27.01-1.22,36.4-14.98,1.2-1.77,3.48-5.68,2.99-29.1-.27-13.33-1.25-24.37-2.13-32.12M777.81,976.43c2.27,7.21,5.41,18.4,7.64,32.35,4.03,25.35,1.6,37.96,3.48,54.57,1.63,14.35,6.86,34.89,23.77,59.08M842.02,1032.95c-3.23-1.77-7.79-4.08-13.42-6.44-4.1-1.7-7.98-3.31-13.04-4.62-4.17-1.06-10.33-2.25-18.07-2.23M907.52,1026.31c-8.68.57-18.43,1.75-28.97,3.93-6.85,1.41-13.18,3.07-18.98,4.84M886.13,1124.57c15.22-21.5,21.48-40.22,24.4-53.09,3.79-16.77,2.54-26.22,6.85-48.38,3.78-19.39,9.11-34.61,12.84-44.1M952.91,1011.11l-11.46,8.32-15.51,11.27M943.36,1072.77c-.6.74-1.25,1.53-1.9,2.39-3.41,4.41-7.38,10.45-10.67,18.12-2.69,6.26-3.26,9.71-6.13,17.59-2.08,5.71-5.3,13.57-10.28,22.7M783.37,1131.42c-5.49-10.52-8.53-19.41-10.28-25.48-3-10.36-3.41-16.66-7.98-25.95-3.4-6.88-7.33-11.89-10-14.93M752.55,1006.41c2.44,3.47,5.53,7.36,9.4,11.34,3.35,3.43,6.64,6.25,9.64,8.56M874.99,874.96c20.3,3.91,37.46,5.41,50.09,6.01,6.33.29,11.72.36,16.37.26,15.74-.29,22.75-2.51,27.73-4.55,4.89-2.01,14.29-6.54,23.12-15.41,9.27-9.32,14.41-19.96,17.3-29.21,2.4-7.67,3.23-14.38,3.55-18.6.07-.88.1-1.63.14-2.28M794.51,1056.07c4.07,3.5,10.31,8.07,18.83,11.55,11.07,4.55,20.95,5.22,26.98,5.15M859.15,1073.62c9.94-.19,17.66-.29,24.83-.34,4.62-.03,9.64-.03,15.41-2.66,3.28-1.49,5.7-3.33,7.28-4.7M722.14,1125c31.28,8.7,75.71,17.47,129.3,16.7,23-.33,44.22-2.39,63.36-5.35,9.4-1.46,18.29-3.14,26.65-4.96,11.72-2.54,22.38-5.32,31.87-8.1M755.1,905.21l10.42,9.71M763.24,924.34l-13.69-12.85M760.32,937.75l-14.21-14.83M965.9,898.09c-3.17.53-7.24,1.51-11.7,3.41-4.2,1.8-7.57,3.9-10.07,5.71M949.05,916.64l7.43-5.15M949.05,928.91l19.97-12.27M739.44,893.04c-.89,6.42-1.66,13.08-2.28,19.97-1.25,13.88-1.75,26.99-1.72,39.23M1009.54,831.71l.05.34,11.98,75.54M709.18,910.44l5.37-60.9.1-1.2M985.18,943.2v-53.18M637.37,834.71c1.48,3.09,3.72,7.05,7.14,11.14,3.21,3.83,6.49,6.61,9.13,8.56M633.95,924.34c1.12-2.78,2.93-7.09,5.42-12.27,1-2.08,1.9-3.91,2.76-5.58,4.6-8.85,7.62-12.77,12.22-21.98,3.84-7.71,5.94-13.45,9.7-23.72,3.74-10.19,6.47-19.1,8.43-26.08M642.82,928.57c3.59-9.23,7.24-16.53,10.24-21.91,4.03-7.28,5.99-9.54,9.06-16.71,3.76-8.79,4.19-13.23,8.07-23.25,2.76-7.12,5.56-12.68,7.41-16.13M653.21,982c-4.26-11.17-9.63-16.7-13.83-19.7-.96-.69-2.27-1.51-3.9-2.66-1.42-1.03-3.12-2.28-5.1-3.91-4-3.29-6.97-6.35-8.85-8.41M613.39,964.65c-1.06,1.05-2.35,2.4-3.59,4.12-1.12,1.48-2.2,3.23-3.12,5.23-2.33,5.05-2.63,9.37-2.85,11.55-.02.21-.05.41-.09.62-.38,3.28-1.27,7.34-3.21,12.24-1.34,3.41-3.21,7.21-5.77,11.41M591.56,1073.62c1.39-15.36,5.1-24.21,8.41-29.55,1-1.58,3.52-5.37,4.14-10.85.21-1.77.19-3.45.02-5.03-.33-2.99-1.18-5.58-2.01-7.53M611.9,1083.04c1.53-3.6,3.59-9.78,3.05-17.42-.63-9.4-5.11-20.47-8.84-20.27-2.56.14-5.8,5.61-8.79,29.55M621.53,964.65c-2.42,3.23-5.58,8-8.27,14.21-1.41,3.23-2.45,6.32-3.26,9.32-.69,2.63-1.2,5.18-1.56,7.71-.72,4.93-.98,9.71-1.18,14.66-.27,6.37-.51,11.94-.03,17.37.46,5.03,1.53,9.92,3.76,15.17,2.63,6.19,5.95,10.78,8.41,13.69M1112.18,983.93c-.57,5.68-.76,12.03-.29,18.91.05.86.12,1.7.21,2.54.74,8.01,2.27,15.41,4.24,22.07,3.43,11.58,8.15,21.02,12.24,27.92M1107.46,1086.75c1.12-.22,9.94-8,13.83-11.46,1.06-.94,1.75-1.58,1.84-1.65l.02-.02M1103.48,1082.75c2.33-.89,5.68-2.47,9.13-5.29,1.99-1.61,3.57-3.31,4.77-4.84.86-1.05,1.54-2.02,2.08-2.87,4.17-8.15,4.02-13.95,3.14-17.69-1.39-5.9-4.58-6.88-7.71-15.27-1.65-4.43-2.13-7.83-2.52-10.19-.36-2.16-.67-3.43-1.77-3.79-.79-.26-1.94,0-3.64,1.49-2.09,1.84-5.03,5.56-9.2,12.49M1078.24,937.75c-.89-6.02-2.49-15.24-5.44-26.26-2.92-10.78-6.02-19.2-12.94-35.13-3.29-7.62-7.46-16.95-12.9-29.09-4.44-9.95-9.8-21.9-13.56-30.25M1091.62,943.2c-.41-7.02-1.7-18.1-6.13-30.85-5.1-14.62-10.64-20.73-17.56-35.81-.91-1.97-1.89-4.22-2.9-6.71-3.14-7.72-6.59-17.88-9.23-30.41M1085.63,818.88c-2.88,2.71-5.92,5.85-8.99,9.42-3.33,3.88-6.16,7.64-8.56,11.12M1070.65,973.87c7.76-7.55,14.62-11.79,19.55-14.28,2.57-1.3,6.25-2.93,10.31-6.5,4.02-3.5,6.57-7.24,8.1-9.88M1090.63,1037.23c2.15-1.72,4.93-4.24,7.71-7.71,1.2-1.49,2.97-3.74,4.68-6.86M611.25,1098.23c2.11-4.74,4.26-10.43,6.01-16.97,1.92-7.26,2.92-13.85,3.41-19.41M735.44,758.16c-4.58,3.31-9.52,7.24-14.59,11.91-1.63,1.51-3.19,3-4.68,4.5-3.91,3.93-7.34,7.76-10.3,11.34M723.86,793.19c2.21-1.46,4.53-3.07,6.92-4.82,3.07-2.28,6.25-4.8,9.49-7.6,5.32-4.6,9.87-9.13,13.71-13.37l.02-.02M1078.24,799.74c.38-6.64-.15-12.05-.74-15.84-.7-4.58-1.7-8.15-3.6-14.96-1.34-4.79-2.56-8.73-3.47-11.5M671.48,735.96c-2.85,1.73-6.92,4.6-10.71,9.13-.31.38-.67.82-1.05,1.32-1.54,2.01-3.52,5.08-5.39,9.71-1.06,2.66-2.11,5.83-2.99,9.63-.1.39-.19.79-.27,1.18-3.79,17.13-1.82,33.43.19,43.69.19.84.34,1.65.51,2.4M627.57,813.02c1.9,7.09,2.35,12.63,1.53,15.68v.02c-.76,2.78-1.77,5.03-1.77,5.03-2.13,4.5-5.01,6.8-9.64,16.66-1.2,2.56-2.16,4.96-3,7.48-1.92,5.89-3.07,12.42-4.8,23.24-3.83,23.9-4.98,34.24-6.23,43.04-.55,3.91-1.12,7.52-1.96,11.88-.1.51-.21,1.03-.29,1.51-2.59,13.01-4.82,18.12-7.19,24.39-1.73,4.58-3.54,9.8-5.65,19.2-.19.86-.38,1.72-.55,2.56-1.18,5.65-2.06,10.98-2.69,16.34-.02.19-.03.38-.07.55-1.03,8.96-1.41,17.98-1.48,28.54-.05,7.12.03,14.95.15,23.92.03,1.32.05,2.66.07,4.02.03,2.61.09,5.17.15,7.64.39,14.28,1.29,26.39,2.18,35.78.86,8.94,1.73,15.38,2.23,18.81,1.82,12.8,3.91,23.66,5.71,31.97h40.52c8.7-16.82,14.45-31.8,18.28-43.38,2.21-6.71,6.81-21.26,10.23-38.41,1.99-10.07,3.59-21.02,4.05-31.82.17-4.27.46-15.1,0-28.54-.41-11.89-.93-12.01-.86-15.99.43-25.62,22.07-30.94,34.53-66.22,2.39-6.71,4.77-15.51,8-15.41,3.04.1,3.78,8.08,10.28,17.69,4.02,5.95,8.49,9.97,11.62,12.42,3.09,7.93,6.64,18.83,8.92,32.11,2.64,15.29,4.55,26.41,2.01,40.53-2.76,15.31-8.85,23.46-5.42,37.1,1.22,4.84,3.16,8.55,4.56,10.85.48,5.23.51,12.15-1.15,19.99-.77,3.72-1.82,7.05-2.9,9.92-3.52,4.1-8.12,10.47-11.36,19.19-1.92,5.13-2.92,9.83-3.43,13.71-3.41,5.23-6.83,10.45-10.23,15.68-2.3,3.52-4.6,7.05-6.9,10.57h279.15l-.02-.03-10.83-27.94c1.41-14.09-.91-24.4-3.43-31.4-.67-1.85-1.37-3.55-2.06-5.13-3.43-7.81-6.69-12.7-4.79-19.41,1.65-5.77,5.46-7.02,8.29-15.14,1.94-5.59,2.09-10.67,1.92-14.12-1.65-8.82-2.73-16.22-3.43-21.62-1.63-12.51-1.37-15.14-1.06-17.06.6-3.74,1.41-4.99,5.94-17.73,1.75-4.89,2.97-7.98,3.76-10.81,4.65-16.58,1.99-21.38,6.73-27.66.26-.34.53-.69.84-1.03,6.01-6.95,10.74-4.02,19.55-11.55,11.69-10,11.5-22.15,15.86-21.98,4.51.17,5.94,14.26,12.48,31.21,1,2.57,2.11,5.22,3.36,7.89.03.09.07.17.12.24,6.9,14.55,15.87,24.97,22.7,31.73-2.99,12.12-4.46,22.77-5.15,31.56-.34,4.19-.5,7.95-.55,11.24-.14,8.12.29,13.52,1,21.73.65,7.53,1.54,17.44,2.42,33.94.09,1.77.19,3.43.26,4.99.6,11.38.91,17.95.6,24.69-.39,8.97-1.34,17.31-2.61,24.9-1.06,6.42-2.35,12.32-3.74,17.64-.07.29-.14.57-.21.84h47.95l10.73-36.09,12.36-41.53,5.44-18.28,4.58-15.43c1.75-8.32,3.45-18.43,4.41-30.03.34-4.26.6-8.72.74-13.35.09-3.02.19-6.47.19-10.3,0-5.77-.19-12.41-.89-19.84-.53-5.53-1.36-11.5-2.59-17.85-.27-1.36-.55-2.73-.86-4.12-2.59-11.91-3.48-10.35-7.95-27.13-6.25-23.46-6.38-33.51-10.06-51.12-.29-1.46-.62-2.95-.98-4.51-2.52-11.19-6.95-27.39-15.12-46.68,1.85-6.16,3.86-15.08,3.78-25.9-.03-3.59-.26-6.38-.57-9.06-.43-3.88-.98-7.52-1.13-12.99-.21-6.62.19-15.8,2.78-26.94,2.83-5.66,4.43-10.18,5.15-13.76,1.18-5.75.19-9.18-1.44-11.36-1.65-2.2-3.16-2.06-10.73-5.42-.41-.17-.82-.36-1.27-.57-10.62-4.84-11.51-6.74-17.98-9.42-.45-.19-.91-.38-1.42-.57-10.23-3.93-11.21-1.36-18.26-4.56-5.01-2.28-7.17-5.13-9.2-8.07-2.21-3.21-4.26-6.54-9.64-9.35-.12-.07-.24-.12-.36-.19-4.94-2.49-9.63-3.04-18.76-4.08-7.24-.84-13.35-.81-17.71-.58-2.85-6.37-6.71-15.43-10.85-26.55-4.84-13.04-7.28-19.58-8.27-25.96-.91-5.8-.39-6.73-.86-32.83-.24-13.42-.39-14.67-.63-16.1-.81-4.68-3.04-17.78-12.78-27.58-.46-.46-1.37-1.08-2.75-1.89-4.07-2.37-12.24-6.35-25.23-12.66-.15-.07-.31-.15-.46-.22-1.12-.55-2.16-1.05-3.14-1.53-7.34-3.57-10.86-5.18-14.4-6.74l-.82-.36c-5.27-2.3-9.87-4.15-13.2-5.46-2.44-.96-4.2-1.63-5.08-1.96-6.95-2.59-15.8-5.63-26.34-8.6-.63-.17-1.27-.36-1.92-.53-16.53,11.05-30.82,17.8-41.1,21.97-12.99,5.29-23.87,8.22-33.39,19.13-5.9,6.76-8.58,13.52-9.99,17.13-2.9,7.45-3.88,14.14-4.07,20.97-.19,6.33.33,12.8.65,20.13.48,11.19.63,27.49-1.15,47.95-3.83,2.18-8.7,4.62-14.52,6.68-4.58,1.65-9.75,3.04-15.44,3.9-1.24.19-2.42.34-3.55.45-12.03,1.25-19.05-.98-31.76.38-.86.09-1.75.19-2.66.31-4.8.67-8.96,1.63-13.04,2.93-3.88,1.22-7.67,2.73-11.89,4.53-2.02.88-4.17,1.8-6.45,2.81-5.25,2.3-10.16,4.74-14.71,7.19-13.42,7.26-23.66,14.78-30.36,20.2-2.21,1.78-4.03,3.35-5.46,4.58-4.14,3.6-7.96,6.92-11.46,10-1.97,1.75-3.83,3.43-5.56,5.05-10.49,9.78-16.85,17.78-17.47,27.54-.05.63-.05,1.27-.05,1.92.07,4.86,1.48,10.45,2.88,14.91.86,2.73,1.72,5.03,2.27,6.5,2.64,7.16,5.8,12.96,8.55,17.35.6.94,1.17,1.82,1.72,2.63.24.46.46.91.69,1.36,3.96,7.88,6.71,15.19,8.36,21.31ZM687.2,1116.95c.31,6.86.33,14.43-.15,22.58-.74,12.65-4.91,19.32-2.28,21.43,1.78,1.42,6.52.86,20.25-9.71"/>
      </g>
      <polyline class="cls-1" points="270.6 1145.4 .5 1145.4 .5 .5 1780.5 .5 1780.5 1145.4 270.6 1145.4"/>
    </g>
  </g>
</svg>

================
File: src/components/auth/AuthScreen.jsx
================
import React from 'react';
import { Login } from './Login';

export function AuthScreen() {
  return <Login />;
}

================
File: src/components/auth/index.js
================
export { AuthScreen } from './AuthScreen';
export { Login } from './Login';

================
File: src/components/auth/Login.jsx
================
import React, { useState } from 'react';
import { useAuth } from '../../context/AuthContext';
import emptyStateSvg from '../../assets/SVG/emptyState.svg';

export function Login() {
  const { login, error, clearError, loading } = useAuth();
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = async (e) => {
    e.preventDefault();
    clearError();
    await login(username, password);
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-stone-950">
      <div className="bg-stone-950 p-8 rounded-lg w-full max-w-md">
      <div className="flex justify-center mb-4">
          <img 
            src={emptyStateSvg} 
            alt="Empty State" 
            className="h-auto"
          />
        </div>
        <h2 className="text-2xl font-bold text-teal-500 mb-6 text-center">SLUMNET</h2>
        
        {error && (
          <div className="bg-red-900 text-white p-3 rounded mb-4">
            {error}
          </div>
        )}
        
        
        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label className="block text-stone-300 mb-2 font-mono text-sm" htmlFor="username">
              Username
            </label>
            <input
              id="username"
              type="text"
              className="w-full p-2 rounded bg-stone-800 text-white border border-stone-600 focus:border-teal-500 focus:outline-none font-mono text-sm"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              required
            />
          </div>
          
          <div className="mb-6">
            <label className="block text-stone-300 mb-2 font-mono text-sm" htmlFor="password">
              Password
            </label>
            <input
              id="password"
              type="password"
              className="w-full p-2 rounded bg-stone-800 text-white border border-stone-600 focus:border-teal-500 focus:outline-none font-mono text-sm"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
          </div>
          
          <button
            type="submit"
            className="w-full bg-teal-600 hover:bg-teal-700 text-white font-mono text-sm py-2 px-4 rounded focus:outline-none focus:shadow-outline"
            disabled={loading}
          >
            {loading ? 'Logging in...' : 'Login'}
          </button>
        </form>
        
        <div className="mt-4 text-center">
          <p className="text-stone-400 text-sm font-mono">
            Are ya in the know?
          </p>
        </div>
      </div>
    </div>
  );
}

================
File: src/components/auth/Register.jsx
================
import React, { useState } from 'react';
import { useAuth } from '../../context/AuthContext';

export function Register({ onSwitchToLogin }) {
  const { register, error, clearError, loading } = useAuth();
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [passwordError, setPasswordError] = useState('');
  const [success, setSuccess] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    clearError();
    setPasswordError('');
    
    // Validate passwords match
    if (password !== confirmPassword) {
      setPasswordError('Passwords do not match');
      return;
    }
    
    // Validate password strength
    if (password.length < 8) {
      setPasswordError('Password must be at least 8 characters long');
      return;
    }
    
    const result = await register(username, email, password);
    if (result.success) {
      setSuccess(true);
      // Reset form
      setUsername('');
      setEmail('');
      setPassword('');
      setConfirmPassword('');
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-900">
      <div className="bg-gray-800 p-8 rounded-lg shadow-lg w-full max-w-md">
        <h2 className="text-2xl font-bold text-teal-500 mb-6 text-center">Create an Account</h2>
        
        {error && (
          <div className="bg-red-900 text-white p-3 rounded mb-4">
            {error}
          </div>
        )}
        
        {passwordError && (
          <div className="bg-red-900 text-white p-3 rounded mb-4">
            {passwordError}
          </div>
        )}
        
        {success && (
          <div className="bg-green-900 text-white p-3 rounded mb-4">
            Registration successful! You can now login.
          </div>
        )}
        
        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label className="block text-gray-300 mb-2" htmlFor="username">
              Username
            </label>
            <input
              id="username"
              type="text"
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:border-teal-500 focus:outline-none"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              required
            />
          </div>
          
          <div className="mb-4">
            <label className="block text-gray-300 mb-2" htmlFor="email">
              Email
            </label>
            <input
              id="email"
              type="email"
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:border-teal-500 focus:outline-none"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
            />
          </div>
          
          <div className="mb-4">
            <label className="block text-gray-300 mb-2" htmlFor="password">
              Password
            </label>
            <input
              id="password"
              type="password"
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:border-teal-500 focus:outline-none"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
            <p className="text-gray-400 text-xs mt-1">Must be at least 8 characters long</p>
          </div>
          
          <div className="mb-6">
            <label className="block text-gray-300 mb-2" htmlFor="confirmPassword">
              Confirm Password
            </label>
            <input
              id="confirmPassword"
              type="password"
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:border-teal-500 focus:outline-none"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              required
            />
          </div>
          
          <button
            type="submit"
            className="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
            disabled={loading}
          >
            {loading ? 'Registering...' : 'Register'}
          </button>
        </form>
        
        <div className="mt-4 text-center">
          <button
            onClick={onSwitchToLogin}
            className="text-teal-400 hover:text-teal-300 text-sm"
          >
            Already have an account? Login
          </button>
        </div>
      </div>
    </div>
  );
}

================
File: src/components/CommandBar.jsx
================
import React, { useEffect, useRef } from 'react';
import { useAnnouncement } from '../context/AnnouncementContext';
import { useActiveUsers } from '../context/ActiveUsersContext';

export const CommandBar = ({ 
  currentWorkspaceIndex = 0,
  switchWorkspace,
  user,
  onLogout
}) => {
  console.log('CommandBar render, currentWorkspaceIndex:', currentWorkspaceIndex);
  const { announcement } = useAnnouncement();
  const { activeUserCount } = useActiveUsers();
  const announcementRef = useRef(null);
  const containerRef = useRef(null);

  // Carousel effect for long announcements with consistent speed
  useEffect(() => {
    if (!announcement || !announcementRef.current || !containerRef.current) return;
    
    const textElement = announcementRef.current;
    const containerElement = containerRef.current;
    const isOverflowing = textElement.scrollWidth > containerElement.clientWidth;
    
    if (isOverflowing) {
      // Fixed animation duration of 15 seconds
      textElement.style.animation = 'scroll-text 40s linear infinite';
    } else {
      textElement.style.animation = 'none';
    }
  }, [announcement]);

  return (
    <div className="w-full bg-stone-800 p-2 flex items-center gap-2">
      <div className="flex gap-2 items-center pr-2 border-r border-stone-600">
        <div className={`rounded-full cursor-pointer ${currentWorkspaceIndex === 0 ? 'w-3 h-3 bg-teal-400' : 'w-2 h-2 bg-stone-600 hover:bg-stone-500'}`} onClick={() => typeof switchWorkspace === 'function' && switchWorkspace(0)} />
        <div className={`rounded-full cursor-pointer ${currentWorkspaceIndex === 1 ? 'w-3 h-3 bg-teal-400' : 'w-2 h-2 bg-stone-600 hover:bg-stone-500'}`} onClick={() => typeof switchWorkspace === 'function' && switchWorkspace(1)} />
        <div className={`rounded-full cursor-pointer ${currentWorkspaceIndex === 2 ? 'w-3 h-3 bg-teal-400' : 'w-2 h-2 bg-stone-600 hover:bg-stone-500'}`} onClick={() => typeof switchWorkspace === 'function' && switchWorkspace(2)} />
        <div className={`rounded-full cursor-pointer ${currentWorkspaceIndex === 3 ? 'w-3 h-3 bg-teal-400' : 'w-2 h-2 bg-stone-600 hover:bg-stone-500'}`} onClick={() => typeof switchWorkspace === 'function' && switchWorkspace(3)} />
      </div>
      
      {/* Announcement section with improved container */}
      <div ref={containerRef} className="flex-1 announcement-container">
        {announcement ? (
          <div 
            ref={announcementRef}
            className="announcement-text text-teal-300 text-sm font-mono"
          >
            {announcement}
          </div>
        ) : (
          <div className="text-gray-500 text-sm font-mono italic">No announcements</div>
        )}
      </div>
      
      {/* Command bar right section with active users and user info */}
      {user && (
        <>
          {/* Active users section */}
          <div className="flex items-center border-l border-stone-600 ml-2 pl-2">
            <div className="flex items-center text-teal-400 text-sm font-mono">
              <span className="leading-none">{activeUserCount}</span>
              <svg className="h-3 w-3 ml-0.5" viewBox="0 0 24 24" fill="currentColor"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z" /></svg>
            </div>
          </div>
          
          {/* Username and logout section */}
          <div className="flex items-center pl-2">
            <span className="text-white text-sm font-mono mr-2">
              {user?.username || 'User'} 
            </span>
            <button 
              onClick={onLogout}
              className="bg-stone-700 hover:bg-stone-600 text-white text-sm px-2 py-1 rounded"
            >
              Logout
            </button>
          </div>
        </>
      )}
    </div>
  );
};

export default CommandBar;

================
File: src/components/EmptyState.jsx
================
import React from 'react';
import emptyStateSvg from '../assets/SVG/emptyState.svg';

export const EmptyState = () => (
  <div className="absolute inset-0 flex flex-col items-center justify-center bg-stone-950">
    <img 
      src={emptyStateSvg} 
      alt="Empty State" 
      className="w-1/4 h-auto"
    />
    <h2 className="text-xl font-semibold text-teal-400 mt-4">SLUMNET</h2>
  </div>
);

export default EmptyState;

================
File: src/components/WindowManager.jsx
================
import React, { useState, useCallback, useEffect } from 'react';
import { WINDOW_CONTENT, WINDOW_TYPES } from '../utils/windowTypes';
import { getWindowBounds } from '../utils/windowUtils';
import { useWindowManager } from '../hooks/useWindowManager';
import { useKeyboardShortcuts } from '../hooks/useKeyboardShortcuts';
import { CommandBar } from './CommandBar';
import EmptyState from './EmptyState';

export const WindowManager = ({ defaultLayout = null }) => {
  const [dragState, setDragState] = useState(null);
  const [notification, setNotification] = useState(null);
  const [flashingWindowIds, setFlashingWindowIds] = useState(new Set());
  
  // Function to flash a window's border red
  const flashWindowBorder = useCallback((windowId) => {
    setFlashingWindowIds(prev => {
      const newSet = new Set(prev);
      newSet.add(windowId);
      return newSet;
    });
    
    // Remove the window from flashing state after 500ms
    setTimeout(() => {
      setFlashingWindowIds(prev => {
        const newSet = new Set(prev);
        newSet.delete(windowId);
        return newSet;
      });
    }, 200);
  }, []);

  const {
    rootNode,
    activeNodeId,
    setActiveNodeId,
    terminalStates,
    updateTerminalState,
    splitWindow,
    createNewWindow,
    closeWindow,
    transformWindow,
    currentWorkspaceIndex,
    workspaceCount,
    switchWorkspace,
    isResizeMode,
    setIsResizeMode,
    resizeActiveWindow,
    isMoveMode,
    setIsMoveMode,
    moveSourceWindowId,
    setMoveSourceWindowId,
    swapWindows
  } = useWindowManager({ 
    defaultLayout,
    onFlashBorder: flashWindowBorder
  });
  
  // Override window.alert to use our notification system
  useEffect(() => {
    const originalAlert = window.alert;
    window.alert = (message) => {
      console.log('Alert:', message);
      
      // If the message is about splitting or creating windows, flash the active window border
      if (message.includes('split') || message.includes('create')) {
        if (activeNodeId) {
          flashWindowBorder(activeNodeId);
        }
      } else {
        // For other alerts, show the notification
        setNotification(message);
        setTimeout(() => setNotification(null), 3000); // Hide after 3 seconds
      }
    };
    
    return () => {
      window.alert = originalAlert;
    };
  }, [activeNodeId, flashWindowBorder]);

  // Log when component mounts
  useEffect(() => {
    console.log('WindowManager component mounted');
    console.log('setIsMoveMode is a function:', typeof setIsMoveMode === 'function');
    console.log('Initial isMoveMode state:', isMoveMode);
  }, [isMoveMode]);
  
  // Log move mode state changes
  useEffect(() => {
    console.log('Move mode changed to:', isMoveMode);
  }, [isMoveMode]);

  // Add keyboard shortcuts
  useKeyboardShortcuts({
    onSplitVertical: () => splitWindow(activeNodeId, 'vertical'),
    onSplitHorizontal: () => splitWindow(activeNodeId, 'horizontal'),
    onClose: () => closeWindow(activeNodeId),
    createNewWindow,
    hasActiveWindow: Boolean(activeNodeId),
    hasRootNode: Boolean(rootNode),
    isResizeMode,
    setIsResizeMode,
    resizeActiveWindow,
    isMoveMode,
    setIsMoveMode,
    moveSourceWindowId,
    setMoveSourceWindowId,
    swapWindows,
    activeNodeId
  });

  // Command handling for terminal
  const handleCommand = useCallback((command) => {
    const parts = command.split(' ');
    const cmd = parts[0].toLowerCase();

    switch (cmd) {
      case 'split':
        if (activeNodeId) {
          const direction = parts[1] === 'vertical' ? 'vertical' : 'horizontal';
          splitWindow(activeNodeId, direction);
        }
        break;
      case 'close':
        if (activeNodeId) {
          closeWindow(activeNodeId);
        }
        break;
    }
  }, [activeNodeId, splitWindow, closeWindow]);

  // Resize handling
  const handleResizeStart = useCallback((e, split) => {
    e.preventDefault();
    e.stopPropagation();
    const rect = e.currentTarget.getBoundingClientRect();
    setDragState({
      split,
      initialPos: {
        x: e.clientX,
        y: e.clientY
      },
      initialRatio: split.splitRatio
    });
  }, []);

  // Helper function to convert percentage-based bounds to pixel dimensions
  const calculatePixelDimensions = useCallback((bounds) => {
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    
    return {
      width: (bounds.width / 100) * windowWidth,
      height: (bounds.height / 100) * windowHeight
    };
  }, []);
  
  // Helper function to check if a window tree would have any windows smaller than the minimum size
  const hasWindowsBelowMinSize = useCallback((root) => {
    if (!root) return false;
    
    // Import constants directly here to avoid dependency issues
    const MIN_WINDOW_WIDTH_PX = 300;
    const MIN_WINDOW_HEIGHT_PX = 200;
    
    // Calculate the bounds of all windows
    const allWindows = getWindowBounds(root);
    
    // Check if any window would be smaller than the minimum size
    return allWindows.some(window => {
      const pixelDimensions = calculatePixelDimensions(window.bounds);
      const isTooSmall = pixelDimensions.width < MIN_WINDOW_WIDTH_PX || 
                         pixelDimensions.height < MIN_WINDOW_HEIGHT_PX;
      
      if (isTooSmall) {
        console.log('Window too small:', window.id);
        console.log('Dimensions:', pixelDimensions);
      }
      
      return isTooSmall;
    });
  }, [calculatePixelDimensions]);

  const handleResizeMove = useCallback((e) => {
    if (!dragState) return;

    const { split, initialPos, initialRatio } = dragState;
    const delta = split.direction === 'horizontal' 
      ? (e.clientX - initialPos.x) / window.innerWidth 
      : (e.clientY - initialPos.y) / window.innerHeight;

    const newRatio = Math.max(0.1, Math.min(0.9, initialRatio + delta));
    
    // Store the original ratio
    const originalRatio = split.splitRatio;
    
    // Apply the new ratio
    split.splitRatio = newRatio;
    
    // Check if this would result in windows that are too small, but don't block the resize
    if (hasWindowsBelowMinSize(rootNode)) {
      console.log('Windows are below minimum size, but resize is allowed');
    }
    
    // If we get here, the resize is allowed
    // Force a re-render
    setDragState(prev => ({ ...prev }));
  }, [dragState, rootNode, hasWindowsBelowMinSize, activeNodeId, flashWindowBorder]);

  const handleResizeEnd = useCallback(() => {
    setDragState(null);
  }, []);

  useEffect(() => {
    if (dragState) {
      window.addEventListener('mousemove', handleResizeMove);
      window.addEventListener('mouseup', handleResizeEnd);
      return () => {
        window.removeEventListener('mousemove', handleResizeMove);
        window.removeEventListener('mouseup', handleResizeEnd);
      };
    }
  }, [dragState, handleResizeMove, handleResizeEnd]);

  // Window tree renderer
  const WindowTreeRenderer = ({ node, depth = 0, available = { x: 0, y: 0, width: 100, height: 100 } }) => {
    if (!node) return null;

    if (node.type === 'window') {
      const windowContent = WINDOW_CONTENT[node.windowType];
      if (!windowContent) {
        console.error('No window content found for type:', node.windowType);
        return null;
      }
      const Component = windowContent.component;
      const isActive = node.id === activeNodeId;
  
      // Check if this window is currently flashing
      const isFlashing = flashingWindowIds.has(node.id);
      
      // Check if this is the first selected window in move mode
      const isFirstSelectedWindow = isMoveMode && moveSourceWindowId === node.id;
      
      return (
        <div
          className={`absolute overflow-hidden border-1 ${
            isFlashing ? 'border-red-600' : 
            isFirstSelectedWindow ? 'border-blue-300' :
            isActive ? (
              isMoveMode ? 'border-green-500' : 
              isResizeMode ? 'border-yellow-500' : 
              'border-teal-500'
            ) : 'border-stone-600'
          } ${isFlashing ? 'animate-pulse' : ''}`}
          style={{
            left: `${available.x}%`,
            top: `${available.y}%`,
            width: `${available.width}%`,
            height: `${available.height}%`,
            transition: 'border-color 0.2s ease-in-out'
          }}
          onClick={() => setActiveNodeId(node.id)}
        >
          <Component 
            key={`window-${node.id}-${node.windowType}`}
            onCommand={handleCommand} 
            isActive={isActive}
            nodeState={node.state}
            nodeId={node.id}
            transformWindow={transformWindow}
            windowState={node.windowType === WINDOW_TYPES.TERMINAL ? terminalStates[node.id] : node.state}
            updateWindowState={(newState) => {
              updateTerminalState(node.id, newState);
            }}
          />
        </div>
      );
    }

    // Calculate split dimensions
    let firstDimensions, secondDimensions;
    if (node.direction === 'horizontal') {
      firstDimensions = {
        x: available.x,
        y: available.y,
        width: available.width * node.splitRatio,
        height: available.height
      };
      secondDimensions = {
        x: available.x + (available.width * node.splitRatio),
        y: available.y,
        width: available.width * (1 - node.splitRatio),
        height: available.height
      };
    } else {
      firstDimensions = {
        x: available.x,
        y: available.y,
        width: available.width,
        height: available.height * node.splitRatio
      };
      secondDimensions = {
        x: available.x,
        y: available.y + (available.height * node.splitRatio),
        width: available.width,
        height: available.height * (1 - node.splitRatio)
      };
    }

    return (
      <div className="absolute inset-0" style={{ pointerEvents: 'none' }}>
        <WindowTreeRenderer 
          node={node.first} 
          depth={depth + 1} 
          available={firstDimensions} 
        />
        <div
          className="absolute bg-stone-700 hover:bg-stone-500 transition-colors"
          style={{
            left: node.direction === 'horizontal' ? `${firstDimensions.width}%` : 0,
            top: node.direction === 'vertical' ? `${firstDimensions.height}%` : 0,
            width: node.direction === 'horizontal' ? '4px' : '100%',
            height: node.direction === 'vertical' ? '4px' : '100%',
            cursor: node.direction === 'horizontal' ? 'col-resize' : 'row-resize',
            pointerEvents: 'auto',
            zIndex: 10
          }}
          onMouseDown={(e) => handleResizeStart(e, node)}
        />
        <WindowTreeRenderer 
          node={node.second} 
          depth={depth + 1} 
          available={secondDimensions}
        />
      </div>
    );
  };

  return (
    <div className="w-full h-screen flex flex-col">
      <CommandBar
        onCommand={handleCommand}
        currentWorkspaceIndex={currentWorkspaceIndex}
        switchWorkspace={switchWorkspace}
      />
      <div className="flex-1 relative bg-stone-900">
        {rootNode ? (
          <WindowTreeRenderer
            node={rootNode}
            terminalStates={terminalStates}
            updateTerminalState={updateTerminalState}
          />
        ) : (
          <EmptyState />
        )}
        
        {/* Notification system */}
        {notification && (
          <div 
            className="absolute top-4 left-1/2 transform -translate-x-1/2 bg-red-500 text-white px-4 py-2 rounded shadow-lg z-50"
            style={{ maxWidth: '80%' }}
          >
            {notification}
          </div>
        )}
      </div>
    </div>
  );
};

export default WindowManager;

================
File: src/components/windows/AdminWindow.jsx
================
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import API_CONFIG from '../../config/api';
import { useAuth } from '../../context/AuthContext';
import { Trash } from 'lucide-react'; // Import Trash icon

const AdminWindow = ({ isActive }) => {
  const { user } = useAuth();
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [editingUser, setEditingUser] = useState(null);
  const [showCreateForm, setShowCreateForm] = useState(false);
  const [formData, setFormData] = useState({
    username: '',
    password: '',
    is_admin: false,
    has_file_access: false
  });
  const [createFormData, setCreateFormData] = useState({
    username: '',
    password: '',
    is_admin: false,
    has_file_access: false
  });
  
  // Chat channels state
  const [activeTab, setActiveTab] = useState('users'); // 'users' or 'channels'
  const [channels, setChannels] = useState([]);
  const [channelLoading, setChannelLoading] = useState(false);
  const [channelError, setChannelError] = useState(null);
  const [newChannelName, setNewChannelName] = useState('');
  const [showCreateChannelForm, setShowCreateChannelForm] = useState(false);

  // Fetch users when component mounts
  useEffect(() => {
    fetchUsers();
  }, []); // Empty dependency array means this runs once on mount
  
  // Load channels when tab changes to channels
  useEffect(() => {
    if (activeTab === 'channels') {
      fetchChannels();
    }
  }, [activeTab]);
  
  // Reset form visibility when switching tabs
  useEffect(() => {
    // Hide forms when switching tabs
    setShowCreateForm(false);
    setShowCreateChannelForm(false);
  }, [activeTab]);

  // Fetch all users from the API
  const fetchUsers = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem('auth_token');
      const response = await axios.get(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.USERS}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      setUsers(response.data);
      setError(null);
    } catch (err) {
      console.error('Failed to fetch users:', err);
      setError('Failed to load users. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Start editing a user
  const handleEdit = (user) => {
    setEditingUser(user.id);
    setFormData({
      username: user.username,
      password: '', // Don't populate password for security
      is_admin: user.is_admin === 1 || user.is_admin === true,
      has_file_access: user.has_file_access === 1 || user.has_file_access === true,
      storage_quota: user.storage_quota || 52428800 // Default to 50MB (52428800 bytes)
    });
  };

  // Cancel editing
  const handleCancel = () => {
    setEditingUser(null);
    setFormData({
      username: '',
      password: '',
      is_admin: false,
      has_file_access: false
    });
  };

  // Handle form input changes for editing
  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  // Handle form input changes for creating
  const handleCreateChange = (e) => {
    const { name, value, type, checked } = e.target;
    setCreateFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  // Save user changes
  const handleSave = async (userId) => {
    try {
      setLoading(true);
      const token = localStorage.getItem('auth_token');
      
      // Build user data object
      const userData = {
        username: formData.username,
        is_admin: formData.is_admin,
        has_file_access: formData.has_file_access,
        storage_quota: formData.storage_quota
      };
      
      // Only include password in the request if it was changed
      if (formData.password) {
        userData.password = formData.password;
      }
      
      await axios.put(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.USERS}/${userId}`,
        userData,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      // Refresh the user list
      await fetchUsers();
      setEditingUser(null);
      setFormData({
        username: '',
        password: '',
        is_admin: false,
        has_file_access: false
      });
    } catch (err) {
      console.error('Failed to update user:', err);
      setError('Failed to update user. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Create a new user
  const handleCreateUser = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem('auth_token');
      
      // Validate form data - only username and password are required
      if (!createFormData.username || !createFormData.password) {
        setError('Username and password are required.');
        setLoading(false);
        return;
      }
      
      // Use the register endpoint instead of users endpoint
      await axios.post(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.REGISTER}`,
        {
          username: createFormData.username,
          password: createFormData.password
        }
      );
      
      // If admin status or file access permissions need to be set, we need to do that in a separate request
      if (createFormData.is_admin || createFormData.has_file_access) {
        try {
          // Get the newly created user
          const usersResponse = await axios.get(
            `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.USERS}`,
            { headers: { Authorization: `Bearer ${token}` } }
          );
          
          const newUser = usersResponse.data.find(u => u.username === createFormData.username);
          
          if (newUser) {
            // Update the user with admin status and file access permissions
            await axios.put(
              `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.USERS}/${newUser.id}`,
              { 
                is_admin: createFormData.is_admin,
                has_file_access: createFormData.has_file_access,
                storage_quota: createFormData.storage_quota || 52428800 // Default to 50MB
              },
              { headers: { Authorization: `Bearer ${token}` } }
            );
          }
        } catch (adminErr) {
          console.error('Failed to set admin status:', adminErr);
          // Don't fail the whole operation if just the admin part fails
        }
      }
      
      // Refresh the user list
      await fetchUsers();
      
      // Reset form and hide it
      setCreateFormData({
        username: '',
        password: '',
        is_admin: false,
        has_file_access: false
      });
      setShowCreateForm(false);
      setError(null);
    } catch (err) {
      console.error('Failed to create user:', err);
      setError(err.response?.data?.message || 'Failed to create user. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Toggle create form visibility
  const toggleCreateForm = () => {
    setShowCreateForm(!showCreateForm);
    if (!showCreateForm) {
      // Reset form data when opening
      setCreateFormData({
        username: '',
        password: '',
        is_admin: false,
        has_file_access: false
      });
    }
  };
  
  // Toggle create channel form visibility
  const toggleCreateChannelForm = () => {
    setShowCreateChannelForm(!showCreateChannelForm);
    if (!showCreateChannelForm) {
      // Reset channel name when opening the form
      setNewChannelName('');
    }
  };

  // Render loading state
  if (loading && users.length === 0) {
    return (
      <div className="bg-stone-900 text-white p-4 h-full flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-teal-500 mx-auto mb-4"></div>
          <p>Loading users...</p>
        </div>
      </div>
    );
  }

  // Render error state
  if (error && users.length === 0) {
    return (
      <div className="bg-stone-900 text-white p-4 h-full flex items-center justify-center">
        <div className="text-center text-red-500">
          <p>{error}</p>
          <button 
            onClick={fetchUsers}
            className="mt-4 px-4 py-2 bg-stone-700 hover:bg-stone-600 rounded"
          >
            Try Again
          </button>
        </div>
      </div>
    );
  }

  // Fetch chat channels
  const fetchChannels = async () => {
    try {
      setChannelLoading(true);
      const token = localStorage.getItem('auth_token');
      const response = await axios.get(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.CHAT_ROOMS}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      setChannels(response.data);
      setChannelError(null);
    } catch (err) {
      console.error('Failed to fetch channels:', err);
      setChannelError('Failed to load chat channels. Please try again.');
    } finally {
      setChannelLoading(false);
    }
  };

  // Create a new chat channel
  const handleCreateChannel = async (e) => {
    e.preventDefault();
    if (!newChannelName.trim()) return;

    try {
      setChannelLoading(true);
      const token = localStorage.getItem('auth_token');
      await axios.post(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.CHAT_ROOMS}`,
        { name: newChannelName },
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      // Refresh the channel list
      await fetchChannels();
      
      // Reset form and hide it
      setNewChannelName('');
      setShowCreateChannelForm(false);
      setChannelError(null);
    } catch (err) {
      console.error('Failed to create channel:', err);
      setChannelError('Failed to create channel. Please try again.');
    } finally {
      setChannelLoading(false);
    }
  };

  // Delete a chat channel
  const handleDeleteChannel = async (channelId) => {
    try {
      setChannelLoading(true);
      const token = localStorage.getItem('auth_token');
      const endpoint = API_CONFIG.ENDPOINTS.CHAT_DELETE_ROOM.replace(':id', channelId);
      await axios.delete(
        `${API_CONFIG.BASE_URL}${endpoint}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      // Refresh the channel list
      await fetchChannels();
      setChannelError(null);
    } catch (err) {
      console.error('Failed to delete channel:', err);
      setChannelError('Failed to delete channel. Please try again.');
    } finally {
      setChannelLoading(false);
    }
  };
  
  // Delete a user
  const handleDeleteUser = async (userId) => {
    // Confirm deletion
    if (!window.confirm('Are you sure you want to delete this user? This action cannot be undone.')) {
      return;
    }
    
    try {
      setLoading(true);
      const token = localStorage.getItem('auth_token');
      
      // Use the DELETE endpoint
      await axios.delete(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.USERS}/${userId}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      // Refresh the user list
      await fetchUsers();
      setError(null);
    } catch (err) {
      console.error('Failed to delete user:', err);
      setError(err.response?.data?.message || 'Failed to delete user. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="bg-stone-900 text-white h-full overflow-auto flex flex-col">
      {/* Header Bar */}
      <div className="p-2 border-b border-stone-700 font-mono text-sm flex items-center justify-between">
        <h2 className="text-teal-400 font-medium">ADMIN PANEL</h2>
        
        {/* Tab Navigation */}
        <div className="flex">
          <button
            className={`px-3 py-1 rounded-t text-xs flex items-center ${
              activeTab === 'users'
                ? 'bg-stone-800 text-teal-300'
                : 'text-stone-400 hover:text-white'
            }`}
            onClick={() => setActiveTab('users')}
          >
            Users
          </button>
          <button
            className={`px-3 py-1 rounded-t text-xs flex items-center ml-1 ${
              activeTab === 'channels'
                ? 'bg-stone-800 text-teal-300'
                : 'text-stone-400 hover:text-white'
            }`}
            onClick={() => setActiveTab('channels')}
          >
            Chat Channels
          </button>
        </div>
      </div>
      
      {/* Create User/Channel Button - Only shown when respective tab is active */}
      {activeTab === 'users' && (
        <div className="p-2 flex justify-end">
          <button
            onClick={toggleCreateForm}
            className="px-3 py-1 bg-teal-600 hover:bg-teal-500 rounded text-sm"
          >
            {showCreateForm ? 'Cancel' : 'Create User'}
          </button>
        </div>
      )}
      
      {activeTab === 'channels' && (
        <div className="p-2 border-b border-stone-700 flex justify-end">
          <button
            onClick={toggleCreateChannelForm}
            className="px-3 py-1 bg-teal-600 hover:bg-teal-500 rounded text-sm"
          >
            {showCreateChannelForm ? 'Cancel' : 'Create Channel'}
          </button>
        </div>
      )}
      
      {/* Main Content Area */}
      <div className="p-4 flex-1 overflow-auto">
        {activeTab === 'users' && error && <p className="text-red-500 mb-4">{error}</p>}
        {activeTab === 'channels' && channelError && <p className="text-red-500 mb-4">{channelError}</p>}
        
        {/* Show users tab content */}
        {activeTab === 'users' && (
          <>
            {/* Create User Form */}
            {showCreateForm && (
              <div className="mb-6 p-4 bg-stone-800 rounded">
                <h3 className="text-lg mb-3 text-teal-400">Create New User</h3>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm text-gray-400 mb-1">Username: <span className="text-red-500">*</span></label>
                    <input
                      type="text"
                      name="username"
                      value={createFormData.username}
                      onChange={handleCreateChange}
                      className="bg-stone-700 text-white px-2 py-1 rounded w-full"
                      placeholder="Enter username"
                    />
                  </div>
                  <div>
                    <label className="block text-sm text-gray-400 mb-1">Password: <span className="text-red-500">*</span></label>
                    <input
                      type="password"
                      name="password"
                      value={createFormData.password}
                      onChange={handleCreateChange}
                      className="bg-stone-700 text-white px-2 py-1 rounded w-full"
                      placeholder="Enter password"
                    />
                  </div>
                  <div className="flex flex-col space-y-2">
                    <label className="flex items-center text-sm text-gray-400">
                      <input
                        type="checkbox"
                        name="is_admin"
                        checked={createFormData.is_admin}
                        onChange={handleCreateChange}
                        className="form-checkbox h-5 w-5 text-teal-500 mr-2"
                      />
                      Admin User
                    </label>
                    <label className="flex items-center text-sm text-gray-400">
                      <input
                        type="checkbox"
                        name="has_file_access"
                        checked={createFormData.has_file_access}
                        onChange={handleCreateChange}
                        className="form-checkbox h-5 w-5 text-teal-500 mr-2"
                      />
                      Private File Access
                    </label>
                  </div>
                  <div>
                    <label className="block text-sm text-gray-400 mb-1">Storage Quota:</label>
                    <div className="flex items-center">
                      <input
                        type="number"
                        name="storage_quota"
                        value={Math.round((createFormData.storage_quota || 52428800) / 1048576)}
                        onChange={(e) => {
                          const mbValue = parseInt(e.target.value) || 0;
                          handleCreateChange({
                            target: {
                              name: 'storage_quota',
                              value: mbValue * 1048576, // Convert MB to bytes
                              type: 'number'
                            }
                          });
                        }}
                        className="bg-stone-700 text-white px-2 py-1 rounded w-20 mr-2"
                        min="0"
                        step="1"
                        disabled={createFormData.is_admin}
                      />
                      <span className="text-sm text-gray-400">MB {createFormData.is_admin && "(Unlimited for admins)"}</span>
                    </div>
                  </div>
                </div>
                <div className="mt-4">
                  <button
                    onClick={handleCreateUser}
                    className="px-4 py-2 bg-teal-600 hover:bg-teal-500 rounded text-sm"
                    disabled={loading}
                  >
                    {loading ? 'Creating...' : 'Create User'}
                  </button>
                </div>
              </div>
            )}
            
            {/* Users Table */}
            <table className="w-full border-collapse">
              <thead>
                <tr className="border-b border-stone-700">
                  <th className="text-left p-2">User ID</th>
                  <th className="text-left p-2">Username</th>
                  <th className="text-left p-2">Admin</th>
                  <th className="text-left p-2">File Access</th>
                  <th className="text-left p-2">Storage Quota</th>
                  <th className="text-left p-2">Actions</th>
                </tr>
              </thead>
              <tbody>
                {users.map(userItem => (
                  <tr key={userItem.id} className="border-b border-stone-800 hover:bg-stone-800">
                    <td className="p-2">
                      {editingUser === userItem.id ? (
                        <span className="text-white px-2 py-1 rounded w-full">
                          {userItem.id}
                        </span>
                      ) : (
                        userItem.id
                      )}
                    </td>
                    <td className="p-2">
                      {editingUser === userItem.id ? (
                        <input
                          type="text"
                          name="username"
                          value={formData.username}
                          onChange={handleChange}
                          className="bg-stone-700 text-white px-2 py-1 rounded w-full"
                        />
                      ) : (
                        userItem.username
                      )}
                    </td>
                    <td className="p-2">
                      {editingUser === userItem.id ? (
                        <input
                          type="checkbox"
                          name="is_admin"
                          checked={formData.is_admin}
                          onChange={handleChange}
                          className="form-checkbox h-5 w-5 text-teal-500"
                        />
                      ) : (
                        userItem.is_admin === 1 || userItem.is_admin === true ? 'Yes' : 'No'
                      )}
                    </td>
                    <td className="p-2">
                      {editingUser === userItem.id ? (
                        <input
                          type="checkbox"
                          name="has_file_access"
                          checked={formData.has_file_access}
                          onChange={handleChange}
                          className="form-checkbox h-5 w-5 text-teal-500"
                        />
                      ) : (
                        userItem.has_file_access === 1 || userItem.has_file_access === true ? 'Yes' : 'No'
                      )}
                    </td>
                    <td className="p-2">
                      {editingUser === userItem.id ? (
                        <div className="flex items-center">
                          <input
                            type="number"
                            name="storage_quota"
                            value={Math.round((formData.storage_quota || 52428800) / 1048576)}
                            onChange={(e) => {
                              const mbValue = parseInt(e.target.value) || 0;
                              handleChange({
                                target: {
                                  name: 'storage_quota',
                                  value: mbValue * 1048576, // Convert MB to bytes
                                  type: 'number'
                                }
                              });
                            }}
                            className="bg-stone-700 text-white px-2 py-1 rounded w-20 mr-2"
                            min="0"
                            step="1"
                            disabled={formData.is_admin}
                          />
                          <span className="text-sm text-gray-400">MB {formData.is_admin && "(Unlimited for admins)"}</span>
                        </div>
                      ) : (
                        userItem.is_admin ? 'Unlimited' : 
                        `${Math.round((userItem.storage_quota || 52428800) / 1048576)} MB`
                      )}
                    </td>
                    <td className="p-2">
                      {editingUser === userItem.id ? (
                        <div className="flex flex-col space-y-2">
                          <div className="mb-2">
                            <label className="block text-sm text-gray-400">New Password:</label>
                            <input
                              type="password"
                              name="password"
                              value={formData.password}
                              onChange={handleChange}
                              placeholder="Leave blank to keep current"
                              className="bg-stone-700 text-white px-2 py-1 rounded w-full"
                            />
                          </div>
                          <div className="flex space-x-2">
                            <button
                              onClick={() => handleSave(userItem.id)}
                              className="px-3 py-1 bg-teal-600 hover:bg-teal-500 rounded text-sm"
                            >
                              Save
                            </button>
                            <button
                              onClick={handleCancel}
                              className="px-3 py-1 bg-stone-600 hover:bg-stone-500 rounded text-sm"
                            >
                              Cancel
                            </button>
                            <button
                              onClick={() => {
                                handleCancel();
                                handleDeleteUser(userItem.id);
                              }}
                              className="px-3 py-1 bg-stone-600 hover:bg-stone-500 rounded text-sm text-red-400 hover:text-red-300"
                            >
                              Delete
                            </button>
                          </div>
                        </div>
                      ) : (
                        <div className="flex space-x-2">
                          <button
                            onClick={() => handleEdit(userItem)}
                            className="px-3 py-1 bg-stone-700 hover:bg-stone-600 rounded text-sm"
                            disabled={loading}
                          >
                            Edit
                          </button>
                          <button
                            onClick={() => handleDeleteUser(userItem.id)}
                            className="px-3 py-1 focus:outline-none text-sm"
                            disabled={loading}
                            title="Delete user"
                          >
                            <Trash size={16} className="text-stone-400 hover:text-stone-300" />
                          </button>
                        </div>
                      )}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
            
            {loading && users.length > 0 && (
              <div className="mt-4 text-center">
                <div className="animate-spin rounded-full h-6 w-6 border-t-2 border-b-2 border-teal-500 mx-auto"></div>
              </div>
            )}
          </>
        )}
        
        {/* Show channels tab content */}
        {activeTab === 'channels' && (
          <>
            {/* Create Channel Form - Only shown when showCreateChannelForm is true */}
            {showCreateChannelForm && (
              <div className="mb-6 p-4 bg-stone-800 rounded">
                <h3 className="text-lg mb-3 text-teal-400">Create New Channel</h3>
                <form onSubmit={handleCreateChannel} className="flex items-end gap-4">
                  <div className="flex-1">
                    <label className="block text-sm text-gray-400 mb-1">Channel Name:</label>
                    <input
                      type="text"
                      value={newChannelName}
                      onChange={(e) => setNewChannelName(e.target.value)}
                      className="bg-stone-700 text-white px-2 py-1 rounded w-full"
                      placeholder="Enter channel name"
                    />
                  </div>
                  <button
                    type="submit"
                    className="px-4 py-1 bg-teal-600 hover:bg-teal-500 rounded text-sm"
                    disabled={channelLoading}
                  >
                    {channelLoading ? 'Creating...' : 'Create Channel'}
                  </button>
                </form>
              </div>
            )}
            
            {/* Channels Table */}
            <table className="w-full border-collapse">
              <thead>
                <tr className="border-b border-stone-700">
                  <th className="text-left p-2">Channel Name</th>
                  <th className="text-left p-2">Created By</th>
                  <th className="text-left p-2">Created At</th>
                  <th className="text-left p-2">Actions</th>
                </tr>
              </thead>
              <tbody>
                {channels.map(channel => (
                  <tr key={channel.id} className="border-b border-stone-800 hover:bg-stone-800">
                    <td className="p-2">{channel.name}</td>
                    <td className="p-2">{channel.created_by || '-'}</td>
                    <td className="p-2">
                      {new Date(channel.created_at).toLocaleString()}
                    </td>
                    <td className="p-2">
                      <button
                        onClick={() => handleDeleteChannel(channel.id)}
                        className="focus:outline-none"
                        title="Delete channel"
                        disabled={channelLoading}
                      >
                        <Trash size={16} className="text-stone-400 hover:text-stone-300" />
                      </button>
                    </td>
                  </tr>
                ))}
                {channels.length === 0 && !channelLoading && (
                  <tr>
                    <td colSpan="4" className="p-4 text-center text-stone-500">
                      No channels found. Create one above.
                    </td>
                  </tr>
                )}
              </tbody>
            </table>
            
            {channelLoading && (
              <div className="mt-4 text-center">
                <div className="animate-spin rounded-full h-6 w-6 border-t-2 border-b-2 border-teal-500 mx-auto"></div>
              </div>
            )}
          </>
        )}
      </div>
    </div>
  );
};

export default AdminWindow;

================
File: src/components/windows/AudioWindow.jsx
================
import React, { useRef, useState, useEffect, useCallback } from 'react';
import { Play, Pause, Volume2 } from 'lucide-react';

const AudioWindow = ({ nodeId, onCommand, windowState, updateWindowState }) => {
  const canvasRef = useRef(null);
  const audioRef = useRef(null);
  const audioContextRef = useRef(null);
  const analyserRef = useRef(null);
  const animationRef = useRef(null);
  const [isPlaying, setIsPlaying] = useState(windowState?.isPlaying || false);
  const [currentTime, setCurrentTime] = useState(windowState?.currentTime || 0);

  // Define draw function outside of other functions to avoid dependency issues
  const draw = useCallback(() => {
    if (!canvasRef.current || !analyserRef.current) {
      console.error('Cannot draw: canvas or analyser is null');
      return;
    }

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const analyser = analyserRef.current;
    
    // Make sure canvas dimensions are set correctly
    if (canvas.width === 0 || canvas.height === 0) {
      canvas.width = canvas.offsetWidth || 300;
      canvas.height = canvas.offsetHeight || 150;
    }
    
    // Use a smaller FFT size for better visualization
    analyser.fftSize = 512;
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    const drawFrame = () => {
      // Cancel any existing animation frame
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
      
      // Request next frame
      animationRef.current = requestAnimationFrame(drawFrame);
      
      // Get frequency data
      analyser.getByteFrequencyData(dataArray);

      // Clear canvas
      ctx.fillStyle = 'rgb(28, 25, 23)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw visualizer
      const barWidth = (canvas.width / bufferLength) * 2.5;
      let barHeight;
      let x = 0;

      for (let i = 0; i < bufferLength; i++) {
        barHeight = dataArray[i] * 1.5;
        
        // Make sure we have a minimum height for bars
        if (barHeight < 1) barHeight = 1;
        
        const gradient = ctx.createLinearGradient(0, canvas.height, 0, 0);
        gradient.addColorStop(0, '#14b8a6');
        gradient.addColorStop(1, '#2dd4bf');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);

        x += barWidth + 1;
      }
    };

    // Start the animation
    drawFrame();
    
    console.log('Visualization started');
    
    // Return a cleanup function
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
        animationRef.current = null;
      }
    };
  }, []);

  // Track if audio element has been connected to a source
  const sourceConnectedRef = useRef(false);

  // Setup audio with Web Audio API for visualization
  const setupAudio = useCallback(async () => {
    try {
      const audio = audioRef.current;
      if (!audio) {
        console.error('Audio element reference is null');
        return false;
      }
      
      // Force reset the sourceConnected flag if we're having issues
      if (audioContextRef.current?.state === 'closed') {
        sourceConnectedRef.current = false;
      }
      
      // Create new AudioContext if needed
      if (!audioContextRef.current || audioContextRef.current.state === 'closed') {
        console.log('Creating new AudioContext');
        
        // Create new AudioContext
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Create and configure analyser
        const analyser = audioContext.createAnalyser();
        analyser.fftSize = 256; // Smaller FFT size for better visualization
        analyser.smoothingTimeConstant = 0.8; // Add smoothing
        
        // Resume audio context (needed due to browser autoplay policies)
        await audioContext.resume();
        
        // Create a new MediaElementSource and connect it
        try {
          console.log('Creating new MediaElementSource');
          const source = audioContext.createMediaElementSource(audio);
          source.connect(analyser);
          analyser.connect(audioContext.destination);
          sourceConnectedRef.current = true;
          
          // Store references
          audioContextRef.current = audioContext;
          analyserRef.current = analyser;
          
          console.log('Audio setup complete with new AudioContext');
        } catch (sourceError) {
          console.error('Error creating MediaElementSource:', sourceError);
          return false;
        }
      } else {
        // If AudioContext exists but is suspended, resume it
        if (audioContextRef.current.state === 'suspended') {
          console.log('Resuming suspended AudioContext');
          await audioContextRef.current.resume();
        }
        
        console.log('Using existing AudioContext');
      }
      
      // Restore playback position from window state
      if (windowState?.currentTime) {
        audio.currentTime = windowState.currentTime;
      }
      
      return true;
    } catch (error) {
      console.error('Error setting up audio:', error);
      return false;
    }
  }, [windowState]);

  // Initialize audio on mount or when windowState changes
  useEffect(() => {
    const initializeAudio = async () => {
      // Set up the audio context
      const success = await setupAudio();
      
      // If setup was successful and we should be playing, start playback
      if (success && windowState?.isPlaying) {
        try {
          await audioRef.current.play();
          draw();
        } catch (error) {
          console.error('Error auto-playing audio:', error);
          setIsPlaying(false);
        }
      }
    };

    if (audioRef.current && 
        (!audioContextRef.current || audioContextRef.current.state === 'closed')) {
      initializeAudio();
    }

    return () => {
      if (audioContextRef.current && audioContextRef.current.state !== 'closed') {
        try {
          audioContextRef.current.close();
        } catch (error) {
          console.error('Error closing AudioContext:', error);
        }
      }
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [windowState, setupAudio, draw]);

  // Toggle play/pause
  const togglePlay = useCallback(async () => {
    if (!audioRef.current) return;

    try {
      console.log('Toggle play clicked, current state:', isPlaying);
      
      // Make sure audio context is initialized and running
      if (!audioContextRef.current || audioContextRef.current.state === 'closed') {
        console.log('Setting up audio again');
        const success = await setupAudio();
        if (!success) {
          console.error('Failed to set up audio');
          return;
        }
      } else if (audioContextRef.current.state === 'suspended') {
        console.log('Resuming suspended AudioContext');
        await audioContextRef.current.resume();
      }

      if (isPlaying) {
        console.log('Pausing audio');
        audioRef.current.pause();
        if (animationRef.current) {
          cancelAnimationFrame(animationRef.current);
          animationRef.current = null;
        }
      } else {
        console.log('Starting audio playback');
        try {
          // Start visualization before playing to ensure it's ready
          if (analyserRef.current && !animationRef.current) {
            console.log('Starting visualization');
            draw();
          }
          
          // Play the audio
          const playPromise = audioRef.current.play();
          if (playPromise) {
            await playPromise;
            console.log('Audio playback started successfully');
            
            // Make sure visualization is running
            if (!animationRef.current && analyserRef.current) {
              console.log('Starting visualization after successful play');
              draw();
            }
          }
        } catch (playError) {
          console.error('Error playing audio:', playError);
        }
      }
      
      setIsPlaying(!isPlaying);
    } catch (error) {
      console.error('Error in togglePlay:', error);
    }
  }, [isPlaying, setupAudio, draw]);

  // Handle canvas resize
  useEffect(() => {
    const resizeCanvas = () => {
      const canvas = canvasRef.current;
      if (!canvas) return;
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
    };

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    return () => window.removeEventListener('resize', resizeCanvas);
  }, []);

  // Update current time when playing
  useEffect(() => {
    if (!audioRef.current) return;
    
    const updateTime = () => {
      setCurrentTime(audioRef.current.currentTime);
    };
    
    audioRef.current.addEventListener('timeupdate', updateTime);
    return () => {
      audioRef.current?.removeEventListener('timeupdate', updateTime);
    };
  }, []);
  
  // Start visualization when audio is playing
  useEffect(() => {
    // If audio is playing but visualization is not running, start it
    if (isPlaying && audioRef.current && analyserRef.current && !animationRef.current) {
      console.log('Starting visualization due to isPlaying state change');
      draw();
    }
    
    // If audio is not playing but visualization is running, stop it
    if (!isPlaying && animationRef.current) {
      console.log('Stopping visualization due to isPlaying state change');
      cancelAnimationFrame(animationRef.current);
      animationRef.current = null;
    }
  }, [isPlaying, draw]);

  // Update window state when relevant state changes
  useEffect(() => {
    if (updateWindowState) {
      updateWindowState({
        isPlaying,
        currentTime
      });
    }
  }, [isPlaying, currentTime, updateWindowState]);

  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400">
      <div className="flex-1 relative">
        <canvas 
          ref={canvasRef}
          className="absolute inset-0 w-full h-full"
        />
      </div>

      <div className="border-t border-stone-700">
        <div className="flex items-center gap-4 mb-4">
          <button 
            onClick={togglePlay}
            className="p-2 hover:bg-stone-800 rounded-full transition-colors"
          >
            {isPlaying ? <Pause size={24} /> : <Play size={24} />}
          </button>
          <Volume2 size={24} />
        </div>

        <audio
          ref={audioRef}
          src="scamming-on-runescape.mp3"
          preload="auto"
          crossOrigin="anonymous"
          onPlay={() => setIsPlaying(true)}
          onPause={() => setIsPlaying(false)}
          onEnded={() => setIsPlaying(false)}
        />

        <div className="p-2 flex items-center gap-2 border-t border-stone-700">
          <span>$</span>
          <input
            type="text"
            className="flex-1 bg-stone-800 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
            onKeyDown={(e) => {
              if (e.key === 'Enter' && e.target.value.trim()) {
                onCommand(e.target.value.trim());
                e.target.value = '';
              }
            }}
          />
        </div>
      </div>
    </div>
  );
};

export default AudioWindow;

================
File: src/components/windows/CanvasPreview.jsx
================
import React, { useMemo } from 'react';
import ReactFlow, {
  Background,
  Controls,
  MiniMap,
  useNodesState,
  useEdgesState
} from 'reactflow';
import 'reactflow/dist/style.css';
import nodeTypes from '../../utils/canvasNodeTypes';

const CanvasPreview = ({ fileContent, nodeTypes: propNodeTypes }) => {
  // Parse the canvas data
  let canvasData;
  try {
    canvasData = JSON.parse(fileContent);
  } catch (error) {
    return (
      <div className="text-red-400 p-4">
        <p>Error parsing canvas file: {error.message}</p>
        <p className="mt-2">Raw content:</p>
        <pre className="font-mono text-sm whitespace-pre-wrap mt-2 bg-stone-800 p-2 rounded">
          {fileContent}
        </pre>
      </div>
    );
  }

  // Memoize the nodeTypes to prevent recreation on each render
  const memoizedNodeTypes = useMemo(() => propNodeTypes || nodeTypes, [propNodeTypes]);
  
  // Use React Flow hooks at the top level of the component
  const [nodes, setNodes] = useNodesState(canvasData.nodes || []);
  const [edges, setEdges] = useEdgesState(canvasData.edges || []);
  
  return (
    <div style={{ width: '100%', height: '100%', minHeight: '300px' }}>
      <ReactFlow
        nodes={nodes}
        edges={edges}
        nodeTypes={memoizedNodeTypes}
        fitView
        attributionPosition="bottom-right"
        minZoom={0.1}
        maxZoom={4}
        defaultViewport={{ x: 0, y: 0, zoom: 1 }}
      >
      <Background color="#44403c" gap={16} />
      <Controls showInteractive={false} />
      <MiniMap
        nodeColor={(node) => {
          switch (node.type) {
            case 'group':
              return node.data.color ? `rgba(${node.data.color}, 0.6)` : 'rgba(20, 184, 166, 0.6)';
            default:
              return '#14b8a6';
          }
        }}
        maskColor="rgba(0, 0, 0, 0.5)"
        style={{ backgroundColor: '#292524' }}
      />
      </ReactFlow>
    </div>
  );
};

export default CanvasPreview;

================
File: src/components/windows/CanvasWindow.jsx
================
import React, { useState, useEffect, useRef, useCallback } from 'react';
import ReactFlow, {
  Background,
  Controls,
  MiniMap,
  useNodesState,
  useEdgesState,
  addEdge,
  Panel
} from 'reactflow';
import 'reactflow/dist/style.css';
import { 
  Plus, 
  Minus, 
  Save, 
  FileText, 
  Trash2, 
  Edit, 
  Link as LinkIcon,
  Square,
  Type
} from 'lucide-react';
import API_CONFIG from '../../config/api';
import { useAuth } from '../../context/AuthContext';
import { useWindowState } from '../../context/WindowStateContext';
import { WINDOW_TYPES } from '../../utils/windowTypes';
import { saveCanvasState, getCanvasState } from '../../services/indexedDBService';

// Custom node types
const TextNode = ({ data }) => {
  return (
    <div className="p-2 bg-stone-800 border border-stone-700 rounded shadow-md">
      <div className="text-teal-400 text-sm whitespace-pre-wrap">{data.text}</div>
    </div>
  );
};

const GroupNode = ({ data }) => {
  return (
    <div 
      className="p-2 bg-stone-900 border border-stone-700 rounded shadow-md"
      style={{ backgroundColor: data.color ? `rgba(${data.color}, 0.2)` : 'rgba(20, 20, 20, 0.7)' }}
    >
      <div className="text-teal-300 font-bold mb-1">{data.label || 'Group'}</div>
      <div className="text-teal-400 text-sm">{data.children?.length || 0} items</div>
    </div>
  );
};

// Node types configuration
const nodeTypes = {
  text: TextNode,
  group: GroupNode
};

const CanvasWindow = ({ isActive, nodeId, onCommand, transformWindow, windowState, updateWindowState, focusRef }) => {
  // Get auth context to check if user is admin
  const { user } = useAuth();
  const isAdmin = user?.is_admin || false;
  
  // Get window state context for additional persistence
  const { setActiveWindow } = useWindowState();
  
  // Ref to track if state has been loaded from IndexedDB
  const stateLoadedRef = useRef(false);
  
  // Use state from windowState or initialize with defaults
  const [canvasName, setCanvasName] = useState(windowState?.canvasName || 'Untitled Canvas');
  const [currentCanvasPath, setCurrentCanvasPath] = useState(windowState?.currentCanvasPath || null);
  const [isLoading, setIsLoading] = useState(false);
  const [errorMessage, setErrorMessage] = useState('');
  const [saveStatus, setSaveStatus] = useState('saved'); // 'saved', 'saving', 'error'
  
  // ReactFlow states
  const [nodes, setNodes, onNodesChange] = useNodesState(windowState?.nodes || []);
  const [edges, setEdges, onEdgesChange] = useEdgesState(windowState?.edges || []);
  const [reactFlowInstance, setReactFlowInstance] = useState(null);
  
  // UI states
  const [selectedElements, setSelectedElements] = useState([]);
  const [showNodeCreator, setShowNodeCreator] = useState(false);
  const [newNodeType, setNewNodeType] = useState('text');
  const [newNodeText, setNewNodeText] = useState('');
  const [newNodeLabel, setNewNodeLabel] = useState('');
  const [newNodeColor, setNewNodeColor] = useState('');
  
  // For auto-save functionality
  const saveTimeoutRef = useRef(null);
  
  // Load canvas state from IndexedDB on mount
  useEffect(() => {
    const loadCanvasState = async () => {
      try {
        // Try to load canvas state from IndexedDB
        const savedState = await getCanvasState(nodeId);
        
        if (savedState && savedState.content && !stateLoadedRef.current) {
          console.log(`Loaded canvas state for window ${nodeId} from IndexedDB:`, savedState.content);
          
          // Update state with saved values
          if (savedState.content.nodes) {
            setNodes(savedState.content.nodes);
          }
          
          if (savedState.content.edges) {
            setEdges(savedState.content.edges);
          }
          
          if (savedState.content.canvasName) {
            setCanvasName(savedState.content.canvasName);
          }
          
          if (savedState.content.currentCanvasPath) {
            setCurrentCanvasPath(savedState.content.currentCanvasPath);
          }
          
          // Mark as loaded
          stateLoadedRef.current = true;
        }
      } catch (error) {
        console.error(`Failed to load canvas state for window ${nodeId} from IndexedDB:`, error);
      }
    };
    
    loadCanvasState();
  }, [nodeId, setNodes, setEdges]);
  
  // Handle window activation
  useEffect(() => {
    if (isActive) {
      // Save this as the active canvas window
      setActiveWindow(nodeId, WINDOW_TYPES.CANVAS);
    }
  }, [isActive, nodeId, setActiveWindow]);
  
  // Save canvas state to IndexedDB when it changes
  useEffect(() => {
    if (!stateLoadedRef.current) return;
    
    // Save the canvas state to IndexedDB
    saveCanvasState({
      id: nodeId,
      content: {
        nodes,
        edges,
        canvasName,
        currentCanvasPath
      }
    }).catch(error => {
      console.error(`Failed to save canvas state for window ${nodeId} to IndexedDB:`, error);
    });
    
  }, [nodes, edges, canvasName, currentCanvasPath, nodeId]);
  
  // Update window state when relevant state changes
  useEffect(() => {
    if (updateWindowState) {
      updateWindowState({
        nodes,
        edges,
        canvasName,
        currentCanvasPath,
        saveStatus
      });
    }
  }, [nodes, edges, canvasName, currentCanvasPath, saveStatus, updateWindowState]);
  
  // Auto-save functionality with debounce
  useEffect(() => {
    // Only auto-save if we have a path and user is admin
    if (currentCanvasPath && isAdmin) {
      // Clear any existing timeout
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
      
      // Set status to saving
      setSaveStatus('saving');
      
      // Set a new timeout for auto-save
      saveTimeoutRef.current = setTimeout(() => {
        saveCanvas();
      }, 2000); // 2 second debounce
    }
    
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, [nodes, edges, currentCanvasPath, isAdmin]);
  
  // Handle connection (edge) creation
  const onConnect = useCallback((params) => {
    setEdges((eds) => addEdge({
      ...params,
      id: `edge-${Date.now()}`,
      type: 'default',
      animated: false,
      style: { stroke: '#14b8a6' }
    }, eds));
  }, [setEdges]);
  
  // Handle node selection
  const onSelectionChange = useCallback(({ nodes, edges }) => {
    setSelectedElements([...nodes, ...edges]);
  }, []);
  
  // Handle drag over for node creation
  const onDragOver = useCallback((event) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);
  
  // Handle drop for node creation
  const onDrop = useCallback(
    (event) => {
      event.preventDefault();
      
      const type = event.dataTransfer.getData('application/reactflow/type');
      if (!type) return;
      
      const position = reactFlowInstance.screenToFlowPosition({
        x: event.clientX,
        y: event.clientY,
      });
      
      const newNode = {
        id: `node-${Date.now()}`,
        type,
        position,
        data: type === 'text' 
          ? { text: 'New text node' } 
          : { label: 'New Group', color: '20, 184, 166' },
        style: type === 'group' 
          ? { width: 400, height: 400, backgroundColor: 'rgba(20, 184, 166, 0.1)' } 
          : undefined
      };
      
      setNodes((nds) => nds.concat(newNode));
    },
    [reactFlowInstance, setNodes]
  );
  
  // Load canvas from file
  const loadCanvas = async (filePath) => {
    try {
      setIsLoading(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsLoading(false);
        return;
      }
      
      // Fetch file content from the server
      const response = await fetch(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_CONTENT}?path=${encodeURIComponent(filePath)}`,
        {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        }
      );
      
      if (!response.ok) {
        // If response is 403, it means the user doesn't have admin access
        if (response.status === 403) {
          setErrorMessage('Admin access required to view file content.');
        } else {
          setErrorMessage(`Failed to load canvas: ${response.statusText}`);
        }
        setIsLoading(false);
        return;
      }
      
      const data = await response.json();
      
      try {
        const canvasData = JSON.parse(data.content);
        
        if (canvasData.nodes && canvasData.edges) {
          setNodes(canvasData.nodes);
          setEdges(canvasData.edges);
          setCurrentCanvasPath(filePath);
          
          // Extract canvas name from file path
          const pathParts = filePath.split('/');
          const fileName = pathParts[pathParts.length - 1];
          setCanvasName(fileName.replace('.canvas', ''));
          
          setSaveStatus('saved');
        } else {
          setErrorMessage('Invalid canvas file format.');
        }
      } catch (parseError) {
        console.error('Error parsing canvas file:', parseError);
        setErrorMessage('Failed to parse canvas file. Invalid format.');
      }
      
      setIsLoading(false);
    } catch (error) {
      console.error('Error loading canvas:', error);
      setErrorMessage(`Error loading canvas: ${error.message}`);
      setSaveStatus('error');
      setIsLoading(false);
    }
  };
  
  // Save canvas to file
  const saveCanvas = async () => {
    try {
      // Check if we have a path
      if (!currentCanvasPath) {
        setErrorMessage('No file path specified. Please save as a new file first.');
        setSaveStatus('error');
        return;
      }
      
      setSaveStatus('saving');
      
      const canvasData = {
        nodes,
        edges
      };
      
      const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_SAVE}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
        },
        body: JSON.stringify({
          path: currentCanvasPath,
          content: JSON.stringify(canvasData, null, 2)
        })
      });
      
      if (!response.ok) {
        throw new Error(`Failed to save canvas: ${response.statusText}`);
      }
      
      setSaveStatus('saved');
      setErrorMessage('');
    } catch (error) {
      console.error('Error saving canvas:', error);
      setErrorMessage(`Error saving canvas: ${error.message}`);
      setSaveStatus('error');
    }
  };
  
  // Create a new node
  const createNode = (type) => {
    if (!reactFlowInstance) return;
    
    const position = {
      x: Math.random() * 400,
      y: Math.random() * 400
    };
    
    let newNode = {
      id: `node-${Date.now()}`,
      type,
      position,
      data: {}
    };
    
    if (type === 'text') {
      newNode.data = { text: newNodeText || 'New text node' };
    } else if (type === 'group') {
      newNode.data = { 
        label: newNodeLabel || 'New Group', 
        color: newNodeColor || '20, 184, 166' 
      };
      newNode.style = { 
        width: 400, 
        height: 400, 
        backgroundColor: `rgba(${newNodeColor || '20, 184, 166'}, 0.1)` 
      };
    }
    
    setNodes((nds) => nds.concat(newNode));
    setShowNodeCreator(false);
    setNewNodeText('');
    setNewNodeLabel('');
    setNewNodeColor('');
  };
  
  // Delete selected elements
  const deleteSelected = () => {
    const selectedNodeIds = selectedElements
      .filter(el => el.type !== 'default')
      .map(el => el.id);
    
    const selectedEdgeIds = selectedElements
      .filter(el => el.type === 'default')
      .map(el => el.id);
    
    setNodes(nodes.filter(node => !selectedNodeIds.includes(node.id)));
    setEdges(edges.filter(edge => !selectedEdgeIds.includes(edge.id)));
    setSelectedElements([]);
  };
  
  // Handle command input
  const handleCommand = (e) => {
    if (e.key === 'Enter' && e.target.value.trim()) {
      const cmd = e.target.value.trim();
      onCommand(cmd);
      e.target.value = '';
      
      // Commands:
      // - save: save the canvas
      // - load [path]: load a canvas from a file
      // - new-text: create a new text node
      // - new-group: create a new group node
      // - delete: delete selected elements
      if (cmd === 'save') {
        saveCanvas();
      } else if (cmd.startsWith('load ')) {
        const path = cmd.substring(5).trim();
        loadCanvas(path);
      } else if (cmd === 'new-text') {
        setNewNodeType('text');
        setShowNodeCreator(true);
      } else if (cmd === 'new-group') {
        setNewNodeType('group');
        setShowNodeCreator(true);
      } else if (cmd === 'delete') {
        deleteSelected();
      }
    }
  };
  
  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400 overflow-hidden">
      <div className="p-2 border-b border-stone-700 font-mono text-sm flex items-center justify-between">
        <div className="flex items-center">
          <span className="mr-2">{canvasName}</span>
          {saveStatus === 'saving' && <span className="text-yellow-400 text-xs ml-2">Saving...</span>}
          {saveStatus === 'saved' && <span className="text-green-400 text-xs ml-2">Saved</span>}
          {saveStatus === 'error' && <span className="text-red-400 text-xs ml-2">Error!</span>}
        </div>
        
        <div className="flex gap-2">
          <button 
            onClick={() => saveCanvas()}
            className="px-2 py-1 bg-stone-800 hover:bg-stone-700 rounded text-xs flex items-center gap-1"
            title="Save canvas"
          >
            <Save size={14} />
            Save
          </button>
          
          <button 
            onClick={() => {
              setNewNodeType('text');
              setShowNodeCreator(true);
            }}
            className="px-2 py-1 bg-stone-800 hover:bg-stone-700 rounded text-xs flex items-center gap-1"
            title="Add text node"
          >
            <Type size={14} />
            Text
          </button>
          
          <button 
            onClick={() => {
              setNewNodeType('group');
              setShowNodeCreator(true);
            }}
            className="px-2 py-1 bg-stone-800 hover:bg-stone-700 rounded text-xs flex items-center gap-1"
            title="Add group node"
          >
            <Square size={14} />
            Group
          </button>
          
          {selectedElements.length > 0 && (
            <button 
              onClick={deleteSelected}
              className="px-2 py-1 bg-stone-800 hover:bg-stone-700 rounded text-xs flex items-center gap-1"
              title="Delete selected"
            >
              <Trash2 size={14} />
              Delete
            </button>
          )}
        </div>
      </div>
      
      {/* Error message */}
      {errorMessage && (
        <div className="p-2 bg-red-900 text-red-200 text-sm">
          {errorMessage}
        </div>
      )}
      
      {/* Node creator dialog */}
      {showNodeCreator && (
        <div className="p-2 border-b border-stone-700 bg-stone-800">
          <div className="flex items-center justify-between mb-1">
            <span className="text-sm font-bold">
              {newNodeType === 'text' ? 'New Text Node' : 'New Group Node'}
            </span>
            <button
              onClick={() => setShowNodeCreator(false)}
              className="p-1 rounded hover:bg-stone-700 text-stone-400"
            >
              <Trash2 size={14} />
            </button>
          </div>
          
          {newNodeType === 'text' ? (
            <div className="flex flex-col gap-2">
              <textarea
                value={newNodeText}
                onChange={(e) => setNewNodeText(e.target.value)}
                placeholder="Enter text content"
                className="w-full bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
                rows={3}
              />
              <div className="flex justify-end">
                <button
                  onClick={() => createNode('text')}
                  className="px-2 py-1 bg-teal-700 text-teal-100 hover:bg-teal-600 rounded text-xs"
                >
                  Create
                </button>
              </div>
            </div>
          ) : (
            <div className="flex flex-col gap-2">
              <input
                type="text"
                value={newNodeLabel}
                onChange={(e) => setNewNodeLabel(e.target.value)}
                placeholder="Group label"
                className="w-full bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
              />
              <select
                value={newNodeColor}
                onChange={(e) => setNewNodeColor(e.target.value)}
                className="w-full bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
              >
                <option value="20, 184, 166">Teal</option>
                <option value="244, 63, 94">Red</option>
                <option value="234, 179, 8">Yellow</option>
                <option value="59, 130, 246">Blue</option>
                <option value="168, 85, 247">Purple</option>
                <option value="34, 197, 94">Green</option>
              </select>
              <div className="flex justify-end">
                <button
                  onClick={() => createNode('group')}
                  className="px-2 py-1 bg-teal-700 text-teal-100 hover:bg-teal-600 rounded text-xs"
                >
                  Create
                </button>
              </div>
            </div>
          )}
        </div>
      )}
      
      {/* Canvas area */}
      <div className="flex-1 overflow-hidden">
        {isLoading ? (
          <div className="flex items-center justify-center h-full">
            <span className="text-teal-300">Loading canvas...</span>
          </div>
        ) : (
          <ReactFlow
            nodes={nodes}
            edges={edges}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChange}
            onConnect={onConnect}
            onInit={setReactFlowInstance}
            onDrop={onDrop}
            onDragOver={onDragOver}
            onSelectionChange={onSelectionChange}
            nodeTypes={nodeTypes}
            fitView
            snapToGrid
            snapGrid={[15, 15]}
            defaultViewport={{ x: 0, y: 0, zoom: 1 }}
            minZoom={0.1}
            maxZoom={4}
            deleteKeyCode="Delete"
            multiSelectionKeyCode="Control"
            selectionKeyCode="Shift"
          >
            <Background color="#44403c" gap={16} />
            <Controls showInteractive={false} />
            <MiniMap
              nodeColor={(node) => {
                switch (node.type) {
                  case 'group':
                    return node.data.color ? `rgba(${node.data.color}, 0.6)` : 'rgba(20, 184, 166, 0.6)';
                  default:
                    return '#14b8a6';
                }
              }}
              maskColor="rgba(0, 0, 0, 0.5)"
              style={{ backgroundColor: '#292524' }}
            />
            
            <Panel position="top-left" className="bg-stone-800 p-2 rounded shadow-md">
              <div className="flex flex-col gap-1">
                <div className="text-xs text-stone-400">Drag to create:</div>
                <div 
                  className="flex items-center gap-1 p-1 bg-stone-700 rounded cursor-grab"
                  draggable
                  onDragStart={(event) => {
                    event.dataTransfer.setData('application/reactflow/type', 'text');
                    event.dataTransfer.effectAllowed = 'move';
                  }}
                >
                  <Type size={14} />
                  <span className="text-xs">Text Node</span>
                </div>
                <div 
                  className="flex items-center gap-1 p-1 bg-stone-700 rounded cursor-grab"
                  draggable
                  onDragStart={(event) => {
                    event.dataTransfer.setData('application/reactflow/type', 'group');
                    event.dataTransfer.effectAllowed = 'move';
                  }}
                >
                  <Square size={14} />
                  <span className="text-xs">Group Node</span>
                </div>
              </div>
            </Panel>
          </ReactFlow>
        )}
      </div>
      
      {/* Command input */}
      <div className="p-2 flex items-center gap-2 border-t border-stone-700">
        <span className="text-teal-400">$</span>
        <input
          ref={focusRef}
          type="text"
          onKeyDown={handleCommand}
          className="flex-1 bg-stone-800 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
          placeholder="Commands: save, load [path], new-text, new-group, delete"
        />
      </div>
    </div>
  );
};

export default CanvasWindow;

================
File: src/components/windows/ChatWindow.jsx
================
import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import { io } from 'socket.io-client';
import axios from 'axios';
import API_CONFIG from '../../config/api';
import { useAuth } from '../../context/AuthContext';
import { useWindowState } from '../../context/WindowStateContext';
import { WINDOW_TYPES } from '../../utils/windowTypes';
import { saveChatState, getChatState } from '../../services/indexedDBService';
import { MoreVertical, Trash, Mic, MicOff, Phone, PhoneOff, Plus } from 'lucide-react'; // Import additional icons
import SimplePeer from 'simple-peer';

// Helper function to safely destroy a peer connection
const safelyDestroyPeer = (peer, userId, destroyedPeersRef) => {
  if (!peer) return;
  
  try {
    // Stop any tracks in the peer's stream
    if (peer._localStream) {
      try {
        peer._localStream.getTracks().forEach(track => track.stop());
      } catch (err) {
        console.error('Error stopping local stream tracks:', err);
      }
    }
    
    // Destroy the peer
    if (peer.destroy) {
      peer.destroy();
      
      // Mark this peer as destroyed if we have a userId and ref
      if (userId && destroyedPeersRef?.current) {
        console.log(`Marking peer ${userId} as destroyed`);
        destroyedPeersRef.current.add(userId);
      }
    }
  } catch (err) {
    console.error('Error safely destroying peer:', err);
  }
};

// Parse a command input
const parseCommand = (input) => {
  // Check if this is a command (starts with /)
  if (!input.startsWith('/')) return null;
  
  // Split the input into command and arguments
  const parts = input.substring(1).trim().split(/\s+/);
  const command = parts[0].toLowerCase();
  const args = parts.slice(1);
  
  return { command, args };
};

const ChatWindow = ({ isActive, nodeId }) => {
  const { user } = useAuth();
  const { setActiveWindow } = useWindowState();
  const [rooms, setRooms] = useState([]);
  const [activeRoom, setActiveRoom] = useState(null);
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');
  const [charCount, setCharCount] = useState(0);
  const [newRoomName, setNewRoomName] = useState('');
  const [socket, setSocket] = useState(null);
  const messagesEndRef = useRef(null);
  // Refs to track loading state
  const stateLoadedRef = useRef(false);
  const roomsLoadedRef = useRef(false);
  
  // Voice chat state
  const [voiceChannels, setVoiceChannels] = useState([]);
  const [activeVoiceChannel, setActiveVoiceChannel] = useState(null);
  const [voiceParticipants, setVoiceParticipants] = useState([]);
  const [isMuted, setIsMuted] = useState(false);
  const [localStream, setLocalStream] = useState(null);
  const [peers, setPeers] = useState({});
  const [newVoiceChannelName, setNewVoiceChannelName] = useState('');
  const [speakingUsers, setSpeakingUsers] = useState(new Set());
  const audioContextRef = useRef(null);
  const analyserRef = useRef(null);
  const speakingTimeoutRef = useRef(null);
  const joinSoundRef = useRef(null);
  const leaveSoundRef = useRef(null);
  
  // Track destroyed peers to prevent signaling to them
  const destroyedPeersRef = useRef(new Set());
  
  // Helper function to create audio elements for remote streams
  const createAudioElement = (userId, stream) => {
    console.log('Creating audio element for user:', userId);
    const existingAudio = document.getElementById(`remote-audio-${userId}`);
    if (existingAudio) {
      console.log('Audio element already exists, removing it first');
      existingAudio.remove();
    }
    
    const audio = document.createElement('audio');
    audio.id = `remote-audio-${userId}`;
    audio.srcObject = stream;
    audio.autoplay = true;
    audio.controls = false; // Hide controls
    audio.volume = 1.0; // Full volume
    document.body.appendChild(audio);
    
    // Verify the audio element was created and is working
    console.log('Audio element created:', audio);
    console.log('Audio element autoplay:', audio.autoplay);
    console.log('Audio element srcObject:', audio.srcObject);
    
    return audio;
  };
  
  const MAX_CHARS = 500; // Maximum character limit

  // New state for tracking which message's menu is open
  const [activeMenu, setActiveMenu] = useState(null);

  // Initialize sound effects
  useEffect(() => {
    // Create the audio element for the join sound
    const joinSound = new Audio('/audio/vine-boom.mp3');
    joinSound.volume = 0.5; // Set volume to 50%
    joinSoundRef.current = joinSound;
    
    // Create the audio element for the leave sound
    const leaveSound = new Audio('/audio/vine-boom-leave.mp3');
    leaveSound.volume = 0.5; // Set volume to 50%
    leaveSoundRef.current = leaveSound;
    
    return () => {
      // Clean up
      if (joinSoundRef.current) {
        joinSoundRef.current.pause();
        joinSoundRef.current.src = '';
      }
      if (leaveSoundRef.current) {
        leaveSoundRef.current.pause();
        leaveSoundRef.current.src = '';
      }
    };
  }, []);
  
  // Connect to WebSocket server
  useEffect(() => {
    const socketInstance = io(API_CONFIG.BASE_URL.replace('/api', ''));
    setSocket(socketInstance);

    // Authenticate the socket connection
    const token = localStorage.getItem('auth_token');
    if (token) {
      socketInstance.emit('authenticate', token);
    }

    return () => {
      // Clean up voice chat if active
      if (localStream) {
        try {
          localStream.getTracks().forEach(track => track.stop());
        } catch (err) {
          console.error('Error stopping local stream tracks on unmount:', err);
        }
      }
      
      // Clean up peer connections safely using our helper function
      try {
        Object.values(peers).forEach(peer => {
          safelyDestroyPeer(peer);
        });
      } catch (err) {
        console.error('Error cleaning up peer connections on unmount:', err);
      }
      
      socketInstance.disconnect();
    };
  }, []);
  
  // Add effects to listen for message_deleted and room_deleted events
  useEffect(() => {
    if (!socket) return;
    
    const handleMessageDeleted = (data) => {
      setMessages(prev => prev.filter(msg => msg.id !== data.id));
    };
    
    const handleRoomDeleted = (data) => {
      // If the active room was deleted, set activeRoom to null
      if (activeRoom && activeRoom.id === data.id) {
        setActiveRoom(null);
      }
      
      // Remove the deleted room from the rooms list
      setRooms(prev => prev.filter(room => room.id !== data.id));
    };
    
    const handleVoiceChannelDeleted = (data) => {
      // If the active voice channel was deleted, leave it
      if (activeVoiceChannel && activeVoiceChannel.id === data.id) {
        leaveVoiceChannel();
      }
      
      // Remove the deleted voice channel from the list
      setVoiceChannels(prev => prev.filter(channel => channel.id !== data.id));
    };

    const handleMessagesCleared = (data) => {
      if (activeRoom && activeRoom.id === data.roomId) {
        // If this is for our current room, clear the messages
        if (data.count === 'all') {
          setMessages([]);
        } else {
          // Remove the most recent N messages
          const messageCount = parseInt(data.count, 10);
          if (!isNaN(messageCount)) {
            setMessages(prev => prev.slice(0, Math.max(0, prev.length - messageCount)));
          }
        }
        
        // Add a system message
        setMessages(prev => [...prev, {
          id: 'system-' + Date.now(),
          username: 'System',
          message: `Messages have been cleared by an admin.`,
          created_at: new Date().toISOString(),
          isSystem: true
        }]);
      }
    };
    
    socket.on('message_deleted', handleMessageDeleted);
    socket.on('room_deleted', handleRoomDeleted);
    socket.on('voice_channel_deleted', handleVoiceChannelDeleted);
    socket.on('messages_cleared', handleMessagesCleared);
    
    return () => {
      socket.off('message_deleted', handleMessageDeleted);
      socket.off('room_deleted', handleRoomDeleted);
      socket.off('voice_channel_deleted', handleVoiceChannelDeleted);
      socket.off('messages_cleared', handleMessagesCleared);
    };
  }, [socket, activeRoom, activeVoiceChannel]);

  // Load chat state from IndexedDB on mount
  useEffect(() => {
    const loadChatState = async () => {
      try {
        // Try to load chat state from IndexedDB
        const savedState = await getChatState(nodeId);
        
        if (savedState && savedState.content && !stateLoadedRef.current) {
          console.log(`Loaded chat state for window ${nodeId} from IndexedDB:`, savedState.content);
          
          // If we have a saved active room ID, we'll use it after fetching rooms
          stateLoadedRef.current = true;
          
          // Store the active room ID to use after fetching rooms
          if (savedState.content.activeRoomId) {
            // We'll set this after fetching rooms
            window.setTimeout(() => {
              if (rooms.length > 0) {
                const savedRoom = rooms.find(room => room.id === savedState.content.activeRoomId);
                if (savedRoom) {
                  setActiveRoom(savedRoom);
                  console.log(`Restored active room: ${savedRoom.name}`);
                }
              }
            }, 100);
          }
        }
      } catch (error) {
        console.error(`Failed to load chat state for window ${nodeId} from IndexedDB:`, error);
      }
    };
    
    loadChatState();
  }, [nodeId]);
  
  // Handle window activation
  useEffect(() => {
    if (isActive) {
      // Save this as the active chat window
      setActiveWindow(nodeId, WINDOW_TYPES.CHAT);
    }
  }, [isActive, nodeId, setActiveWindow]);

  // Fetch available rooms
  useEffect(() => {
    const fetchRooms = async () => {
      try {
        const token = localStorage.getItem('auth_token');
        const response = await axios.get(`${API_CONFIG.BASE_URL}/chat/rooms`, {
          headers: { Authorization: `Bearer ${token}` }
        });
        setRooms(response.data);
        roomsLoadedRef.current = true;
        
        // Get saved active room ID from sessionStorage
        const savedRoomId = sessionStorage.getItem(`chat_active_room_${nodeId}`);
        
        if (savedRoomId && response.data.length > 0) {
          // Try to find the saved room
          const savedRoom = response.data.find(room => 
            room.id === parseInt(savedRoomId, 10) || room.id === savedRoomId
          );
          
          if (savedRoom) {
            console.log(`Restoring saved room: ${savedRoom.name}`);
            setActiveRoom(savedRoom);
            
            // Load any saved draft message for this room
            const savedDraft = localStorage.getItem(`chat_draft_${nodeId}_${savedRoom.id}`);
            if (savedDraft) {
              setNewMessage(savedDraft);
              setCharCount(savedDraft.length);
            }
            
            return;
          }
        }
        
        // If no saved room was found or restored, and there are rooms but no active room,
        // set the first one as active
        if (response.data.length > 0 && !activeRoom) {
          setActiveRoom(response.data[0]);
        }
      } catch (error) {
        console.error('Failed to fetch rooms:', error);
      }
    };

    fetchRooms();
  }, []); // Only run once on mount

  // Save active room to IndexedDB and sessionStorage when it changes
  useEffect(() => {
    if (!activeRoom) return;
    
    // Save to sessionStorage for immediate persistence across refreshes
    sessionStorage.setItem(`chat_active_room_${nodeId}`, activeRoom.id);
    
    // Also save to IndexedDB for longer term storage if state is loaded
    if (stateLoadedRef.current) {
      saveChatState({
        id: nodeId,
        content: {
          activeRoomId: activeRoom.id
        }
      }).catch(error => {
        console.error(`Failed to save chat state for window ${nodeId} to IndexedDB:`, error);
      });
      
      console.log(`Saved active room ID ${activeRoom.id} to IndexedDB for window ${nodeId}`);
    }
    
    // Check for any saved draft message
    const savedDraft = localStorage.getItem(`chat_draft_${nodeId}_${activeRoom.id}`);
    if (savedDraft && newMessage !== savedDraft) {
      setNewMessage(savedDraft);
      setCharCount(savedDraft.length);
    }
  }, [activeRoom, nodeId, newMessage]);

  // Join room and fetch messages
  useEffect(() => {
    if (!activeRoom || !socket) return;

    // Join the room via WebSocket
    socket.emit('join_room', activeRoom.id);

    // Fetch messages for the room
    const fetchMessages = async () => {
      try {
        const token = localStorage.getItem('auth_token');
        const response = await axios.get(
          `${API_CONFIG.BASE_URL}/chat/rooms/${activeRoom.id}/messages`,
          { headers: { Authorization: `Bearer ${token}` } }
        );
        setMessages(response.data);
      } catch (error) {
        console.error('Failed to fetch messages:', error);
      }
    };

    // Fetch voice channels for the room
    const fetchVoiceChannels = async () => {
      try {
        const token = localStorage.getItem('auth_token');
        const response = await axios.get(
          `${API_CONFIG.BASE_URL}/chat/rooms/${activeRoom.id}/voice-channels`,
          { headers: { Authorization: `Bearer ${token}` } }
        );
        setVoiceChannels(response.data);
      } catch (error) {
        console.error('Failed to fetch voice channels:', error);
      }
    };

    fetchMessages();
    fetchVoiceChannels();

    // Listen for new messages
    const handleNewMessage = (message) => {
      setMessages((prev) => [...prev, message]);
    };

    socket.on('new_message', handleNewMessage);
//test
    return () => {
      // Leave the room when component unmounts or room changes
      socket.emit('leave_room', activeRoom.id);
      socket.off('new_message', handleNewMessage);
    };
  }, [activeRoom, socket]);

  // Set up voice activity detection
  useEffect(() => {
    if (!localStream || !socket || !activeVoiceChannel) return;
    
    // Create audio context and analyzer
    try {
      // Clean up any existing audio context
      if (audioContextRef.current) {
        audioContextRef.current.close();
      }
      
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      audioContextRef.current = audioContext;
      
      // Create analyzer node
      const analyser = audioContext.createAnalyser();
      analyser.fftSize = 256;
      analyser.smoothingTimeConstant = 0.8;
      analyserRef.current = analyser;
      
      // Connect the stream to the analyzer
      const source = audioContext.createMediaStreamSource(localStream);
      source.connect(analyser);
      
      // Set up the buffer for the analyzer
      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);
      
      // Function to check if user is speaking
      const checkSpeaking = () => {
        if (!analyser || !socket || !activeVoiceChannel || isMuted) return;
        
        analyser.getByteFrequencyData(dataArray);
        
        // Calculate average volume
        let sum = 0;
        for (let i = 0; i < bufferLength; i++) {
          sum += dataArray[i];
        }
        const average = sum / bufferLength;
        
        // Threshold for speaking detection
        const threshold = 20; // Adjust as needed
        
        // Check if speaking
        const isSpeaking = average > threshold;
        
        // If speaking state changed, emit event
        if (isSpeaking && !speakingUsers.has(user.id)) {
          // User started speaking
          socket.emit('voice_speaking_start', {
            channelId: activeVoiceChannel.id
          });
          
          // Update local state
          setSpeakingUsers(prev => {
            const newSet = new Set(prev);
            newSet.add(user.id);
            return newSet;
          });
          
          // Clear any existing timeout
          if (speakingTimeoutRef.current) {
            clearTimeout(speakingTimeoutRef.current);
          }
        } else if (!isSpeaking && speakingUsers.has(user.id)) {
          // Set a timeout to stop speaking status after a short delay
          // This prevents the speaking status from flickering
          if (!speakingTimeoutRef.current) {
            speakingTimeoutRef.current = setTimeout(() => {
              socket.emit('voice_speaking_stop', {
                channelId: activeVoiceChannel.id
              });
              
              // Update local state
              setSpeakingUsers(prev => {
                const newSet = new Set(prev);
                newSet.delete(user.id);
                return newSet;
              });
              
              speakingTimeoutRef.current = null;
            }, 300); // 300ms delay
          }
        }
      };
      
      // Set up interval to check speaking
      const intervalId = setInterval(checkSpeaking, 100); // Check every 100ms
      
      return () => {
        clearInterval(intervalId);
        if (speakingTimeoutRef.current) {
          clearTimeout(speakingTimeoutRef.current);
        }
        if (audioContextRef.current) {
          audioContextRef.current.close();
          audioContextRef.current = null;
        }
        analyserRef.current = null;
      };
    } catch (error) {
      console.error('Error setting up voice activity detection:', error);
    }
  }, [localStream, socket, activeVoiceChannel, isMuted, user.id, speakingUsers]);
  
  // Voice chat socket event handlers
  useEffect(() => {
    if (!socket) return;
    
    // Handle speaking events
    const handleUserSpeakingStart = (data) => {
      if (data.channelId === activeVoiceChannel?.id && data.userId !== user.id) {
        setSpeakingUsers(prev => {
          const newSet = new Set(prev);
          newSet.add(data.userId);
          return newSet;
        });
      }
    };
    
    const handleUserSpeakingStop = (data) => {
      if (data.channelId === activeVoiceChannel?.id && data.userId !== user.id) {
        setSpeakingUsers(prev => {
          const newSet = new Set(prev);
          newSet.delete(data.userId);
          return newSet;
        });
      }
    };
    
    socket.on('user_speaking_start', handleUserSpeakingStart);
    socket.on('user_speaking_stop', handleUserSpeakingStop);
    
    // Handle when a user joins a voice channel
    const handleUserJoinedVoice = (data) => {
      console.log('User joined voice:', data);
      
      // Add to participants list
      setVoiceParticipants(prev => {
        // Check if user is already in the list
        if (prev.some(p => p.user_id === data.userId)) {
          return prev;
        }
        
        // Play join sound if this is our active channel and we're not the one joining
        if (activeVoiceChannel && 
            activeVoiceChannel.id === data.channelId && 
            data.userId !== user.id &&
            joinSoundRef.current) {
          // Reset the audio to the beginning and play it
          joinSoundRef.current.currentTime = 0;
          joinSoundRef.current.play().catch(err => {
            console.error('Error playing join sound:', err);
          });
        }
        
        return [...prev, {
          user_id: data.userId,
          username: data.username,
          is_muted: data.isMuted,
          channel_id: data.channelId
        }];
      });
      
      // If this is our active voice channel and we have a local stream,
      // initiate a peer connection to the new user
      if (activeVoiceChannel && 
          activeVoiceChannel.id === data.channelId && 
          localStream && 
          localStream.active && // Check that stream is active
          data.userId !== user.id) {
        
        console.log('Creating new peer connection to user:', data.userId);
        
        // Create peer connection with optimized settings
        try {
          // Track connection start time for performance monitoring
          const connectionStartTime = performance.now();
          
          const peer = new SimplePeer({
            initiator: true,
            trickle: true, // Enable trickle ICE for faster connections
            stream: localStream,
            config: {
              iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' }
              ],
              iceCandidatePoolSize: 10 // Pre-gather some ICE candidates
            }
          });
            
            peer.on('signal', signal => {
              console.log('Generated signal for user:', data.userId, signal);
              console.time('signaling-' + data.userId);
              socket.emit('voice_signal', {
                channelId: activeVoiceChannel.id,
                targetUserId: data.userId,
                signal
              });
            });
            
            peer.on('stream', stream => {
              console.log('Received stream from user:', data.userId, stream);
              // Create audio element for the remote stream
              createAudioElement(data.userId, stream);
            });
            
            // Add error handling
            peer.on('error', err => {
              console.error('Peer connection error (initiator):', err);
            });
            
            // Monitor ICE connection state
            peer.on('iceStateChange', state => {
              console.log('ICE state change (initiator):', state);
            });
            
            // Monitor connection state with timing
            peer.on('connect', () => {
              console.timeEnd('signaling-' + data.userId);
              const connectionTime = performance.now() - connectionStartTime;
              console.log('Peer connection established (initiator) with user:', data.userId, 'in', connectionTime.toFixed(0), 'ms');
            });
            
            // Add to peers state
            setPeers(prev => ({
              ...prev,
              [data.userId]: peer
            }));
          } catch (err) {
            console.error('Error creating peer connection (initiator):', err);
          }
      }
    };

    
    
    // Handle when a user leaves a voice channel
    const handleUserLeftVoice = (data) => {
      console.log('User left voice:', data);
      
      // Play leave sound if this is our active channel and we're not the one leaving
      if (activeVoiceChannel && 
          activeVoiceChannel.id === data.channelId && 
          data.userId !== user.id &&
          leaveSoundRef.current) {
        // Reset the audio to the beginning and play it
        leaveSoundRef.current.currentTime = 0;
        leaveSoundRef.current.play().catch(err => {
          console.error('Error playing leave sound:', err);
        });
      }
      
      // Remove from participants list
      setVoiceParticipants(prev => 
        prev.filter(p => !(p.user_id === data.userId && p.channel_id === data.channelId))
      );
      
      // If we have a peer connection to this user, clean it up
      if (peers[data.userId]) {
        // Use our helper function to safely destroy the peer
        safelyDestroyPeer(peers[data.userId], data.userId, destroyedPeersRef);
        
        // Remove the audio element
        const audioElement = document.getElementById(`remote-audio-${data.userId}`);
        if (audioElement) {
          try {
            audioElement.remove();
          } catch (err) {
            console.error('Error removing audio element:', err);
          }
        }
        
        // Remove from peers state with a small delay to allow cleanup
        setTimeout(() => {
          setPeers(prev => {
            const newPeers = { ...prev };
            delete newPeers[data.userId];
            return newPeers;
          });
        }, 200);
      }
    };
    
    // Handle voice participants list
    const handleVoiceParticipants = (data) => {
      if (data.channelId === activeVoiceChannel?.id) {
        setVoiceParticipants(data.participants);
      }
    };
    
    // Handle WebRTC signaling
    const handleVoiceSignal = (data) => {
      console.log('Received voice signal:', data);
      
      // If the signal is for us and we're in the same channel
      if (data.channelId === activeVoiceChannel?.id && data.fromUserId !== user.id) {
        
        // If we already have a peer for this user and it's not in the destroyed list
        if (peers[data.fromUserId] && !destroyedPeersRef.current.has(data.fromUserId)) {
          console.log('Signaling existing peer for user:', data.fromUserId);
          try {
            peers[data.fromUserId].signal(data.signal);
          } catch (err) {
            console.error('Error signaling peer, it may have been destroyed:', err);
            // Mark this peer as destroyed to prevent future signaling attempts
            destroyedPeersRef.current.add(data.fromUserId);
          }
        } else {
          // Check if we have a valid stream
          if (!localStream || !localStream.active) {
            console.error('Cannot create peer connection: localStream is not available or not active');
            return;
          }
          
          // Create a new peer with optimized settings
          console.log('Creating new non-initiator peer for user:', data.fromUserId);
          
          try {
            // Track connection start time for performance monitoring
            const connectionStartTime = performance.now();
            
            const peer = new SimplePeer({
              initiator: false,
              trickle: true, // Enable trickle ICE for faster connections
              stream: localStream,
              config: {
                iceServers: [
                  { urls: 'stun:stun.l.google.com:19302' },
                  { urls: 'stun:stun1.l.google.com:19302' },
                  { urls: 'stun:stun2.l.google.com:19302' },
                  { urls: 'stun:stun3.l.google.com:19302' },
                  { urls: 'stun:stun4.l.google.com:19302' }
                ],
                iceCandidatePoolSize: 10 // Pre-gather some ICE candidates
              }
            });
              
              peer.on('signal', signal => {
                console.log('Generated response signal for user:', data.fromUserId, signal);
                console.time('signaling-' + data.fromUserId);
                socket.emit('voice_signal', {
                  channelId: activeVoiceChannel.id,
                  targetUserId: data.fromUserId,
                  signal
                });
              });
              
              peer.on('stream', stream => {
                console.log('Received stream from user:', data.fromUserId, stream);
                // Create audio element for the remote stream
                createAudioElement(data.fromUserId, stream);
              });
              
              // Add error handling
              peer.on('error', err => {
                console.error('Peer connection error (non-initiator):', err);
              });
              
              // Monitor ICE connection state
              peer.on('iceStateChange', state => {
                console.log('ICE state change (non-initiator):', state);
              });
              
              // Monitor connection state with timing
              peer.on('connect', () => {
                console.timeEnd('signaling-' + data.fromUserId);
                const connectionTime = performance.now() - connectionStartTime;
                console.log('Peer connection established (non-initiator) with user:', data.fromUserId, 'in', connectionTime.toFixed(0), 'ms');
              });
              
              // Signal with the received data
              peer.signal(data.signal);
              
              // Add to peers state
              setPeers(prev => ({
                ...prev,
                [data.fromUserId]: peer
              }));
            } catch (err) {
              console.error('Error creating peer connection (non-initiator):', err);
            }
        }
      }
    };
    
    // Handle mute status changes
    const handleUserMuteChanged = (data) => {
      setVoiceParticipants(prev => 
        prev.map(p => 
          p.user_id === data.userId && p.channel_id === data.channelId
            ? { ...p, is_muted: data.isMuted }
            : p
        )
      );
    };
    
    socket.on('user_joined_voice', handleUserJoinedVoice);
    socket.on('user_left_voice', handleUserLeftVoice);
    socket.on('voice_participants', handleVoiceParticipants);
    socket.on('voice_signal', handleVoiceSignal);
    socket.on('user_mute_changed', handleUserMuteChanged);
    
    return () => {
      socket.off('user_joined_voice', handleUserJoinedVoice);
      socket.off('user_left_voice', handleUserLeftVoice);
      socket.off('voice_participants', handleVoiceParticipants);
      socket.off('voice_signal', handleVoiceSignal);
      socket.off('user_mute_changed', handleUserMuteChanged);
    };
  }, [socket, activeVoiceChannel, localStream, peers, user]);

  // Scroll to bottom when messages change
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  const handleMessageChange = (e) => {
    const value = e.target.value;
    if (value.length <= MAX_CHARS) {
      setNewMessage(value);
      setCharCount(value.length);
      
      // Save draft message to localStorage
      if (activeRoom) {
        localStorage.setItem(`chat_draft_${nodeId}_${activeRoom.id}`, value);
      }
    }
  };

    // Command execution function
    const executeCommand = async (parsedCommand) => {
      const { command, args } = parsedCommand;
      
      // Handle different commands
      switch (command) {
        case 'clear':
        case 'delete':
          // Check if user is admin
          if (!user?.is_admin) {
            // Add system message that only admins can use this command
            setMessages(prev => [...prev, {
              id: 'system-' + Date.now(),
              username: 'System',
              message: 'Command failed: Admin privileges required',
              created_at: new Date().toISOString(),
              isSystem: true
            }]);
            return;
          }
          
          try {
            let count = 'all';
            if (args.length > 0) {
              count = args[0].toLowerCase() === 'all' ? 'all' : parseInt(args[0], 10);
              if (count !== 'all' && (isNaN(count) || count <= 0)) {
                setMessages(prev => [...prev, {
                  id: 'system-' + Date.now(),
                  username: 'System',
                  message: 'Invalid count. Usage: /clear [count|all]',
                  created_at: new Date().toISOString(),
                  isSystem: true
                }]);
                return;
              }
            }
            
            // Call the API to delete messages
            const token = localStorage.getItem('auth_token');
            const response = await axios.delete(
              `${API_CONFIG.BASE_URL}/chat/rooms/${activeRoom.id}/messages?count=${count}`,
              { headers: { Authorization: `Bearer ${token}` } }
            );
            
            // Add system message about successful deletion
            setMessages(prev => [...prev, {
              id: 'system-' + Date.now(),
              username: 'System',
              message: `${response.data.count} messages have been deleted from this channel.`,
              created_at: new Date().toISOString(),
              isSystem: true
            }]);
          } catch (error) {
            console.error('Failed to clear messages:', error);
            setMessages(prev => [...prev, {
              id: 'system-' + Date.now(),
              username: 'System',
              message: `Failed to clear messages: ${error.response?.data?.message || error.message}`,
              created_at: new Date().toISOString(),
              isSystem: true
            }]);
          }
          break;
          
        // Add other commands here in the future if needed
        
        default:
          // Unknown command
          setMessages(prev => [...prev, {
            id: 'system-' + Date.now(),
            username: 'System',
            message: `Unknown command: /${command}`,
            created_at: new Date().toISOString(),
            isSystem: true
          }]);
      }
    };

    const handleSendMessage = async (e) => {
      e.preventDefault();
      if (!newMessage.trim() || !activeRoom) return;
  
      // Check if this is a command
      const parsedCommand = parseCommand(newMessage);
      if (parsedCommand) {
        // This is a command, handle it with executeCommand
        await executeCommand(parsedCommand);
        setNewMessage('');
        setCharCount(0);
        // Clear the draft message from localStorage
        localStorage.removeItem(`chat_draft_${nodeId}_${activeRoom.id}`);
        return;
      }
  
      // This is a regular message, send it to the server
      try {
        const token = localStorage.getItem('auth_token');
        await axios.post(
          `${API_CONFIG.BASE_URL}/chat/rooms/${activeRoom.id}/messages`,
          { message: newMessage },
          { headers: { Authorization: `Bearer ${token}` } }
        );
        setNewMessage('');
        setCharCount(0);
        // Clear the draft message from localStorage
        localStorage.removeItem(`chat_draft_${nodeId}_${activeRoom.id}`);
      } catch (error) {
        console.error('Failed to send message:', error);
      }
    };

  const handleCreateRoom = async (e) => {
    e.preventDefault();
    if (!newRoomName.trim()) return;

    try {
      const token = localStorage.getItem('auth_token');
      const response = await axios.post(
        `${API_CONFIG.BASE_URL}/chat/rooms`,
        { name: newRoomName },
        { headers: { Authorization: `Bearer ${token}` } }
      );
      setRooms((prev) => [response.data, ...prev]);
      setNewRoomName('');
      setActiveRoom(response.data);
    } catch (error) {
      console.error('Failed to create room:', error);
    }
  };
  
  // Add new function to handle message deletion
  const handleDeleteMessage = async (messageId) => {
    try {
      const token = localStorage.getItem('auth_token');
      const endpoint = API_CONFIG.ENDPOINTS.CHAT_DELETE_MESSAGE.replace(':id', messageId);
      await axios.delete(
        `${API_CONFIG.BASE_URL}${endpoint}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      // The message will be removed from the UI when the socket event is received
      setActiveMenu(null); // Close the menu
    } catch (error) {
      console.error('Failed to delete message:', error);
    }
  };

  // Toggle menu function
  const toggleMenu = (messageId) => {
    setActiveMenu(activeMenu === messageId ? null : messageId);
  };

  const joinRoom = async (room) => {
    try {
      const token = localStorage.getItem('auth_token');
      await axios.post(
        `${API_CONFIG.BASE_URL}/chat/rooms/${room.id}/join`,
        {},
        { headers: { Authorization: `Bearer ${token}` } }
      );
      setActiveRoom(room);
    } catch (error) {
      console.error('Failed to join room:', error);
    }
  };
  
  // Voice chat functions
  const createVoiceChannel = async (e) => {
    e.preventDefault();
    if (!newVoiceChannelName.trim() || !activeRoom) return;
    
    try {
      const token = localStorage.getItem('auth_token');
      const response = await axios.post(
        `${API_CONFIG.BASE_URL}/chat/rooms/${activeRoom.id}/voice-channels`,
        { name: newVoiceChannelName },
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      setVoiceChannels(prev => [response.data, ...prev]);
      setNewVoiceChannelName('');
    } catch (error) {
      console.error('Failed to create voice channel:', error);
    }
  };
  
  const joinVoiceChannel = async (channel) => {
    // If already in a voice channel, leave it first
    if (activeVoiceChannel) {
      await leaveVoiceChannel();
    }
    
    try {
      // Request microphone access
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      
      // Verify we have an active stream with audio tracks
      if (!stream || !stream.active || stream.getAudioTracks().length === 0) {
        console.error('Failed to get active audio stream');
        alert('Could not access microphone. Please check your permissions.');
        return;
      }
      
      // Set initial mute state
      stream.getAudioTracks()[0].enabled = !isMuted;
      
      // Store the stream
      setLocalStream(stream);
      
      // Set the active voice channel
      setActiveVoiceChannel(channel);
      
      // Join the channel via socket
      socket.emit('join_voice', { 
        channelId: channel.id,
        isMuted
      });
      
      console.log(`Joined voice channel: ${channel.name}`);
    } catch (error) {
      console.error('Failed to join voice channel:', error);
      alert('Could not access microphone. Please check your permissions.');
    }
  };
  
  const leaveVoiceChannel = async () => {
    if (!activeVoiceChannel || !socket) return;
    
    // Notify server
    socket.emit('leave_voice', activeVoiceChannel.id);
    
    // Clean up peer connections safely using our helper function
    try {
      // Get keys (user IDs) from the peers object to use with safelyDestroyPeer
      Object.entries(peers).forEach(([userId, peer]) => {
        safelyDestroyPeer(peer, userId, destroyedPeersRef);
      });
    } catch (err) {
      console.error('Error cleaning up peer connections:', err);
    }
    
    // Clear the destroyed peers set when leaving a channel
    destroyedPeersRef.current = new Set();
    
    // Delay setting peers to empty to allow cleanup to complete
    setTimeout(() => {
      setPeers({});
    }, 300);
    
    // Remove remote audio elements
    document.querySelectorAll('[id^="remote-audio-"]').forEach(el => {
      try {
        el.remove();
      } catch (err) {
        console.error('Error removing audio element:', err);
      }
    });
    
    // Stop local stream
    if (localStream) {
      try {
        localStream.getTracks().forEach(track => track.stop());
      } catch (err) {
        console.error('Error stopping local stream tracks:', err);
      }
      setLocalStream(null);
    }
    
    // Clear active voice channel
    setActiveVoiceChannel(null);
    setVoiceParticipants([]);
    
    console.log('Left voice channel');
  };
  
  const toggleMute = () => {
    if (!localStream) return;
    
    // Toggle mute state
    const newMuteState = !isMuted;
    setIsMuted(newMuteState);
    
    // Update audio track
    localStream.getAudioTracks()[0].enabled = !newMuteState;
    
    // Notify others
    if (socket && activeVoiceChannel) {
      socket.emit('voice_mute_toggle', {
        channelId: activeVoiceChannel.id,
        isMuted: newMuteState
      });
    }
  };

  return (
    <div className="flex h-full">
      {/* Room sidebar */}
      <div className="w-1/9 max-w-[20%] min-w-[10%] bg-stone-900 border-r border-stone-700 flex flex-col">
        {/* Text channels */}
        <div className="p-2 border-b border-stone-700">
          <h3 className="text-teal-400 font-medium text-sm">Text Channels</h3>
        </div>
        <div className="flex-1 overflow-y-auto">
          {rooms.map((room) => (
            <div
              key={room.id}
              className={`text-sm p-2 cursor-pointer hover:bg-stone-700 ${
                activeRoom?.id === room.id ? 'bg-stone-800' : ''
              }`}
              onClick={() => joinRoom(room)}
            >
              <div className="text-white">{room.name}</div>
            </div>
          ))}
        </div>
        
        {/* Voice channels
        {activeRoom && (
          <>
            <div className="p-2 border-t border-b border-stone-700 flex justify-between items-center">
              <h3 className="text-teal-400 font-medium text-sm">Voice Channels</h3>
            </div>   
            <div className="overflow-y-auto">
              {voiceChannels.map((channel) => (
                <div
                  key={channel.id}
                  className={`text-sm p-2 cursor-pointer hover:bg-stone-700 ${
                    activeVoiceChannel?.id === channel.id ? 'bg-stone-800' : ''
                  }`}
                >
                  <div 
                    className="text-white flex items-center justify-between"
                    onClick={() => activeVoiceChannel?.id === channel.id ? leaveVoiceChannel() : joinVoiceChannel(channel)}
                  >
                    <span>{channel.name}</span>
                    {activeVoiceChannel?.id === channel.id ? (
                      <PhoneOff size={16} className="text-red-500" />
                    ) : (
                      <Phone size={16} className="text-teal-400" />
                    )}
                  </div> 
                  
                  {voiceParticipants.length > 0 && channel.id === activeVoiceChannel?.id && (
                    <div className="mt-1 pl-2 border-l border-stone-700">
                      {voiceParticipants.map(participant => (
                        <div key={participant.user_id} className="flex items-center text-xs text-stone-400 py-1">
                          {participant.is_muted ? (
                            <MicOff size={12} className="mr-1 text-red-500" />
                          ) : (
                            <Mic size={12} className={`mr-1 ${speakingUsers.has(participant.user_id) ? 'text-teal-400 animate-pulse' : 'text-green-500'}`} />
                          )}
                          <span 
                            className={`${speakingUsers.has(participant.user_id) && !participant.is_muted ? 'text-teal-400 font-medium animate-pulse' : ''}`}
                            style={{
                              textShadow: speakingUsers.has(participant.user_id) && !participant.is_muted ? '0 0 10px rgba(20, 184, 166, 0.5)' : 'none'
                            }}
                          >
                            {participant.username}
                          </span>
                          {participant.user_id === user.id && (
                            <button 
                              onClick={(e) => {
                                e.stopPropagation();
                                toggleMute();
                              }}
                              className="ml-2 text-stone-400 hover:text-teal-400"
                              title={isMuted ? "Unmute" : "Mute"}
                            >
                              {isMuted ? <MicOff size={12} /> : <Mic size={12} />}
                            </button>
                          )}
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              ))}
            </div>
          </>
        )}*/}
      </div>

      {/* Chat area */}
      <div className="flex-1 flex flex-col">
        {activeRoom ? (
          <>
            <div className="p-2 bg-stone-900 border-b border-stone-700 font-mono text-sm">
              <h3 className="text-teal-400 font-medium">{activeRoom.name}</h3>
            </div>
            <div className="flex-1 overflow-y-auto p-4 bg-stone-900">
              {messages.map((msg) => (
                <div
                  key={msg.id}
                  className="mb-1"
                >
                  <div
                    className="hover:bg-stone-800 inline-block rounded-lg px-4 py-2 w-[100%] break-all overflow-wrap break-word hyphens-auto overflow-hidden whitespace-pre-wrap relative text-white"
                    style={{ wordBreak: 'break-word', overflowWrap: 'break-word' }}
                  >
                    <div className="text-teal-400 flex font-medium text-s mb-1">
                      {msg.username}
                      <div className="text-xs text-white opacity-75 mt-1 ml-3">
                        {(() => {
                          // Ensure UTC interpretation by appending 'Z' if not already present
                          const timestamp = msg.created_at.endsWith('Z') ? 
                            msg.created_at : 
                            msg.created_at + 'Z';
                          
                          const msgDate = new Date(timestamp);
                          
                          return msgDate.toLocaleTimeString('en-US', {
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit',
                            hour: 'numeric',
                            minute: '2-digit',
                            timeZoneName: 'short',
                            hour12: false
                          });
                        })()}
                      </div>
                      
                      {/* Admin controls - only show if user is admin */}
                      {user?.is_admin && (
                        <div className="ml-auto">
                          <button 
                            onClick={(e) => {
                              e.stopPropagation();
                              handleDeleteMessage(msg.id);
                            }}
                            className="text-stone-400 hover:text-stone-300 focus:outline-none"
                            title="Delete message"
                          >
                            <Trash size={16} />
                          </button>
                        </div>
                      )}
                    </div>
                    <div>{msg.message}</div>
                  </div>
                </div>
              ))}
              <div ref={messagesEndRef} />
            </div>
            <form
              onSubmit={handleSendMessage}
              className="p-2 bg-stone-900 border-t border-stone-700 flex"
            >
              <div className="flex-1 flex flex-col">
                <input
                  type="text"
                  value={newMessage}
                  onChange={handleMessageChange}
                  className="flex-1 bg-stone-800 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none focus:ring-1 focus:ring-teal-400"
                  maxLength={MAX_CHARS}
                />
              </div>
            </form>
          </>
        ) : (
          <div className="flex-1 flex items-center justify-center bg-stone-900">
            <div className="text-stone-500">
              Select a channel to start chatting
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default ChatWindow;

================
File: src/components/windows/DiceRollGif.jsx
================
import React, { useEffect, useRef, useState } from 'react';

/**
 * Component to display dice roll GIF with animation completion detection
 */
const DiceRollGif = ({ src, onAnimationComplete }) => {
  const imgRef = useRef(null);
  const [isLoaded, setIsLoaded] = useState(false);
  
  // When the image loads, start tracking animation completion
  const handleImageLoad = () => {
    setIsLoaded(true);
  };
  
  // Effect to handle animation completion
  useEffect(() => {
    if (!isLoaded || !imgRef.current) return;
    
    // Create a temporary canvas to analyze the GIF
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    // Set a timeout that slightly exceeds typical GIF durations
    // This is a fallback in case we can't detect the exact animation end
    const timeoutId = setTimeout(() => {
      onAnimationComplete();
    }, 3000); // 3 seconds should be enough for most dice roll animations
    
    // For a more accurate approach (future improvement):
    // We could load the GIF via a GIF parsing library to get exact duration
    // Or track the animation via requestAnimationFrame and pixel comparison

    return () => {
      clearTimeout(timeoutId);
    };
  }, [isLoaded, onAnimationComplete]);
  
  return (
    <img 
      ref={imgRef}
      src={src} 
      alt="Rolling dice" 
      className="inline-block max-w-full h-32"
      onLoad={handleImageLoad}
    />
  );
};

export default DiceRollGif;

================
File: src/components/windows/explorer/api/fileOperations.js
================
import API_CONFIG from '../../../../config/api';

// Function to fetch public directory contents
export const fetchPublicDirectoryContents = async (publicPath = '/', refreshAll = false) => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // If refreshAll is true, start from the root
    const pathToFetch = refreshAll ? '/' : publicPath;
    
    // Fetch public directory contents from the server
    const response = await fetch(
      `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PUBLIC_FILES_LIST}?path=${encodeURIComponent(pathToFetch)}`,
      {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      }
    );
    
    if (!response.ok) {
      throw new Error(`Failed to load public files: ${response.statusText}`);
    }
    
    const data = await response.json();
    
    // Transform the data to match our expected format
    const transformedFiles = data.items.map(item => ({
      name: item.name,
      type: item.type,
      path: item.path,
      children: item.children || [],
      isPublic: true
    }));
    
    return {
      files: transformedFiles,
      error: null
    };
  } catch (error) {
    console.error('Error fetching public directory contents:', error);
    return {
      files: [],
      error: error.message || 'Failed to load public files. Please try again.'
    };
  }
};

// Function to fetch public file content
export const fetchPublicFileContent = async (filePath) => {
  console.log(`[DEBUG] fetchPublicFileContent called with path: ${filePath}`);
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      console.log('[DEBUG] Public file fetch - No auth token found');
      throw new Error('Authentication required. Please log in.');
    }
    
    // Fetch public file content from the server
    const url = `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PUBLIC_FILE_CONTENT}?path=${encodeURIComponent(filePath)}`;
    console.log(`[DEBUG] Public file fetch - Requesting URL: ${url}`);
    
    const response = await fetch(
      url,
      {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      }
    );
    
    console.log(`[DEBUG] Public file fetch - Response status: ${response.status}`);
    
    if (!response.ok) {
      const errorText = await response.text();
      console.log(`[DEBUG] Public file fetch - Error response: ${errorText}`);
      throw new Error(`Failed to load file content: ${response.statusText}`);
    }
    
    const data = await response.json();
    console.log(`[DEBUG] Public file fetch - Content received length: ${data.content?.length || 0} characters`);
    
    return {
      content: data.content,
      error: null
    };
  } catch (error) {
    console.error('[DEBUG] Error fetching public file content:', error);
    return {
      content: '',
      error: error.message || 'Error loading file'
    };
  }
};

// Function to fetch private directory contents from the server (admin only)
export const fetchDirectoryContents = async (path = '/', refreshAll = false) => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // If refreshAll is true, start from the root
    const pathToFetch = refreshAll ? '/' : path;
    
    // Fetch directory contents from the server
    const response = await fetch(
      `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILES_LIST}?path=${encodeURIComponent(pathToFetch)}`,
      {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      }
    );
    
    if (!response.ok) {
      // If response is 403, it means the user doesn't have admin access
      if (response.status === 403) {
        throw new Error('Admin access required to view files.');
      } else {
        throw new Error(`Failed to load files: ${response.statusText}`);
      }
    }
    
    const data = await response.json();
    
    // Transform the data to match our expected format
    const transformedFiles = data.items.map(item => ({
      name: item.name,
      type: item.type,
      path: item.path,
      children: item.children || []
    }));
    
    return {
      files: transformedFiles,
      error: null
    };
  } catch (error) {
    console.error('Error fetching directory contents:', error);
    return {
      files: [],
      error: error.message || 'Failed to load files. Please try again.'
    };
  }
};

// Function to fetch file content
export const fetchFileContent = async (filePath) => {
  console.log(`[DEBUG] fetchFileContent called with path: ${filePath}`);
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      console.log('[DEBUG] Private file fetch - No auth token found');
      throw new Error('Authentication required. Please log in.');
    }
    
    // Fetch file content from the server
    const url = `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_CONTENT}?path=${encodeURIComponent(filePath)}`;
    console.log(`[DEBUG] Private file fetch - Requesting URL: ${url}`);
    
    const response = await fetch(
      url,
      {
        headers: {
          'Authorization': `Bearer ${token}`
        }
      }
    );
    
    console.log(`[DEBUG] Private file fetch - Response status: ${response.status}`);
    
    if (!response.ok) {
      // If response is 403, it means the user doesn't have admin access
      if (response.status === 403) {
        console.log('[DEBUG] Private file fetch - Access denied (403)');
        throw new Error('Admin access required to view file content.');
      } else {
        const errorText = await response.text();
        console.log(`[DEBUG] Private file fetch - Error response: ${errorText}`);
        throw new Error(`Failed to load file content: ${response.statusText}`);
      }
    }
    
    const data = await response.json();
    console.log(`[DEBUG] Private file fetch - Content received length: ${data.content?.length || 0} characters`);
    
    return {
      content: data.content,
      error: null
    };
  } catch (error) {
    console.error('[DEBUG] Error fetching private file content:', error);
    return {
      content: '',
      error: error.message || 'Error loading file'
    };
  }
};

// Function to save file content
export const saveFileContent = async (filePath, content) => {
  console.log(`[DEBUG] saveFileContent called:`, {
    filePath,
    contentType: typeof content,
    contentLength: content?.length || 0,
    isMapFile: filePath?.endsWith('.map'),
    contentPreview: typeof content === 'string' ? content.substring(0, 100) + '...' : 'not a string'
  });
  
  try {
    // Check if filePath is valid
    if (!filePath || filePath.trim() === '') {
      console.error('[DEBUG] saveFileContent - Invalid file path');
      throw new Error('No file selected. Please select a file first.');
    }
    
    // Special handling for .map files to ensure rotation is included
    let contentToSave = content;
    if (filePath?.endsWith('.map') && typeof content === 'string') {
      // For map files, parse the JSON, process it, and re-stringify it
      try {
        const mapData = JSON.parse(content);
        
        // Ensure all cells have rotation property
        if (mapData.layers && Array.isArray(mapData.layers)) {
          mapData.layers.forEach(layer => {
            if (layer.cells && Array.isArray(layer.cells)) {
              layer.cells = layer.cells.map(cell => {
                // If rotation doesn't exist, add it with default value of 0
                if (cell.rotation === undefined) {
                  return { ...cell, rotation: 0 };
                }
                // Ensure rotation is a number
                if (typeof cell.rotation !== 'number') {
                  return { ...cell, rotation: Number(cell.rotation) };
                }
                return cell;
              });
            }
          });
        }
        
        // Use a custom replacer to guarantee rotation values are included
        contentToSave = JSON.stringify(mapData, (key, value) => {
          if (key === 'rotation') {
            return value === undefined ? 0 : Number(value);
          }
          return value;
        }, 2);
        
        console.log('[DEBUG] saveFileContent - Map file processed to ensure rotation values');
      } catch (parseError) {
        console.error('[DEBUG] saveFileContent - Error processing map data:', parseError);
        // If we can't parse, just use the original content
        contentToSave = content;
      }
    }
    
    // Create request body
    const requestBody = JSON.stringify({
      path: filePath,
      content: contentToSave
    });
    
    console.log(`[DEBUG] saveFileContent - Request body size: ${requestBody.length} bytes`);
    
    // Make the API request
    console.log(`[DEBUG] saveFileContent - Sending request to: ${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_SAVE}`);
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_SAVE}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
      },
      body: requestBody
    });
    
    console.log(`[DEBUG] saveFileContent - Response status: ${response.status}`);
    
    const responseData = await response.json();
    console.log(`[DEBUG] saveFileContent - Response data:`, responseData);
    
    if (!response.ok) {
      throw new Error(responseData.message || `Failed to save file: ${response.statusText}`);
    }
    
    console.log(`[DEBUG] saveFileContent - Success!`);
    return { 
      error: null,
      size: responseData.size,
      modified: responseData.modified
    };
  } catch (error) {
    console.error('[DEBUG] Error saving file:', error);
    return { error: error.message || 'Error saving file' };
  }
};

// Simple path join function for browser environment
const joinPaths = (...parts) => {
  // Filter out empty parts and normalize
  const normalized = parts.map(part => {
    if (part === undefined || part === null) return '';
    // Remove leading/trailing slashes
    return part.toString().replace(/^\/+|\/+$/g, '');
  }).filter(Boolean);
  
  // Join with slashes and add leading slash
  return '/' + normalized.join('/');
};

// Function to create a new file or folder
export const createNewItem = async (activeTab, activeFolderPath, newItemName, createType) => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // Determine if we're creating in the public folder or private folder
    const isPublicFolder = activeTab === 'public';
    
    // Construct the full path for the new item
    let newItemPath;
    if (isPublicFolder) {
      // For public folder, prefix with /public if not already included
      const publicPrefix = activeFolderPath.startsWith('/public') ? '' : '/public';
      // Remove any leading slash from activeFolderPath if it exists and if using publicPrefix
      const folderPath = publicPrefix && activeFolderPath.startsWith('/') 
        ? activeFolderPath.substring(1) 
        : activeFolderPath;
      newItemPath = joinPaths(publicPrefix, folderPath, newItemName.trim());
    } else {
      // For private folder (admin only)
      newItemPath = joinPaths(activeFolderPath, newItemName.trim());
    }
    
    // Create the new file or folder
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_CREATE}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        path: newItemPath,
        type: createType,
        content: createType === 'file' ? '' : undefined
      })
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || `Failed to create ${createType}: ${response.statusText}`);
    }
    
    return { 
      success: true, 
      path: newItemPath,
      error: null
    };
  } catch (error) {
    console.error(`Error creating ${createType}:`, error);
    return { 
      success: false, 
      path: null,
      error: error.message || `Failed to create ${createType}` 
    };
  }
};

// Function to rename a file or folder
export const renameItem = async (itemPath, newName) => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // Rename the file or folder
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_RENAME}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        oldPath: itemPath,
        newName: newName.trim()
      })
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || `Failed to rename: ${response.statusText}`);
    }
    
    return { success: true, error: null };
  } catch (error) {
    console.error('Error renaming:', error);
    return { success: false, error: error.message || 'Failed to rename' };
  }
};

// Function to delete a file or folder
export const deleteItem = async (itemPath) => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // Delete the file or folder
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_DELETE}?path=${encodeURIComponent(itemPath)}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || `Failed to delete: ${response.statusText}`);
    }
    
    return { success: true, error: null };
  } catch (error) {
    console.error('Error deleting:', error);
    return { success: false, error: error.message || 'Failed to delete' };
  }
};

// Function to move a file or folder
// Function to get storage usage statistics
export const getStorageStats = async () => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // Fetch storage stats from the server
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.STORAGE_STATS}`, {
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });
    
    if (!response.ok) {
      throw new Error(`Failed to load storage stats: ${response.statusText}`);
    }
    
    const data = await response.json();
    
    return {
      quota: data.quota,
      used: data.used,
      available: data.available,
      unlimited: data.unlimited,
      error: null
    };
  } catch (error) {
    console.error('Error fetching storage stats:', error);
    return {
      quota: 0,
      used: 0,
      available: 0,
      unlimited: false,
      error: error.message || 'Failed to load storage stats'
    };
  }
};

export const moveItem = async (sourcePath, destinationPath) => {
  try {
    // Get the authentication token
    const token = localStorage.getItem('auth_token');
    if (!token) {
      throw new Error('Authentication required. Please log in.');
    }
    
    // Call the API to move the file
    const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_MOVE}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        sourcePath,
        destinationPath
      })
    });
    
    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.message || `Failed to move: ${response.statusText}`);
    }
    
    return { success: true, error: null };
  } catch (error) {
    console.error('Error moving item:', error);
    return { success: false, error: error.message || 'Failed to move item' };
  }
};

================
File: src/components/windows/explorer/components/canvas/CanvasContainer.jsx
================
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { 
  generateId, 
  isPointInNode, 
  createTextNode, 
  createEdge,
  calculateBestConnectionSides,
  getConnectionPoints,
  drawConnection,
  getCanvasColor
} from '../../utils/canvasUtils';
import TextNode from './TextNode';

/**
 * CanvasContainer handles the infinite canvas, viewport, and interactions
 */
const CanvasContainer = ({ 
  canvasData, 
  onChange,
  readOnly = false
}) => {
  // State for viewport and interaction
  const [scale, setScale] = useState(1);
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  const [isPanning, setIsPanning] = useState(false);
  const [panStart, setPanStart] = useState({ x: 0, y: 0 });
  const [selectedNodeIds, setSelectedNodeIds] = useState([]);
  const [editingNodeId, setEditingNodeId] = useState(null);
  const [isConnecting, setIsConnecting] = useState(false);
  const [connectionStart, setConnectionStart] = useState(null);
  const [hoveredNodeId, setHoveredNodeId] = useState(null);
  const [isDragging, setIsDragging] = useState(false);
  const [draggedNodeIds, setDraggedNodeIds] = useState([]);

  // Refs for canvas elements
  const containerRef = useRef(null);
  const canvasRef = useRef(null);
  const interactionLayerRef = useRef(null);

  // Get the currently selected node
  const selectedNode = canvasData.nodes.find(node => node.id === selectedNodeIds[0]);

  // Draw the canvas with nodes and edges
  const drawCanvas = useCallback(() => {
    if (!canvasRef.current) return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const { width, height } = canvas;
    
    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    
    // Apply viewport transformation
    ctx.save();
    ctx.translate(offset.x, offset.y);
    ctx.scale(scale, scale);
    
    // Draw background grid (optional)
    ctx.strokeStyle = '#2a2a2a';
    ctx.lineWidth = 1 / scale;
    
    const gridSize = 20;
    const startX = Math.floor(-offset.x / scale / gridSize) * gridSize;
    const startY = Math.floor(-offset.y / scale / gridSize) * gridSize;
    const endX = Math.ceil((width - offset.x) / scale / gridSize) * gridSize;
    const endY = Math.ceil((height - offset.y) / scale / gridSize) * gridSize;
    
    // Draw vertical grid lines
    for (let x = startX; x <= endX; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, startY);
      ctx.lineTo(x, endY);
      ctx.stroke();
    }
    
    // Draw horizontal grid lines
    for (let y = startY; y <= endY; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(startX, y);
      ctx.lineTo(endX, y);
      ctx.stroke();
    }
    
    // Draw edges
    canvasData.edges.forEach(edge => {
      const sourceNode = canvasData.nodes.find(n => n.id === edge.fromNode);
      const targetNode = canvasData.nodes.find(n => n.id === edge.toNode);
      
      if (sourceNode && targetNode) {
        // Get connection points
        const points = getConnectionPoints(
          sourceNode, 
          targetNode, 
          edge.fromSide, 
          edge.toSide
        );
        
        // Draw the connection
        drawConnection(
          ctx, 
          points.source, 
          points.target, 
          getCanvasColor(edge.color),
          edge.fromEnd === 'arrow',
          edge.toEnd === 'arrow'
        );
      }
    });
    
    // Restore the context
    ctx.restore();
  }, [canvasData, offset, scale]);

  // Resize canvas to fit container
  const resizeCanvas = useCallback(() => {
    if (!containerRef.current || !canvasRef.current || !interactionLayerRef.current) return;
    
    const container = containerRef.current;
    const canvas = canvasRef.current;
    const interactionLayer = interactionLayerRef.current;
    
    // Set canvas size to match container
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    interactionLayer.width = container.clientWidth;
    interactionLayer.height = container.clientHeight;
    
    // Redraw canvas
    drawCanvas();
  }, [drawCanvas]);

  // Initialize and set up event listeners
  useEffect(() => {
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    return () => {
      window.removeEventListener('resize', resizeCanvas);
    };
  }, [resizeCanvas]);

  // Redraw canvas when data changes
  useEffect(() => {
    drawCanvas();
  }, [canvasData, drawCanvas, selectedNodeIds, scale, offset]);

  // Handle mouse wheel for zooming
  const handleWheel = (e) => {
    e.preventDefault();
    
    const { deltaY } = e;
    const direction = deltaY > 0 ? -1 : 1;
    
    // Calculate zoom
    const factor = 0.1;
    const newScale = Math.max(0.1, scale * (1 + direction * factor));
    
    // Get mouse position relative to canvas
    const rect = canvasRef.current.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Calculate new offset to zoom around mouse position
    const newOffsetX = mouseX - (mouseX - offset.x) * (newScale / scale);
    const newOffsetY = mouseY - (mouseY - offset.y) * (newScale / scale);
    
    setScale(newScale);
    setOffset({ x: newOffsetX, y: newOffsetY });
  };

  // Handle mouse down for panning and selection
  const handleMouseDown = (e) => {
    // Get mouse position relative to canvas
    const rect = canvasRef.current.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Convert to canvas coordinates
    const canvasX = (mouseX - offset.x) / scale;
    const canvasY = (mouseY - offset.y) / scale;
    
    // Check if clicked on a node
    const nodeUnderMouse = canvasData.nodes.find(node => 
      isPointInNode({ x: canvasX, y: canvasY }, node)
    );
    
    if (nodeUnderMouse) {
      // Select the node
      if (e.shiftKey) {
        // Add to selection if holding shift
        setSelectedNodeIds(prev => 
          prev.includes(nodeUnderMouse.id) 
            ? prev.filter(id => id !== nodeUnderMouse.id) 
            : [...prev, nodeUnderMouse.id]
        );
      } else if (!selectedNodeIds.includes(nodeUnderMouse.id)) {
        // Replace selection
        setSelectedNodeIds([nodeUnderMouse.id]);
      }
      
      // Prepare for dragging
      setIsDragging(true);
      setDraggedNodeIds(selectedNodeIds.includes(nodeUnderMouse.id) 
        ? selectedNodeIds 
        : [nodeUnderMouse.id]
      );
    } else {
      // Start panning
      setIsPanning(true);
      setPanStart({ x: mouseX, y: mouseY });
      
      // Clear selection unless shift is held
      if (!e.shiftKey) {
        setSelectedNodeIds([]);
      }
    }
  };

  // Handle mouse move for panning and dragging
  const handleMouseMove = (e) => {
    // Get mouse position relative to canvas
    const rect = canvasRef.current.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Convert to canvas coordinates
    const canvasX = (mouseX - offset.x) / scale;
    const canvasY = (mouseY - offset.y) / scale;
    
    // Handle panning
    if (isPanning) {
      const deltaX = mouseX - panStart.x;
      const deltaY = mouseY - panStart.y;
      
      setOffset(prev => ({
        x: prev.x + deltaX,
        y: prev.y + deltaY
      }));
      
      setPanStart({ x: mouseX, y: mouseY });
    }
    
    // Handle dragging
    if (isDragging && draggedNodeIds.length > 0 && !readOnly) {
      // Calculate the delta from last mouse position
      const lastMousePos = {
        x: (panStart.x - offset.x) / scale,
        y: (panStart.y - offset.y) / scale
      };
      
      const deltaX = canvasX - lastMousePos.x;
      const deltaY = canvasY - lastMousePos.y;
      
      // Update node positions
      const updatedNodes = canvasData.nodes.map(node => {
        if (draggedNodeIds.includes(node.id)) {
          return {
            ...node,
            x: node.x + deltaX,
            y: node.y + deltaY
          };
        }
        return node;
      });
      
      // Update canvas data
      onChange({
        ...canvasData,
        nodes: updatedNodes
      });
      
      // Update pan start
      setPanStart({ x: mouseX, y: mouseY });
    }
    
    // Check for node under mouse for hover effect
    const nodeUnderMouse = canvasData.nodes.find(node => 
      isPointInNode({ x: canvasX, y: canvasY }, node)
    );
    
    setHoveredNodeId(nodeUnderMouse?.id || null);
  };

  // Handle mouse up to stop panning and dragging
  const handleMouseUp = () => {
    setIsPanning(false);
    setIsDragging(false);
    setDraggedNodeIds([]);
  };

  // Handle node selection
  const handleNodeSelect = (nodeId) => {
    setSelectedNodeIds([nodeId]);
  };

  // Handle node text change
  const handleNodeTextChange = (nodeId, text) => {
    const updatedNodes = canvasData.nodes.map(node => {
      if (node.id === nodeId) {
        return {
          ...node,
          text
        };
      }
      return node;
    });
    
    onChange({
      ...canvasData,
      nodes: updatedNodes
    });
  };

  // Handle node resize
  const handleNodeResize = (nodeId, width, height) => {
    const updatedNodes = canvasData.nodes.map(node => {
      if (node.id === nodeId) {
        return {
          ...node,
          width,
          height
        };
      }
      return node;
    });
    
    onChange({
      ...canvasData,
      nodes: updatedNodes
    });
  };

  // Handle node move
  const handleNodeMove = (nodeId, x, y) => {
    const updatedNodes = canvasData.nodes.map(node => {
      if (node.id === nodeId) {
        return {
          ...node,
          x,
          y
        };
      }
      return node;
    });
    
    onChange({
      ...canvasData,
      nodes: updatedNodes
    });
  };

  // Add a new text node at a specific position
  const addTextNode = (x, y, text = 'New note') => {
    if (readOnly) return;
    
    // Convert screen coordinates to canvas coordinates
    const canvasX = (x - offset.x) / scale;
    const canvasY = (y - offset.y) / scale;
    
    // Create a new node
    const newNode = createTextNode(canvasX, canvasY, text);
    
    // Add to canvas data
    onChange({
      ...canvasData,
      nodes: [...canvasData.nodes, newNode]
    });
    
    // Select the new node
    setSelectedNodeIds([newNode.id]);
    
    // Start editing the new node
    setEditingNodeId(newNode.id);
    
    return newNode.id;
  };

  // Create a connection between two nodes
  const connectNodes = (sourceId, targetId) => {
    if (readOnly) return;
    
    // Find the nodes
    const sourceNode = canvasData.nodes.find(n => n.id === sourceId);
    const targetNode = canvasData.nodes.find(n => n.id === targetId);
    
    if (!sourceNode || !targetNode) return;
    
    // Calculate best connection sides
    const { fromSide, toSide } = calculateBestConnectionSides(sourceNode, targetNode);
    
    // Create a new edge
    const newEdge = createEdge(sourceId, targetId, fromSide, toSide);
    
    // Add to canvas data
    onChange({
      ...canvasData,
      edges: [...canvasData.edges, newEdge]
    });
    
    return newEdge.id;
  };

  // Delete selected nodes and their connections
  const deleteSelected = () => {
    if (readOnly || selectedNodeIds.length === 0) return;
    
    // Filter out selected nodes
    const updatedNodes = canvasData.nodes.filter(node => 
      !selectedNodeIds.includes(node.id)
    );
    
    // Filter out edges connected to deleted nodes
    const updatedEdges = canvasData.edges.filter(edge => 
      !selectedNodeIds.includes(edge.fromNode) && 
      !selectedNodeIds.includes(edge.toNode)
    );
    
    // Update canvas data
    onChange({
      ...canvasData,
      nodes: updatedNodes,
      edges: updatedEdges
    });
    
    // Clear selection
    setSelectedNodeIds([]);
  };

  // Start editing a node
  const startNodeEditing = (nodeId) => {
    setEditingNodeId(nodeId);
  };

  // Stop editing a node
  const stopNodeEditing = () => {
    setEditingNodeId(null);
  };

  return (
    <div 
      ref={containerRef}
      className="relative w-full h-full overflow-hidden bg-stone-900"
      tabIndex={0} // Make container focusable for keyboard shortcuts
      onKeyDown={(e) => {
        // Delete key to remove selected nodes
        if (e.key === 'Delete' && !readOnly) {
          deleteSelected();
        }
      }}
    >
      {/* Canvas for rendering edges */}
      <canvas 
        ref={canvasRef}
        className="absolute top-0 left-0 w-full h-full"
      />
      
      {/* Interaction layer */}
      <canvas 
        ref={interactionLayerRef}
        className="absolute top-0 left-0 w-full h-full"
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        onWheel={handleWheel}
        onDoubleClick={(e) => {
          if (readOnly) return;
          
          // Get mouse position
          const rect = canvasRef.current.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;
          
          // Add a new node at this position
          addTextNode(mouseX, mouseY);
        }}
      />
      
      {/* Node elements */}
      <div className="absolute top-0 left-0 w-full h-full pointer-events-none">
        {canvasData.nodes.map(node => (
          node.type === 'text' && (
            <TextNode
              key={node.id}
              node={node}
              selected={selectedNodeIds.includes(node.id)}
              onSelect={handleNodeSelect}
              onChange={handleNodeTextChange}
              onResize={handleNodeResize}
              onMove={handleNodeMove}
              scale={scale}
              isEditing={editingNodeId === node.id}
              onStartEditing={startNodeEditing}
              onStopEditing={stopNodeEditing}
            />
          )
        ))}
      </div>
      
      {/* Controls */}
      <div className="absolute bottom-4 right-4 flex flex-col gap-2 bg-stone-800 p-2 rounded shadow">
        <button 
          className="p-2 bg-stone-700 hover:bg-stone-600 rounded text-white"
          onClick={() => setScale(scale + 0.1)}
        >
          +
        </button>
        <button 
          className="p-2 bg-stone-700 hover:bg-stone-600 rounded text-white"
          onClick={() => setScale(Math.max(0.1, scale - 0.1))}
        >
          -
        </button>
        <button 
          className="p-2 bg-stone-700 hover:bg-stone-600 rounded text-white"
          onClick={() => {
            // Reset view
            setScale(1);
            setOffset({ x: 0, y: 0 });
          }}
        >
          Reset
        </button>
      </div>
    </div>
  );
};

export default CanvasContainer;

================
File: src/components/windows/explorer/components/canvas/CanvasEditor.jsx
================
import React, { useState, useEffect, useCallback } from 'react';
import { 
  createEmptyCanvas, 
  createTextNode, 
  createEdge, 
  generateId 
} from '../../utils/canvasUtils';
import CanvasContainer from './CanvasContainer';
import { 
  Plus, 
  Save, 
  Trash2, 
  Type,
  Link as LinkIcon,
  ArrowRight
} from 'lucide-react';

/**
 * Canvas Editor component that implements the JSONCanvas format
 * This is the main component for editing .canvas files
 */
const CanvasEditor = ({ fileContent, selectedFile, onSave }) => {
  const [canvasData, setCanvasData] = useState(createEmptyCanvas());
  const [canvasName, setCanvasName] = useState('Untitled Canvas');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [saveStatus, setSaveStatus] = useState('saved'); // 'saved', 'saving', 'error'
  const [showNodeCreator, setShowNodeCreator] = useState(false);
  const [newNodeText, setNewNodeText] = useState('');
  const [showConnectionCreator, setShowConnectionCreator] = useState(false);
  const [connectionNodes, setConnectionNodes] = useState({ source: '', target: '' });

  // Load canvas data when fileContent changes
  useEffect(() => {
    try {
      if (fileContent) {
        setIsLoading(true);
        
        // Parse the JSON canvas file
        const parsed = JSON.parse(fileContent);
        
        // Check if it has the basic JSONCanvas structure
        if (parsed.nodes || parsed.edges) {
          setCanvasData({
            nodes: parsed.nodes || [],
            edges: parsed.edges || []
          });
          
          // Extract canvas name from file path
          if (selectedFile) {
            const pathParts = selectedFile.path.split('/');
            const fileName = pathParts[pathParts.length - 1];
            setCanvasName(fileName.replace('.canvas', ''));
          }
          
          setSaveStatus('saved');
        } else {
          // Create a new canvas if the structure is invalid
          setCanvasData(createEmptyCanvas());
          console.warn('Invalid canvas format, creating new canvas');
        }
        
        setError(null);
      } else {
        // Create a new canvas if no content
        setCanvasData(createEmptyCanvas());
      }
    } catch (err) {
      console.error('Error parsing canvas file:', err);
      setError('Failed to parse canvas file. Creating a new canvas.');
      setCanvasData(createEmptyCanvas());
    } finally {
      setIsLoading(false);
    }
  }, [fileContent, selectedFile]);

  // Save canvas to file
  const handleSaveCanvas = useCallback(() => {
    if (!selectedFile) return;
    
    try {
      // Set status to saving
      setSaveStatus('saving');
      
      // Convert canvasData to proper format for saving
      // Make sure to remove any runtime-only properties
      const saveData = {
        nodes: canvasData.nodes.map(node => ({
          id: node.id,
          type: node.type,
          x: node.x,
          y: node.y,
          width: node.width,
          height: node.height,
          text: node.text,
          color: node.color
        })),
        edges: canvasData.edges.map(edge => ({
          id: edge.id,
          fromNode: edge.fromNode,
          toNode: edge.toNode,
          fromSide: edge.fromSide,
          toSide: edge.toSide,
          fromEnd: edge.fromEnd,
          toEnd: edge.toEnd,
          color: edge.color
        }))
      };
      
      // Serialize to JSON
      const jsonData = JSON.stringify(saveData, null, 2);
      
      // Call parent onSave function
      onSave(jsonData);
      
      // Update status
      setSaveStatus('saved');
    } catch (err) {
      console.error('Error saving canvas:', err);
      setError('Failed to save canvas file.');
      setSaveStatus('error');
    }
  }, [canvasData, selectedFile, onSave]);

  // Auto-save when canvas data changes
  useEffect(() => {
    if (canvasData.nodes.length > 0 || canvasData.edges.length > 0) {
      // Only trigger auto-save if we have content
      const timer = setTimeout(() => {
        handleSaveCanvas();
      }, 1000); // 1 second debounce
      
      return () => clearTimeout(timer);
    }
  }, [canvasData, handleSaveCanvas]);

  // Add a new node to the canvas
  const addNode = (type, text) => {
    // Create a node positioned in the center of the visible area
    const centerX = 100;
    const centerY = 100;
    
    let newNode;
    if (type === 'text') {
      newNode = createTextNode(centerX, centerY, text || 'New note');
    } else {
      // Default to text node
      newNode = createTextNode(centerX, centerY, text || 'New note');
    }
    
    // Add node to canvas data
    setCanvasData(prev => ({
      ...prev,
      nodes: [...prev.nodes, newNode]
    }));
    
    // Reset UI state
    setShowNodeCreator(false);
    setNewNodeText('');
    
    return newNode.id;
  };

  // Create a connection between two nodes
  const createConnection = (sourceId, targetId) => {
    // Find nodes to connect
    const sourceNode = canvasData.nodes.find(n => n.id === sourceId);
    const targetNode = canvasData.nodes.find(n => n.id === targetId);
    
    if (!sourceNode || !targetNode) {
      setError('Could not find one or both nodes to connect.');
      return;
    }
    
    // Create the edge and add it to canvas data
    const newEdge = createEdge(sourceId, targetId);
    
    setCanvasData(prev => ({
      ...prev,
      edges: [...prev.edges, newEdge]
    }));
    
    // Reset UI state
    setShowConnectionCreator(false);
    setConnectionNodes({ source: '', target: '' });
    
    return newEdge.id;
  };

  // Delete selected nodes
  const handleDeleteSelected = (nodeIds) => {
    if (!nodeIds || nodeIds.length === 0) return;
    
    // Remove nodes
    const updatedNodes = canvasData.nodes.filter(node => 
      !nodeIds.includes(node.id)
    );
    
    // Remove edges connected to those nodes
    const updatedEdges = canvasData.edges.filter(edge => 
      !nodeIds.includes(edge.fromNode) && 
      !nodeIds.includes(edge.toNode)
    );
    
    // Update canvas data
    setCanvasData({
      nodes: updatedNodes,
      edges: updatedEdges
    });
  };

  // Handle canvas data changes from CanvasContainer
  const handleCanvasChange = (newData) => {
    setCanvasData(newData);
    setSaveStatus('saving');
  };

  // If the canvas is still loading, show a loading state
  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-full">
        <span className="text-teal-300">Loading canvas editor...</span>
      </div>
    );
  }

  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400 overflow-hidden">
      {/* Toolbar */}
      <div className="p-2 border-b border-stone-700 flex justify-between items-center bg-stone-800">
        <h2 className="text-md font-semibold text-teal-400">{canvasName}</h2>
        
        <div className="flex gap-2">
          <button 
            onClick={handleSaveCanvas}
            className="px-2 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs flex items-center gap-1"
            title="Save canvas"
          >
            <Save size={14} />
            Save
          </button>
          
          <button 
            onClick={() => setShowNodeCreator(true)}
            className="px-2 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs flex items-center gap-1"
            title="Add text node"
          >
            <Type size={14} />
            Add Note
          </button>
          
          <button 
            onClick={() => setShowConnectionCreator(true)}
            className="px-2 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs flex items-center gap-1"
            title="Create connection"
          >
            <ArrowRight size={14} />
            Connect
          </button>
        </div>
      </div>
      
      {/* Error message */}
      {error && (
        <div className="p-2 bg-red-900 text-red-200 text-sm">
          {error}
        </div>
      )}
      
      {/* Node creator dialog */}
      {showNodeCreator && (
        <div className="p-2 border-b border-stone-700 bg-stone-800">
          <div className="flex items-center justify-between mb-1">
            <span className="text-sm font-bold">
              New Text Node
            </span>
            <button
              onClick={() => setShowNodeCreator(false)}
              className="p-1 rounded hover:bg-stone-700 text-stone-400"
            >
              <Trash2 size={14} />
            </button>
          </div>
          
          <div className="flex flex-col gap-2">
            <textarea
              value={newNodeText}
              onChange={(e) => setNewNodeText(e.target.value)}
              placeholder="Enter text content"
              className="w-full bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
              rows={3}
            />
            <div className="flex justify-end">
              <button
                onClick={() => addNode('text', newNodeText)}
                className="px-2 py-1 bg-teal-700 text-teal-100 hover:bg-teal-600 rounded text-xs"
              >
                Create
              </button>
            </div>
          </div>
        </div>
      )}
      
      {/* Connection creator dialog */}
      {showConnectionCreator && (
        <div className="p-2 border-b border-stone-700 bg-stone-800">
          <div className="flex items-center justify-between mb-1">
            <span className="text-sm font-bold">
              Create Connection
            </span>
            <button
              onClick={() => setShowConnectionCreator(false)}
              className="p-1 rounded hover:bg-stone-700 text-stone-400"
            >
              <Trash2 size={14} />
            </button>
          </div>
          
          <div className="flex flex-col gap-2">
            <div className="flex gap-2 items-center">
              <label className="text-xs w-20">From Node:</label>
              <select
                value={connectionNodes.source}
                onChange={(e) => setConnectionNodes(prev => ({ ...prev, source: e.target.value }))}
                className="flex-1 bg-stone-700 text-teal-400 px-2 py-1 rounded text-xs focus:outline-none"
              >
                <option value="">Select source node</option>
                {canvasData.nodes.map(node => (
                  <option key={node.id} value={node.id}>
                    {node.text ? node.text.substring(0, 20) + (node.text.length > 20 ? '...' : '') : node.id}
                  </option>
                ))}
              </select>
            </div>
            
            <div className="flex gap-2 items-center">
              <label className="text-xs w-20">To Node:</label>
              <select
                value={connectionNodes.target}
                onChange={(e) => setConnectionNodes(prev => ({ ...prev, target: e.target.value }))}
                className="flex-1 bg-stone-700 text-teal-400 px-2 py-1 rounded text-xs focus:outline-none"
              >
                <option value="">Select target node</option>
                {canvasData.nodes.map(node => (
                  <option key={node.id} value={node.id}>
                    {node.text ? node.text.substring(0, 20) + (node.text.length > 20 ? '...' : '') : node.id}
                  </option>
                ))}
              </select>
            </div>
            
            <div className="flex justify-end">
              <button
                onClick={() => createConnection(connectionNodes.source, connectionNodes.target)}
                disabled={!connectionNodes.source || !connectionNodes.target}
                className={`px-2 py-1 rounded text-xs ${
                  connectionNodes.source && connectionNodes.target
                    ? 'bg-teal-700 text-teal-100 hover:bg-teal-600'
                    : 'bg-stone-600 text-stone-400 cursor-not-allowed'
                }`}
              >
                Connect
              </button>
            </div>
          </div>
        </div>
      )}
      
      {/* Canvas container */}
      <div className="flex-1 overflow-hidden">
        <CanvasContainer 
          canvasData={canvasData}
          onChange={handleCanvasChange}
          onDeleteSelected={handleDeleteSelected}
        />
      </div>
      
      {/* Status indicator */}
      <div className="px-2 py-1 border-t border-stone-700 bg-stone-800 text-xs flex justify-between">
        <span>
          {canvasData.nodes.length} nodes, {canvasData.edges.length} connections
        </span>
        <span>
          {saveStatus === 'saving' && <span className="text-yellow-400">Saving...</span>}
          {saveStatus === 'saved' && <span className="text-green-400">Saved</span>}
          {saveStatus === 'error' && <span className="text-red-400">Error saving!</span>}
        </span>
      </div>
    </div>
  );
};

export default CanvasEditor;

================
File: src/components/windows/explorer/components/canvas/TextNode.jsx
================
import React, { useState, useRef, useEffect } from 'react';
import { getCanvasColor } from '../../utils/canvasUtils';

/**
 * TextNode component renders an individual text node in the canvas
 */
const TextNode = ({
  node,
  selected,
  onSelect,
  onChange,
  onResize,
  onMove,
  scale,
  isEditing,
  onStartEditing,
  onStopEditing
}) => {
  const [localText, setLocalText] = useState(node.text || '');
  const textareaRef = useRef(null);
  const nodeRef = useRef(null);
  const resizeHandleRef = useRef(null);
  const [isResizing, setIsResizing] = useState(false);
  const [initialSize, setInitialSize] = useState({ width: 0, height: 0 });
  const [initialPosition, setInitialPosition] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });

  // Update local text when node text changes
  useEffect(() => {
    setLocalText(node.text || '');
  }, [node.text]);

  // Focus the textarea when editing starts
  useEffect(() => {
    if (isEditing && textareaRef.current) {
      textareaRef.current.focus();
    }
  }, [isEditing]);

  // Handle mouse down for node selection and drag start
  const handleMouseDown = (e) => {
    e.stopPropagation();
    
    // Select this node
    onSelect(node.id);
    
    // If not already editing, prepare for dragging
    if (!isEditing) {
      setIsDragging(true);
      setInitialPosition({ x: node.x, y: node.y });
      setDragOffset({
        x: e.clientX / scale - node.x,
        y: e.clientY / scale - node.y
      });
    }
  };

  // Handle mouse down on resize handle
  const handleResizeMouseDown = (e) => {
    e.stopPropagation();
    
    // Start resizing
    setIsResizing(true);
    setInitialSize({ width: node.width, height: node.height });
    setInitialPosition({ x: e.clientX, y: e.clientY });
  };

  // Handle text change
  const handleTextChange = (e) => {
    const newText = e.target.value;
    setLocalText(newText);
    onChange(node.id, newText);
  };

  // Handle double click to start editing
  const handleDoubleClick = (e) => {
    e.stopPropagation();
    
    // Start editing
    if (!isEditing) {
      onStartEditing(node.id);
    }
  };

  // Handle blur to stop editing
  const handleBlur = () => {
    if (isEditing) {
      onStopEditing();
    }
  };

  // Get the background color
  const bgColor = getCanvasColor(node.color) || '#1e293b';
  const borderColor = selected ? '#14b8a6' : '#334155';

  return (
    <div
      ref={nodeRef}
      className="absolute select-none"
      style={{
        left: node.x,
        top: node.y,
        width: node.width,
        height: node.height,
        transform: `scale(${scale})`,
        transformOrigin: 'top left',
        zIndex: selected ? 10 : 1
      }}
      onMouseDown={handleMouseDown}
      onDoubleClick={handleDoubleClick}
    >
      <div
        className="w-full h-full rounded-md overflow-hidden flex flex-col"
        style={{
          backgroundColor: bgColor,
          border: `2px solid ${borderColor}`,
          boxShadow: selected ? '0 0 0 2px rgba(20, 184, 166, 0.5)' : 'none'
        }}
      >
        {isEditing ? (
          <textarea
            ref={textareaRef}
            className="w-full h-full p-2 bg-transparent text-white resize-none focus:outline-none"
            value={localText}
            onChange={handleTextChange}
            onBlur={handleBlur}
          />
        ) : (
          <div className="w-full h-full p-2 text-white overflow-auto whitespace-pre-wrap">
            {localText}
          </div>
        )}
        
        {/* Resize handle - only show when selected */}
        {selected && (
          <div
            ref={resizeHandleRef}
            className="absolute bottom-0 right-0 w-4 h-4 bg-teal-500 rounded-tl-md cursor-nwse-resize"
            onMouseDown={handleResizeMouseDown}
          />
        )}
      </div>
    </div>
  );
};

export default TextNode;

================
File: src/components/windows/explorer/components/CanvasEditor.jsx
================
import React, { useState, useEffect, useRef, useCallback } from 'react';
import ReactFlow, {
  Background,
  Controls,
  MiniMap,
  useNodesState,
  useEdgesState,
  addEdge,
  Panel
} from 'reactflow';
import 'reactflow/dist/style.css';
import { 
  Plus, 
  Save, 
  FileText, 
  Trash2, 
  Type,
  Square,
  Link as LinkIcon,
  Edit,
} from 'lucide-react';

// Import node types from the node registry
import nodeTypes from './nodes';

/**
 * Canvas Editor component for use within the FileContent area
 * This component handles the editing of .canvas files in the file explorer
 */
const CanvasEditor = ({ fileContent, selectedFile, onSave }) => {
  const [canvasName, setCanvasName] = useState('Untitled Canvas');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [saveStatus, setSaveStatus] = useState('saved'); // 'saved', 'saving', 'error'
  
  // ReactFlow states
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const [reactFlowInstance, setReactFlowInstance] = useState(null);
  
  // UI states
  const [selectedElements, setSelectedElements] = useState([]);
  const [showNodeCreator, setShowNodeCreator] = useState(false);
  const [newNodeType, setNewNodeType] = useState('text');
  const [newNodeText, setNewNodeText] = useState('');
  const [editingNode, setEditingNode] = useState(null);
  
  // For auto-save functionality
  const saveTimeoutRef = useRef(null);
  
  // Setup custom node types with required props
  const customNodeTypes = {};
  
  // Add the TextNode and pass required props
  customNodeTypes.text = (props) => {
    // Create a handler for text updates
    const handleNodeTextChange = (nodeId, newText) => {
      setNodes((nds) => 
        nds.map((node) => {
          if (node.id === nodeId) {
            return {
              ...node,
              data: {
                ...node.data,
                text: newText
              }
            };
          }
          return node;
        })
      );
    };
    
    // Add the onChange handler to node data
    const nodeWithHandlers = {
      ...props,
      data: {
        ...props.data,
        onChange: handleNodeTextChange
      },
      editingNode: editingNode,
      setEditingNode: setEditingNode
    };
    
    // Use the TextNode component from the registry
    return React.createElement(nodeTypes.text, nodeWithHandlers);
  };
  
  // Load canvas data when fileContent changes
  useEffect(() => {
    try {
      if (fileContent) {
        setIsLoading(true);
        
        // Parse the JSON canvas file
        const canvasData = JSON.parse(fileContent);
        
        if (canvasData.nodes && canvasData.edges) {
          // Transform nodes from JSONCanvas format to ReactFlow format
          const transformedNodes = canvasData.nodes.map(node => {
            // Check if node has position as an object or direct x/y properties
            const nodeX = node.position?.x !== undefined ? node.position.x : (node.x || 0);
            const nodeY = node.position?.y !== undefined ? node.position.y : (node.y || 0);
            
            return {
              id: node.id,
              type: node.type,
              // For ReactFlow, use position property
              position: {
                x: nodeX,
                y: nodeY
              },
              // Preserve data, or create default data object with text if not present
              data: node.data || { text: node.text || "Text node" }
            };
          });
          
          console.log('[DEBUG] Transformed nodes:', transformedNodes.length);
          setNodes(transformedNodes);
          setEdges(canvasData.edges);
          
          // Extract canvas name from file path or use from canvas data
          if (canvasData.name) {
            setCanvasName(canvasData.name);
          } else if (selectedFile) {
            const pathParts = selectedFile.path.split('/');
            const fileName = pathParts[pathParts.length - 1];
            setCanvasName(fileName.replace('.canvas', ''));
          }
          
          setSaveStatus('saved');
        } else {
          // Create a new canvas if the structure is invalid
          createNewCanvas();
        }
        
        setIsLoading(false);
        setError(null);
      } else {
        // Create a new canvas if no content
        createNewCanvas();
      }
    } catch (err) {
      console.error('Error parsing canvas file:', err);
      setError('Failed to parse canvas file. Creating a new canvas.');
      createNewCanvas();
      setIsLoading(false);
    }
  }, [fileContent, selectedFile]);
  
  // Auto-save when node/edge data changes
  useEffect(() => {
    if (nodes.length > 0 || edges.length > 0) {
      // Only start auto-save if we have actual content
      
      // Clear any existing timeout
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
      
      // Set save status to 'saving'
      setSaveStatus('saving');
      
      // Set a new timeout for auto-save
      saveTimeoutRef.current = setTimeout(() => {
        handleSaveCanvas();
      }, 1000); // 1 second debounce
    }
    
    // Cleanup function to clear the timeout when component unmounts
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, [nodes, edges]);
  
  // Create a new canvas
  const createNewCanvas = () => {
    setNodes([]);
    setEdges([]);
    
    // Set canvas name from file if available
    if (selectedFile) {
      const pathParts = selectedFile.path.split('/');
      const fileName = pathParts[pathParts.length - 1];
      setCanvasName(fileName.replace('.canvas', ''));
    } else {
      setCanvasName('Untitled Canvas');
    }
    
    setSaveStatus('saved');
  };
  
  // Save canvas to file
  const handleSaveCanvas = () => {
    if (!selectedFile) return;
    
    try {
      // Transform nodes from ReactFlow format back to JSONCanvas format
      const transformedNodes = nodes.map(node => {
        // Extract position from ReactFlow format
        const nodePosition = node.position || { x: 0, y: 0 };
        
        return {
          id: node.id,
          type: node.type,
          // Store position in a position object for compatibility with JSONCanvas format
          position: {
            x: nodePosition.x,
            y: nodePosition.y
          },
          // Preserve the data object
          data: node.data
        };
      });
      
      // Create canvas data structure
      const canvasData = {
        name: canvasName,
        nodes: transformedNodes,
        edges,
        version: "1.0",
        metadata: {
          created: new Date().toISOString(),
          modified: new Date().toISOString()
        }
      };
      
      // Debug logs to track the data flow
      console.log('[DEBUG] Canvas Editor - Saving canvas data:', {
        nodesLength: transformedNodes.length,
        edgesLength: edges.length,
        selectedFile: selectedFile?.path
      });
      
      // Set status to saving
      setSaveStatus('saving');
      
      // Serialize to JSON string
      const canvasContent = JSON.stringify(canvasData, null, 2);
      
      // Call the parent onSave function
      onSave(canvasContent);
      
      // Update state
      setSaveStatus('saved');
      setError(null);
    } catch (err) {
      console.error('Error saving canvas:', err);
      setError('Failed to save canvas file.');
      setSaveStatus('error');
    }
  };
  
  // Handle connection (edge) creation
  const onConnect = useCallback((params) => {
    // Create a custom edge with styling and ID
    setEdges((eds) => addEdge({
      ...params,
      id: `edge-${Date.now()}`,
      type: 'default',
      animated: false,
      style: { stroke: '#14b8a6' }
    }, eds));
  }, [setEdges]);
  
  // Handle node selection
  const onSelectionChange = useCallback(({ nodes, edges }) => {
    setSelectedElements([...nodes, ...edges]);
  }, []);
  
  // Handle drag over for node creation
  const onDragOver = useCallback((event) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);
  
  // Handle drop for node creation
  const onDrop = useCallback(
    (event) => {
      event.preventDefault();
      
      const type = event.dataTransfer.getData('application/reactflow/type');
      if (!type || !reactFlowInstance) return;
      
      const position = reactFlowInstance.screenToFlowPosition({
        x: event.clientX,
        y: event.clientY,
      });
      
      const newNode = {
        id: `node-${Date.now()}`,
        type,
        position,
        data: { text: 'New text node' },
      };
      
      setNodes((nds) => nds.concat(newNode));
    },
    [reactFlowInstance, setNodes]
  );
  
  // Create a new node
  const createNode = (type) => {
    if (!reactFlowInstance) return;
    
    // If we have a viewport, center the node in the visible area
    const position = reactFlowInstance.project({
      x: window.innerWidth / 2,
      y: window.innerHeight / 2
    });
    
    const newNode = {
      id: `node-${Date.now()}`,
      type,
      position,
      data: { text: newNodeText || 'New text node' }
    };
    
    // Add the node and immediately set it to edit mode
    setNodes((nds) => {
      const updatedNodes = nds.concat(newNode);
      setTimeout(() => {
        setEditingNode(newNode.id);
      }, 100);
      return updatedNodes;
    });
    
    setShowNodeCreator(false);
    setNewNodeText('');
  };
  
  // Delete selected elements
  const deleteSelected = () => {
    const selectedNodeIds = selectedElements
      .filter(el => el.type !== 'default')
      .map(el => el.id);
    
    const selectedEdgeIds = selectedElements
      .filter(el => el.type === 'default')
      .map(el => el.id);
    
    setNodes(nodes.filter(node => !selectedNodeIds.includes(node.id)));
    setEdges(edges.filter(edge => !selectedEdgeIds.includes(edge.id)));
    setSelectedElements([]);
  };
  
  // If canvas data isn't loaded yet, show a loading state
  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-full">
        <span className="text-teal-300">Loading canvas editor...</span>
      </div>
    );
  }
  
  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400 overflow-hidden">
      {/* Toolbar */}
      <div className="p-2 border-b border-stone-700 flex justify-between items-center bg-stone-800">
        <h2 className="text-md font-semibold text-teal-400">{canvasName}</h2>
        
        <div className="flex gap-2">
          <button 
            onClick={handleSaveCanvas}
            className="px-2 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs flex items-center gap-1"
            title="Save canvas"
          >
            <Save size={14} />
            Save
          </button>
          
          <button 
            onClick={() => {
              setNewNodeType('text');
              setShowNodeCreator(true);
            }}
            className="px-2 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs flex items-center gap-1"
            title="Add text node"
          >
            <Type size={14} />
            Add Node
          </button>
          
          {/* Edit button - appears when a node is selected */}
          {selectedElements.length === 1 && selectedElements[0].type === 'text' && (
            <button 
              onClick={() => setEditingNode(selectedElements[0].id)}
              className="px-2 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs flex items-center gap-1"
              title="Edit selected node"
            >
              <Edit size={14} />
              Edit
            </button>
          )}
          
          {selectedElements.length > 0 && (
            <button 
              onClick={deleteSelected}
              className="px-2 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs flex items-center gap-1"
              title="Delete selected"
            >
              <Trash2 size={14} />
              Delete
            </button>
          )}
        </div>
      </div>
      
      {/* Error message */}
      {error && (
        <div className="p-2 bg-red-900 text-red-200 text-sm">
          {error}
        </div>
      )}
      
      {/* Node creator dialog */}
      {showNodeCreator && (
        <div className="p-2 border-b border-stone-700 bg-stone-800">
          <div className="flex items-center justify-between mb-1">
            <span className="text-sm font-bold">
              New Text Node
            </span>
            <button
              onClick={() => setShowNodeCreator(false)}
              className="p-1 rounded hover:bg-stone-700 text-stone-400"
            >
              <Trash2 size={14} />
            </button>
          </div>
          
          <div className="flex flex-col gap-2">
            <textarea
              value={newNodeText}
              onChange={(e) => setNewNodeText(e.target.value)}
              placeholder="Enter text content"
              className="w-full bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
              rows={3}
            />
            <div className="flex justify-end">
              <button
                onClick={() => createNode('text')}
                className="px-2 py-1 bg-teal-700 text-teal-100 hover:bg-teal-600 rounded text-xs"
              >
                Create
              </button>
            </div>
          </div>
        </div>
      )}
      
      {/* Canvas area */}
      <div className="flex-1 overflow-hidden">
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          connectionMode="loose"
          onConnect={onConnect}
          onInit={setReactFlowInstance}
          onDrop={onDrop}
          onDragOver={onDragOver}
          onSelectionChange={onSelectionChange}
          nodeTypes={customNodeTypes}
          fitView
          snapToGrid
          snapGrid={[15, 15]}
          defaultViewport={{ x: 0, y: 0, zoom: 1 }}
          minZoom={0.1}
          maxZoom={4}
          deleteKeyCode="Delete"
          multiSelectionKeyCode="Control"
          selectionKeyCode="Shift"
        >
          {/* Empty canvas help message */}
          {nodes.length === 0 && (
            <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
              <div className="bg-stone-800 bg-opacity-80 p-6 rounded-lg shadow-lg text-center max-w-md">
                <Type size={40} className="mx-auto mb-4 text-teal-500" />
                <h3 className="text-xl text-teal-400 mb-2 font-semibold">Canvas Editor</h3>
                <p className="text-stone-300 mb-4">
                  This is your canvas workspace. Create notes and connect them with arrows.
                </p>
                <ul className="text-left text-stone-300 space-y-2 mb-4">
                  <li> Click "Add Node" to create a new text node</li>
                  <li> Hover over a node and click the edit button to edit content</li>
                  <li> Drag from a node's connection handle (teal dot) to another node to create a connection</li>
                  <li> Select nodes and press Delete or use the Delete button</li>
                </ul>
                <p className="text-stone-400 text-sm">
                  See canvas-editor-documentation.md for more details
                </p>
              </div>
            </div>
          )}
          <Background color="#44403c" gap={16} />
          <Controls showInteractive={false} />
          <MiniMap
            nodeColor={(node) => '#14b8a6'}
            maskColor="rgba(0, 0, 0, 0.5)"
            style={{ backgroundColor: '#292524' }}
          />
          
          <Panel position="top-left" className="bg-stone-800 p-2 rounded shadow-md">
            <div className="flex flex-col gap-1">
              <div className="text-xs text-stone-400">Drag to create:</div>
              <div 
                className="flex items-center gap-1 p-1 bg-stone-700 rounded cursor-grab"
                draggable
                onDragStart={(event) => {
                  event.dataTransfer.setData('application/reactflow/type', 'text');
                  event.dataTransfer.effectAllowed = 'move';
                }}
              >
                <Type size={14} />
                <span className="text-xs">Text Node</span>
              </div>
            </div>
          </Panel>
        </ReactFlow>
      </div>
    </div>
  );
};

export default CanvasEditor;

================
File: src/components/windows/explorer/components/CommandInput.jsx
================
import React from 'react';

const CommandInput = ({ focusRef, isAdmin, handleCommand }) => {
  // Handle command input
  const onKeyDown = (e) => {
    if (e.key === 'Enter' && e.target.value.trim()) {
      const cmd = e.target.value.trim();
      handleCommand(cmd);
      e.target.value = '';
    }
  };

  return (
    <div className="p-2 flex items-center gap-2 border-t border-stone-700">
      <span className="text-teal-400">$</span>
      <input
        ref={focusRef}
        type="text"
        onKeyDown={onKeyDown}
        className="flex-1 bg-stone-800 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
      />
    </div>
  );
};

export default CommandInput;

================
File: src/components/windows/explorer/components/dialogs/FileDialogs.jsx
================
import React, { useRef, useEffect } from 'react';
import { X } from 'lucide-react';

// Dialog for creating a new file or folder
export const CreateFileDialog = ({
  showCreateDialog,
  createType,
  newItemName,
  setNewItemName,
  isCreating,
  errorMessage,
  closeCreateDialog,
  createNewItem
}) => {
  const createInputRef = useRef(null);
  
  // Focus the input field when the dialog is shown
  useEffect(() => {
    if (showCreateDialog && createInputRef.current) {
      createInputRef.current.focus();
    }
  }, [showCreateDialog]);
  
  // Handle key press in the create dialog
  const handleCreateKeyPress = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      createNewItem();
    } else if (e.key === 'Escape') {
      closeCreateDialog();
    }
  };
  
  if (!showCreateDialog) return null;
  
  return (
    <div className="p-2 border-t border-stone-700 bg-stone-800">
      <div className="flex items-center justify-between mb-1">
        <span className="text-sm font-bold">
          {createType === 'file' ? 'New File' : 'New Folder'}
        </span>
        <button
          onClick={closeCreateDialog}
          className="p-1 rounded hover:bg-stone-700 text-stone-400"
        >
          <X size={14} />
        </button>
      </div>
      <div className="flex gap-2">
        <input
          ref={createInputRef}
          type="text"
          value={newItemName}
          onChange={(e) => setNewItemName(e.target.value)}
          onKeyDown={handleCreateKeyPress}
          placeholder={createType === 'file' ? 'filename.ext' : 'folder name'}
          className="flex-1 bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
          disabled={isCreating}
        />
        <button
          onClick={createNewItem}
          disabled={isCreating || !newItemName.trim()}
          className={`px-2 py-1 rounded text-xs ${
            isCreating || !newItemName.trim()
              ? 'bg-stone-700 text-stone-500 cursor-not-allowed'
              : 'bg-teal-700 text-teal-100 hover:bg-teal-600'
          }`}
        >
          {isCreating ? 'Creating...' : 'Create'}
        </button>
      </div>
    </div>
  );
};

// Dialog for renaming a file or folder
export const RenameDialog = ({
  showRenameDialog,
  itemToRename,
  newName,
  setNewName,
  isRenaming,
  errorMessage,
  closeRenameDialog,
  renameItem
}) => {
  const renameInputRef = useRef(null);
  
  // Focus the input field when the dialog is shown
  useEffect(() => {
    if (showRenameDialog && renameInputRef.current) {
      renameInputRef.current.focus();
    }
  }, [showRenameDialog]);
  
  // Handle key press in the rename dialog
  const handleRenameKeyPress = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      renameItem();
    } else if (e.key === 'Escape') {
      closeRenameDialog();
    }
  };
  
  if (!showRenameDialog || !itemToRename) return null;
  
  return (
    <div className="p-2 border-t border-stone-700 bg-stone-800">
      <div className="flex items-center justify-between mb-1">
        <span className="text-sm font-bold">
          Rename {itemToRename.type === 'directory' ? 'Folder' : 'File'}
        </span>
        <button
          onClick={closeRenameDialog}
          className="p-1 rounded hover:bg-stone-700 text-stone-400"
        >
          <X size={14} />
        </button>
      </div>
      <div className="flex gap-2">
        <input
          ref={renameInputRef}
          type="text"
          value={newName}
          onChange={(e) => setNewName(e.target.value)}
          onKeyDown={handleRenameKeyPress}
          placeholder="New name"
          className="flex-1 bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
          disabled={isRenaming}
        />
        <button
          onClick={renameItem}
          disabled={isRenaming || !newName.trim() || newName === itemToRename.name}
          className={`px-2 py-1 rounded text-xs ${
            isRenaming || !newName.trim() || newName === itemToRename.name
              ? 'bg-stone-700 text-stone-500 cursor-not-allowed'
              : 'bg-teal-700 text-teal-100 hover:bg-teal-600'
          }`}
        >
          {isRenaming ? 'Renaming...' : 'Rename'}
        </button>
      </div>
    </div>
  );
};

// Dialog for deleting a file or folder
export const DeleteDialog = ({
  showDeleteDialog,
  itemToDelete,
  isDeleting,
  errorMessage,
  closeDeleteDialog,
  handleDeleteItem
}) => {
  if (!showDeleteDialog || !itemToDelete) return null;
  
  return (
    <div className="p-2 border-t border-stone-700 bg-stone-800">
      <div className="flex items-center justify-between mb-1">
        <span className="text-sm font-bold">
          Delete {itemToDelete.type === 'directory' ? 'Folder' : 'File'}
        </span>
        <button
          onClick={closeDeleteDialog}
          className="p-1 rounded hover:bg-stone-700 text-stone-400"
        >
          <X size={14} />
        </button>
      </div>
      <div className="mb-2 text-sm">
        <p>Are you sure you want to delete <span className="text-red-400 font-bold">{itemToDelete.name}</span>?</p>
        {itemToDelete.type === 'directory' && (
          <p className="text-red-400 text-xs mt-1">This will delete all files and folders inside it!</p>
        )}
      </div>
      <div className="flex gap-2 justify-end">
        <button
          onClick={closeDeleteDialog}
          className="px-2 py-1 rounded text-xs bg-stone-700 hover:bg-stone-600"
        >
          Cancel
        </button>
        <button
          onClick={handleDeleteItem}
          disabled={isDeleting}
          className={`px-2 py-1 rounded text-xs ${
            isDeleting
              ? 'bg-red-900 text-red-300 cursor-not-allowed'
              : 'bg-red-700 text-red-100 hover:bg-red-600'
          }`}
        >
          {isDeleting ? 'Deleting...' : 'Delete'}
        </button>
      </div>
    </div>
  );
};

================
File: src/components/windows/explorer/components/FileContent.jsx
================
import React, { useRef, useEffect } from 'react';
import { FileText, Edit, Eye, Bold, Italic, Code as CodeIcon, Link, Heading, List, ListOrdered, CheckSquare, Download, Map } from 'lucide-react';
import { handleEditorKeyDown, convertMarkdownToHtml } from '../utils/markdownUtils';
import MapEditor from './MapEditor';
import CanvasEditor from './CanvasEditor';

const FileContent = ({
  selectedFile,
  isContentLoading,
  fileContent,
  errorMessage,
  showPreview,
  editMode,
  saveStatus,
  converter,
  isAdmin,
  user,
  activeTab,
  setFileContent,
  toggleEditMode,
  handleMarkdownChange,
  handleSaveFileContent,
  handleExportFile
}) => {
  // Debug logging
  console.log('[DEBUG] FileContent rendered with props:', {
    selectedFile,
    isContentLoading,
    fileContentLength: fileContent?.length || 0,
    hasContent: !!fileContent,
    showPreview,
    editMode,
    saveStatus
  });

  // Add an effect to log when file content changes
  useEffect(() => {
    console.log('[DEBUG] FileContent - fileContent changed:', {
      length: fileContent?.length || 0,
      preview: fileContent?.substring(0, 50),
      hasContent: !!fileContent
    });
  }, [fileContent]);

  // Add an effect to log when selected file changes
  useEffect(() => {
    console.log('[DEBUG] FileContent - selectedFile changed:', selectedFile);
  }, [selectedFile]);
  
  // Add debugging for save file content function
  const wrappedHandleSaveFileContent = (content) => {
    console.log('[DEBUG] FileContent - handleSaveFileContent called with:', {
      contentType: typeof content,
      contentLength: content?.length || 0,
      contentPreview: typeof content === 'string' ? content.substring(0, 100) + '...' : 'not a string',
      selectedFilePath: selectedFile?.path,
      selectedFileName: selectedFile?.name
    });
    
    // Call the original function
    handleSaveFileContent(content);
  };

  const textareaRef = useRef(null);

  // Insert markdown syntax at cursor position
  const insertMarkdown = (prefix, suffix = '') => {
    const textarea = textareaRef.current;
    if (!textarea) return;
    
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const text = fileContent;
    
    // If text is selected, wrap it with prefix and suffix
    if (start !== end) {
      const selectedText = text.substring(start, end);
      const newContent = text.substring(0, start) + prefix + selectedText + suffix + text.substring(end);
      setFileContent(newContent);
      
      // Set cursor position after the inserted text
      setTimeout(() => {
        textarea.selectionStart = start + prefix.length;
        textarea.selectionEnd = end + prefix.length;
        textarea.focus();
      }, 0);
    } else {
      // No selection, just insert at cursor
      const newContent = text.substring(0, start) + prefix + suffix + text.substring(start);
      setFileContent(newContent);
      
      // Move cursor between prefix and suffix
      setTimeout(() => {
        textarea.selectionStart = textarea.selectionEnd = start + prefix.length;
        textarea.focus();
      }, 0);
    }
  };

  // Insert list items
  const insertList = (listPrefix) => {
    const textarea = textareaRef.current;
    if (!textarea) return;
    
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const text = fileContent;
    
    // If text is selected, apply list formatting to each line
    if (start !== end) {
      const selectedText = text.substring(start, end);
      const lines = selectedText.split('\n');
      
      // Format each line as a list item
      const formattedLines = lines.map(line => {
        // Skip empty lines
        if (line.trim() === '') return line;
        
        // For numbered lists, increment the number for each line
        if (listPrefix === '1. ') {
          const index = lines.indexOf(line) + 1;
          return `${index}. ${line}`;
        }
        
        return `${listPrefix}${line}`;
      });
      
      const newContent = text.substring(0, start) + formattedLines.join('\n') + text.substring(end);
      setFileContent(newContent);
      
      // Set cursor position after the inserted text
      setTimeout(() => {
        textarea.selectionStart = start;
        textarea.selectionEnd = start + formattedLines.join('\n').length;
        textarea.focus();
      }, 0);
    } else {
      // No selection, just insert at cursor
      const newContent = text.substring(0, start) + listPrefix + text.substring(start);
      setFileContent(newContent);
      
      // Move cursor after the inserted prefix
      setTimeout(() => {
        textarea.selectionStart = textarea.selectionEnd = start + listPrefix.length;
        textarea.focus();
      }, 0);
    }
  };

  // Handle editor keyboard events
  const onEditorKeyDown = (e) => {
    handleEditorKeyDown(e, textareaRef, fileContent, setFileContent);
  };

  return (
    <div className="flex-1 flex flex-col overflow-hidden">
      {selectedFile ? (
        <>
          {/* Header with file name, status, and controls */}
          <div className="p-2 border-b border-stone-700 font-mono text-sm flex items-center justify-between">
            <div className="flex items-center">
              <span className="mr-2">{selectedFile.name}</span>
              {saveStatus === 'saving' && <span className="text-yellow-400 text-xs ml-2">Saving...</span>}
              {saveStatus === 'saved' && <span className="text-green-400 text-xs ml-2">Saved</span>}
              {saveStatus === 'error' && <span className="text-red-400 text-xs ml-2">Error!</span>}
            </div>
            
            <div className="flex gap-2">
              {/* Export button - available for all file types */}
              <button 
                onClick={handleExportFile}
                className="px-2 py-1 bg-stone-800 hover:bg-stone-700 rounded text-xs flex items-center gap-1"
                title="Export file"
              >
                <Download size={14} />
                Export
              </button>
              
              {/* Show edit/preview toggle for markdown files to admins or users with file access (for private files) */}
              {selectedFile.name.endsWith('.md') && (isAdmin || (user && user.has_file_access && activeTab === 'private')) && (
                <>
                  {editMode && (
                    <button 
                      onClick={handleSaveFileContent}
                      className="px-2 py-1 bg-stone-800 hover:bg-stone-700 rounded text-xs"
                      title="Save file"
                    >
                      Save
                    </button>
                  )}
                  <button 
                    onClick={toggleEditMode}
                    className={`px-2 py-1 rounded text-xs flex items-center gap-1 ${editMode ? 'bg-teal-700 text-teal-100' : 'bg-stone-800 hover:bg-stone-700'}`}
                    title={editMode ? "Switch to preview mode" : "Switch to edit mode"}
                  >
                    {editMode ? <Eye size={14} /> : <Edit size={14} />}
                    {editMode ? 'Preview' : 'Edit'}
                  </button>
                </>
              )}
            </div>
          </div>
          
          {/* Error message */}
          {errorMessage && (
            <div className="p-2 bg-red-900 text-red-200 text-sm">
              {errorMessage}
            </div>
          )}
          
          {/* Content area - editor or preview based on file type */}
          {isContentLoading ? (
            <div className="flex-1 flex items-center justify-center">
              <span className="text-teal-300">Loading content...</span>
            </div>
          ) : selectedFile.name.endsWith('.canvas') && (isAdmin || (user && user.has_file_access && activeTab === 'private')) ? (
            // Canvas Editor for .canvas files - only for admin users and users with file access
            <CanvasEditor
              fileContent={fileContent}
              selectedFile={selectedFile}
              onSave={wrappedHandleSaveFileContent}
            />
          ) : selectedFile.name.endsWith('.map') && (isAdmin || (user && user.has_file_access && activeTab === 'private')) ? (
            // Map Editor for .map files - only for admin users and users with file access
            <MapEditor 
              fileContent={fileContent}
              selectedFile={selectedFile}
              onSave={wrappedHandleSaveFileContent}
            />
          ) : editMode && selectedFile.name.endsWith('.md') && (isAdmin || (user && user.has_file_access && activeTab === 'private')) ? (
            // Markdown Editor mode - only for markdown files and admin users
            <div className="flex-1 flex flex-col">
              {/* Markdown toolbar */}
              <div className="p-2 border-b border-stone-700 bg-stone-800 flex flex-wrap gap-2">
                <button 
                  onClick={() => insertMarkdown('### ')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Heading"
                >
                  <Heading size={16} />
                </button>
                <button 
                  onClick={() => insertMarkdown('**', '**')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Bold"
                >
                  <Bold size={16} />
                </button>
                <button 
                  onClick={() => insertMarkdown('*', '*')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Italic"
                >
                  <Italic size={16} />
                </button>
                <button 
                  onClick={() => insertMarkdown('`', '`')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Inline Code"
                >
                  <CodeIcon size={16} />
                </button>
                <button 
                  onClick={() => insertMarkdown('[', '](url)')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Link"
                >
                  <Link size={16} />
                </button>
                <span className="border-r border-stone-700 h-6"></span>
                <button 
                  onClick={() => insertList('- ')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Bullet List"
                >
                  <List size={16} />
                </button>
                <button 
                  onClick={() => insertList('1. ')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Numbered List"
                >
                  <ListOrdered size={16} />
                </button>
                <button 
                  onClick={() => insertList('- [ ] ')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Checklist"
                >
                  <CheckSquare size={16} />
                </button>
              </div>
              
              <div className="flex-1 p-2">
                <textarea
                  ref={textareaRef}
                  className="w-full h-full bg-stone-800 text-teal-50 p-4 resize-none focus:outline-none font-mono"
                  value={fileContent}
                  onChange={handleMarkdownChange}
                  onKeyDown={onEditorKeyDown}
                  placeholder="# Start typing your markdown here..."
                />
              </div>
            </div>
          ) : (
            // Preview mode
            <div className="flex-1 overflow-auto p-4">
              <div className="markdown-preview text-teal-50">
                {selectedFile.name.endsWith('.md') ? (
                  <div 
                    dangerouslySetInnerHTML={{ 
                      __html: convertMarkdownToHtml(converter, fileContent) 
                    }} 
                    className="markdown-content"
                  />
                ) : (
                  <pre className="font-mono text-sm whitespace-pre-wrap">
                    {fileContent}
                  </pre>
                )}
              </div>
            </div>
          )}
        </>
      ) : (
        // No file selected
        <div className="flex items-center justify-center h-full text-stone-600">
          <div className="text-center">
            <FileText size={48} className="mx-auto mb-4" />
            <p>Select a file to view</p>
            <p className="text-xs mt-2">All file types are supported for viewing</p>
            {isAdmin && (
              <p className="text-xs mt-1">
                Admin users can edit markdown (.md), map (.map), and canvas (.canvas) files
              </p>
            )}
            {!isAdmin && user && user.has_file_access && (
              <p className="text-xs mt-1">
                Users with file access can edit markdown (.md), map (.map), and canvas (.canvas) files in the Private section
              </p>
            )}
          </div>
        </div>
      )}
    </div>
  );
};

export default FileContent;

================
File: src/components/windows/explorer/components/FileTree.jsx
================
import React from 'react';
import { 
  FolderOpen, ChevronRight, ChevronDown, File, Coffee, Code, 
  BookOpen, FileText, Globe, Lock, FileEdit, Trash2, Music, Image, Figma,
  FolderPlus, Plus, Map
} from 'lucide-react';
import { getFileIconName } from '../utils/fileUtils';
import StorageStats from './StorageStats';
import { CreateFileDialog, RenameDialog, DeleteDialog } from './dialogs/FileDialogs';

const FileTree = ({ 
  files, 
  publicFiles, 
  activeTab,
  expandedFolders,
  currentPath,
  selectedFile,
  isTreeLoading,
  errorMessage,
  isAdmin,
  user,
  toggleFolder,
  handleFileSelect,
  openRenameDialog,
  openDeleteDialog,
  openCreateDialog,
  handleDragStart,
  handleDragOver,
  handleDragLeave,
  handleDrop,
  handleContainerDragOver,
  handleContainerDragLeave,
  handleContainerDrop,
  dropTarget,
  storageStats,
  // Dialog-related props
  showCreateDialog,
  createType,
  newItemName,
  setNewItemName,
  isCreating,
  closeCreateDialog,
  createNewItem,
  showRenameDialog,
  itemToRename,
  newName,
  setNewName,
  isRenaming,
  closeRenameDialog,
  renameItem,
  showDeleteDialog,
  itemToDelete,
  isDeleting,
  closeDeleteDialog,
  handleDeleteItem
}) => {
  
  // Get file icon based on file extension
  const getFileIcon = (fileName) => {
    const iconName = getFileIconName(fileName);
    const iconProps = { size: 16, className: "mr-2" };
    
    switch (iconName) {
      case 'FileText': return <FileText {...iconProps} />;
      case 'Code': return <Code {...iconProps} />;
      case 'Coffee': return <Coffee {...iconProps} />;
      case 'BookOpen': return <BookOpen {...iconProps} />;
      case 'Globe': return <Globe {...iconProps} />;
      case 'Music': return <Music {...iconProps} />;
      case 'Image': return <Image {...iconProps} />;
      case 'Figma': return <Figma {...iconProps} />;
      case 'Map': return <Map {...iconProps} />;
      default: return <File {...iconProps} />;
    }
  };
  
  // Render the file tree recursively
  const renderFileTree = (items) => {
    // Keep track of the path to the currently selected file to highlight its parent folder
    const selectedFilePath = selectedFile?.path || '';
    const selectedFileParentPath = selectedFile && selectedFile.type !== 'directory' ? 
      selectedFilePath.substring(0, selectedFilePath.lastIndexOf('/')) || '/' : '';
    
    return items.map(item => {
      if (item.type === 'directory') {
        const isExpanded = expandedFolders[item.path];
        // A folder is considered active if it's the current path OR if it's the parent of the selected file
        const isActive = currentPath === item.path || (selectedFileParentPath === item.path);
        return (
          <div key={item.path} className="ml-2">
            <div 
              className={`flex items-center justify-between py-1 px-1 rounded hover:bg-stone-700 cursor-pointer group ${
                isActive ? 'bg-stone-800 text-teal-300 font-bold' : 
                isExpanded ? 'text-teal-300' : 'text-teal-400'
              } ${dropTarget && dropTarget.path === item.path ? 'bg-teal-900 border border-teal-500' : ''}`}
              onClick={() => toggleFolder(item.path, item)}
              draggable={isAdmin || (user?.has_file_access && activeTab === 'private')}
              onDragStart={(e) => handleDragStart(e, item)}
              onDragOver={(e) => handleDragOver(e, item)}
              onDragLeave={(e) => handleDragLeave(e)}
              onDrop={(e) => handleDrop(e, item)}
            >
              <div className="flex items-center">
                {isExpanded ? <ChevronDown size={14} /> : <ChevronRight size={14} />}
                <FolderOpen size={16} className="ml-1 mr-2" />
                <span className="text-sm">{item.name}</span>
              </div>
              
              {/* File operation buttons */}
            {(isAdmin || (user && user.has_file_access && activeTab === 'private')) && (
                <div className="flex">
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      openRenameDialog(item);
                    }}
                    className="p-1 rounded hover:bg-stone-600 text-stone-400 hover:text-teal-300 opacity-0 group-hover:opacity-100"
                    title="Rename folder"
                  >
                    <FileEdit size={14} />
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      openDeleteDialog(item);
                    }}
                    className="p-1 rounded hover:bg-stone-600 text-stone-400 hover:text-red-400 opacity-0 group-hover:opacity-100"
                    title="Delete folder"
                  >
                    <Trash2 size={14} />
                  </button>
                </div>
              )}
            </div>
            
            {isExpanded && item.children && (
              <div className="ml-2 border-l border-stone-700">
                {renderFileTree(item.children)}
              </div>
            )}
          </div>
        );
      } else {
        const isSelected = selectedFile && selectedFile.path === item.path;
        return (
          <div 
            key={item.path} 
            className={`flex items-center justify-between py-1 px-1 ml-4 rounded cursor-pointer hover:bg-stone-700 group ${isSelected ? 'bg-stone-700 text-teal-300' : 'text-teal-50'}`}
            onClick={() => handleFileSelect(item)}
            draggable={isAdmin || (user?.has_file_access && activeTab === 'private')}
            onDragStart={(e) => handleDragStart(e, item)}
          >
            <div className="flex items-center">
              {getFileIcon(item.name)}
              <span className="text-sm">{item.name}</span>
            </div>
            
            {/* File operation buttons */}
            {(isAdmin || (user && user.has_file_access && activeTab === 'private')) && (
              <div className="flex">
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    openRenameDialog(item);
                  }}
                  className="p-1 rounded hover:bg-stone-600 text-stone-400 hover:text-teal-300 opacity-0 group-hover:opacity-100"
                  title="Rename file"
                >
                  <FileEdit size={14} />
                </button>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    openDeleteDialog(item);
                  }}
                  className="p-1 rounded hover:bg-stone-600 text-stone-400 hover:text-red-400 opacity-0 group-hover:opacity-100"
                  title="Delete file"
                >
                  <Trash2 size={14} />
                </button>
              </div>
            )}
          </div>
        );
      }
    });
  };

  return (
    <div className="w-1/4 border-r border-stone-700 flex flex-col overflow-hidden">
      <div className="p-2 border-b border-stone-700 font-mono text-sm flex items-center justify-between">
        <div className="flex items-center">
          <span>FILES</span>
          
          {/* Tabs for switching between public and private files */}
          <div className="flex ml-4">
            <button
              onClick={() => {
                if (activeTab !== 'public') {
                  // First set the active tab, then select the root folder
                  handleFileSelect({ 
                    path: '/', 
                    type: 'directory', 
                    name: 'Root', 
                    isPublic: true,
                    setTab: 'public' // Add flag to explicitly set the tab
                  });
                }
              }}
              className={`px-2 py-1 rounded-t text-xs flex items-center gap-1 ${
                activeTab === 'public' 
                  ? 'bg-stone-700 text-teal-300' 
                  : 'bg-stone-800 hover:bg-stone-700'
              }`}
              title="Public files (readable by all users)"
            >
              <Globe size={14} />
              <span>Public</span>
            </button>
            
            {(isAdmin || (user && user.has_file_access)) && (
              <button
                onClick={() => {
                  if (activeTab !== 'private') {
                    // First set the active tab, then select the root folder
                    handleFileSelect({ 
                      path: '/', 
                      type: 'directory', 
                      name: 'Root',
                      setTab: 'private' // Add flag to explicitly set the tab
                    });
                  }
                }}
                className={`px-2 py-1 rounded-t text-xs flex items-center gap-1 ml-1 ${
                  activeTab === 'private' 
                    ? 'bg-stone-700 text-teal-300' 
                    : 'bg-stone-800 hover:bg-stone-700'
                }`}
                title="Private files (admin only)"
              >
                <Lock size={14} />
                <span>Private</span>
              </button>
            )}
          </div>
        </div>
        
        {/* File creation buttons (admins for both tabs, users with file access only for private tab) */}
        {(isAdmin || (user && user.has_file_access && activeTab === 'private')) && (
          <div className="flex gap-2">
            <button
              onClick={() => openCreateDialog('file')}
              className="p-1 rounded hover:bg-stone-700 text-teal-400"
              title="Create new file"
            >
              <Plus size={16} />
            </button>
            <button
              onClick={() => openCreateDialog('directory')}
              className="p-1 rounded hover:bg-stone-700 text-teal-400"
              title="Create new folder"
            >
              <FolderPlus size={16} />
            </button>
          </div>
        )}
      </div>
      
      <div 
        className="flex-1 overflow-auto"
        onDragOver={handleContainerDragOver}
        onDragLeave={handleContainerDragLeave}
        onDrop={handleContainerDrop}
      >
        {isTreeLoading ? (
          <div className="flex items-center justify-center h-full">
            <span className="text-teal-300">Loading files...</span>
          </div>
        ) : errorMessage ? (
          <div className="p-2 text-red-400">{errorMessage}</div>
        ) : (
          <div className="p-2 font-mono">
            {activeTab === 'public' ? (
              // Show public files to all users
              <>
                <div className="flex items-center py-1 px-1 text-teal-300">
                  <Globe size={16} className="mr-2" />
                  <span className="text-sm font-bold">Public Files</span>
                </div>
                {publicFiles.length > 0 ? (
                  renderFileTree(publicFiles)
                ) : (
                  <div className="ml-4 text-stone-500 text-sm">No public files available</div>
                )}
              </>
            ) : (
              // Show private files to admin users
              <>
                <div className="flex items-center py-1 px-1 text-teal-300">
                  <Lock size={16} className="mr-2" />
                  <span className="text-sm font-bold">Private Files</span>
                </div>
                {files.length > 0 ? (
                  renderFileTree(files)
                ) : (
                  <div className="ml-4 text-stone-500 text-sm">No private files available</div>
                )}
              </>
            )}
          </div>
        )}
      </div>
      
      <div className="p-2 border-t border-stone-700 text-xs">
        {selectedFile ? selectedFile.path : currentPath}
      </div>
      
      {/* Storage statistics display */}
      {(isAdmin || (user && user.has_file_access)) && (
        <StorageStats stats={storageStats} />
      )}
      
      {/* File operation dialogs */}
      <CreateFileDialog
        showCreateDialog={showCreateDialog}
        createType={createType}
        newItemName={newItemName}
        setNewItemName={setNewItemName}
        isCreating={isCreating}
        errorMessage={errorMessage}
        closeCreateDialog={closeCreateDialog}
        createNewItem={createNewItem}
      />
        
      <RenameDialog
        showRenameDialog={showRenameDialog}
        itemToRename={itemToRename}
        newName={newName}
        setNewName={setNewName}
        isRenaming={isRenaming}
        errorMessage={errorMessage}
        closeRenameDialog={closeRenameDialog}
        renameItem={renameItem}
      />
        
      <DeleteDialog
        showDeleteDialog={showDeleteDialog}
        itemToDelete={itemToDelete}
        isDeleting={isDeleting}
        errorMessage={errorMessage}
        closeDeleteDialog={closeDeleteDialog}
        handleDeleteItem={handleDeleteItem}
      />
    </div>
  );
};

export default FileTree;

================
File: src/components/windows/explorer/components/MapEditor.jsx
================
import React, { useState, useRef, useEffect, useCallback } from 'react';
import { Map, Save, FileDown } from 'lucide-react';
import { 
  createEmptyMap, 
  serializeMap, 
  parseMapFile, 
  convertMapToAscii, 
  convertAsciiToMap 
} from '../../mapeditor/utils/mapUtils';

// Import sub-components
import MapToolbar from '../../mapeditor/MapToolbar';
import MapCanvas from '../../mapeditor/MapCanvas';
import LayerPanel from '../../mapeditor/LayerPanel';
import TilePalette from '../../mapeditor/TilePalette';

/**
 * Map Editor component for use within the FileContent area
 * This component handles the editing of .map files in the file explorer
 */
const MapEditor = ({ fileContent, selectedFile, onSave }) => {
  // State for map data
  const [mapData, setMapData] = useState(null);
  const [currentLayer, setCurrentLayer] = useState(0);
  const [currentTool, setCurrentTool] = useState('floor'); // Default to floor instead of select
  const [isDirty, setIsDirty] = useState(false);
  const [error, setError] = useState(null);
  const [saveStatus, setSaveStatus] = useState('saved'); // 'saved', 'saving', 'error'
  const [showAsciiModal, setShowAsciiModal] = useState(false);
  const [asciiContent, setAsciiContent] = useState('');
  const [asciiImportText, setAsciiImportText] = useState('');
  const [asciiModalMode, setAsciiModalMode] = useState('export'); // 'export' or 'import'
  const [selectedTileId, setSelectedTileId] = useState(0);
  const [selectedRotation, setSelectedRotation] = useState(0); // Add state for rotation
  const [showGrid, setShowGrid] = useState(true); // State for grid visibility
  const [brushSize, setBrushSize] = useState(1); // State for brush size
  
  // Use ref instead of state for the reset view function to avoid render-phase updates
  const resetViewFnRef = useRef(null);
  
  // References
  const autoSaveTimeoutRef = useRef(null);
  const isInitialLoadRef = useRef(true); // Track initial load to prevent layer reset during auto-save

  // Load map data when fileContent changes
  useEffect(() => {
    try {
      if (fileContent) {
        const parsedMap = parseMapFile(fileContent);
        setMapData(parsedMap);
        
        // Only reset currentLayer on initial load, not on auto-saves
        if (isInitialLoadRef.current) {
          setCurrentLayer(0);
          isInitialLoadRef.current = false;
        }
        
        setIsDirty(false);
        setError(null);
      } else {
        // Create a new map if no content
        setMapData(createEmptyMap());
        setIsDirty(true);
      }
    } catch (err) {
      console.error('Error parsing map file:', err);
      setError('Failed to parse map file. Creating a new map.');
      setMapData(createEmptyMap());
      setIsDirty(true);
    }
  }, [fileContent]);
  
  // Auto-save when map data changes
  useEffect(() => {
    // If the map is dirty (has unsaved changes), auto-save after a delay
    if (isDirty && mapData) {
      // Clear any existing timeout
      if (autoSaveTimeoutRef.current) {
        clearTimeout(autoSaveTimeoutRef.current);
      }
      
      // Set save status to 'saving'
      setSaveStatus('saving');
      
      // Set a new timeout for auto-save
      autoSaveTimeoutRef.current = setTimeout(() => {
        handleSaveMap();
      }, 1000); // 1 second debounce
    }
    
    // Cleanup function to clear the timeout when component unmounts
    return () => {
      if (autoSaveTimeoutRef.current) {
        clearTimeout(autoSaveTimeoutRef.current);
      }
    };
  }, [isDirty, mapData]);

  // Handler for saving the map
  const handleSaveMap = () => {
    if (!mapData) return;
    
    try {
      // Serialize the map data to JSON string
      const mapContent = serializeMap(mapData);
      
      // Debug logs to track the data flow
      console.log('[DEBUG] Map Editor - Saving map data:', {
        mapDataExists: !!mapData,
        serializedLength: mapContent?.length,
        serializedPreview: mapContent?.substring(0, 100) + '...',
        selectedFile: selectedFile?.path
      });
      
      // Set status to saving
      setSaveStatus('saving');
      
      // Call the parent onSave function
      onSave(mapContent);
      
      // Update state
      setIsDirty(false);
      setSaveStatus('saved');
    } catch (err) {
      console.error('Error saving map:', err);
      setError('Failed to save map file.');
      setSaveStatus('error');
    }
  };

  // Handler for map edits
  // Add 'rotation' parameter to accept the rotation value from MapCanvas
  const handleEdit = (x, y, tool, rotation) => {
    if (!mapData || !mapData.layers || !mapData.layers[currentLayer]) return;
    
    // Clone the current map data to avoid direct state mutation
    const newMapData = { ...mapData };
    const layerData = { ...newMapData.layers[currentLayer] };
    
    // Find if the cell already exists in this layer
    const existingCellIndex = layerData.cells.findIndex(cell => cell.x === x && cell.y === y);
    
    if (tool === 'erase') {
      // If erasing and the cell exists, remove it
      if (existingCellIndex !== -1) {
        layerData.cells = layerData.cells.filter((_, index) => index !== existingCellIndex);
      }
    } else {
      // Create the cell data based on the tool type
      // Include the received rotation value
      let cellData = { x, y, type: tool, rotation: rotation || 0 }; // Default to 0 if rotation is undefined/falsy
      
      // Include the selected tile ID for both floor and wall tools
      if (tool === 'floor' || tool === 'wall') {
        cellData.tileId = selectedTileId;
      }
      
      // If a cell already exists at this position, update it immutably
      if (existingCellIndex !== -1) {
        // Create a new array with the updated cell
        layerData.cells = layerData.cells.map((cell, index) => 
          index === existingCellIndex ? cellData : cell
        );
      } else {
        // Otherwise, add a new cell (already immutable via push to a cloned array)
        layerData.cells.push(cellData);
      }
    }
    
    // Update the layer in the map data
    newMapData.layers[currentLayer] = layerData;
    
    // Update state
    setMapData(newMapData);
    setIsDirty(true);
  };

  // Handler for rotation changes from TilePalette
  const handleRotateTile = (newRotation) => {
    setSelectedRotation(newRotation);
    // Note: We don't mark as dirty here, as rotation is a tool setting, not map data change
  };

  // Layer management functions
  const handleToggleLayerVisibility = (layerIndex) => {
    if (!mapData || !mapData.layers || !mapData.layers[layerIndex]) return;
    
    const newMapData = { ...mapData };
    newMapData.layers[layerIndex] = {
      ...newMapData.layers[layerIndex],
      visible: !newMapData.layers[layerIndex].visible
    };
    
    setMapData(newMapData);
    setIsDirty(true);
  };

  const handleAddLayer = () => {
    if (!mapData) return;
    
    const newLayerName = `Layer ${mapData.layers.length + 1}`;
    const newLayer = {
      name: newLayerName,
      visible: true,
      cells: []
    };
    
    const newMapData = { 
      ...mapData,
      layers: [...mapData.layers, newLayer]
    };
    
    setMapData(newMapData);
    setCurrentLayer(newMapData.layers.length - 1);
    setIsDirty(true);
  };

  const handleRemoveLayer = (layerIndex) => {
    if (!mapData || !mapData.layers || mapData.layers.length <= 1) return;
    
    const newMapData = { ...mapData };
    newMapData.layers = newMapData.layers.filter((_, index) => index !== layerIndex);
    
    setMapData(newMapData);
    
    // Adjust current layer if necessary
    if (currentLayer >= newMapData.layers.length) {
      setCurrentLayer(newMapData.layers.length - 1);
    }
    
    setIsDirty(true);
  };

  const handleMoveLayerUp = (layerIndex) => {
    if (!mapData || !mapData.layers || layerIndex >= mapData.layers.length - 1) return;
    
    const newMapData = { ...mapData };
    const layers = [...newMapData.layers];
    
    // Swap layers
    [layers[layerIndex], layers[layerIndex + 1]] = [layers[layerIndex + 1], layers[layerIndex]];
    
    newMapData.layers = layers;
    setMapData(newMapData);
    
    // Update current layer if necessary
    if (currentLayer === layerIndex) {
      setCurrentLayer(layerIndex + 1);
    } else if (currentLayer === layerIndex + 1) {
      setCurrentLayer(layerIndex);
    }
    
    setIsDirty(true);
  };

  const handleMoveLayerDown = (layerIndex) => {
    if (!mapData || !mapData.layers || layerIndex <= 0) return;
    
    const newMapData = { ...mapData };
    const layers = [...newMapData.layers];
    
    // Swap layers
    [layers[layerIndex], layers[layerIndex - 1]] = [layers[layerIndex - 1], layers[layerIndex]];
    
    newMapData.layers = layers;
    setMapData(newMapData);
    
    // Update current layer if necessary
    if (currentLayer === layerIndex) {
      setCurrentLayer(layerIndex - 1);
    } else if (currentLayer === layerIndex - 1) {
      setCurrentLayer(layerIndex);
    }
    
    setIsDirty(true);
  };

  const handleRenameLayer = (layerIndex, newName) => {
    if (!mapData || !mapData.layers || !mapData.layers[layerIndex] || !newName) return;
    
    const newMapData = { ...mapData };
    newMapData.layers[layerIndex] = {
      ...newMapData.layers[layerIndex],
      name: newName
    };
    
    setMapData(newMapData);
    setIsDirty(true);
  };

  // Handler for exporting to ASCII
  const handleExportAscii = () => {
    if (!mapData) return;
    
    try {
      // Convert the map data to ASCII
      const ascii = convertMapToAscii(mapData);
      setAsciiContent(ascii);
      setAsciiModalMode('export');
      setShowAsciiModal(true);
    } catch (err) {
      console.error('Error exporting to ASCII:', err);
      setError('Failed to export map to ASCII format.');
    }
  };

  // Handler for importing from ASCII
  const handleImportAscii = () => {
    setAsciiImportText('');
    setAsciiModalMode('import');
    setShowAsciiModal(true);
  };

  // Handler for confirming ASCII import
  const handleConfirmAsciiImport = () => {
    if (!asciiImportText.trim()) {
      setError('No ASCII content to import.');
      return;
    }
    
    try {
      // Convert ASCII to map data
      const newMapData = convertAsciiToMap(asciiImportText, mapData.name);
      
      // Preserve metadata from existing map if possible
      if (mapData.metadata) {
        newMapData.metadata = {
          ...newMapData.metadata,
          author: mapData.metadata.author || 'user',
          modified: new Date().toISOString()
        };
      }
      
      // Update the map data
      setMapData(newMapData);
      setIsDirty(true);
      setShowAsciiModal(false);
    } catch (err) {
      console.error('Error importing from ASCII:', err);
      setError('Failed to import ASCII map. The format may be invalid.');
    }
  };

  // Handler for downloading the ASCII map
  const handleDownloadAscii = () => {
    if (!asciiContent) return;
    
    try {
      // Create a blob with the ASCII content
      const blob = new Blob([asciiContent], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      
      // Create a temporary anchor element to trigger the download
      const a = document.createElement('a');
      a.href = url;
      a.download = `${mapData.name || 'map'}.txt`;
      
      // Append the anchor to the document, click it, and remove it
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      // Clean up by revoking the object URL
      URL.revokeObjectURL(url);
    } catch (err) {
      console.error('Error downloading ASCII map:', err);
      setError('Failed to download ASCII map.');
    }
  };


  // Handler for applying map property changes
  const handleApplyProperties = (properties) => {
    if (!mapData) return;

    const newMapData = { 
      ...mapData,
      name: properties.name,
      width: properties.width,
      height: properties.height,
      gridSize: properties.gridSize
    };

    // Update map data
    setMapData(newMapData);
    setIsDirty(true);
  };
  
  // Handler for updating layer opacity
  const handleUpdateLayerOpacity = (layerIndex, opacity) => {
    if (!mapData || !mapData.layers || !mapData.layers[layerIndex]) return;
    
    const newMapData = { ...mapData };
    newMapData.layers[layerIndex] = {
      ...newMapData.layers[layerIndex],
      opacity: opacity
    };
    
    setMapData(newMapData);
    setIsDirty(true);
  };

  // If map data isn't loaded yet, show a loading state
  if (!mapData) {
    return (
      <div className="flex items-center justify-center h-full">
        <span className="text-teal-300">Loading map editor...</span>
      </div>
    );
  }

  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400 overflow-hidden">
      {/* Toolbar */}
      <MapToolbar 
        onSave={handleSaveMap}
        onUndo={() => console.log('Undo not implemented')}
        onRedo={() => console.log('Redo not implemented')}
        onClear={() => {
          // Create a new empty map but preserve properties like name, width, height, gridSize
          const newMap = createEmptyMap();
          newMap.name = mapData.name;
          newMap.width = mapData.width;
          newMap.height = mapData.height;
          newMap.gridSize = mapData.gridSize;
          // Preserve metadata if it exists
          if (mapData.metadata) {
            newMap.metadata = { ...mapData.metadata };
          }
          setMapData(newMap);
          setIsDirty(true);
        }}
        onExportAscii={handleExportAscii}
        onImportAscii={handleImportAscii}
        onToggleGrid={() => setShowGrid(!showGrid)}
        onResetView={() => {
          // Call the reset view function if it exists
          if (resetViewFnRef.current) {
            resetViewFnRef.current();
          }
        }}
        showGrid={showGrid}
        saveStatus={saveStatus}
        mapData={mapData}
        onApplyProperties={handleApplyProperties}
      />
      
      {/* Error message */}
      {error && (
        <div className="p-2 bg-red-900 text-red-200 text-sm">
          {error}
        </div>
      )}
      
      {/* Main content area */}
      <div className="flex-1 flex overflow-hidden">
        {/* Canvas for map editing */}
        <MapCanvas 
          mapData={mapData}
          currentLayer={currentLayer}
          currentTool={currentTool}
          selectedTileId={selectedTileId}
          selectedRotation={selectedRotation} // Pass rotation state to canvas
          onEdit={handleEdit}
          showGrid={showGrid}
          resetViewRef={resetViewFnRef} // Pass ref instead of setter function
          brushSize={brushSize}
        />
        
        {/* Layer panel with integrated tile palette */}
        <LayerPanel 
          layers={mapData.layers}
          currentLayer={currentLayer}
          setCurrentLayer={setCurrentLayer}
          onToggleLayerVisibility={handleToggleLayerVisibility}
          onAddLayer={handleAddLayer}
          onRemoveLayer={handleRemoveLayer}
          onMoveLayerUp={handleMoveLayerUp}
          onMoveLayerDown={handleMoveLayerDown}
          onRenameLayer={handleRenameLayer}
          onUpdateLayerOpacity={handleUpdateLayerOpacity}
          selectedTileId={selectedTileId}
          onSelectTile={setSelectedTileId}
          selectedRotation={selectedRotation} // Pass rotation state to LayerPanel
          onRotateTile={handleRotateTile} // Pass rotation handler to LayerPanel
          currentTool={currentTool}
          setCurrentTool={setCurrentTool}
          brushSize={brushSize}
          setBrushSize={setBrushSize}
        />
      </div>
      
      
      {/* ASCII Modal */}
      {showAsciiModal && (
        <div className="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50">
          <div className="bg-stone-800 border border-stone-700 rounded-lg shadow-lg w-full max-w-3xl max-h-[80vh] flex flex-col">
            <div className="flex justify-between items-center p-4 border-b border-stone-700">
              <h2 className="text-lg font-semibold text-teal-300">
                {asciiModalMode === 'export' ? 'ASCII Map Export' : 'Import ASCII Map'}
              </h2>
              <button 
                onClick={() => setShowAsciiModal(false)}
                className="p-1 hover:bg-stone-700 rounded text-teal-400"
              >
                &times;
              </button>
            </div>
            
            <div className="p-4 flex-1 overflow-auto">
              {asciiModalMode === 'export' ? (
                <div className="flex flex-col h-full">
                  <p className="mb-4 text-sm text-stone-300">
                    This is the ASCII representation of your map. Each character represents a cell type:
                    <br />
                    <code className="bg-stone-900 px-1 rounded">
                      # = Wall, . = Floor, + = Door, " = Grass, ' = Ashes, &gt; = Stairs, @ = Spawn
                    </code>
                  </p>
                  <pre className="bg-stone-900 p-4 rounded font-mono text-teal-100 text-sm overflow-auto flex-1 whitespace-pre">
                    {asciiContent}
                  </pre>
                </div>
              ) : (
                <div className="flex flex-col h-full">
                  <p className="mb-4 text-sm text-stone-300">
                    Paste ASCII map content below. Each character represents a cell type:
                    <br />
                    <code className="bg-stone-900 px-1 rounded">
                      # = Wall, . = Floor, + = Door, " = Grass, ' = Ashes, &gt; = Stairs, @ = Spawn
                    </code>
                  </p>
                  <textarea 
                    className="bg-stone-900 p-4 rounded font-mono text-teal-100 text-sm overflow-auto flex-1 resize-none focus:outline-none focus:ring-1 focus:ring-teal-500"
                    value={asciiImportText}
                    onChange={e => setAsciiImportText(e.target.value)}
                    placeholder="Paste ASCII map here..."
                  />
                </div>
              )}
            </div>
            
            <div className="p-4 border-t border-stone-700 flex justify-end space-x-2">
              <button 
                onClick={() => setShowAsciiModal(false)}
                className="px-4 py-2 bg-stone-700 hover:bg-stone-600 rounded text-teal-100"
              >
                Cancel
              </button>
              
              {asciiModalMode === 'export' ? (
                <button 
                  onClick={handleDownloadAscii}
                  className="px-4 py-2 bg-teal-700 hover:bg-teal-600 rounded text-teal-100 flex items-center"
                >
                  <FileDown size={16} className="mr-2" />
                  Download ASCII
                </button>
              ) : (
                <button 
                  onClick={handleConfirmAsciiImport}
                  className="px-4 py-2 bg-teal-700 hover:bg-teal-600 rounded text-teal-100"
                >
                  Import
                </button>
              )}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default MapEditor;

================
File: src/components/windows/explorer/components/nodes/index.js
================
import TextNode from './TextNode';

/**
 * Node type registry
 * Export all node types from this file to easily import them elsewhere
 */

const nodeTypes = {
  // Add all node types here
  text: TextNode,
  // Additional node types can be added here in the future
};

export default nodeTypes;

================
File: src/components/windows/explorer/components/nodes/TextNode.jsx
================
import React, { useState } from 'react';
import { Edit } from 'lucide-react';
import { Handle, Position } from 'reactflow';

/**
 * TextNode component for displaying and editing text nodes in the canvas
 * This component is used in the Canvas Editor
 */
const TextNode = ({ id, data, isConnectable, setEditingNode, editingNode }) => {
  const isEditing = editingNode === id;
  const [isHovered, setIsHovered] = useState(false);
  
  const handleEditClick = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setEditingNode(id);
  };
  
  const handleEdit = (e) => {
    const updatedText = e.target.value;
    
    // Update the node data is handled by the parent component
    // through the setNodes function passed via data
    if (data.onChange) {
      data.onChange(id, updatedText);
    }
  };
  
  const handleBlur = () => {
    setEditingNode(null);
  };
  
  const handleKeyDown = (e) => {
    if (e.key === 'Escape') {
      setEditingNode(null);
    } else if (e.key === 'Enter' && e.ctrlKey) {
      setEditingNode(null);
    }
  };
  
  return (
    <div 
      className="p-2 bg-stone-800 border border-stone-700 rounded shadow-md relative"
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
    >
      <Handle 
        type="source" 
        position={Position.Top} 
        isConnectable={isConnectable} 
        style={{ 
          background: '#14b8a6', // teal-500 color
          width: '0.45rem',
          height: '0.45rem',
          borderRadius: '9999px',
          border: 'none'
        }}
      />

      {/* Bottom handle */}
      <Handle 
        type="source" 
        position={Position.Bottom} 
        isConnectable={isConnectable} 
        style={{ 
          background: '#14b8a6', // teal-500 color
          width: '0.45rem',
          height: '0.45rem',
          borderRadius: '9999px',
          border: 'none'
        }}
      />

      {/* Right handle */}
      <Handle 
        type="source" 
        position={Position.Right} 
        id="right"
        isConnectable={isConnectable} 
        style={{ 
          background: '#14b8a6', // teal-500 color
          width: '0.45rem',
          height: '0.45rem',
          borderRadius: '9999px',
          border: 'none'
        }}
      />

      {/* Left handle */}
      <Handle 
        type="source" 
        position={Position.Left} 
        id="left"
        isConnectable={isConnectable} 
        style={{ 
          background: '#14b8a6', // teal-500 color
          width: '0.45rem',
          height: '0.45rem',
          borderRadius: '9999px',
          border: 'none'
        }}
      />
      {isEditing ? (
        <textarea
          className="w-full h-full bg-stone-700 text-teal-400 p-2 rounded font-mono text-sm focus:outline-none resize-none min-h-[80px]"
          value={data.text}
          onChange={handleEdit}
          onBlur={handleBlur}
          onKeyDown={handleKeyDown}
          autoFocus
        />
      ) : (
        <>
          <div className="text-teal-400 text-sm whitespace-pre-wrap pr-6">{data.text}</div>
          {isHovered && (
            <button
              className="absolute top-1 right-1 bg-stone-700 p-1 rounded-sm hover:bg-stone-600 transition-colors"
              onClick={handleEditClick}
              title="Edit node"
            >
              <Edit size={14} className="text-teal-400" />
            </button>
          )}
        </>
      )}
    </div>
  );
};

export default TextNode;

================
File: src/components/windows/explorer/components/StorageStats.jsx
================
import React from 'react';

const StorageStats = ({ stats, isAdmin }) => {
  // If stats aren't available yet or the user doesn't have file access, don't show anything
  if (!stats || stats.isLoading) {
    return null;
  }

  // Format bytes to human-readable format
  const formatBytes = (bytes, decimals = 2) => {
    if (bytes === 0) return '0 Bytes';
    if (bytes === null || bytes === undefined) return 'Unlimited';
    
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
  };

  // Calculate percentage used
  const percentUsed = stats.unlimited ? 0 : Math.min(100, Math.round((stats.used / stats.quota) * 100)) || 0;
  
  return (
    <div className="px-2 py-1 bg-stone-800 text-xs border-t border-stone-700">
      <div className="flex justify-between items-center ${isAdmin ? 'mb-0' : 'mb-1'}">
        <span className="text-gray-400">Storage:</span>
        <span className="text-teal-400">
          {stats.unlimited 
            ? 'Unlimited (Admin)'
            : `${formatBytes(stats.used)} of ${formatBytes(stats.quota)}`
          }
        </span>
      </div>
      
      {!stats.unlimited && (
        <div className="w-full bg-stone-700 rounded-full h-1.5 mb-1">
          <div 
            className="bg-teal-600 h-1.5 rounded-full" 
            style={{ width: `${percentUsed}%` }}
          ></div>
        </div>
      )}
    </div>
  );
};

export default StorageStats;

================
File: src/components/windows/explorer/ExplorerWindow.jsx
================
import React from 'react';
import useExplorerState from './state/useExplorerState';
import { useAuth } from '../../../context/AuthContext';
import FileTree from './components/FileTree';
import FileContent from './components/FileContent';
import CommandInput from './components/CommandInput';
import StorageStats from './components/StorageStats';
import '../ExplorerWindow.css';

const ExplorerWindow = ({ isActive, nodeId, onCommand, transformWindow, windowState, updateWindowState, focusRef }) => {
  // Get auth context to check user permissions
  const { user } = useAuth();
  // Use the custom hook to manage state and operations
  const explorerState = useExplorerState(nodeId, windowState, updateWindowState);
  
  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400 overflow-hidden">
      <div className="flex flex-1 overflow-hidden relative">
        {/* File tree panel */}
        <FileTree 
          files={explorerState.files}
          publicFiles={explorerState.publicFiles}
          activeTab={explorerState.activeTab}
          expandedFolders={explorerState.expandedFolders}
          currentPath={explorerState.currentPath}
          selectedFile={explorerState.selectedFile}
          isTreeLoading={explorerState.isTreeLoading}
          errorMessage={explorerState.errorMessage}
          isAdmin={explorerState.isAdmin}
          user={user}
          toggleFolder={explorerState.toggleFolder}
          handleFileSelect={explorerState.handleFileSelect}
          openRenameDialog={explorerState.openRenameDialog}
          openDeleteDialog={explorerState.openDeleteDialog}
          openCreateDialog={explorerState.openCreateDialog}
          handleDragStart={explorerState.handleDragStart}
          handleDragOver={explorerState.handleDragOver}
          handleDragLeave={explorerState.handleDragLeave}
          handleDrop={explorerState.handleDrop}
          handleContainerDragOver={explorerState.handleContainerDragOver}
          handleContainerDragLeave={explorerState.handleContainerDragLeave}
          handleContainerDrop={explorerState.handleContainerDrop}
          dropTarget={explorerState.dropTarget}
          storageStats={explorerState.storageStats}
          // Dialog-related props
          showCreateDialog={explorerState.showCreateDialog}
          createType={explorerState.createType}
          newItemName={explorerState.newItemName}
          setNewItemName={explorerState.setNewItemName}
          isCreating={explorerState.isCreating}
          closeCreateDialog={explorerState.closeCreateDialog}
          createNewItem={explorerState.createNewItem}
          showRenameDialog={explorerState.showRenameDialog}
          itemToRename={explorerState.itemToRename}
          newName={explorerState.newName}
          setNewName={explorerState.setNewName}
          isRenaming={explorerState.isRenaming}
          closeRenameDialog={explorerState.closeRenameDialog}
          renameItem={explorerState.renameItem}
          showDeleteDialog={explorerState.showDeleteDialog}
          itemToDelete={explorerState.itemToDelete}
          isDeleting={explorerState.isDeleting}
          closeDeleteDialog={explorerState.closeDeleteDialog}
          handleDeleteItem={explorerState.handleDeleteItem}
        />
        
        
        {/* File content panel */}
        <FileContent
          selectedFile={explorerState.selectedFile}
          isContentLoading={explorerState.isContentLoading}
          fileContent={explorerState.fileContent}
          errorMessage={explorerState.errorMessage}
          showPreview={explorerState.showPreview}
          editMode={explorerState.editMode}
          saveStatus={explorerState.saveStatus}
          converter={explorerState.converter}
          isAdmin={explorerState.isAdmin}
          user={user}
          activeTab={explorerState.activeTab}
          setFileContent={explorerState.setFileContent}
          toggleEditMode={explorerState.toggleEditMode}
          handleMarkdownChange={explorerState.handleMarkdownChange}
          handleSaveFileContent={explorerState.handleSaveFileContent}
          handleExportFile={explorerState.handleExportFile}
        />
      </div>
      
      {/* Command input */}
      <CommandInput
        focusRef={focusRef}
        isAdmin={explorerState.isAdmin}
        handleCommand={explorerState.handleCommand}
      />
    </div>
  );
};

export default ExplorerWindow;

================
File: src/components/windows/explorer/README.md
================
# Explorer Window Component

This directory contains a modular implementation of the ExplorerWindow component. The code has been refactored to improve maintainability and make it easier to extend functionality.

## Architecture Overview

The ExplorerWindow has been split into several components and modules following a clean separation of concerns:

```
explorer/
 ExplorerWindow.jsx              # Main component (orchestrator)
 state/
    useExplorerState.js         # Custom hook for state management
 components/
    FileTree.jsx                # Tree view UI and navigation
    FileContent.jsx             # Content viewing/editing panel
    CommandInput.jsx            # Command input field
    dialogs/
        FileDialogs.jsx         # Dialog components for file operations
 api/
    fileOperations.js           # API calls and file operations
 utils/
    fileUtils.js                # File-related utility functions
    markdownUtils.js            # Markdown-specific utilities
 README.md                       # This documentation file
```

## Component Responsibilities

### ExplorerWindow.jsx
- Acts as the main component that orchestrates all other components
- Retrieves state and operations from useExplorerState
- Passes down props to child components

### useExplorerState.js
- Centralizes all state management
- Handles state persistence and retrieval
- Implements business logic for all user interactions
- Provides functions for file operations

### FileTree.jsx
- Displays the directory structure
- Handles file/folder selection
- Manages UI for drag and drop operations

### FileContent.jsx
- Displays file content based on file type
- Provides editing interface for markdown files
- Renders markdown preview

### CommandInput.jsx
- Provides command input interface
- Handles command execution

### FileDialogs.jsx
- Contains dialog components for creating, renaming, and deleting files/folders

### fileOperations.js
- Encapsulates API calls to the server
- Handles error states and response parsing

### fileUtils.js and markdownUtils.js
- Provide utility functions for file and markdown operations

## Data Flow

1. User interactions in UI components trigger functions received from useExplorerState
2. useExplorerState processes these actions, updates state, and interacts with the API as needed
3. State changes flow back to UI components through props

## Adding Support for New File Types

To add support for new file types (e.g., canvas files, audio files, images):

1. Update `fileUtils.js` to recognize and provide appropriate icons for the new file types
2. Extend `FileContent.jsx` to render the new file types appropriately
3. If needed, add specific utility files (similar to markdownUtils.js) for the new file types
4. Update state in `useExplorerState.js` to handle any special behaviors for the new file types

## State Management

The component uses a custom hook approach for state management, which offers several advantages:

- Centralizes state logic in one place
- Makes the main component simpler and more declarative
- Allows for easier testing of business logic
- Simplifies adding new features or file type support

This approach is more maintainable than using a context provider for this specific use case, as the component tree is not deeply nested. If the component structure becomes more complex in the future, the code could be adapted to use a context provider instead.

================
File: src/components/windows/explorer/state/useExplorerState.js
================
import { useState, useEffect, useRef } from 'react';
import { useAuth } from '../../../../context/AuthContext';
import { useWindowState } from '../../../../context/WindowStateContext';
import { WINDOW_TYPES } from '../../../../utils/windowTypes';
import { saveExplorerState, getExplorerState } from '../../../../services/indexedDBService';
import { createMarkdownConverter } from '../utils/markdownUtils';
import { 
  fetchPublicDirectoryContents, 
  fetchDirectoryContents, 
  fetchPublicFileContent, 
  fetchFileContent,
  saveFileContent as apiSaveFileContent,
  createNewItem as apiCreateNewItem,
  renameItem as apiRenameItem,
  deleteItem as apiDeleteItem,
  moveItem as apiMoveItem,
  getStorageStats as apiGetStorageStats
} from '../api/fileOperations';
import { 
  getParentDirectoryPath, 
  expandParentFolders, 
  getActiveFolderPath 
} from '../utils/fileUtils';

const useExplorerState = (nodeId, windowState, updateWindowState) => {
  // Get auth context to check if user is admin
  const { user } = useAuth();
  const isAdmin = user?.is_admin || false;
  
  // Get window state context for additional persistence
  const { setActiveWindow } = useWindowState();
  
  // Refs to track state loading and saving
  const stateLoadedRef = useRef(false);
  const explorerSaveTimeoutRef = useRef(null); // New ref for debounced explorer state saving
  
  // Reference to store the saved state that needs to be restored after files are loaded
  const pendingStateRestoreRef = useRef(null);
  const fileLoadedRef = useRef(false);
  
  // Use state from windowState or initialize with defaults
  const [files, setFiles] = useState([]);
  const [publicFiles, setPublicFiles] = useState([]);
  const [currentPath, setCurrentPath] = useState(windowState?.currentPath || '/');
  const [selectedFile, setSelectedFile] = useState(windowState?.selectedFile || null);
  const [expandedFolders, setExpandedFolders] = useState(windowState?.expandedFolders || {});
  const [isTreeLoading, setIsTreeLoading] = useState(true);
  const [isContentLoading, setIsContentLoading] = useState(false);
  const [fileContent, setFileContent] = useState(windowState?.fileContent || '');
  const [errorMessage, setErrorMessage] = useState('');
  const [showPreview, setShowPreview] = useState(windowState?.showPreview || false);
  const [activeTab, setActiveTab] = useState(windowState?.activeTab || 'public'); // 'public' or 'private'
  
  // Additional state for markdown editing
  const [editMode, setEditMode] = useState(windowState?.editMode || false);
  const [saveStatus, setSaveStatus] = useState('saved'); // 'saved', 'saving', 'error'
  
  // State for file/folder creation
  const [showCreateDialog, setShowCreateDialog] = useState(false);
  const [createType, setCreateType] = useState('file'); // 'file' or 'directory'
  const [newItemName, setNewItemName] = useState('');
  const [isCreating, setIsCreating] = useState(false);
  
  // State for file/folder renaming
  const [showRenameDialog, setShowRenameDialog] = useState(false);
  const [itemToRename, setItemToRename] = useState(null);
  const [newName, setNewName] = useState('');
  const [isRenaming, setIsRenaming] = useState(false);
  
  // State for file/folder deletion
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [itemToDelete, setItemToDelete] = useState(null);
  const [isDeleting, setIsDeleting] = useState(false);
  
  // State for drag and drop
  const [draggedItem, setDraggedItem] = useState(null);
  const [dropTarget, setDropTarget] = useState(null);
  const [isMoving, setIsMoving] = useState(false);
  
  // For auto-save functionality and editor references
  const saveTimeoutRef = useRef(null);
  
  // Create markdown converter
  const converter = createMarkdownConverter();

  // Track previous node ID to detect window swaps
  const prevNodeIdRef = useRef(nodeId);

  // Load explorer state from IndexedDB on mount or when nodeId changes
  useEffect(() => {
    const loadExplorerState = async () => {
      console.log(`[DEBUG] Starting to load explorer state for window ${nodeId}`);
      
      // If nodeId changed but it's not the first load, it likely means a window swap occurred
      const isSwapDetected = prevNodeIdRef.current !== nodeId && prevNodeIdRef.current !== null;
      if (isSwapDetected) {
        console.log(`[DEBUG] Node ID changed from ${prevNodeIdRef.current} to ${nodeId}, possible window swap detected`);
        // Reset the state loaded flag to force a reload after a swap
        stateLoadedRef.current = false;
        // Clear any pending state
        pendingStateRestoreRef.current = null;
      }
      
      // Update prevNodeIdRef for future comparisons
      prevNodeIdRef.current = nodeId;
      
      try {
        // Try to load explorer state from IndexedDB
        const savedState = await getExplorerState(nodeId);
        console.log(`[DEBUG] Retrieved state from IndexedDB:`, savedState);
        
        if (savedState && savedState.content && !stateLoadedRef.current) {
          console.log(`[DEBUG] Valid saved state found for window ${nodeId}:`, savedState.content);
          
          // Store the saved state in the ref for later restoration after files are loaded
          pendingStateRestoreRef.current = savedState.content;
          
          // Restore expanded folders and active tab immediately
          if (savedState.content.expandedFolders) {
            console.log(`[DEBUG] Restoring expanded folders`);
            setExpandedFolders(savedState.content.expandedFolders);
          }
          
          if (savedState.content.activeTab) {
            console.log(`[DEBUG] Restoring active tab: ${savedState.content.activeTab}`);
            setActiveTab(savedState.content.activeTab);
          }
          
          if (savedState.content.editMode !== undefined && isAdmin) {
            console.log(`[DEBUG] Restoring edit mode: ${savedState.content.editMode}`);
            setEditMode(savedState.content.editMode);
          }
          
          // Mark as loaded
          stateLoadedRef.current = true;
        } else {
          console.log(`[DEBUG] No valid saved state found or state already loaded`);
          // Even if no state is loaded, mark as loaded to allow future saves
          stateLoadedRef.current = true;
        }
      } catch (error) {
        console.error(`[DEBUG] Failed to load explorer state:`, error);
        // Ensure we still mark state as loaded even if there's an error
        stateLoadedRef.current = true;
      }
    };
    
    loadExplorerState();
  }, [nodeId, isAdmin]);
  
  // Handle window activation
  useEffect(() => {
    if (windowState?.isActive) {
      // Save this as the active explorer window
      setActiveWindow(nodeId, WINDOW_TYPES.EXPLORER);
    }
  }, [windowState?.isActive, nodeId, setActiveWindow]);
  
  // Save explorer state to IndexedDB when it changes
  useEffect(() => {
    // Early return if state hasn't been loaded yet (prevents overwriting with default values)
    if (!stateLoadedRef.current) return;
    
    // Clear any existing timeout
    if (explorerSaveTimeoutRef.current) {
      clearTimeout(explorerSaveTimeoutRef.current);
    }
    
    // Save the explorer state to IndexedDB with debounce
    explorerSaveTimeoutRef.current = setTimeout(() => {
      console.log(`[DEBUG] Saving explorer state for window ${nodeId}:`, {
        selectedFile,
        expandedFolders,
        activeTab,
        editMode
      });
      
      saveExplorerState({
        id: nodeId,
        content: {
          selectedFile,
          expandedFolders,
          activeTab,
          editMode
        }
      }).catch(error => {
        console.error(`[DEBUG] Failed to save explorer state for window ${nodeId} to IndexedDB:`, error);
      });
    }, 300); // 300ms debounce
    
    // Clear timeout on cleanup
    return () => {
      if (explorerSaveTimeoutRef.current) {
        clearTimeout(explorerSaveTimeoutRef.current);
      }
    };
  }, [selectedFile, expandedFolders, activeTab, editMode, nodeId]);

  // Load initial directory contents and restore selected file afterward
  useEffect(() => {
    console.log('[DEBUG] Starting to load directory contents');
    
    // First, load the files
    const loadFilesAndRestoreSelection = async () => {
      try {
        // Load public files for all users
        await handleFetchPublicDirectoryContents('/', true);
        
      // Load private files for admin users or users with file access (if applicable)
      if (isAdmin || user?.has_file_access) {
        try {
          await handleFetchDirectoryContents('/', true);
        } catch (error) {
          console.error('Failed to load private files:', error);
          setFiles([]);
          if (activeTab === 'private') {
            setErrorMessage('Failed to load private files. Please ensure your directory exists.');
          }
        }
      }
        
        // Mark files as loaded
        fileLoadedRef.current = true;
        
        // Now that files are loaded, restore the selected file if we have one pending
        if (pendingStateRestoreRef.current && pendingStateRestoreRef.current.selectedFile) {
          const restoredFile = pendingStateRestoreRef.current.selectedFile;
          console.log(`[DEBUG] Now restoring selected file after files are loaded:`, restoredFile);
          
          // Set the selected file
          setSelectedFile(restoredFile);
          
          // Update the current path to ensure parent directories are visible
          if (restoredFile.type === 'file') {
            // For files, set the current path to the parent directory
            const parentPath = getParentDirectoryPath(restoredFile.path);
            setCurrentPath(parentPath);
          } else {
            // For directories, set the current path to the directory itself
            setCurrentPath(restoredFile.path);
          }
          
          // Ensure parent folders are expanded
          setExpandedFolders(prev => expandParentFolders(restoredFile.path, prev));
          
          // If it's a file, load its content
          if (restoredFile.type === 'file') {
            console.log(`[DEBUG] Loading content for restored file: ${restoredFile.path}`);
            
            // Set the preview mode for markdown files
            if (restoredFile.name.endsWith('.md')) {
              console.log(`[DEBUG] Setting preview mode for markdown file`);
              setShowPreview(true);
              
              // Also restore edit mode if it was saved
              if (pendingStateRestoreRef.current.editMode && isAdmin) {
                console.log(`[DEBUG] Restoring edit mode: ${pendingStateRestoreRef.current.editMode}`);
                setEditMode(pendingStateRestoreRef.current.editMode);
              }
            }
            
            // Use handleFileSelect to load the file content
            // Use setTimeout to ensure this happens after state updates
            setTimeout(() => {
              console.log(`[DEBUG] Executing delayed file selection for: ${restoredFile.path}`);
              handleFileSelect(restoredFile, true);
            }, 100);
          }
          
          // Clear the pending restore
          pendingStateRestoreRef.current = null;
        } else {
          console.log('[DEBUG] No file to restore or files not loaded yet');
        }
      } catch (error) {
        console.error('[DEBUG] Error in loadFilesAndRestoreSelection:', error);
      }
    };
    
    loadFilesAndRestoreSelection();
  }, [isAdmin, activeTab]);

  // State for storage statistics
  const [storageStats, setStorageStats] = useState({
    quota: 0,
    used: 0,
    available: 0,
    unlimited: false,
    isLoading: false
  });

  // Fetch storage statistics
  const fetchStorageStats = async () => {
    if (!user?.has_file_access && !isAdmin) return;
    
    setStorageStats(prev => ({ ...prev, isLoading: true }));
    
    try {
      const stats = await apiGetStorageStats();
      if (stats.error) {
        setErrorMessage(stats.error);
        setStorageStats(prev => ({
          ...prev,
          isLoading: false
        }));
      } else {
        setStorageStats({
          quota: stats.quota,
          used: stats.used,
          available: stats.available,
          unlimited: stats.unlimited,
          isLoading: false
        });
      }
    } catch (error) {
      console.error('Error fetching storage stats:', error);
      setStorageStats(prev => ({
        ...prev,
        isLoading: false
      }));
    }
  };

  // Fetch storage stats on mount and after file operations
  useEffect(() => {
    if (user?.has_file_access || isAdmin) {
      fetchStorageStats();
    }
  }, [user, isAdmin]);

  // Reset content states when switching tabs
  useEffect(() => {
    // Clear file content and reset view states when changing tabs
    setSelectedFile(null);
    setFileContent('');
    setShowPreview(false);
    setEditMode(false);
    setSaveStatus('saved');
    setErrorMessage('');
    
    // Reset current path to root for the selected tab
    setCurrentPath('/');
  }, [activeTab]);

  // Auto-save functionality with debounce
  useEffect(() => {
    // Auto-save if in edit mode, user has permission, and we have a markdown file selected
    // Allow for admins and users with file_access (for private files)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (editMode && hasEditPermission && selectedFile && selectedFile.name.endsWith('.md') && fileContent) {
      // Clear any existing timeout
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
      
      // Set status to saving
      setSaveStatus('saving');
      
      // Set a new timeout for auto-save
      saveTimeoutRef.current = setTimeout(() => {
        handleSaveFileContent();
      }, 1000); // 1 second debounce
    }
    
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, [fileContent, editMode, isAdmin, selectedFile]);

  // Update window state when relevant state changes
  useEffect(() => {
    if (updateWindowState) {
      updateWindowState({
        currentPath,
        selectedFile,
        expandedFolders,
        fileContent,
        showPreview,
        editMode,
        saveStatus,
        activeTab
      });
    }
  }, [currentPath, selectedFile, expandedFolders, fileContent, showPreview, editMode, saveStatus, activeTab, updateWindowState]);
  
  // Fetch public directory contents
  const handleFetchPublicDirectoryContents = async (publicPath = '/', refreshAll = false) => {
    setIsTreeLoading(true);
    setErrorMessage('');
    
    const result = await fetchPublicDirectoryContents(publicPath, refreshAll);
    
    if (result.error) {
      setErrorMessage(result.error);
    } else {
      setPublicFiles(result.files);
      
      // Only update the current path if we're not refreshing the entire tree
      if (!refreshAll) {
        setCurrentPath(publicPath);
      }
      
      // If we refreshed the entire tree, make sure the current path's parent folders are expanded
      if (refreshAll && currentPath !== '/') {
        setExpandedFolders(prev => expandParentFolders(currentPath, prev));
      }
    }
    
    setIsTreeLoading(false);
    return result; // Return result so we can chain promises
  };
  
  // Fetch public file content
  const handleFetchPublicFileContent = async (filePath) => {
    setIsContentLoading(true);
    setErrorMessage('');
    
    const result = await fetchPublicFileContent(filePath);
    
    if (result.error) {
      setErrorMessage(result.error);
      setSaveStatus('error');
    } else {
      setFileContent(result.content);
      setSaveStatus('saved');
    }
    
    setIsContentLoading(false);
  };
  
  // Fetch private directory contents
  const handleFetchDirectoryContents = async (path = '/', refreshAll = false) => {
    setIsTreeLoading(true);
    setErrorMessage('');
    
    const result = await fetchDirectoryContents(path, refreshAll);
    
    if (result.error) {
      setErrorMessage(result.error);
    } else {
      setFiles(result.files);
      
      // Only update the current path if we're not refreshing the entire tree
      if (!refreshAll) {
        setCurrentPath(path);
      }
      
      // If we refreshed the entire tree, make sure the current path's parent folders are expanded
      if (refreshAll && currentPath !== '/') {
        setExpandedFolders(prev => expandParentFolders(currentPath, prev));
      }
    }
    
    setIsTreeLoading(false);
    return result; // Return result so we can chain promises
  };
  
  // Fetch private file content
  const handleFetchFileContent = async (filePath) => {
    setIsContentLoading(true);
    setErrorMessage('');
    
    const result = await fetchFileContent(filePath);
    
    if (result.error) {
      setErrorMessage(result.error);
      setSaveStatus('error');
    } else {
      setFileContent(result.content);
      setSaveStatus('saved');
    }
    
    setIsContentLoading(false);
  };
  
  // Save file content
  const handleSaveFileContent = async (content) => {
    console.log('[DEBUG] useExplorerState - handleSaveFileContent called:', {
      selectedFilePath: selectedFile?.path,
      selectedFileName: selectedFile?.name,
      contentProvided: content !== undefined,
      // If content is provided, use it, otherwise use the state's fileContent
      contentToSaveType: typeof (content !== undefined ? content : fileContent),
      contentToSaveLength: (content !== undefined ? content : fileContent)?.length || 0,
      contentToSavePreview: typeof (content !== undefined ? content : fileContent) === 'string' 
        ? (content !== undefined ? content : fileContent).substring(0, 100) + '...' 
        : 'not a string'
    });
    
    // Check if filePath is valid
    if (!selectedFile || !selectedFile.path || selectedFile.path.trim() === '') {
      console.error('[DEBUG] handleSaveFileContent - No file selected');
      setErrorMessage('No file selected. Please select a file first.');
      setSaveStatus('error');
      return;
    }
    
    setSaveStatus('saving');
    
    // Use content parameter if provided, otherwise use state's fileContent
    const contentToSave = content !== undefined ? content : fileContent;
    
    console.log('[DEBUG] Sending to API:', {
      path: selectedFile.path,
      contentType: typeof contentToSave,
      contentLength: contentToSave?.length || 0
    });
    
    const result = await apiSaveFileContent(selectedFile.path, contentToSave);
    
    if (result.error) {
      console.error('[DEBUG] API Save Error:', result.error);
      setErrorMessage(result.error);
      setSaveStatus('error');
    } else {
      console.log('[DEBUG] API Save Success:', result);
      setErrorMessage('');
      setSaveStatus('saved');
      
      // If content parameter was provided, update the state's fileContent
      if (content !== undefined) {
        setFileContent(content);
      }
    }
  };
  
  // Toggle folder expansion
  const toggleFolder = (folderPath, folder) => {
    const isExpanding = !expandedFolders[folderPath];
    
    setExpandedFolders(prev => ({
      ...prev,
      [folderPath]: isExpanding
    }));
    
    // If we're expanding the folder, also set it as the current path
    if (isExpanding) {
      setCurrentPath(folderPath);
      setSelectedFile(folder);
    }
  };
  
  // Create a new file or folder
  const createNewItem = async () => {
    if (!newItemName.trim()) {
      setErrorMessage('Name cannot be empty');
      return;
    }
    
    setIsCreating(true);
    setErrorMessage('');
    
    // Get the active folder path where the new item should be created
    const activeFolderPath = getActiveFolderPath(selectedFile, currentPath);
    
    const result = await apiCreateNewItem(activeTab, activeFolderPath, newItemName, createType);
    
    if (result.error) {
      setErrorMessage(result.error);
    } else {
      // Close the dialog and reset the form
      setShowCreateDialog(false);
      setNewItemName('');
      
      // Refresh the entire file tree from the root
      if (activeTab === 'public') {
        handleFetchPublicDirectoryContents('/', true);
      } else {
        handleFetchDirectoryContents('/', true);
      }
      
      // If it's a directory, expand it
      if (createType === 'directory' && result.path) {
        setExpandedFolders(prev => ({
          ...prev,
          [result.path]: true
        }));
      }
    }
    
    setIsCreating(false);
  };
  
  // Open the create dialog
  const openCreateDialog = (type) => {
    setCreateType(type);
    setNewItemName('');
    setErrorMessage('');
    setShowCreateDialog(true);
  };
  
  // Close the create dialog
  const closeCreateDialog = () => {
    setShowCreateDialog(false);
    setNewItemName('');
    setErrorMessage('');
  };
  
  // Open the rename dialog
  const openRenameDialog = (item) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission) {
      setErrorMessage('Admin access required to rename files or file access permission for private files.');
      return;
    }
    
    setItemToRename(item);
    setNewName(item.name);
    setErrorMessage('');
    setShowRenameDialog(true);
  };
  
  // Close the rename dialog
  const closeRenameDialog = () => {
    setShowRenameDialog(false);
    setItemToRename(null);
    setNewName('');
    setErrorMessage('');
  };
  
  // Rename a file or folder
  const renameItem = async () => {
    if (!newName.trim()) {
      setErrorMessage('Name cannot be empty');
      return;
    }
    
    if (!itemToRename) {
      setErrorMessage('No item selected for renaming');
      return;
    }
    
    setIsRenaming(true);
    setErrorMessage('');
    
    const result = await apiRenameItem(itemToRename.path, newName);
    
    if (result.error) {
      setErrorMessage(result.error);
    } else {
      // Close the dialog and reset the form
      setShowRenameDialog(false);
      setItemToRename(null);
      setNewName('');
      
      // If the renamed item was selected, update the selected file
      if (selectedFile && selectedFile.path === itemToRename.path) {
        setSelectedFile(null);
      }
      
      // Refresh the appropriate file list
      if (itemToRename.isPublic) {
        handleFetchPublicDirectoryContents('/', true);
      } else {
        handleFetchDirectoryContents('/', true);
      }
    }
    
    setIsRenaming(false);
  };
  
  // Open the delete dialog
  const openDeleteDialog = (item) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission) {
      setErrorMessage('Admin access required to delete files or file access permission for private files.');
      return;
    }
    
    setItemToDelete(item);
    setErrorMessage('');
    setShowDeleteDialog(true);
  };
  
  // Close the delete dialog
  const closeDeleteDialog = () => {
    setShowDeleteDialog(false);
    setItemToDelete(null);
    setErrorMessage('');
  };
  
  // Delete a file or folder
  const handleDeleteItem = async () => {
    if (!itemToDelete) {
      setErrorMessage('No item selected for deletion');
      return;
    }
    
    setIsDeleting(true);
    setErrorMessage('');
    
    const result = await apiDeleteItem(itemToDelete.path);
    
    if (result.error) {
      setErrorMessage(result.error);
    } else {
      // Close the dialog
      setShowDeleteDialog(false);
      setItemToDelete(null);
      
      // If the deleted item was selected, clear the selection
      if (selectedFile && selectedFile.path === itemToDelete.path) {
        setSelectedFile(null);
        setFileContent('');
        setShowPreview(false);
        if (editMode) {
          setEditMode(false);
        }
      }
      
      // Refresh the appropriate file list
      if (itemToDelete.isPublic) {
        handleFetchPublicDirectoryContents('/', true);
      } else {
        handleFetchDirectoryContents('/', true);
      }
    }
    
    setIsDeleting(false);
  };
  
  // Handle drag start event
  const handleDragStart = (e, item) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission) return;
    
    setDraggedItem(item);
    e.dataTransfer.setData('text/plain', item.path);
    e.dataTransfer.effectAllowed = 'move';
    
    // Add dragging class to the element
    e.currentTarget.classList.add('dragging');
    
    // Remove the class after a short delay to ensure it's applied
    setTimeout(() => {
      if (e.currentTarget) {
        e.currentTarget.classList.remove('dragging');
      }
    }, 100);
  };
  
  // Handle drag over event
  const handleDragOver = (e, folder) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission || !draggedItem) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    // Only allow dropping into directories
    if (folder.type === 'directory') {
      setDropTarget(folder);
      e.dataTransfer.dropEffect = 'move';
      
      // Add drop-target class to the element
      e.currentTarget.classList.add('drop-target');
    }
  };
  
  // Handle drag over for the file tree container (to allow dropping to root)
  const handleContainerDragOver = (e) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission || !draggedItem) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    // Set root as the drop target
    const rootFolder = {
      type: 'directory',
      path: draggedItem.isPublic ? '/public' : '/',
      name: 'Root'
    };
    setDropTarget(rootFolder);
    e.dataTransfer.dropEffect = 'move';
  };
  
  // Handle drag leave event
  const handleDragLeave = (e) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission) return;
    
    e.preventDefault();
    e.stopPropagation();
    setDropTarget(null);
    
    // Remove drop-target class from the element
    e.currentTarget.classList.remove('drop-target');
  };
  
  // Handle drag leave for the container
  const handleContainerDragLeave = (e) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission) return;
    
    e.preventDefault();
    e.stopPropagation();
    setDropTarget(null);
  };
  
  // Handle drop event
  const handleDrop = async (e, targetFolder) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission || !draggedItem || !targetFolder) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    // Reset drop target
    setDropTarget(null);
    
    // Remove drop-target class from the element
    e.currentTarget.classList.remove('drop-target');
    
    // Only allow dropping into directories
    if (targetFolder.type !== 'directory') {
      return;
    }
    
    // Check if dropping on itself
    if (draggedItem.path === targetFolder.path) {
      return;
    }
    
    // Check if dropping in current location (parent folder is the same)
    const draggedParent = getParentDirectoryPath(draggedItem.path);
    if (draggedParent === targetFolder.path) {
      return;
    }
    
    setIsMoving(true);
    setErrorMessage('');
    
    const result = await apiMoveItem(draggedItem.path, targetFolder.path);
    
    if (result.error) {
      setErrorMessage(result.error);
    } else {
      // If the moved item was selected, clear the selection
      if (selectedFile && selectedFile.path === draggedItem.path) {
        setSelectedFile(null);
        setFileContent('');
        setShowPreview(false);
        if (editMode) {
          setEditMode(false);
        }
      }
      
      // Refresh the appropriate file list
      if (draggedItem.isPublic) {
        handleFetchPublicDirectoryContents('/', true);
      } else {
        handleFetchDirectoryContents('/', true);
      }
    }
    
    // Clear drag state
    setDraggedItem(null);
    setIsMoving(false);
  };
  
  // Handle drop event for the container (moving to root)
  const handleContainerDrop = async (e) => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission || !draggedItem || !dropTarget) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    // Process the drop using the dropTarget which was set in handleContainerDragOver
    const targetFolder = dropTarget;
    
    // Reset drop target
    setDropTarget(null);
    
    // Check if dropping in current location (parent folder is the same)
    const draggedParent = getParentDirectoryPath(draggedItem.path);
    if (draggedParent === targetFolder.path) {
      return;
    }
    
    setIsMoving(true);
    setErrorMessage('');
    
    const result = await apiMoveItem(draggedItem.path, targetFolder.path);
    
    if (result.error) {
      setErrorMessage(result.error);
    } else {
      // If the moved item was selected, clear the selection
      if (selectedFile && selectedFile.path === draggedItem.path) {
        setSelectedFile(null);
        setFileContent('');
        setShowPreview(false);
        if (editMode) {
          setEditMode(false);
        }
      }
      
      // Refresh the appropriate file list
      if (draggedItem.isPublic) {
        handleFetchPublicDirectoryContents('/', true);
      } else {
        handleFetchDirectoryContents('/', true);
      }
    }
    
    // Clear drag state
    setDraggedItem(null);
    setIsMoving(false);
  };
  
  // Handle folder selection
  const handleFolderSelect = (folder) => {
    // Update the current path to the selected folder's path
    setCurrentPath(folder.path);
    
    // Set the selected folder
    setSelectedFile(folder);
    
    // Expand the folder
    setExpandedFolders(prev => ({
      ...prev,
      [folder.path]: true
    }));
    
    // Reset content and preview
    setFileContent('');
    setShowPreview(false);
    
    // Reset edit mode
    if (editMode) {
      setEditMode(false);
    }
  };
  
  // Handle file selection
  const handleFileSelect = (file, skipTabSwitch = false) => {
    // Check if this selection should change the active tab, but skip when restoring files
    if (!skipTabSwitch) {
      if (file.setTab) {
        setActiveTab(file.setTab);
      } else if (file.isPublic !== undefined) {
        // Update active tab based on file's isPublic property
        setActiveTab(file.isPublic ? 'public' : 'private');
      }
    }

    // If it's a directory, handle it differently
    if (file.type === 'directory') {
      handleFolderSelect(file);
      return;
    }
    
    setSelectedFile(file);
    
    // Make sure parent folders are expanded so the file is visible on reload
    setExpandedFolders(prev => expandParentFolders(file.path, prev));
    
    // Set current path to the parent directory for better context
    const parentPath = getParentDirectoryPath(file.path);
    setCurrentPath(parentPath);
    
    // Reset edit mode when selecting a new file
    if (editMode) {
      setEditMode(false);
    }
    
    // Fetch content for all file types
    if (file.isPublic) {
      // Fetch public file content
      handleFetchPublicFileContent(file.path);
    } else {
      // Fetch private file content (admin only)
      handleFetchFileContent(file.path);
    }
    
    // Only set preview mode for markdown files
    if (file.name.endsWith('.md')) {
      setShowPreview(true);
    } else {
      setShowPreview(false);
    }
  };
  
  // Toggle edit mode
  const toggleEditMode = () => {
    // Allow admins or users with file_access (for private files only)
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    if (!hasEditPermission) {
      setErrorMessage('Admin access required to edit files or file access permission for private files.');
      return;
    }
    
    if (!selectedFile || !selectedFile.name.endsWith('.md')) {
      setErrorMessage('Only markdown files can be edited.');
      return;
    }
    
    setEditMode(!editMode);
    // When switching to preview mode, ensure preview is shown
    if (editMode) {
      setShowPreview(true);
    }
  };
  
  // Handle markdown content change
  const handleMarkdownChange = (e) => {
    setFileContent(e.target.value);
  };
  
  // Handle commands (for the command input)
  const handleCommand = (cmd) => {
    // Commands:
    // - refresh: refresh file list
    // - preview: toggle markdown preview
    // - edit: toggle edit mode (users with permission)
    // - save: manually save the current file
    // - new-file: create a new file (users with permission)
    // - new-folder: create a new folder (users with permission)
    // - rename: rename selected file or folder (users with permission)
    // - delete: delete selected file or folder (users with permission)
    // - public: switch to public files tab
    // - private: switch to private files tab (users with permission)
    
    // Check permission for file operations
    const hasEditPermission = isAdmin || (user?.has_file_access && activeTab === 'private');
    const canAccessPrivate = isAdmin || user?.has_file_access;
    
    if (cmd === 'refresh') {
      if (activeTab === 'public') {
        handleFetchPublicDirectoryContents('/', true);
      } else {
        handleFetchDirectoryContents('/', true);
      }
    } else if (cmd === 'preview' && selectedFile?.name.endsWith('.md')) {
      setShowPreview(!showPreview);
      if (editMode) {
        setEditMode(false);
      }
    } else if (cmd === 'edit' && selectedFile?.name.endsWith('.md')) {
      toggleEditMode();
    } else if (cmd === 'save' && editMode && selectedFile?.name.endsWith('.md')) {
      handleSaveFileContent();
    } else if (cmd === 'new-file' && hasEditPermission) {
      openCreateDialog('file');
    } else if (cmd === 'new-folder' && hasEditPermission) {
      openCreateDialog('directory');
    } else if (cmd === 'rename' && selectedFile && hasEditPermission) {
      openRenameDialog(selectedFile);
    } else if (cmd === 'delete' && selectedFile && hasEditPermission) {
      openDeleteDialog(selectedFile);
    } else if (cmd === 'public') {
      setActiveTab('public');
    } else if (cmd === 'private' && canAccessPrivate) {
      setActiveTab('private');
    } else {
      setErrorMessage(`Unknown command: ${cmd}`);
    }
  };

  // Handle file or folder export/download
  const handleExportFile = async () => {
    if (!selectedFile) {
      setErrorMessage('No file or folder selected');
      return;
    }
    
    try {
      // If it's a directory, create a zip file
      if (selectedFile.type === 'directory') {
        // Import JSZip dynamically 
        const JSZip = (await import('jszip')).default;
        const zip = new JSZip();
        
        setErrorMessage('Creating zip file...');
        
        // Function to recursively gather files from a folder
        const addFolderToZip = async (folderPath, zipFolder) => {
          // Determine which API to use based on whether the folder is public or private
          const fetchApi = selectedFile.isPublic ? fetchPublicDirectoryContents : fetchDirectoryContents;
          
          // Fetch directory contents
          const result = await fetchApi(folderPath, false);
          
          if (result.error) {
            throw new Error(`Failed to access folder: ${result.error}`);
          }
          
          // Process each item in the folder
          for (const item of result.files) {
            if (item.type === 'directory') {
              // Create a subfolder in the zip and process recursively
              const newFolder = zipFolder.folder(item.name);
              await addFolderToZip(item.path, newFolder);
            } else {
              // Fetch file content
              const contentApi = selectedFile.isPublic ? fetchPublicFileContent : fetchFileContent;
              const contentResult = await contentApi(item.path);
              
              if (contentResult.error) {
                console.error(`Error loading file content for ${item.path}: ${contentResult.error}`);
                continue;
              }
              
              // Add file to zip
              zipFolder.file(item.name, contentResult.content);
            }
          }
        };
        
        // Start the recursive process from the selected folder
        await addFolderToZip(selectedFile.path, zip);
        
        // Generate the zip file
        const content = await zip.generateAsync({type: 'blob'});
        
        // Create a filename for the zip file (folder name + .zip)
        const zipFileName = `${selectedFile.name}.zip`;
        
        // Create a temporary URL for the blob
        const url = URL.createObjectURL(content);
        
        // Create a temporary anchor element to trigger the download
        const a = document.createElement('a');
        a.href = url;
        a.download = zipFileName;
        
        // Append the anchor to the document, click it, and remove it
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        // Clean up by revoking the object URL
        URL.revokeObjectURL(url);
        
        // Clear the export message
        setErrorMessage('');
      } else {
        // For single file export, keep existing behavior
        if (!fileContent) {
          setErrorMessage('File has no content');
          return;
        }
        
        // Create a blob with the file content
        const blob = new Blob([fileContent], { type: 'text/plain' });
        
        // Create a temporary URL for the blob
        const url = URL.createObjectURL(blob);
        
        // Create a temporary anchor element to trigger the download
        const a = document.createElement('a');
        a.href = url;
        a.download = selectedFile.name;
        
        // Append the anchor to the document, click it, and remove it
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        // Clean up by revoking the object URL
        URL.revokeObjectURL(url);
      }
    } catch (error) {
      console.error('Error exporting:', error);
      setErrorMessage(`Failed to export: ${error.message}`);
    }
  };
  
  return {
    files,
    publicFiles,
    currentPath,
    selectedFile,
    expandedFolders,
    isTreeLoading,
    isContentLoading,
    fileContent,
    errorMessage,
    showPreview,
    activeTab,
    editMode,
    saveStatus,
    showCreateDialog,
    createType, 
    newItemName,
    isCreating,
    showRenameDialog,
    itemToRename,
    newName,
    isRenaming,
    showDeleteDialog,
    itemToDelete,
    isDeleting,
    draggedItem,
    dropTarget,
    isMoving,
    converter,
    isAdmin,
    storageStats,
    fetchStorageStats,
    handleFetchPublicDirectoryContents,
    handleFetchDirectoryContents,
    handleSaveFileContent,
    handleExportFile,
    toggleFolder,
    createNewItem,
    openCreateDialog,
    closeCreateDialog,
    openRenameDialog,
    closeRenameDialog,
    renameItem,
    openDeleteDialog,
    closeDeleteDialog,
    handleDeleteItem,
    handleDragStart,
    handleDragOver,
    handleContainerDragOver,
    handleDragLeave,
    handleContainerDragLeave,
    handleDrop,
    handleContainerDrop,
    handleFileSelect,
    toggleEditMode,
    handleMarkdownChange,
    handleCommand,
    setNewItemName,
    setNewName,
    setErrorMessage,
    setFileContent,
    setSelectedFile
  };
};

export default useExplorerState;

================
File: src/components/windows/explorer/utils/canvasUtils.js
================
/**
 * Utility functions for the canvas editor
 */

/**
 * Generate a unique ID for a node or edge
 * @param {string} prefix - Prefix for the ID (e.g., 'node' or 'edge')
 * @returns {string} Unique ID
 */
export const generateId = (prefix = 'node') => {
  return `${prefix}-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
};

/**
 * Calculate the distance between two points
 * @param {Object} point1 - First point {x, y}
 * @param {Object} point2 - Second point {x, y}
 * @returns {number} Distance
 */
export const distance = (point1, point2) => {
  return Math.sqrt(
    Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2)
  );
};

/**
 * Check if a point is inside a node
 * @param {Object} point - Point to check {x, y}
 * @param {Object} node - Node {x, y, width, height}
 * @returns {boolean} True if point is inside node
 */
export const isPointInNode = (point, node) => {
  return (
    point.x >= node.x &&
    point.x <= node.x + node.width &&
    point.y >= node.y &&
    point.y <= node.y + node.height
  );
};

/**
 * Get connection points for edges based on the fromSide and toSide
 * @param {Object} fromNode - Source node {x, y, width, height}
 * @param {Object} toNode - Target node {x, y, width, height}
 * @param {string} fromSide - Side of source node to connect from ('top', 'right', 'bottom', 'left')
 * @param {string} toSide - Side of target node to connect to ('top', 'right', 'bottom', 'left')
 * @returns {Object} Connection points {source: {x, y}, target: {x, y}}
 */
export const getConnectionPoints = (fromNode, toNode, fromSide = 'right', toSide = 'left') => {
  const source = { x: 0, y: 0 };
  const target = { x: 0, y: 0 };

  // Source node connection point
  switch (fromSide) {
    case 'top':
      source.x = fromNode.x + fromNode.width / 2;
      source.y = fromNode.y;
      break;
    case 'right':
      source.x = fromNode.x + fromNode.width;
      source.y = fromNode.y + fromNode.height / 2;
      break;
    case 'bottom':
      source.x = fromNode.x + fromNode.width / 2;
      source.y = fromNode.y + fromNode.height;
      break;
    case 'left':
      source.x = fromNode.x;
      source.y = fromNode.y + fromNode.height / 2;
      break;
    default:
      source.x = fromNode.x + fromNode.width;
      source.y = fromNode.y + fromNode.height / 2;
  }

  // Target node connection point
  switch (toSide) {
    case 'top':
      target.x = toNode.x + toNode.width / 2;
      target.y = toNode.y;
      break;
    case 'right':
      target.x = toNode.x + toNode.width;
      target.y = toNode.y + toNode.height / 2;
      break;
    case 'bottom':
      target.x = toNode.x + toNode.width / 2;
      target.y = toNode.y + toNode.height;
      break;
    case 'left':
      target.x = toNode.x;
      target.y = toNode.y + toNode.height / 2;
      break;
    default:
      target.x = toNode.x;
      target.y = toNode.y + toNode.height / 2;
  }

  return { source, target };
};

/**
 * Calculate the best connection sides for two nodes
 * @param {Object} fromNode - Source node {x, y, width, height}
 * @param {Object} toNode - Target node {x, y, width, height}
 * @returns {Object} Best sides {fromSide, toSide}
 */
export const calculateBestConnectionSides = (fromNode, toNode) => {
  // Calculate center points
  const fromCenter = {
    x: fromNode.x + fromNode.width / 2,
    y: fromNode.y + fromNode.height / 2
  };
  const toCenter = {
    x: toNode.x + toNode.width / 2,
    y: toNode.y + toNode.height / 2
  };

  // Calculate angle between centers
  const angle = Math.atan2(toCenter.y - fromCenter.y, toCenter.x - fromCenter.x);
  
  // Convert angle to degrees
  const degrees = (angle * 180) / Math.PI;
  
  // Determine from side based on angle
  let fromSide;
  if (degrees >= -45 && degrees < 45) {
    fromSide = 'right';
  } else if (degrees >= 45 && degrees < 135) {
    fromSide = 'bottom';
  } else if (degrees >= 135 || degrees < -135) {
    fromSide = 'left';
  } else {
    fromSide = 'top';
  }
  
  // Calculate opposite side for target
  let toSide;
  switch (fromSide) {
    case 'right': toSide = 'left'; break;
    case 'bottom': toSide = 'top'; break;
    case 'left': toSide = 'right'; break;
    case 'top': toSide = 'bottom'; break;
    default: toSide = 'left';
  }
  
  return { fromSide, toSide };
};

/**
 * Draw an arrow at the end of a line
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {number} x - X coordinate of arrow tip
 * @param {number} y - Y coordinate of arrow tip
 * @param {number} angle - Angle of the line in radians
 * @param {number} size - Size of the arrow
 */
export const drawArrow = (ctx, x, y, angle, size = 10) => {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle);
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(-size, -size / 2);
  ctx.lineTo(-size, size / 2);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
};

/**
 * Draw a connection line between two points with optional arrow
 * @param {CanvasRenderingContext2D} ctx - Canvas context
 * @param {Object} source - Source point {x, y}
 * @param {Object} target - Target point {x, y}
 * @param {string} color - Line color
 * @param {boolean} showSourceArrow - Whether to show an arrow at the source
 * @param {boolean} showTargetArrow - Whether to show an arrow at the target
 */
export const drawConnection = (ctx, source, target, color = '#14b8a6', showSourceArrow = false, showTargetArrow = true) => {
  const angle = Math.atan2(target.y - source.y, target.x - source.x);
  
  // Draw line
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(source.x, source.y);
  ctx.lineTo(target.x, target.y);
  ctx.stroke();
  
  // Draw arrows
  ctx.fillStyle = color;
  if (showSourceArrow) {
    drawArrow(ctx, source.x, source.y, angle + Math.PI);
  }
  if (showTargetArrow) {
    drawArrow(ctx, target.x, target.y, angle);
  }
};

/**
 * Convert a canvas color code to an actual color
 * @param {string} colorCode - Color code (e.g., '1', '2', '#FF0000')
 * @returns {string} CSS color value
 */
export const getCanvasColor = (colorCode) => {
  // Map of preset colors
  const colorMap = {
    '1': '#ef4444', // red
    '2': '#f97316', // orange
    '3': '#eab308', // yellow
    '4': '#22c55e', // green
    '5': '#06b6d4', // cyan
    '6': '#a855f7'  // purple
  };
  
  // If colorCode is a preset, return the mapped color
  if (colorMap[colorCode]) {
    return colorMap[colorCode];
  }
  
  // Otherwise, return the color code as is (assuming it's a valid CSS color)
  return colorCode || '#14b8a6'; // Default to teal if no color provided
};

/**
 * Create a new empty canvas with the JSONCanvas format
 * @returns {Object} Empty canvas data
 */
export const createEmptyCanvas = () => {
  return {
    nodes: [],
    edges: []
  };
};

/**
 * Create a new text node with default properties
 * @param {number} x - X position
 * @param {number} y - Y position
 * @param {string} text - Node text content
 * @returns {Object} New text node
 */
export const createTextNode = (x, y, text = 'New note') => {
  return {
    id: generateId('node'),
    type: 'text',
    x,
    y,
    width: 200,
    height: 100,
    text
  };
};

/**
 * Create a new edge connecting two nodes
 * @param {string} fromNode - ID of source node
 * @param {string} toNode - ID of target node
 * @param {string} fromSide - Side of source node ('top', 'right', 'bottom', 'left')
 * @param {string} toSide - Side of target node ('top', 'right', 'bottom', 'left')
 * @returns {Object} New edge
 */
export const createEdge = (fromNode, toNode, fromSide = 'right', toSide = 'left') => {
  return {
    id: generateId('edge'),
    fromNode,
    toNode,
    fromSide,
    toSide,
    fromEnd: 'none',
    toEnd: 'arrow'
  };
};

================
File: src/components/windows/explorer/utils/fileUtils.js
================
// Helper function to get parent directory path from a file path
export const getParentDirectoryPath = (filePath) => {
  // Remove trailing slash if present
  const normalizedPath = filePath.endsWith('/') ? filePath.slice(0, -1) : filePath;
  // Find the last slash in the path
  const lastSlashIndex = normalizedPath.lastIndexOf('/');
  
  if (lastSlashIndex === -1) {
    // No slash found, return root
    return '/';
  }
  
  // Return everything up to the last slash
  return normalizedPath.substring(0, lastSlashIndex) || '/';
};

// Helper function to expand all parent folders of a path
export const expandParentFolders = (filePath, currentExpandedFolders) => {
  const parts = filePath.split('/').filter(Boolean);
  let currentPath = '';
  
  // Create a new expanded folders object
  const newExpandedFolders = { ...currentExpandedFolders };
  
  // Expand each parent folder
  for (let i = 0; i < parts.length; i++) {
    currentPath += '/' + parts[i];
    newExpandedFolders[currentPath] = true;
  }
  
  return newExpandedFolders;
};

// Get file icon based on file extension
export const getFileIconName = (fileName) => {
  if (fileName.endsWith('.md')) return 'FileText';
  if (fileName.endsWith('.jsx') || fileName.endsWith('.js')) return 'Code';
  if (fileName.endsWith('.json')) return 'Coffee';
  if (fileName.endsWith('.css')) return 'BookOpen';
  if (fileName.endsWith('.html')) return 'Globe';
  if (fileName.endsWith('.svg') || fileName.endsWith('.png') || fileName.endsWith('.jpg') || fileName.endsWith('.jpeg') || fileName.endsWith('.gif')) return 'Image';
  if (fileName.endsWith('.mp3') || fileName.endsWith('.wav') || fileName.endsWith('.ogg')) return 'Music';
  if (fileName.endsWith('.canvas')) return 'Figma';
  if (fileName.endsWith('.map')) return 'Map';
  return 'File';
};

// Helper function to get the active folder path based on selected item and current path
export const getActiveFolderPath = (selectedFile, currentPath) => {
  if (selectedFile) {
    // If selected item is a directory, use its path
    if (selectedFile.type === 'directory') {
      return selectedFile.path;
    }
    // If selected item is a file, use its parent directory
    return getParentDirectoryPath(selectedFile.path);
  }
  // Fall back to current path if no file is selected
  return currentPath;
};

================
File: src/components/windows/explorer/utils/markdownUtils.js
================
import showdown from 'showdown';

// Initialize Showdown converter for Markdown with enhanced options
export const createMarkdownConverter = () => {
  const converter = new showdown.Converter({
    tables: true,
    tasklists: true,
    strikethrough: true,
    emoji: true,
    breaks: true,  // Enable line breaks to be rendered as <br> tags
    simpleLineBreaks: true,
    openLinksInNewWindow: true,
    backslashEscapesHTMLTags: true,
    ghCodeBlocks: true,
    ghCompatibleHeaderId: true,
    ghMentions: true,
    smoothLivePreview: true
  });
  
  // Enable additional extensions
  converter.setFlavor('github');
  
  return converter;
};

// Insert markdown syntax at cursor position
export const insertMarkdown = (textareaRef, fileContent, setFileContent, prefix, suffix = '') => {
  const textarea = textareaRef.current;
  if (!textarea) return;
  
  const start = textarea.selectionStart;
  const end = textarea.selectionEnd;
  const text = fileContent;
  
  // If text is selected, wrap it with prefix and suffix
  if (start !== end) {
    const selectedText = text.substring(start, end);
    const newContent = text.substring(0, start) + prefix + selectedText + suffix + text.substring(end);
    setFileContent(newContent);
    
    // Set cursor position after the inserted text
    setTimeout(() => {
      textarea.selectionStart = start + prefix.length;
      textarea.selectionEnd = end + prefix.length;
      textarea.focus();
    }, 0);
  } else {
    // No selection, just insert at cursor
    const newContent = text.substring(0, start) + prefix + suffix + text.substring(start);
    setFileContent(newContent);
    
    // Move cursor between prefix and suffix
    setTimeout(() => {
      textarea.selectionStart = textarea.selectionEnd = start + prefix.length;
      textarea.focus();
    }, 0);
  }
};

// Insert list items
export const insertList = (textareaRef, fileContent, setFileContent, listPrefix) => {
  const textarea = textareaRef.current;
  if (!textarea) return;
  
  const start = textarea.selectionStart;
  const end = textarea.selectionEnd;
  const text = fileContent;
  
  // If text is selected, apply list formatting to each line
  if (start !== end) {
    const selectedText = text.substring(start, end);
    const lines = selectedText.split('\n');
    
    // Format each line as a list item
    const formattedLines = lines.map(line => {
      // Skip empty lines
      if (line.trim() === '') return line;
      
      // For numbered lists, increment the number for each line
      if (listPrefix === '1. ') {
        const index = lines.indexOf(line) + 1;
        return `${index}. ${line}`;
      }
      
      return `${listPrefix}${line}`;
    });
    
    const newContent = text.substring(0, start) + formattedLines.join('\n') + text.substring(end);
    setFileContent(newContent);
    
    // Set cursor position after the inserted text
    setTimeout(() => {
      textarea.selectionStart = start;
      textarea.selectionEnd = start + formattedLines.join('\n').length;
      textarea.focus();
    }, 0);
  } else {
    // No selection, just insert at cursor
    const newContent = text.substring(0, start) + listPrefix + text.substring(start);
    setFileContent(newContent);
    
    // Move cursor after the inserted prefix
    setTimeout(() => {
      textarea.selectionStart = textarea.selectionEnd = start + listPrefix.length;
      textarea.focus();
    }, 0);
  }
};

// Get the current line of text at cursor position
export const getCurrentLine = (text, cursorPos) => {
  const textBeforeCursor = text.substring(0, cursorPos);
  const lineStartPos = textBeforeCursor.lastIndexOf('\n') + 1;
  const lineEndPos = text.indexOf('\n', cursorPos);
  const actualLineEndPos = lineEndPos !== -1 ? lineEndPos : text.length;
  return text.substring(lineStartPos, actualLineEndPos);
};

// Handle keyboard events in the editor
export const handleEditorKeyDown = (e, textareaRef, fileContent, setFileContent) => {
  // Handle keyboard shortcuts
  if (e.ctrlKey || e.metaKey) {
    // Ctrl+B or Cmd+B for bold
    if (e.key === 'b') {
      e.preventDefault();
      insertMarkdown(textareaRef, fileContent, setFileContent, '**', '**');
      return;
    }
    
    // Ctrl+I or Cmd+I for italic
    if (e.key === 'i') {
      e.preventDefault();
      insertMarkdown(textareaRef, fileContent, setFileContent, '*', '*');
      return;
    }
    
    // Ctrl+Shift+L for unordered list
    if (e.shiftKey && e.key === 'L') {
      e.preventDefault();
      insertList(textareaRef, fileContent, setFileContent, '- ');
      return;
    }
    
    // Ctrl+Shift+O for ordered list
    if (e.shiftKey && e.key === 'O') {
      e.preventDefault();
      insertList(textareaRef, fileContent, setFileContent, '1. ');
      return;
    }
    
    // Ctrl+Shift+C for checklist
    if (e.shiftKey && e.key === 'C') {
      e.preventDefault();
      insertList(textareaRef, fileContent, setFileContent, '- [ ] ');
      return;
    }
  }
  
  // Auto-continue lists on Enter
  if (e.key === 'Enter' && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
    const textarea = textareaRef.current;
    if (!textarea) return;
    
    const cursorPos = textarea.selectionStart;
    const text = fileContent;
    const currentLine = getCurrentLine(text, cursorPos);
    
    // Check for list patterns
    const bulletListMatch = currentLine.match(/^(\s*)(-|\*|\+)\s+(.*)/);
    const numberedListMatch = currentLine.match(/^(\s*)(\d+)\.?\s+(.*)/);
    const checklistMatch = currentLine.match(/^(\s*)(-|\*|\+)\s+\[([ xX])\]\s+(.*)/);
    
    if (bulletListMatch || numberedListMatch || checklistMatch) {
      // Get the indentation and list marker
      let indentation, marker, content;
      
      if (checklistMatch) {
        indentation = checklistMatch[1];
        marker = checklistMatch[2];
        const checkState = checklistMatch[3];
        content = checklistMatch[4];
        
        // If the checklist item is empty, remove the list marker
        if (content.trim() === '') {
          e.preventDefault();
          const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
          const newContent = text.substring(0, lineStart) + text.substring(cursorPos);
          setFileContent(newContent);
          setTimeout(() => {
            textarea.selectionStart = textarea.selectionEnd = lineStart;
            textarea.focus();
          }, 0);
          return;
        }
        
        // Continue the checklist with an unchecked box
        e.preventDefault();
        const newListItem = `\n${indentation}${marker} [ ] `;
        insertMarkdown(textareaRef, fileContent, setFileContent, newListItem);
        return;
      } else if (bulletListMatch) {
        indentation = bulletListMatch[1];
        marker = bulletListMatch[2];
        content = bulletListMatch[3];
        
        // If the list item is empty, remove the list marker
        if (content.trim() === '') {
          e.preventDefault();
          const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
          const newContent = text.substring(0, lineStart) + text.substring(cursorPos);
          setFileContent(newContent);
          setTimeout(() => {
            textarea.selectionStart = textarea.selectionEnd = lineStart;
            textarea.focus();
          }, 0);
          return;
        }
        
        // Continue the bullet list
        e.preventDefault();
        const newListItem = `\n${indentation}${marker} `;
        insertMarkdown(textareaRef, fileContent, setFileContent, newListItem);
        return;
      } else if (numberedListMatch) {
        indentation = numberedListMatch[1];
        const number = parseInt(numberedListMatch[2], 10);
        content = numberedListMatch[3];
        
        // If the list item is empty, remove the list marker
        if (content.trim() === '') {
          e.preventDefault();
          const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
          const newContent = text.substring(0, lineStart) + text.substring(cursorPos);
          setFileContent(newContent);
          setTimeout(() => {
            textarea.selectionStart = textarea.selectionEnd = lineStart;
            textarea.focus();
          }, 0);
          return;
        }
        
        // Continue the numbered list with incremented number
        e.preventDefault();
        const newListItem = `\n${indentation}${number + 1}. `;
        insertMarkdown(textareaRef, fileContent, setFileContent, newListItem);
        return;
      }
    }
  }
  
  // Handle tab for indentation in lists
  if (e.key === 'Tab') {
    const textarea = textareaRef.current;
    if (!textarea) return;
    
    const cursorPos = textarea.selectionStart;
    const text = fileContent;
    const currentLine = getCurrentLine(text, cursorPos);
    
    // Check if we're in a list item
    const listMatch = currentLine.match(/^(\s*)(-|\*|\+|\d+\.|\[[ xX]\])\s+/);
    if (listMatch) {
      e.preventDefault();
      
      // Add or remove indentation based on shift key
      if (e.shiftKey) {
        // Outdent: remove 2 spaces from the beginning if they exist
        if (currentLine.startsWith('  ')) {
          const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
          const lineEnd = text.indexOf('\n', cursorPos);
          const actualLineEnd = lineEnd !== -1 ? lineEnd : text.length;
          
          const newContent = text.substring(0, lineStart) + currentLine.substring(2) + text.substring(actualLineEnd);
          setFileContent(newContent);
          
          // Adjust cursor position
          const newCursorPos = cursorPos - 2;
          setTimeout(() => {
            textarea.selectionStart = textarea.selectionEnd = newCursorPos > lineStart ? newCursorPos : lineStart;
            textarea.focus();
          }, 0);
        }
      } else {
        // Indent: add 2 spaces at the beginning
        const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
        const lineEnd = text.indexOf('\n', cursorPos);
        const actualLineEnd = lineEnd !== -1 ? lineEnd : text.length;
        
        const newContent = text.substring(0, lineStart) + '  ' + currentLine + text.substring(actualLineEnd);
        setFileContent(newContent);
        
        // Adjust cursor position
        const newCursorPos = cursorPos + 2;
        setTimeout(() => {
          textarea.selectionStart = textarea.selectionEnd = newCursorPos;
          textarea.focus();
        }, 0);
      }
    }
  }
};

// Convert markdown to HTML
export const convertMarkdownToHtml = (converter, markdown) => {
  return converter.makeHtml(markdown);
};

================
File: src/components/windows/ExplorerWindow-fix.jsx
================
// This is a patch file that contains only important modifications to fix the file persistence issue
// You should compare this with your existing ExplorerWindow.jsx and integrate these changes

// KEY CHANGES:

// 1. In handleFileSelect function, add this line AFTER setting the selected file:
/*
    // Make sure parent folders are expanded so the file is visible on reload
    expandParentFolders(file.path);
*/

// 2. In loadExplorerState function, when restoring a file, add this code to ensure proper path setting:
/*
    // Important: Update the currentPath to ensure parent directories are visible
    if (restoredFile.type === 'file') {
      // For files, set the current path to the parent directory
      const parentPath = getParentDirectoryPath(restoredFile.path);
      setCurrentPath(parentPath);
    } else {
      // For directories, set the current path to the directory itself
      setCurrentPath(restoredFile.path);
    }
*/

// 3. Add a debounce for explorer state saving by adding a new ref:
/*
    const explorerSaveTimeoutRef = useRef(null); // New ref for debounced explorer state saving
*/

// 4. Modify the useEffect that saves explorer state to add debounce:
/*
  // Save explorer state to IndexedDB when it changes
  useEffect(() => {
    // Early return if state hasn't been loaded yet (prevents overwriting with default values)
    if (!stateLoadedRef.current) return;
    
    // Clear any existing timeout
    if (explorerSaveTimeoutRef.current) {
      clearTimeout(explorerSaveTimeoutRef.current);
    }
    
    // Save the explorer state to IndexedDB with debounce
    explorerSaveTimeoutRef.current = setTimeout(() => {
      console.log(`Saving explorer state for window ${nodeId}:`, {
        selectedFile,
        expandedFolders,
        activeTab
      });
      
      saveExplorerState({
        id: nodeId,
        content: {
          selectedFile,
          expandedFolders,
          activeTab
        }
      }).catch(error => {
        console.error(`Failed to save explorer state for window ${nodeId} to IndexedDB:`, error);
      });
    }, 300); // 300ms debounce
    
    // Clear timeout on cleanup
    return () => {
      if (explorerSaveTimeoutRef.current) {
        clearTimeout(explorerSaveTimeoutRef.current);
      }
    };
  }, [selectedFile, expandedFolders, activeTab, nodeId]);
*/

// 5. Modify the initial directory loading code to ensure selected files have their parent folders expanded:
/*
  // Load initial directory contents
  useEffect(() => {
    // Load public files for all users
    fetchPublicDirectoryContents('/', true).then(() => {
      // After files are loaded, try to restore expanded state for the selected file
      if (selectedFile) {
        console.log('Ensuring parent folders for selected file are expanded:', selectedFile.path);
        expandParentFolders(selectedFile.path);
      }
    });
    
    // Load private files for admin users
    if (isAdmin) {
      fetchDirectoryContents('/', true).catch(error => {
        console.error('Failed to load private files:', error);
        // Set a specific error message for private files without affecting public files
        setFiles([]);
        if (activeTab === 'private') {
          setErrorMessage('Failed to load private files. Please ensure your admin directory exists.');
        }
      });
    }
  }, [isAdmin, activeTab]);
*/

// 6. Always set stateLoaded to true in loadExplorerState even if no state is found:
/*
  if (savedState && savedState.content) {
    // ... existing code ...
  } else {
    // Even if no state is loaded, mark as loaded to allow future saves
    stateLoadedRef.current = true;
  }
*/

================
File: src/components/windows/ExplorerWindow.css
================
/* Markdown content styling */
.markdown-content {
    color: #f0f9ff; /* Light blue-white for readability */
    line-height: 1;
    font-family: 'Oxygen Mono', monospace;
    padding: 1rem;
    white-space: pre-wrap; /* Preserve line breaks */
  }

  /* Bold text styling */
  .markdown-content strong {
    font-weight: 700;
    color: #2dd4bf; /* Teal accent color to make bold text stand out */
  }
  
  /* Italic text styling */
  .markdown-content em {
    font-style: italic;
    color: #a5f3fc; /* Light cyan for emphasis */
  }
  
  /* Header styles with clear size differences */
  .markdown-content h1 {
    font-size: 2.5rem;
    font-weight: 700;
    margin-top: 1.5rem;
    margin-bottom: 1rem;
    color: #2dd4bf; /* Teal accent color */
    border-bottom: 1px solid #44403c;
    padding-bottom: 0.5rem;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content h2 {
    font-size: 2rem;
    font-weight: 600;
    margin-top: 1.5rem;
    margin-bottom: 0.75rem;
    color: #2dd4bf;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content h3 {
    font-size: 1.75rem;
    font-weight: 600;
    margin-top: 1.25rem;
    margin-bottom: 0.75rem;
    color: #2dd4bf;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content h4 {
    font-size: 1.5rem;
    font-weight: 600;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    color: #2dd4bf;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content h5 {
    font-size: 1.25rem;
    font-weight: 600;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    color: #2dd4bf;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content h6 {
    font-size: 1rem;
    font-weight: 600;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    color: #2dd4bf;
    font-family: 'Oxygen Mono', monospace;
  }
  
  /* Paragraph styling */
  .markdown-content p {
    margin-top: 0.5rem;
    margin-bottom: 0.5rem;
    font-family: 'Oxygen Mono', monospace;
  }
  
  /* Make sure the code blocks stand out */
  .markdown-content pre {
    background-color: #1c1917; /* Darker background for code */
    border-radius: 0.25rem;
    padding: 1rem;
    overflow-x: auto;
    margin: 1rem 0;
    font-family: 'Oxygen Mono', monospace;
    font-size: 0.875rem;
    line-height: 1;
  }
  
  .markdown-content code {
    font-family: 'Oxygen Mono', monospace;
    background-color: #1c1917;
    padding: 0.2rem 0.4rem;
    border-radius: 0.25rem;
    font-size: 0.875em;
  }
  
  /* Add some spacing between sections */
  .markdown-content br + h1,
  .markdown-content br + h2,
  .markdown-content br + h3,
  .markdown-content br + h4,
  .markdown-content br + h5,
  .markdown-content br + h6 {
    margin-top: 0.5rem;
  }
  
/* Lists */
.markdown-content ul, .markdown-content ol {
  margin-top: 0.5rem;
  margin-bottom: 1rem;
  padding-left: 2rem;
  font-family: 'Oxygen Mono', monospace;
  list-style-position: outside;
}

/* Bullet points */
.markdown-content ul {
  list-style-type: disc;
}

/* Numbered lists */
.markdown-content ol {
  list-style-type: decimal;
}

.markdown-content li {
  margin-top: 0.25rem;
  margin-bottom: 0.25rem;
  padding-left: 0.5rem;
  display: list-item;
}

/* Make sure list items are clearly visible */
.markdown-content ul > li::marker {
  color: #2dd4bf; /* Teal color for bullet points */
}

.markdown-content ol > li::marker {
  color: #2dd4bf; /* Teal color for numbers */
  font-weight: bold;
}

/* Task lists (checkboxes) */
.markdown-content .task-list {
  list-style-type: none;
  padding-left: 0.5rem;
}

.markdown-content .task-list-item {
  display: flex;
  align-items: flex-start;
  margin-bottom: 0.5rem;
}

.markdown-content .task-list-item-checkbox {
  margin-right: 0.5rem;
  margin-top: 0.25rem;
  appearance: none;
  -webkit-appearance: none;
  width: 1rem;
  height: 1rem;
  border: 1px solid #2dd4bf;
  border-radius: 0.25rem;
  background-color: #1c1917;
  cursor: pointer;
  position: relative;
}

.markdown-content .task-list-item-checkbox:checked {
  background-color: #2dd4bf;
}

.markdown-content .task-list-item-checkbox:checked::after {
  content: '';
  position: absolute;
  color: #1c1917;
  font-size: 0.75rem;
  top: -0.125rem;
  left: 0.125rem;
}

/* Alternative styling for checklists as rendered by Showdown */
.markdown-content ul li input[type="checkbox"] {
  margin-right: 0.5rem;
  margin-top: 0.25rem;
  appearance: none;
  -webkit-appearance: none;
  width: 1rem;
  height: 1rem;
  border: 1px solid #2dd4bf;
  border-radius: 0.25rem;
  background-color: #1c1917;
  cursor: pointer;
  position: relative;
  vertical-align: middle;
}

.markdown-content ul li input[type="checkbox"]:checked {
  background-color: #2dd4bf;
}

.markdown-content ul li input[type="checkbox"]:checked::after {
  content: '';
  position: absolute;
  color: #1c1917;
  font-size: 0.75rem;
  top: -0.125rem;
  left: 0.125rem;
}

/* Remove default bullets for checklist items */
.markdown-content ul li:has(input[type="checkbox"]) {
  list-style-type: none;
  margin-left: -1.5rem;
}

/* Specific styling for Showdown's task list output */
.markdown-content ul.contains-task-list {
  list-style-type: none;
  padding-left: 1rem;
}

.markdown-content ul.contains-task-list li.task-list-item {
  list-style-type: none;
  padding-left: 0;
  display: flex;
  align-items: center;
}

/* Nested lists */
.markdown-content ul ul,
.markdown-content ol ol,
.markdown-content ul ol,
.markdown-content ol ul {
  margin-top: 0.25rem;
  margin-bottom: 0.25rem;
}
  
  /* Links */
  .markdown-content a {
    color: #14b8a6;
    text-decoration: underline;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content a:hover {
    color: #2dd4bf;
  }

/* Drag and drop styles */
[draggable] {
  cursor: grab;
}

[draggable]:active {
  cursor: grabbing;
}

/* Style for the drop target when dragging over */
.drop-target {
  background-color: rgba(20, 184, 166, 0.2) !important;
  border: 2px dashed rgb(20, 184, 166) !important;
  border-radius: 0.25rem;
}

/* Style for the item being dragged */
.dragging {
  opacity: 0.5;
  background-color: rgba(20, 184, 166, 0.1);
}

================
File: src/components/windows/ExplorerWindow.jsx
================
import React, { useState, useEffect, useRef, useCallback } from 'react';
import { 
  FolderOpen, FileText, ChevronRight, ChevronDown, File, Coffee, Code, 
  BookOpen, Edit, Eye, Plus, FolderPlus, X, Globe, Lock, FileEdit, Trash2,
  List, ListOrdered, CheckSquare, Bold, Italic, Code as CodeIcon, Link, Heading
} from 'lucide-react';
import showdown from 'showdown';
import path from 'path-browserify';
import API_CONFIG from '../../config/api';
import { useAuth } from '../../context/AuthContext';
import { useWindowState } from '../../context/WindowStateContext';
import { WINDOW_TYPES } from '../../utils/windowTypes';
import { saveExplorerState, getExplorerState } from '../../services/indexedDBService';
import './ExplorerWindow.css';

const ExplorerWindow = ({ isActive, nodeId, onCommand, transformWindow, windowState, updateWindowState, focusRef }) => {
  // Get auth context to check if user is admin
  const { user } = useAuth();
  const isAdmin = user?.is_admin || false;
  
  // Get window state context for additional persistence
  const { setActiveWindow } = useWindowState();
  
  // Ref to track if state has been loaded from IndexedDB
  const stateLoadedRef = useRef(false);
  
  // Use state from windowState or initialize with defaults
  const [files, setFiles] = useState([]);
  const [publicFiles, setPublicFiles] = useState([]);
  const [currentPath, setCurrentPath] = useState(windowState?.currentPath || '/');
  const [selectedFile, setSelectedFile] = useState(windowState?.selectedFile || null);
  const [expandedFolders, setExpandedFolders] = useState(windowState?.expandedFolders || {});
  const [isTreeLoading, setIsTreeLoading] = useState(true);
  const [isContentLoading, setIsContentLoading] = useState(false);
  const [fileContent, setFileContent] = useState(windowState?.fileContent || '');
  const [errorMessage, setErrorMessage] = useState('');
  const [showPreview, setShowPreview] = useState(windowState?.showPreview || false);
  const [activeTab, setActiveTab] = useState(windowState?.activeTab || 'public'); // 'public' or 'private'
  
  // Additional state for markdown editing
  const [editMode, setEditMode] = useState(windowState?.editMode || false);
  const [saveStatus, setSaveStatus] = useState('saved'); // 'saved', 'saving', 'error'
  
  // State for file/folder creation
  const [showCreateDialog, setShowCreateDialog] = useState(false);
  const [createType, setCreateType] = useState('file'); // 'file' or 'directory'
  const [newItemName, setNewItemName] = useState('');
  const [isCreating, setIsCreating] = useState(false);
  
  // State for file/folder renaming
  const [showRenameDialog, setShowRenameDialog] = useState(false);
  const [itemToRename, setItemToRename] = useState(null);
  const [newName, setNewName] = useState('');
  const [isRenaming, setIsRenaming] = useState(false);
  
  // State for file/folder deletion
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [itemToDelete, setItemToDelete] = useState(null);
  const [isDeleting, setIsDeleting] = useState(false);
  
  // State for drag and drop
  const [draggedItem, setDraggedItem] = useState(null);
  const [dropTarget, setDropTarget] = useState(null);
  const [isMoving, setIsMoving] = useState(false);
  
  // For auto-save functionality and editor references
  const saveTimeoutRef = useRef(null);
  const createInputRef = useRef(null);
  const renameInputRef = useRef(null);
  const textareaRef = useRef(null);
  
  // Initialize Showdown converter for Markdown with enhanced options
  const converter = new showdown.Converter({
    tables: true,
    tasklists: true,
    strikethrough: true,
    emoji: true,
    breaks: true,  // Enable line breaks to be rendered as <br> tags
    simpleLineBreaks: true,
    openLinksInNewWindow: true,
    backslashEscapesHTMLTags: true,
    ghCodeBlocks: true,
    ghCompatibleHeaderId: true,
    ghMentions: true,
    smoothLivePreview: true
  });
  
  // Enable additional extensions
  converter.setFlavor('github');

  // Helper function to expand all parent folders of a path
  const expandParentFolders = (filePath) => {
    const parts = filePath.split('/').filter(Boolean);
    let currentPath = '';
    
    // Create a new expanded folders object
    const newExpandedFolders = { ...expandedFolders };
    
    // Expand each parent folder
    for (let i = 0; i < parts.length; i++) {
      currentPath += '/' + parts[i];
      newExpandedFolders[currentPath] = true;
    }
    
    setExpandedFolders(newExpandedFolders);
  };

  // Function to fetch public directory contents
  const fetchPublicDirectoryContents = async (publicPath = '/', refreshAll = false) => {
    try {
      setIsTreeLoading(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsTreeLoading(false);
        return;
      }
      
      // If refreshAll is true, start from the root
      const pathToFetch = refreshAll ? '/' : publicPath;
      
      // Fetch public directory contents from the server
      const response = await fetch(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PUBLIC_FILES_LIST}?path=${encodeURIComponent(pathToFetch)}`,
        {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        }
      );
      
      if (!response.ok) {
        setErrorMessage(`Failed to load public files: ${response.statusText}`);
        setIsTreeLoading(false);
        return;
      }
      
      const data = await response.json();
      
      // Transform the data to match our expected format
      const transformedFiles = data.items.map(item => ({
        name: item.name,
        type: item.type,
        path: item.path,
        children: item.children || [],
        isPublic: true
      }));
      
      setPublicFiles(transformedFiles);
      
      // Only update the current path if we're not refreshing the entire tree
      if (!refreshAll) {
        setCurrentPath(publicPath);
      }
      
      setIsTreeLoading(false);
      
      // If we refreshed the entire tree, make sure the current path's parent folders are expanded
      if (refreshAll && currentPath !== '/') {
        expandParentFolders(currentPath);
      }
    } catch (error) {
      console.error('Error fetching public directory contents:', error);
      setErrorMessage('Failed to load public files. Please try again.');
      setIsTreeLoading(false);
    }
  };

  // Function to fetch public file content
  const fetchPublicFileContent = async (filePath) => {
    try {
      setIsContentLoading(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsContentLoading(false);
        return;
      }
      
      // Fetch public file content from the server
      const response = await fetch(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PUBLIC_FILE_CONTENT}?path=${encodeURIComponent(filePath)}`,
        {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        }
      );
      
      if (!response.ok) {
        setErrorMessage(`Failed to load file content: ${response.statusText}`);
        setIsContentLoading(false);
        return;
      }
      
      const data = await response.json();
      setFileContent(data.content);
      setIsContentLoading(false);
      setSaveStatus('saved');
    } catch (error) {
      console.error('Error fetching public file content:', error);
      setErrorMessage(`Error loading file: ${error.message}`);
      setSaveStatus('error');
      setIsContentLoading(false);
    }
  };

  // Function to fetch private directory contents from the server (admin only)
  const fetchDirectoryContents = async (path = '/', refreshAll = false) => {
    try {
      setIsTreeLoading(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsTreeLoading(false);
        return;
      }
      
      // If refreshAll is true, start from the root
      const pathToFetch = refreshAll ? '/' : path;
      
      // Fetch directory contents from the server
      const response = await fetch(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILES_LIST}?path=${encodeURIComponent(pathToFetch)}`,
        {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        }
      );
      
      if (!response.ok) {
        // If response is 403, it means the user doesn't have admin access
        if (response.status === 403) {
          setErrorMessage('Admin access required to view files.');
        } else {
          setErrorMessage(`Failed to load files: ${response.statusText}`);
        }
        setIsTreeLoading(false);
        return;
      }
      
      const data = await response.json();
      
      // Transform the data to match our expected format
      const transformedFiles = data.items.map(item => ({
        name: item.name,
        type: item.type,
        path: item.path,
        children: item.children || []
      }));
      
      setFiles(transformedFiles);
      
      // Only update the current path if we're not refreshing the entire tree
      if (!refreshAll) {
        setCurrentPath(path);
      }
      
      setIsTreeLoading(false);
      
      // If we refreshed the entire tree, make sure the current path's parent folders are expanded
      if (refreshAll && currentPath !== '/') {
        expandParentFolders(currentPath);
      }
    } catch (error) {
      console.error('Error fetching directory contents:', error);
      setErrorMessage('Failed to load files. Please try again.');
      setIsTreeLoading(false);
    }
  };

  // Function to fetch file content
  const fetchFileContent = async (filePath) => {
    try {
      setIsContentLoading(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsContentLoading(false);
        return;
      }
      
      // Fetch file content from the server
      const response = await fetch(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_CONTENT}?path=${encodeURIComponent(filePath)}`,
        {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        }
      );
      
      if (!response.ok) {
        // If response is 403, it means the user doesn't have admin access
        if (response.status === 403) {
          setErrorMessage('Admin access required to view file content.');
        } else {
          setErrorMessage(`Failed to load file content: ${response.statusText}`);
        }
        setIsContentLoading(false);
        return;
      }
      
      const data = await response.json();
      setFileContent(data.content);
      setIsContentLoading(false);
      setSaveStatus('saved');
    } catch (error) {
      console.error('Error fetching file content:', error);
      setErrorMessage(`Error loading file: ${error.message}`);
      setSaveStatus('error');
      setIsContentLoading(false);
    }
  };
  
  // Function to save file content
  const saveFileContent = async () => {
    try {
      // Check if filePath is valid
      if (!selectedFile || !selectedFile.path || selectedFile.path.trim() === '') {
        setErrorMessage('No file selected. Please select a file first.');
        setSaveStatus('error');
        return;
      }
      
      setSaveStatus('saving');
      
      const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_SAVE}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
        },
        body: JSON.stringify({
          path: selectedFile.path,
          content: fileContent
        })
      });
      
      if (!response.ok) {
        throw new Error(`Failed to save file: ${response.statusText}`);
      }
      
      setSaveStatus('saved');
      setErrorMessage('');
    } catch (error) {
      console.error('Error saving file:', error);
      setErrorMessage(`Error saving file: ${error.message}`);
      setSaveStatus('error');
    }
  };
  
  // Insert markdown syntax at cursor position
  const insertMarkdown = (prefix, suffix = '') => {
    const textarea = textareaRef.current;
    if (!textarea) return;
    
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const text = fileContent;
    
    // If text is selected, wrap it with prefix and suffix
    if (start !== end) {
      const selectedText = text.substring(start, end);
      const newContent = text.substring(0, start) + prefix + selectedText + suffix + text.substring(end);
      setFileContent(newContent);
      
      // Set cursor position after the inserted text
      setTimeout(() => {
        textarea.selectionStart = start + prefix.length;
        textarea.selectionEnd = end + prefix.length;
        textarea.focus();
      }, 0);
    } else {
      // No selection, just insert at cursor
      const newContent = text.substring(0, start) + prefix + suffix + text.substring(start);
      setFileContent(newContent);
      
      // Move cursor between prefix and suffix
      setTimeout(() => {
        textarea.selectionStart = textarea.selectionEnd = start + prefix.length;
        textarea.focus();
      }, 0);
    }
  };
  
  // Insert list items
  const insertList = (listPrefix) => {
    const textarea = textareaRef.current;
    if (!textarea) return;
    
    const start = textarea.selectionStart;
    const end = textarea.selectionEnd;
    const text = fileContent;
    
    // If text is selected, apply list formatting to each line
    if (start !== end) {
      const selectedText = text.substring(start, end);
      const lines = selectedText.split('\n');
      
      // Format each line as a list item
      const formattedLines = lines.map(line => {
        // Skip empty lines
        if (line.trim() === '') return line;
        
        // For numbered lists, increment the number for each line
        if (listPrefix === '1. ') {
          const index = lines.indexOf(line) + 1;
          return `${index}. ${line}`;
        }
        
        return `${listPrefix}${line}`;
      });
      
      const newContent = text.substring(0, start) + formattedLines.join('\n') + text.substring(end);
      setFileContent(newContent);
      
      // Set cursor position after the inserted text
      setTimeout(() => {
        textarea.selectionStart = start;
        textarea.selectionEnd = start + formattedLines.join('\n').length;
        textarea.focus();
      }, 0);
    } else {
      // No selection, just insert at cursor
      const newContent = text.substring(0, start) + listPrefix + text.substring(start);
      setFileContent(newContent);
      
      // Move cursor after the inserted prefix
      setTimeout(() => {
        textarea.selectionStart = textarea.selectionEnd = start + listPrefix.length;
        textarea.focus();
      }, 0);
    }
  };
  
  // Get the current line of text at cursor position
  const getCurrentLine = (text, cursorPos) => {
    const textBeforeCursor = text.substring(0, cursorPos);
    const lineStartPos = textBeforeCursor.lastIndexOf('\n') + 1;
    const lineEndPos = text.indexOf('\n', cursorPos);
    const actualLineEndPos = lineEndPos !== -1 ? lineEndPos : text.length;
    return text.substring(lineStartPos, actualLineEndPos);
  };
  
  // Handle keyboard events in the editor
  const handleEditorKeyDown = (e) => {
    // Handle keyboard shortcuts
    if (e.ctrlKey || e.metaKey) {
      // Ctrl+B or Cmd+B for bold
      if (e.key === 'b') {
        e.preventDefault();
        insertMarkdown('**', '**');
        return;
      }
      
      // Ctrl+I or Cmd+I for italic
      if (e.key === 'i') {
        e.preventDefault();
        insertMarkdown('*', '*');
        return;
      }
      
      // Ctrl+Shift+L for unordered list
      if (e.shiftKey && e.key === 'L') {
        e.preventDefault();
        insertList('- ');
        return;
      }
      
      // Ctrl+Shift+O for ordered list
      if (e.shiftKey && e.key === 'O') {
        e.preventDefault();
        insertList('1. ');
        return;
      }
      
      // Ctrl+Shift+C for checklist
      if (e.shiftKey && e.key === 'C') {
        e.preventDefault();
        insertList('- [ ] ');
        return;
      }
    }
    
    // Auto-continue lists on Enter
    if (e.key === 'Enter' && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
      const textarea = textareaRef.current;
      if (!textarea) return;
      
      const cursorPos = textarea.selectionStart;
      const text = fileContent;
      const currentLine = getCurrentLine(text, cursorPos);
      
      // Check for list patterns
      const bulletListMatch = currentLine.match(/^(\s*)(-|\*|\+)\s+(.*)/);
      const numberedListMatch = currentLine.match(/^(\s*)(\d+)\.?\s+(.*)/);
      const checklistMatch = currentLine.match(/^(\s*)(-|\*|\+)\s+\[([ xX])\]\s+(.*)/);
      
      if (bulletListMatch || numberedListMatch || checklistMatch) {
        // Get the indentation and list marker
        let indentation, marker, content;
        
        if (checklistMatch) {
          indentation = checklistMatch[1];
          marker = checklistMatch[2];
          const checkState = checklistMatch[3];
          content = checklistMatch[4];
          
          // If the checklist item is empty, remove the list marker
          if (content.trim() === '') {
            e.preventDefault();
            const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
            const newContent = text.substring(0, lineStart) + text.substring(cursorPos);
            setFileContent(newContent);
            setTimeout(() => {
              textarea.selectionStart = textarea.selectionEnd = lineStart;
              textarea.focus();
            }, 0);
            return;
          }
          
          // Continue the checklist with an unchecked box
          e.preventDefault();
          const newListItem = `\n${indentation}${marker} [ ] `;
          insertMarkdown(newListItem);
          return;
        } else if (bulletListMatch) {
          indentation = bulletListMatch[1];
          marker = bulletListMatch[2];
          content = bulletListMatch[3];
          
          // If the list item is empty, remove the list marker
          if (content.trim() === '') {
            e.preventDefault();
            const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
            const newContent = text.substring(0, lineStart) + text.substring(cursorPos);
            setFileContent(newContent);
            setTimeout(() => {
              textarea.selectionStart = textarea.selectionEnd = lineStart;
              textarea.focus();
            }, 0);
            return;
          }
          
          // Continue the bullet list
          e.preventDefault();
          const newListItem = `\n${indentation}${marker} `;
          insertMarkdown(newListItem);
          return;
        } else if (numberedListMatch) {
          indentation = numberedListMatch[1];
          const number = parseInt(numberedListMatch[2], 10);
          content = numberedListMatch[3];
          
          // If the list item is empty, remove the list marker
          if (content.trim() === '') {
            e.preventDefault();
            const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
            const newContent = text.substring(0, lineStart) + text.substring(cursorPos);
            setFileContent(newContent);
            setTimeout(() => {
              textarea.selectionStart = textarea.selectionEnd = lineStart;
              textarea.focus();
            }, 0);
            return;
          }
          
          // Continue the numbered list with incremented number
          e.preventDefault();
          const newListItem = `\n${indentation}${number + 1}. `;
          insertMarkdown(newListItem);
          return;
        }
      }
    }
    
    // Handle tab for indentation in lists
    if (e.key === 'Tab') {
      const textarea = textareaRef.current;
      if (!textarea) return;
      
      const cursorPos = textarea.selectionStart;
      const text = fileContent;
      const currentLine = getCurrentLine(text, cursorPos);
      
      // Check if we're in a list item
      const listMatch = currentLine.match(/^(\s*)(-|\*|\+|\d+\.|\[[ xX]\])\s+/);
      if (listMatch) {
        e.preventDefault();
        
        // Add or remove indentation based on shift key
        if (e.shiftKey) {
          // Outdent: remove 2 spaces from the beginning if they exist
          if (currentLine.startsWith('  ')) {
            const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
            const lineEnd = text.indexOf('\n', cursorPos);
            const actualLineEnd = lineEnd !== -1 ? lineEnd : text.length;
            
            const newContent = text.substring(0, lineStart) + currentLine.substring(2) + text.substring(actualLineEnd);
            setFileContent(newContent);
            
            // Adjust cursor position
            const newCursorPos = cursorPos - 2;
            setTimeout(() => {
              textarea.selectionStart = textarea.selectionEnd = newCursorPos > lineStart ? newCursorPos : lineStart;
              textarea.focus();
            }, 0);
          }
        } else {
          // Indent: add 2 spaces at the beginning
          const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
          const lineEnd = text.indexOf('\n', cursorPos);
          const actualLineEnd = lineEnd !== -1 ? lineEnd : text.length;
          
          const newContent = text.substring(0, lineStart) + '  ' + currentLine + text.substring(actualLineEnd);
          setFileContent(newContent);
          
          // Adjust cursor position
          const newCursorPos = cursorPos + 2;
          setTimeout(() => {
            textarea.selectionStart = textarea.selectionEnd = newCursorPos;
            textarea.focus();
          }, 0);
        }
      }
    }
  };
  
  // Handle markdown content change
  const handleMarkdownChange = (e) => {
    setFileContent(e.target.value);
  };

  // Load explorer state from IndexedDB on mount
  useEffect(() => {
    const loadExplorerState = async () => {
      try {
        // Try to load explorer state from IndexedDB
        const savedState = await getExplorerState(nodeId);
        
        if (savedState && savedState.content && !stateLoadedRef.current) {
          console.log(`Loaded explorer state for window ${nodeId} from IndexedDB:`, savedState.content);
          
          let restoredFile = null;
          
          // Update state with saved values
          if (savedState.content.selectedFile) {
            restoredFile = savedState.content.selectedFile;
            setSelectedFile(restoredFile);
          }
          
          if (savedState.content.expandedFolders) {
            setExpandedFolders(savedState.content.expandedFolders);
          }
          
          if (savedState.content.activeTab) {
            setActiveTab(savedState.content.activeTab);
          }
          
          // Mark as loaded
          stateLoadedRef.current = true;
          
          // If a file was restored and it's a markdown file, load its content
          if (restoredFile && restoredFile.type === 'file' && restoredFile.name.endsWith('.md')) {
            // Set the preview mode for markdown files
            setShowPreview(true);
            
            // Load the file content based on whether it's a public or private file
            if (restoredFile.isPublic) {
              // Fetch public file content
              fetchPublicFileContent(restoredFile.path);
            } else if (isAdmin) {
              // Fetch private file content (admin only)
              fetchFileContent(restoredFile.path);
            }
          }
        }
      } catch (error) {
        console.error(`Failed to load explorer state for window ${nodeId} from IndexedDB:`, error);
      }
    };
    
    loadExplorerState();
  }, [nodeId, isAdmin]);
  
  // Handle window activation
  useEffect(() => {
    if (isActive) {
      // Save this as the active explorer window
      setActiveWindow(nodeId, WINDOW_TYPES.EXPLORER);
    }
  }, [isActive, nodeId, setActiveWindow]);
  
  // Save explorer state to IndexedDB when it changes
  useEffect(() => {
    if (!stateLoadedRef.current) return;
    
    // Save the explorer state to IndexedDB
    saveExplorerState({
      id: nodeId,
      content: {
        selectedFile,
        expandedFolders,
        activeTab
      }
    }).catch(error => {
      console.error(`Failed to save explorer state for window ${nodeId} to IndexedDB:`, error);
    });
    
  }, [selectedFile, expandedFolders, activeTab, nodeId]);

  // Load initial directory contents
  useEffect(() => {
    // Load public files for all users
    fetchPublicDirectoryContents();
    
    // Load private files for admin users
    if (isAdmin) {
      fetchDirectoryContents().catch(error => {
        console.error('Failed to load private files:', error);
        // Set a specific error message for private files without affecting public files
        setFiles([]);
        if (activeTab === 'private') {
          setErrorMessage('Failed to load private files. Please ensure your admin directory exists.');
        }
      });
    }
  }, [isAdmin]);

  // Reset content states when switching tabs
  useEffect(() => {
    // Clear file content and reset view states when changing tabs
    setSelectedFile(null);
    setFileContent('');
    setShowPreview(false);
    setEditMode(false);
    setSaveStatus('saved');
    setErrorMessage('');
    
    // Reset current path to root for the selected tab
    setCurrentPath('/');
  }, [activeTab]);

  // Auto-save functionality with debounce
  useEffect(() => {
    // Only auto-save if in edit mode, user is admin, and we have a markdown file selected
    if (editMode && isAdmin && selectedFile && selectedFile.name.endsWith('.md') && fileContent) {
      // Clear any existing timeout
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
      
      // Set status to saving
      setSaveStatus('saving');
      
      // Set a new timeout for auto-save
      saveTimeoutRef.current = setTimeout(() => {
        saveFileContent();
      }, 1000); // 1 second debounce
    }
    
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, [fileContent, editMode, isAdmin, selectedFile]);

  // Update window state when relevant state changes
  useEffect(() => {
    if (updateWindowState) {
      updateWindowState({
        currentPath,
        selectedFile,
        expandedFolders,
        fileContent,
        showPreview,
        editMode,
        saveStatus,
        activeTab
      });
    }
  }, [currentPath, selectedFile, expandedFolders, fileContent, showPreview, editMode, saveStatus, activeTab, updateWindowState]);
  
  // Focus the input field when the create or rename dialog is shown
  useEffect(() => {
    if (showCreateDialog && createInputRef.current) {
      createInputRef.current.focus();
    }
    if (showRenameDialog && renameInputRef.current) {
      renameInputRef.current.focus();
    }
  }, [showCreateDialog, showRenameDialog]);

  // Toggle folder expansion
  const toggleFolder = (folderPath, folder) => {
    const isExpanding = !expandedFolders[folderPath];
    
    setExpandedFolders(prev => ({
      ...prev,
      [folderPath]: isExpanding
    }));
    
    // If we're expanding the folder, also set it as the current path
    if (isExpanding) {
      setCurrentPath(folderPath);
      setSelectedFile(folder);
    }
  };
  
  // Helper function to get the active folder path based on selected item and current path
  const getActiveFolderPath = () => {
    if (selectedFile) {
      // If selected item is a directory, use its path
      if (selectedFile.type === 'directory') {
        return selectedFile.path;
      }
      // If selected item is a file, use its parent directory
      return getParentDirectoryPath(selectedFile.path);
    }
    // Fall back to current path if no file is selected
    return currentPath;
  };
  
  // Create a new file or folder
  const createNewItem = async () => {
    if (!newItemName.trim()) {
      setErrorMessage('Name cannot be empty');
      return;
    }
    
    try {
      setIsCreating(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsCreating(false);
        return;
      }
      
      // Determine if we're creating in the public folder or private folder
      const isPublicFolder = activeTab === 'public';
      
      // Get the active folder path where the new item should be created
      const activeFolderPath = getActiveFolderPath();
      
      // Construct the full path for the new item
      let newItemPath;
      if (isPublicFolder) {
        // For public folder, prefix with /public if not already included
        const publicPrefix = activeFolderPath.startsWith('/public') ? '' : '/public';
        newItemPath = path.join(publicPrefix, activeFolderPath, newItemName.trim()).replace(/\\/g, '/');
      } else {
        // For private folder (admin only)
        newItemPath = path.join(activeFolderPath, newItemName.trim()).replace(/\\/g, '/');
      }
      
      // Create the new file or folder
      const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_CREATE}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          path: newItemPath,
          type: createType,
          content: createType === 'file' ? '' : undefined
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || `Failed to create ${createType}: ${response.statusText}`);
      }
      
      // Close the dialog and reset the form
      setShowCreateDialog(false);
      setNewItemName('');
      
      // Refresh the entire file tree from the root
      if (isPublicFolder) {
        fetchPublicDirectoryContents('/', true);
      } else {
        fetchDirectoryContents('/', true);
      }
      
      // If it's a directory, expand it
      if (createType === 'directory') {
        setExpandedFolders(prev => ({
          ...prev,
          [newItemPath]: true
        }));
      }
      
      setIsCreating(false);
    } catch (error) {
      console.error(`Error creating ${createType}:`, error);
      setErrorMessage(`Failed to create ${createType}: ${error.message}`);
      setIsCreating(false);
    }
  };
  
  // Open the create dialog
  const openCreateDialog = (type) => {
    setCreateType(type);
    setNewItemName('');
    setErrorMessage('');
    setShowCreateDialog(true);
  };
  
  // Close the create dialog
  const closeCreateDialog = () => {
    setShowCreateDialog(false);
    setNewItemName('');
    setErrorMessage('');
  };
  
  // Handle key press in the create dialog
  const handleCreateKeyPress = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      createNewItem();
    } else if (e.key === 'Escape') {
      closeCreateDialog();
    }
  };

  // Open the rename dialog for a file or folder
  const openRenameDialog = (item) => {
    if (!isAdmin) {
      setErrorMessage('Admin access required to rename files.');
      return;
    }
    
    setItemToRename(item);
    setNewName(item.name);
    setErrorMessage('');
    setShowRenameDialog(true);
  };
  
  // Close the rename dialog
  const closeRenameDialog = () => {
    setShowRenameDialog(false);
    setItemToRename(null);
    setNewName('');
    setErrorMessage('');
  };
  
  // Open the delete dialog for a file or folder
  const openDeleteDialog = (item) => {
    if (!isAdmin) {
      setErrorMessage('Admin access required to delete files.');
      return;
    }
    
    setItemToDelete(item);
    setErrorMessage('');
    setShowDeleteDialog(true);
  };
  
  // Close the delete dialog
  const closeDeleteDialog = () => {
    setShowDeleteDialog(false);
    setItemToDelete(null);
    setErrorMessage('');
  };
  
  // Handle drag start event
  const handleDragStart = (e, item) => {
    if (!isAdmin) return;
    
    setDraggedItem(item);
    e.dataTransfer.setData('text/plain', item.path);
    e.dataTransfer.effectAllowed = 'move';
    
    // Add dragging class to the element
    e.currentTarget.classList.add('dragging');
    
    // Remove the class after a short delay to ensure it's applied
    setTimeout(() => {
      if (e.currentTarget) {
        e.currentTarget.classList.remove('dragging');
      }
    }, 100);
  };
  
  // Handle drag over event
  const handleDragOver = (e, folder) => {
    if (!isAdmin || !draggedItem) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    // Only allow dropping into directories
    if (folder.type === 'directory') {
      setDropTarget(folder);
      e.dataTransfer.dropEffect = 'move';
      
      // Add drop-target class to the element
      e.currentTarget.classList.add('drop-target');
    }
  };
  
  // Handle drag over for the file tree container (to allow dropping to root)
  const handleContainerDragOver = (e) => {
    if (!isAdmin || !draggedItem) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    // Set root as the drop target
    const rootFolder = {
      type: 'directory',
      path: draggedItem.isPublic ? '/public' : '/',
      name: 'Root'
    };
    setDropTarget(rootFolder);
    e.dataTransfer.dropEffect = 'move';
  };
  
  // Handle drag leave event
  const handleDragLeave = (e) => {
    if (!isAdmin) return;
    
    e.preventDefault();
    e.stopPropagation();
    setDropTarget(null);
    
    // Remove drop-target class from the element
    e.currentTarget.classList.remove('drop-target');
  };
  
  // Handle drag leave for the container
  const handleContainerDragLeave = (e) => {
    if (!isAdmin) return;
    
    e.preventDefault();
    e.stopPropagation();
    setDropTarget(null);
  };
  
  // Handle drop event
  const handleDrop = async (e, targetFolder) => {
    if (!isAdmin || !draggedItem || !targetFolder) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    // Reset drop target
    setDropTarget(null);
    
    // Remove drop-target class from the element
    e.currentTarget.classList.remove('drop-target');
    
    // Only allow dropping into directories
    if (targetFolder.type !== 'directory') {
      return;
    }
    
    // Check if dropping on itself
    if (draggedItem.path === targetFolder.path) {
      return;
    }
    
    // Check if dropping in current location (parent folder is the same)
    const draggedParent = getParentDirectoryPath(draggedItem.path);
    if (draggedParent === targetFolder.path) {
      return;
    }
    
    try {
      setIsMoving(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsMoving(false);
        return;
      }
      
      // Call the API to move the file
      const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_MOVE}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          sourcePath: draggedItem.path,
          destinationPath: targetFolder.path
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || `Failed to move ${draggedItem.type}: ${response.statusText}`);
      }
      
      // If the moved item was selected, clear the selection
      if (selectedFile && selectedFile.path === draggedItem.path) {
        setSelectedFile(null);
        setFileContent('');
        setShowPreview(false);
        if (editMode) {
          setEditMode(false);
        }
      }
      
      // Refresh the appropriate file list
      if (draggedItem.isPublic) {
        fetchPublicDirectoryContents('/', true);
      } else {
        fetchDirectoryContents('/', true);
      }
      
      // Clear drag state
      setDraggedItem(null);
      setIsMoving(false);
    } catch (error) {
      console.error(`Error moving ${draggedItem.type}:`, error);
      setErrorMessage(`Failed to move ${draggedItem.type}: ${error.message}`);
      setDraggedItem(null);
      setIsMoving(false);
    }
  };
  
  // Handle drop event for the container (moving to root)
  const handleContainerDrop = async (e) => {
    if (!isAdmin || !draggedItem || !dropTarget) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    // Process the drop using the dropTarget which was set in handleContainerDragOver
    const targetFolder = dropTarget;
    
    // Reset drop target
    setDropTarget(null);
    
    // Check if dropping in current location (parent folder is the same)
    const draggedParent = getParentDirectoryPath(draggedItem.path);
    if (draggedParent === targetFolder.path) {
      return;
    }
    
    try {
      setIsMoving(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsMoving(false);
        return;
      }
      
      // Call the API to move the file
      const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_MOVE}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          sourcePath: draggedItem.path,
          destinationPath: targetFolder.path
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || `Failed to move ${draggedItem.type}: ${response.statusText}`);
      }
      
      // If the moved item was selected, clear the selection
      if (selectedFile && selectedFile.path === draggedItem.path) {
        setSelectedFile(null);
        setFileContent('');
        setShowPreview(false);
        if (editMode) {
          setEditMode(false);
        }
      }
      
      // Refresh the appropriate file list
      if (draggedItem.isPublic) {
        fetchPublicDirectoryContents('/', true);
      } else {
        fetchDirectoryContents('/', true);
      }
      
      // Clear drag state
      setDraggedItem(null);
      setIsMoving(false);
    } catch (error) {
      console.error(`Error moving ${draggedItem.type} to root:`, error);
      setErrorMessage(`Failed to move ${draggedItem.type} to root: ${error.message}`);
      setDraggedItem(null);
      setIsMoving(false);
    }
  };
  
  // Delete a file or folder
  const deleteItem = async () => {
    if (!itemToDelete) {
      setErrorMessage('No item selected for deletion');
      return;
    }
    
    try {
      setIsDeleting(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsDeleting(false);
        return;
      }
      
      // Delete the file or folder
      const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_DELETE}?path=${encodeURIComponent(itemToDelete.path)}`, {
        method: 'DELETE',
        headers: {
          'Authorization': `Bearer ${token}`
        }
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || `Failed to delete ${itemToDelete.type}: ${response.statusText}`);
      }
      
      // Close the dialog
      setShowDeleteDialog(false);
      setItemToDelete(null);
      
      // If the deleted item was selected, clear the selection
      if (selectedFile && selectedFile.path === itemToDelete.path) {
        setSelectedFile(null);
        setFileContent('');
        setShowPreview(false);
        if (editMode) {
          setEditMode(false);
        }
      }
      
      // Refresh the appropriate file list
      if (itemToDelete.isPublic) {
        fetchPublicDirectoryContents('/', true);
      } else {
        fetchDirectoryContents('/', true);
      }
      
      setIsDeleting(false);
    } catch (error) {
      console.error(`Error deleting ${itemToDelete.type}:`, error);
      setErrorMessage(`Failed to delete ${itemToDelete.type}: ${error.message}`);
      setIsDeleting(false);
    }
  };
  
  // Handle key press in the rename dialog
  const handleRenameKeyPress = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      renameItem();
    } else if (e.key === 'Escape') {
      closeRenameDialog();
    }
  };
  
  // Rename a file or folder
  const renameItem = async () => {
    if (!newName.trim()) {
      setErrorMessage('Name cannot be empty');
      return;
    }
    
    if (!itemToRename) {
      setErrorMessage('No item selected for renaming');
      return;
    }
    
    try {
      setIsRenaming(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsRenaming(false);
        return;
      }
      
      // Rename the file or folder
      const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_RENAME}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          oldPath: itemToRename.path,
          newName: newName.trim()
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || `Failed to rename ${itemToRename.type}: ${response.statusText}`);
      }
      
      // Close the dialog and reset the form
      setShowRenameDialog(false);
      setItemToRename(null);
      setNewName('');
      
      // If the renamed item was selected, update the selected file
      if (selectedFile && selectedFile.path === itemToRename.path) {
        setSelectedFile(null);
      }
      
      // Refresh the appropriate file list
      if (itemToRename.isPublic) {
        fetchPublicDirectoryContents('/', true);
      } else {
        fetchDirectoryContents('/', true);
      }
      
      setIsRenaming(false);
    } catch (error) {
      console.error(`Error renaming ${itemToRename.type}:`, error);
      setErrorMessage(`Failed to rename ${itemToRename.type}: ${error.message}`);
      setIsRenaming(false);
    }
  };
  
  // Handle folder selection
  const handleFolderSelect = (folder) => {
    // Update the current path to the selected folder's path
    setCurrentPath(folder.path);
    
    // Set the selected folder
    setSelectedFile(folder);
    
    // Expand the folder
    setExpandedFolders(prev => ({
      ...prev,
      [folder.path]: true
    }));
    
    // Reset content and preview
    setFileContent('');
    setShowPreview(false);
    
    // Reset edit mode
    if (editMode) {
      setEditMode(false);
    }
  };
  
  // Helper function to get parent directory path
  const getParentDirectoryPath = (filePath) => {
    // Remove trailing slash if present
    const normalizedPath = filePath.endsWith('/') ? filePath.slice(0, -1) : filePath;
    // Find the last slash in the path
    const lastSlashIndex = normalizedPath.lastIndexOf('/');
    
    if (lastSlashIndex === -1) {
      // No slash found, return root
      return '/';
    }
    
    // Return everything up to the last slash
    return normalizedPath.substring(0, lastSlashIndex) || '/';
  };
  
  // Handle file selection
  const handleFileSelect = (file) => {
    // If it's a directory, handle it differently
    if (file.type === 'directory') {
      handleFolderSelect(file);
      return;
    }
    
    setSelectedFile(file);
    
    // We don't change the current path when selecting a file
    // This prevents the file tree from reloading unnecessarily
    
    // Reset edit mode when selecting a new file
    if (editMode) {
      setEditMode(false);
    }
    
    // If it's a markdown file, fetch its content and show preview
    if (file.name.endsWith('.md')) {
      if (file.isPublic) {
        // Fetch public file content
        fetchPublicFileContent(file.path);
      } else {
        // Fetch private file content (admin only)
        fetchFileContent(file.path);
      }
      setShowPreview(true);
    } else {
      setFileContent('');
      setShowPreview(false);
    }
  };

  // Get file icon based on file extension
  const getFileIcon = (fileName) => {
    if (fileName.endsWith('.md')) return <FileText size={16} className="mr-2" />;
    if (fileName.endsWith('.jsx') || fileName.endsWith('.js')) return <Code size={16} className="mr-2" />;
    if (fileName.endsWith('.json')) return <Coffee size={16} className="mr-2" />;
    if (fileName.endsWith('.css')) return <BookOpen size={16} className="mr-2" />;
    return <File size={16} className="mr-2" />;
  };
  
  // Render the file tree recursively
  const renderFileTree = (items) => {
    // Keep track of the path to the currently selected file to highlight its parent folder
    const selectedFilePath = selectedFile?.path || '';
    const selectedFileParentPath = selectedFile && selectedFile.type !== 'directory' ? 
      getParentDirectoryPath(selectedFilePath) : '';
    
    return items.map(item => {
      if (item.type === 'directory') {
        const isExpanded = expandedFolders[item.path];
        // A folder is considered active if it's the current path OR if it's the parent of the selected file
        const isActive = currentPath === item.path || (selectedFileParentPath === item.path);
        return (
          <div key={item.path} className="ml-2">
            <div 
              className={`flex items-center justify-between py-1 px-1 rounded hover:bg-stone-700 cursor-pointer group ${
                isActive ? 'bg-stone-800 text-teal-300 font-bold' : 
                isExpanded ? 'text-teal-300' : 'text-teal-400'
              } ${dropTarget && dropTarget.path === item.path ? 'bg-teal-900 border border-teal-500' : ''}`}
              onClick={() => toggleFolder(item.path, item)}
              draggable={isAdmin}
              onDragStart={(e) => handleDragStart(e, item)}
              onDragOver={(e) => handleDragOver(e, item)}
              onDragLeave={(e) => handleDragLeave(e)}
              onDrop={(e) => handleDrop(e, item)}
            >
              <div className="flex items-center">
                {isExpanded ? <ChevronDown size={14} /> : <ChevronRight size={14} />}
                <FolderOpen size={16} className="ml-1 mr-2" />
                <span className="text-sm">{item.name}</span>
              </div>
              
              {/* Admin-only buttons */}
              {isAdmin && (
                <div className="flex">
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      openRenameDialog(item);
                    }}
                    className="p-1 rounded hover:bg-stone-600 text-stone-400 hover:text-teal-300 opacity-0 group-hover:opacity-100"
                    title="Rename folder"
                  >
                    <FileEdit size={14} />
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      openDeleteDialog(item);
                    }}
                    className="p-1 rounded hover:bg-stone-600 text-stone-400 hover:text-red-400 opacity-0 group-hover:opacity-100"
                    title="Delete folder"
                  >
                    <Trash2 size={14} />
                  </button>
                </div>
              )}
            </div>
            
            {isExpanded && item.children && (
              <div className="ml-2 border-l border-stone-700">
                {renderFileTree(item.children)}
              </div>
            )}
          </div>
        );
      } else {
        const isSelected = selectedFile && selectedFile.path === item.path;
        return (
          <div 
            key={item.path} 
            className={`flex items-center justify-between py-1 px-1 ml-4 rounded cursor-pointer hover:bg-stone-700 group ${isSelected ? 'bg-stone-700 text-teal-300' : 'text-teal-50'}`}
            onClick={() => handleFileSelect(item)}
            draggable={isAdmin}
            onDragStart={(e) => handleDragStart(e, item)}
          >
            <div className="flex items-center">
              {getFileIcon(item.name)}
              <span className="text-sm">{item.name}</span>
            </div>
            
            {/* Admin-only buttons */}
            {isAdmin && (
              <div className="flex">
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    openRenameDialog(item);
                  }}
                  className="p-1 rounded hover:bg-stone-600 text-stone-400 hover:text-teal-300 opacity-0 group-hover:opacity-100"
                  title="Rename file"
                >
                  <FileEdit size={14} />
                </button>
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    openDeleteDialog(item);
                  }}
                  className="p-1 rounded hover:bg-stone-600 text-stone-400 hover:text-red-400 opacity-0 group-hover:opacity-100"
                  title="Delete file"
                >
                  <Trash2 size={14} />
                </button>
              </div>
            )}
          </div>
        );
      }
    });
  };

  // Toggle edit mode
  const toggleEditMode = () => {
    if (!isAdmin) {
      setErrorMessage('Admin access required to edit files.');
      return;
    }
    
    if (!selectedFile || !selectedFile.name.endsWith('.md')) {
      setErrorMessage('Only markdown files can be edited.');
      return;
    }
    
    setEditMode(!editMode);
    // When switching to preview mode, ensure preview is shown
    if (editMode) {
      setShowPreview(true);
    }
  };

  // Handle command input
  const handleCommand = (e) => {
    if (e.key === 'Enter' && e.target.value.trim()) {
      const cmd = e.target.value.trim();
      onCommand(cmd);
      e.target.value = '';
      
      // Commands:
      // - refresh: refresh file list
      // - preview: toggle markdown preview
      // - edit: toggle edit mode (admin only)
      // - save: manually save the current file
      // - new-file: create a new file (admin only)
      // - new-folder: create a new folder (admin only)
      // - rename: rename selected file or folder (admin only)
      // - delete: delete selected file or folder (admin only)
      // - public: switch to public files tab
      // - private: switch to private files tab (admin only)
      if (cmd === 'refresh') {
        // Refresh the appropriate file list based on the active tab
        if (activeTab === 'public') {
          fetchPublicDirectoryContents('/', true);
        } else {
          fetchDirectoryContents('/', true);
        }
      } else if (cmd === 'preview' && selectedFile?.name.endsWith('.md')) {
        setShowPreview(!showPreview);
        if (editMode) {
          setEditMode(false); // Exit edit mode when switching to preview
        }
      } else if (cmd === 'edit' && selectedFile?.name.endsWith('.md')) {
        toggleEditMode();
      } else if (cmd === 'save' && editMode && selectedFile?.name.endsWith('.md')) {
        saveFileContent();
      } else if (cmd === 'new-file' && isAdmin) {
        openCreateDialog('file');
      } else if (cmd === 'new-folder' && isAdmin) {
        openCreateDialog('directory');
      } else if (cmd === 'rename' && isAdmin && selectedFile) {
        openRenameDialog(selectedFile);
      } else if (cmd === 'delete' && isAdmin && selectedFile) {
        openDeleteDialog(selectedFile);
      } else if (cmd === 'public') {
        setActiveTab('public');
      } else if (cmd === 'private' && isAdmin) {
        setActiveTab('private');
      }
    }
  };

  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400 overflow-hidden">
      <div className="flex flex-1 overflow-hidden">
        {/* File tree panel */}
        <div className="w-1/3 border-r border-stone-700 flex flex-col overflow-hidden">
          <div className="p-2 border-b border-stone-700 font-mono text-sm flex items-center justify-between">
            <div className="flex items-center">
              <span>FILES</span>
              
              {/* Tabs for switching between public and private files */}
              <div className="flex ml-4">
                <button
                  onClick={() => setActiveTab('public')}
                  className={`px-2 py-1 rounded-t text-xs flex items-center gap-1 ${
                    activeTab === 'public' 
                      ? 'bg-stone-700 text-teal-300' 
                      : 'bg-stone-800 hover:bg-stone-700'
                  }`}
                  title="Public files (readable by all users)"
                >
                  <Globe size={14} />
                  <span>Public</span>
                </button>
                
                {isAdmin && (
                  <button
                    onClick={() => setActiveTab('private')}
                    className={`px-2 py-1 rounded-t text-xs flex items-center gap-1 ml-1 ${
                      activeTab === 'private' 
                        ? 'bg-stone-700 text-teal-300' 
                        : 'bg-stone-800 hover:bg-stone-700'
                    }`}
                    title="Private files (admin only)"
                  >
                    <Lock size={14} />
                    <span>Private</span>
                  </button>
                )}
              </div>
            </div>
            
            {/* Admin-only file creation buttons */}
            {isAdmin && (
              <div className="flex gap-2">
                <button
                  onClick={() => openCreateDialog('file')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Create new file"
                >
                  <Plus size={16} />
                </button>
                <button
                  onClick={() => openCreateDialog('directory')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Create new folder"
                >
                  <FolderPlus size={16} />
                </button>
              </div>
            )}
          </div>
          
          <div 
            className="flex-1 overflow-auto"
            onDragOver={handleContainerDragOver}
            onDragLeave={handleContainerDragLeave}
            onDrop={handleContainerDrop}
          >
            {isTreeLoading ? (
              <div className="flex items-center justify-center h-full">
                <span className="text-teal-300">Loading files...</span>
              </div>
            ) : errorMessage ? (
              <div className="p-2 text-red-400">{errorMessage}</div>
            ) : (
              <div className="p-2 font-mono">
                {activeTab === 'public' ? (
                  // Show public files to all users
                  <>
                    <div className="flex items-center py-1 px-1 text-teal-300">
                      <Globe size={16} className="mr-2" />
                      <span className="text-sm font-bold">Public Files</span>
                    </div>
                    {publicFiles.length > 0 ? (
                      renderFileTree(publicFiles)
                    ) : (
                      <div className="ml-4 text-stone-500 text-sm">No public files available</div>
                    )}
                  </>
                ) : (
                  // Show private files to admin users
                  <>
                    <div className="flex items-center py-1 px-1 text-teal-300">
                      <Lock size={16} className="mr-2" />
                      <span className="text-sm font-bold">Private Files (Admin Only)</span>
                    </div>
                    {files.length > 0 ? (
                      renderFileTree(files)
                    ) : (
                      <div className="ml-4 text-stone-500 text-sm">No private files available</div>
                    )}
                  </>
                )}
              </div>
            )}
          </div>
          
          {/* Create file/folder dialog */}
          {showCreateDialog && (
            <div className="p-2 border-t border-stone-700 bg-stone-800">
              <div className="flex items-center justify-between mb-1">
                <span className="text-sm font-bold">
                  {createType === 'file' ? 'New File' : 'New Folder'}
                </span>
                <button
                  onClick={closeCreateDialog}
                  className="p-1 rounded hover:bg-stone-700 text-stone-400"
                >
                  <X size={14} />
                </button>
              </div>
              <div className="flex gap-2">
                <input
                  ref={createInputRef}
                  type="text"
                  value={newItemName}
                  onChange={(e) => setNewItemName(e.target.value)}
                  onKeyDown={handleCreateKeyPress}
                  placeholder={createType === 'file' ? 'filename.ext' : 'folder name'}
                  className="flex-1 bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
                  disabled={isCreating}
                />
                <button
                  onClick={createNewItem}
                  disabled={isCreating || !newItemName.trim()}
                  className={`px-2 py-1 rounded text-xs ${
                    isCreating || !newItemName.trim()
                      ? 'bg-stone-700 text-stone-500 cursor-not-allowed'
                      : 'bg-teal-700 text-teal-100 hover:bg-teal-600'
                  }`}
                >
                  {isCreating ? 'Creating...' : 'Create'}
                </button>
              </div>
            </div>
          )}
          
          {/* Rename file/folder dialog */}
          {showRenameDialog && itemToRename && (
            <div className="p-2 border-t border-stone-700 bg-stone-800">
              <div className="flex items-center justify-between mb-1">
                <span className="text-sm font-bold">
                  Rename {itemToRename.type === 'directory' ? 'Folder' : 'File'}
                </span>
                <button
                  onClick={closeRenameDialog}
                  className="p-1 rounded hover:bg-stone-700 text-stone-400"
                >
                  <X size={14} />
                </button>
              </div>
              <div className="flex gap-2">
                <input
                  ref={renameInputRef}
                  type="text"
                  value={newName}
                  onChange={(e) => setNewName(e.target.value)}
                  onKeyDown={handleRenameKeyPress}
                  placeholder="New name"
                  className="flex-1 bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
                  disabled={isRenaming}
                />
                <button
                  onClick={renameItem}
                  disabled={isRenaming || !newName.trim() || newName === itemToRename.name}
                  className={`px-2 py-1 rounded text-xs ${
                    isRenaming || !newName.trim() || newName === itemToRename.name
                      ? 'bg-stone-700 text-stone-500 cursor-not-allowed'
                      : 'bg-teal-700 text-teal-100 hover:bg-teal-600'
                  }`}
                >
                  {isRenaming ? 'Renaming...' : 'Rename'}
                </button>
              </div>
            </div>
          )}
          
          {/* Delete file/folder confirmation dialog */}
          {showDeleteDialog && itemToDelete && (
            <div className="p-2 border-t border-stone-700 bg-stone-800">
              <div className="flex items-center justify-between mb-1">
                <span className="text-sm font-bold">
                  Delete {itemToDelete.type === 'directory' ? 'Folder' : 'File'}
                </span>
                <button
                  onClick={closeDeleteDialog}
                  className="p-1 rounded hover:bg-stone-700 text-stone-400"
                >
                  <X size={14} />
                </button>
              </div>
              <div className="mb-2 text-sm">
                <p>Are you sure you want to delete <span className="text-red-400 font-bold">{itemToDelete.name}</span>?</p>
                {itemToDelete.type === 'directory' && (
                  <p className="text-red-400 text-xs mt-1">This will delete all files and folders inside it!</p>
                )}
              </div>
              <div className="flex gap-2 justify-end">
                <button
                  onClick={closeDeleteDialog}
                  className="px-2 py-1 rounded text-xs bg-stone-700 hover:bg-stone-600"
                >
                  Cancel
                </button>
                <button
                  onClick={deleteItem}
                  disabled={isDeleting}
                  className={`px-2 py-1 rounded text-xs ${
                    isDeleting
                      ? 'bg-red-900 text-red-300 cursor-not-allowed'
                      : 'bg-red-700 text-red-100 hover:bg-red-600'
                  }`}
                >
                  {isDeleting ? 'Deleting...' : 'Delete'}
                </button>
              </div>
            </div>
          )}
          
          <div className="p-2 border-t border-stone-700 text-xs">
            {selectedFile ? selectedFile.path : currentPath}
          </div>
        </div>
        
        {/* File content panel (preview or edit) */}
        <div className="flex-1 flex flex-col overflow-hidden">
          {selectedFile ? (
            <>
              {/* Header with file name, status, and controls */}
              <div className="p-2 border-b border-stone-700 font-mono text-sm flex items-center justify-between">
                <div className="flex items-center">
                  <span className="mr-2">{selectedFile.name}</span>
                  {saveStatus === 'saving' && <span className="text-yellow-400 text-xs ml-2">Saving...</span>}
                  {saveStatus === 'saved' && <span className="text-green-400 text-xs ml-2">Saved</span>}
                  {saveStatus === 'error' && <span className="text-red-400 text-xs ml-2">Error!</span>}
                </div>
                
                {/* Only show edit/preview toggle for markdown files and admin users */}
                {selectedFile.name.endsWith('.md') && isAdmin && (
                  <div className="flex gap-2">
                    <button 
                      onClick={toggleEditMode}
                      className={`px-2 py-1 rounded text-xs flex items-center gap-1 ${editMode ? 'bg-teal-700 text-teal-100' : 'bg-stone-800 hover:bg-stone-700'}`}
                      title={editMode ? "Switch to preview mode" : "Switch to edit mode"}
                    >
                      {editMode ? <Eye size={14} /> : <Edit size={14} />}
                      {editMode ? 'Preview' : 'Edit'}
                    </button>
                    
                    {editMode && (
                      <button 
                        onClick={saveFileContent}
                        className="px-2 py-1 bg-stone-800 hover:bg-stone-700 rounded text-xs"
                        title="Save file"
                      >
                        Save
                      </button>
                    )}
                  </div>
                )}
              </div>
              
              {/* Error message */}
              {errorMessage && (
                <div className="p-2 bg-red-900 text-red-200 text-sm">
                  {errorMessage}
                </div>
              )}
              
              {/* Content area - either editor or preview */}
              {isContentLoading ? (
                <div className="flex-1 flex items-center justify-center">
                  <span className="text-teal-300">Loading content...</span>
                </div>
              ) : editMode && selectedFile.name.endsWith('.md') && isAdmin ? (
                // Editor mode - only for markdown files and admin users
                <div className="flex-1 flex flex-col">
                  {/* Markdown toolbar */}
                  <div className="p-2 border-b border-stone-700 bg-stone-800 flex flex-wrap gap-2">
                    <button 
                      onClick={() => insertMarkdown('### ')}
                      className="p-1 rounded hover:bg-stone-700 text-teal-400"
                      title="Heading"
                    >
                      <Heading size={16} />
                    </button>
                    <button 
                      onClick={() => insertMarkdown('**', '**')}
                      className="p-1 rounded hover:bg-stone-700 text-teal-400"
                      title="Bold"
                    >
                      <Bold size={16} />
                    </button>
                    <button 
                      onClick={() => insertMarkdown('*', '*')}
                      className="p-1 rounded hover:bg-stone-700 text-teal-400"
                      title="Italic"
                    >
                      <Italic size={16} />
                    </button>
                    <button 
                      onClick={() => insertMarkdown('`', '`')}
                      className="p-1 rounded hover:bg-stone-700 text-teal-400"
                      title="Inline Code"
                    >
                      <CodeIcon size={16} />
                    </button>
                    <button 
                      onClick={() => insertMarkdown('[', '](url)')}
                      className="p-1 rounded hover:bg-stone-700 text-teal-400"
                      title="Link"
                    >
                      <Link size={16} />
                    </button>
                    <span className="border-r border-stone-700 h-6"></span>
                    <button 
                      onClick={() => insertList('- ')}
                      className="p-1 rounded hover:bg-stone-700 text-teal-400"
                      title="Bullet List"
                    >
                      <List size={16} />
                    </button>
                    <button 
                      onClick={() => insertList('1. ')}
                      className="p-1 rounded hover:bg-stone-700 text-teal-400"
                      title="Numbered List"
                    >
                      <ListOrdered size={16} />
                    </button>
                    <button 
                      onClick={() => insertList('- [ ] ')}
                      className="p-1 rounded hover:bg-stone-700 text-teal-400"
                      title="Checklist"
                    >
                      <CheckSquare size={16} />
                    </button>
                  </div>
                  
                  <div className="flex-1 p-2">
                    <textarea
                      ref={textareaRef}
                      className="w-full h-full bg-stone-800 text-teal-50 p-4 resize-none focus:outline-none font-mono"
                      value={fileContent}
                      onChange={handleMarkdownChange}
                      onKeyDown={handleEditorKeyDown}
                      placeholder="# Start typing your markdown here..."
                    />
                  </div>
                </div>
              ) : showPreview ? (
                // Preview mode
                <div className="flex-1 overflow-auto p-4">
                  <div className="markdown-preview text-teal-50">
                    {selectedFile.name.endsWith('.md') ? (
                      <div 
                        dangerouslySetInnerHTML={{ 
                          __html: converter.makeHtml(fileContent) 
                        }} 
                        className="markdown-content"
                      />
                    ) : (
                      <pre className="font-mono text-sm whitespace-pre-wrap">
                        {fileContent}
                      </pre>
                    )}
                  </div>
                </div>
              ) : null}
            </>
          ) : (
            // No file selected
            <div className="flex items-center justify-center h-full text-stone-600">
              <div className="text-center">
                <FileText size={48} className="mx-auto mb-4" />
                <p>Select a markdown file to preview</p>
                <p className="text-xs mt-2">Use the 'preview' command to toggle preview mode</p>
                {isAdmin && <p className="text-xs mt-1">Admin users can use the 'edit' command to edit markdown files</p>}
              </div>
            </div>
          )}
        </div>
      </div>
      
      {/* Command input */}
      <div className="p-2 flex items-center gap-2 border-t border-stone-700">
        <span className="text-teal-400">$</span>
        <input
          ref={focusRef}
          type="text"
          onKeyDown={handleCommand}
          className="flex-1 bg-stone-800 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
        />
      </div>
    </div>
  );
};

export default ExplorerWindow;

================
File: src/components/windows/index.js
================
import TerminalWindow from './TerminalWindow';
import ExplorerWindow from './explorer/ExplorerWindow';
import withCommandHandling from '../../hocs/withCommandHandling';
import withWindowState from '../../hocs/withWindowState';
import withCommandInput from '../../hocs/withCommandInput';
import AudioWindow from './AudioWindow';
import ChatWindow from './ChatWindow';
import AdminWindow from './AdminWindow';
import CanvasWindow from './CanvasWindow';
import { WINDOW_TYPES } from '../../utils/constants';

// Create enhanced versions of each window component by wrapping them with HOCs
// Terminal and Explorer already have command inputs, so we don't need to add them
export const EnhancedTerminalWindow = withWindowState(withCommandHandling(TerminalWindow), WINDOW_TYPES.TERMINAL);
export const EnhancedExplorerWindow = withWindowState(withCommandHandling(ExplorerWindow), WINDOW_TYPES.EXPLORER);

// For other windows, add the command input
export const EnhancedAudioWindow = withWindowState(withCommandHandling(withCommandInput(AudioWindow)), WINDOW_TYPES.AUDIO);
export const EnhancedChatWindow = withWindowState(withCommandHandling(withCommandInput(ChatWindow)), WINDOW_TYPES.CHAT);
export const EnhancedAdminWindow = withWindowState(withCommandHandling(withCommandInput(AdminWindow)), WINDOW_TYPES.ADMIN);
export const EnhancedCanvasWindow = withWindowState(withCommandHandling(CanvasWindow), WINDOW_TYPES.CANVAS);

// Also export the base components in case they're needed
export { TerminalWindow, ExplorerWindow, ChatWindow, AdminWindow, CanvasWindow };

================
File: src/components/windows/mapeditor/components/OpacitySlider.jsx
================
import React, { useState, useRef, useEffect } from 'react';
import '../styles/RangeSlider.css';

/**
 * Custom OpacitySlider component that provides better interaction handling
 * than the standard HTML range input in complex UI scenarios.
 */
const OpacitySlider = ({ value, onChange, className = '' }) => {
  // Refs for DOM elements
  const trackRef = useRef(null);
  const thumbRef = useRef(null);
  const containerRef = useRef(null);
  
  // State to track dragging status
  const [isDragging, setIsDragging] = useState(false);
  const [displayValue, setDisplayValue] = useState(value || 1.0);
  
  // Update display value when prop changes
  useEffect(() => {
    setDisplayValue(value || 1.0);
  }, [value]);
  
  // Calculate position based on value (0-1)
  const getThumbPosition = (val) => {
    return `${val * 100}%`;
  };
  
  // Calculate value from mouse/touch position
  const calculateValueFromPosition = (clientX) => {
    if (!trackRef.current) return 0;
    
    const rect = trackRef.current.getBoundingClientRect();
    const trackWidth = rect.width;
    const offset = clientX - rect.left;
    
    // Calculate value (0-1) based on position
    let newValue = offset / trackWidth;
    
    // Clamp value between 0 and 1
    newValue = Math.max(0, Math.min(1, newValue));
    
    // Round to nearest 0.05
    return Math.round(newValue * 20) / 20;
  };
  
  // Handle mouse/touch down
  const handleStart = (clientX) => {
    setIsDragging(true);
    const newValue = calculateValueFromPosition(clientX);
    setDisplayValue(newValue);
    if (onChange) onChange(newValue);
    
    // Add document-level event listeners
    document.addEventListener('mousemove', handleMove);
    document.addEventListener('mouseup', handleEnd);
    document.addEventListener('touchmove', handleTouchMove);
    document.addEventListener('touchend', handleEnd);
  };
  
  // Handle mouse/touch move
  const handleMove = (e) => {
    if (!isDragging) return;
    const newValue = calculateValueFromPosition(e.clientX);
    setDisplayValue(newValue);
    if (onChange) onChange(newValue);
  };
  
  // Handle touch move with proper event handling
  const handleTouchMove = (e) => {
    if (!isDragging || !e.touches[0]) return;
    const newValue = calculateValueFromPosition(e.touches[0].clientX);
    setDisplayValue(newValue);
    if (onChange) onChange(newValue);
  };
  
  // Handle mouse/touch up - end dragging
  const handleEnd = () => {
    setIsDragging(false);
    
    // Remove document-level event listeners
    document.removeEventListener('mousemove', handleMove);
    document.removeEventListener('mouseup', handleEnd);
    document.removeEventListener('touchmove', handleTouchMove);
    document.removeEventListener('touchend', handleEnd);
  };
  
  // Handle mouse down on track/thumb
  const handleMouseDown = (e) => {
    e.stopPropagation();
    e.preventDefault();
    handleStart(e.clientX);
  };
  
  // Handle touch start on track/thumb
  const handleTouchStart = (e) => {
    e.stopPropagation();
    if (e.touches[0]) {
      handleStart(e.touches[0].clientX);
    }
  };

  return (
    <div 
      className={`custom-slider-container ${className}`}
      ref={containerRef}
      onClick={e => e.stopPropagation()}
    >
      {/* Display percentage value */}
      <div className="flex items-center justify-between mb-2">
        <span className="text-xs text-stone-400" title="Adjust layer transparency">
          Opacity:
        </span>
        <span className="text-xs font-medium text-teal-300">
          {Math.round(displayValue * 100)}%
        </span>
      </div>
      
      {/* Slider track and thumb */}
      <div 
        className="custom-slider-track"
        ref={trackRef}
        onMouseDown={handleMouseDown}
        onTouchStart={handleTouchStart}
        onClick={e => e.stopPropagation()}
        style={{
          background: `linear-gradient(to right, #14b8a6 0%, #14b8a6 ${displayValue * 100}%, #44403c ${displayValue * 100}%, #44403c 100%)`
        }}
      >
        {/* Draggable thumb */}
        <div
          className="custom-slider-thumb"
          ref={thumbRef}
          style={{ left: getThumbPosition(displayValue) }}
          onMouseDown={handleMouseDown}
          onTouchStart={handleTouchStart}
        />
      </div>
    </div>
  );
};

export default OpacitySlider;

================
File: src/components/windows/mapeditor/LayerPanel.jsx
================
import React, { useState, useEffect, useRef } from 'react';
import { Eye, EyeOff, Layers, Plus, Trash2, ArrowUp, ArrowDown, Edit2, ChevronDown, ChevronUp } from 'lucide-react';
import TilePalette from './TilePalette';
import OpacitySlider from './components/OpacitySlider';

/**
 * Layer panel component for the Map Editor
 * Allows for managing layers (visibility, order, etc) and selecting tiles
 */
const LayerPanel = ({ 
  layers, 
  currentLayer, 
  setCurrentLayer, 
  onToggleLayerVisibility, 
  onAddLayer, 
  onRemoveLayer, 
  onMoveLayerUp, 
  onMoveLayerDown, 
  onRenameLayer,
  onUpdateLayerOpacity,
  selectedTileId = 0,
  onSelectTile,
  selectedRotation, // Add prop for receiving rotation state
  onRotateTile,     // Add prop for passing rotation handler
  currentTool,
  setCurrentTool,
  brushSize = 1,
  setBrushSize
}) => {
  // State for tracking which layer is being edited and the current edited name
  const [editingLayerIndex, setEditingLayerIndex] = useState(null);
  const [editedLayerName, setEditedLayerName] = useState('');
  const [expandedOpacityLayers, setExpandedOpacityLayers] = useState({});
  const layerNameInputRef = useRef(null);
  
  // Toggle opacity controls for a layer
  const toggleOpacityControls = (layerIndex, e) => {
    e.stopPropagation();
    setExpandedOpacityLayers(prev => ({
      ...prev,
      [layerIndex]: !prev[layerIndex]
    }));
  };
  
  // Focus input when editing starts
  useEffect(() => {
    if (editingLayerIndex !== null && layerNameInputRef.current) {
      layerNameInputRef.current.focus();
    }
  }, [editingLayerIndex]);
  
  // Handle starting the edit process
  const handleStartEditing = (e, layerIndex) => {
    e.stopPropagation();
    setEditingLayerIndex(layerIndex);
    setEditedLayerName(layers[layerIndex].name);
  };
  
  // Handle saving the edited name
  const handleSaveLayerName = (layerIndex) => {
    if (editedLayerName.trim()) {
      onRenameLayer(layerIndex, editedLayerName);
    }
    setEditingLayerIndex(null);
  };
  
  // Handle keydown events in the input field
  const handleInputKeyDown = (e, layerIndex) => {
    if (e.key === 'Enter') {
      handleSaveLayerName(layerIndex);
    } else if (e.key === 'Escape') {
      setEditingLayerIndex(null);
    }
  };

  return (
    <div className="w-64 bg-stone-800 border-l border-stone-700 flex flex-col overflow-hidden">
      {/* Brush Size Control */}
      <div className="p-2 border-b border-stone-700">
        <div className="flex items-center justify-between">
          <span className="text-sm text-teal-400">BRUSH SIZE:</span>
          <div className="flex items-center">
            <button
              onClick={() => setBrushSize(Math.max(1, brushSize - 1))}
              className="px-2 py-0.5 bg-stone-700 hover:bg-stone-600 rounded-l text-teal-300 text-xs focus:outline-none"
            >
              -
            </button>
            <input
                type="number"
                value={brushSize}
                onChange={(e) => {
                  const value = parseInt(e.target.value, 10);
                  if (!isNaN(value) && value > 0) setBrushSize(value);
                }}
                className="w-10 bg-stone-700 text-xs text-teal-100 px-1 py-0.5 border-x-0 focus:outline-none text-center
                          [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none"
                min="1"
                max="10"
              />
            <button
              onClick={() => setBrushSize(Math.min(10, brushSize + 1))}
              className="px-2 py-0.5 bg-stone-700 hover:bg-stone-600 rounded-r text-teal-300 text-xs focus:outline-none"
            >
              +
            </button>
          </div>
        </div>
        <div className="text-xs text-stone-400 mt-1">
          {brushSize}{brushSize}
        </div>
      </div>
      
      {/* Tile Type and Palette Section */}
      <div className="border-b border-stone-700">
        <TilePalette 
          selectedTileId={selectedTileId}
          onSelectTile={onSelectTile}
          selectedRotation={selectedRotation} // Pass rotation state down
          onRotateTile={onRotateTile}         // Pass rotation handler down
          tileType={currentTool}
          onChangeTileType={setCurrentTool}
        />
      </div>
      <div className="p-2 border-b border-stone-700 font-mono text-sm flex items-center justify-between">
        <div className="flex items-center">
          <Layers size={14} className="mr-2" />
          <span>LAYERS</span>
        </div>
        <button
          onClick={onAddLayer}
          className="p-1 rounded hover:bg-stone-700 text-teal-400"
          title="Add new layer"
        >
          <Plus size={16} />
        </button>
      </div>
      
      <div className="flex-1 overflow-auto">
        {layers && layers.length > 0 ? (
          <div className="p-2">
            {/* Show layers in reverse order so top layer is shown first */}
            {[...layers].reverse().map((layer, idx) => {
              // Calculate the actual index
              const actualIndex = layers.length - 1 - idx;
              const isActive = currentLayer === actualIndex;
              
              return (
                <div 
                  key={`layer-${actualIndex}`}
                  className={`mb-2 p-2 rounded border ${
                    isActive 
                      ? 'bg-stone-700 border-teal-500 text-teal-300' 
                      : 'bg-stone-800 border-stone-700 text-teal-50 hover:bg-stone-700'
                  }`}
                  onClick={() => setCurrentLayer(actualIndex)}
                >
                  <div className="flex items-center justify-between">
                    <div className="flex items-center">
                      {/* Layer visibility toggle */}
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          onToggleLayerVisibility(actualIndex);
                        }}
                        className="mr-2 hover:bg-stone-600 p-1 rounded"
                        title={layer.visible ? "Hide layer" : "Show layer"}
                      >
                        {layer.visible ? <Eye size={14} /> : <EyeOff size={14} />}
                      </button>
                      
                      {/* Layer name - either editable or static */}
                      {editingLayerIndex === actualIndex ? (
                        <input
                          ref={layerNameInputRef}
                          className="bg-stone-600 text-sm text-teal-100 px-1 py-0.5 rounded border border-teal-500 focus:outline-none"
                          value={editedLayerName}
                          onChange={(e) => setEditedLayerName(e.target.value)}
                          onKeyDown={(e) => handleInputKeyDown(e, actualIndex)}
                          onBlur={() => handleSaveLayerName(actualIndex)}
                          onClick={(e) => e.stopPropagation()}
                          size={15}
                        />
                      ) : (
                        <span className="text-sm">{layer.name}</span>
                      )}
                    </div>
                    
                    {/* Layer operations */}
                    <div className="flex">
                      {/* Toggle opacity controls button */}
                      <button
                        onClick={(e) => toggleOpacityControls(actualIndex, e)}
                        className={`p-1 hover:bg-stone-600 rounded ${expandedOpacityLayers[actualIndex] ? 'bg-stone-600' : ''}`}
                        title="Toggle opacity controls"
                      >
                        {expandedOpacityLayers[actualIndex] ? 
                          <ChevronUp size={14} /> : 
                          <ChevronDown size={14} />
                        }
                      </button>
                      <button
                        onClick={(e) => handleStartEditing(e, actualIndex)}
                        className="p-1 hover:bg-stone-600 rounded"
                        title="Rename layer"
                      >
                        <Edit2 size={14} />
                      </button>
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          onMoveLayerUp(actualIndex);
                        }}
                        className="p-1 hover:bg-stone-600 rounded"
                        title="Move layer up"
                        disabled={actualIndex === layers.length - 1}
                      >
                        <ArrowUp size={14} className={actualIndex === layers.length - 1 ? "opacity-30" : ""} />
                      </button>
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          onMoveLayerDown(actualIndex);
                        }}
                        className="p-1 hover:bg-stone-600 rounded"
                        title="Move layer down"
                        disabled={actualIndex === 0}
                      >
                        <ArrowDown size={14} className={actualIndex === 0 ? "opacity-30" : ""} />
                      </button>
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          onRemoveLayer(actualIndex);
                        }}
                        className="p-1 hover:bg-red-900 rounded text-red-400 hover:text-red-300"
                        title="Delete layer"
                        disabled={layers.length <= 1}
                      >
                        <Trash2 size={14} className={layers.length <= 1 ? "opacity-30" : ""} />
                      </button>
                    </div>
                  </div>
                  
                  {/* Opacity controls - only shown when expanded */}
                  {expandedOpacityLayers[actualIndex] && (
                    <div 
                      className="mt-2 px-1 pt-2 border-t border-stone-600" 
                      onClick={e => e.stopPropagation()}
                    >
                      <div className="flex items-center">
                        <div className="text-xs text-stone-400 mr-2 w-14">Opacity:</div>
                        
                        {/* Numeric input */}
                        <div className="flex items-center">
                          <input
                            type="text"
                            value={Math.round((layer.opacity || 1.0) * 100)}
                            onChange={(e) => {
                              // Get the value as a number
                              let value = parseInt(e.target.value, 10);
                              
                              // Validate: ensure it's a number between 0-100
                              if (isNaN(value)) value = 100;
                              value = Math.max(0, Math.min(100, value));
                              
                              // Convert percentage to decimal (0-1 range) and update
                              const opacityValue = value / 100;
                              if (onUpdateLayerOpacity) {
                                onUpdateLayerOpacity(actualIndex, opacityValue);
                              }
                            }}
                            className="w-10 bg-stone-700 text-xs text-teal-100 px-1 py-0.5 rounded border border-stone-600 focus:border-teal-500 focus:outline-none text-center"
                            title="Layer opacity (0-100%)"
                          />
                          <span className="text-xs text-stone-400 ml-1">%</span>
                        </div>
                      </div>
                    </div>
                  )}
                </div>
              );
            })}
          </div>
        ) : (
          <div className="flex items-center justify-center h-full">
            <span className="text-stone-500">No layers defined</span>
          </div>
        )}
      </div>
      
      {/* Layer information */}
      <div className="p-2 border-t border-stone-700 text-xs">
        {layers && currentLayer !== undefined && layers[currentLayer] ? (
          <div>
            <div className="text-stone-400">Selected: {layers[currentLayer].name}</div>
            <div className="text-stone-400">Total cells: {layers[currentLayer].cells?.length || 0}</div>
          </div>
        ) : (
          <div className="text-stone-500">No layer selected</div>
        )}
      </div>
    </div>
  );
};

export default LayerPanel;

================
File: src/components/windows/mapeditor/MapCanvas.jsx
================
import React, { useRef, useEffect, useState, useLayoutEffect, useCallback } from 'react';
import { Grid } from 'lucide-react';
import { screenToGridCoordinates, gridToScreenCoordinates } from './utils/mapUtils';
import { getTileCoordinates, FLOOR_TILESET_PATH, WALL_TILESET_PATH, SHADOW_TILESET_PATH, TILE_SIZE, TILESET_COLS } from './utils/tileRegistry';

/**
 * The main canvas component for the Grid Map Editor
 * Handles rendering and interaction with the grid map
 */
const MapCanvas = ({ 
  mapData, 
  currentLayer, 
  currentTool, 
  selectedTileId = 0,
  selectedRotation = 0,
  onEdit, 
  showGrid = true, 
  resetViewRef,
  brushSize = 1
}) => {
  const containerRef = useRef(null);
  const canvasRef = useRef(null);
  const [gridSize, setGridSize] = useState(32);
  const [viewportOffset, setViewportOffset] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
  const [activeMouseButton, setActiveMouseButton] = useState(null);
  const [hoverCell, setHoverCell] = useState(null);
  const [canvasSize, setCanvasSize] = useState({ width: 800, height: 600 });
  const [isSpacePressed, setIsSpacePressed] = useState(false);
  const [floorTilesetImage, setFloorTilesetImage] = useState(null);
  const [wallTilesetImage, setWallTilesetImage] = useState(null);
  const [shadowTilesetImage, setShadowTilesetImage] = useState(null);
  const [actualColumns, setActualColumns] = useState(TILESET_COLS);
  
  // Reset view to origin (0,0) function
  const resetViewToOrigin = useCallback(() => {
    setViewportOffset({ x: 0, y: 0 });
  }, []);

  // Store the reset function in the provided ref
  useEffect(() => {
    if (resetViewRef) {
      resetViewRef.current = resetViewToOrigin;
    }
  }, [resetViewToOrigin, resetViewRef]);
  
  // Load the tileset images on component mount
  useEffect(() => {
    // Load floor tileset
    const floorImg = new Image();
    floorImg.onload = () => {
      // Calculate columns based on the image width
      const cols = Math.floor(floorImg.width / TILE_SIZE);
      console.log(`MapCanvas: Detected ${cols} columns in the floor sprite sheet`);
      
      // Batch state updates to avoid multiple re-renders
      setActualColumns(cols);
      setFloorTilesetImage(floorImg);
    };
    floorImg.onerror = () => console.error('Failed to load floor tileset');
    floorImg.src = FLOOR_TILESET_PATH;
    
    // Load wall tileset
    const wallImg = new Image();
    wallImg.onload = () => {
      setWallTilesetImage(wallImg);
      console.log('MapCanvas: Wall tileset loaded successfully');
    };
    wallImg.onerror = () => console.error('Failed to load wall tileset');
    wallImg.src = WALL_TILESET_PATH;

    const shadowImg = new Image();
    shadowImg.onload = () => {
      setShadowTilesetImage(shadowImg);
      console.log('MapCanvas: Shadow tileset loaded successfully');
    };
    shadowImg.onerror = () => console.error('Failed to load shadow tileset');
    shadowImg.src = SHADOW_TILESET_PATH;
  }, []);

  /**
   * Draw a tile on the canvas based on its type and tile ID
   * @param {CanvasRenderingContext2D} ctx - Canvas context
   * @param {number} x - X position on canvas
   * @param {number} y - Y position on canvas
   * @param {number} size - Size of the tile
   * @param {Object} cell - The cell data including type and tileId
   */
  // Pass showGrid to the drawTile function
  const drawTile = (ctx, x, y, size, cell) => {
    const { type, tileId, rotation = 0 } = cell;
    
    // Add debugging for rotation values
    if (rotation !== 0) {
      console.log(`Drawing cell at (${cell.x}, ${cell.y}) with rotation: ${rotation}`);
    }
    
    // Handle floor tiles with tileset
    if (type === 'floor' && tileId !== undefined && floorTilesetImage) {
      // Calculate coordinates based on actual columns in the sheet
      // instead of using getTileCoordinates which might use the wrong column count
      const col = tileId % actualColumns;
      const row = Math.floor(tileId / actualColumns);
      const sourceX = col * TILE_SIZE;
      const sourceY = row * TILE_SIZE;
      
      // Handle rotation
      if (rotation !== 0) {
        // Save the current context state
        ctx.save();
        
        // Move to the center of the tile position
        ctx.translate(x + size/2, y + size/2);
        
        // Rotate the context by the specified angle (convert degrees to radians)
        const angleInRadians = (rotation * Math.PI) / 180;
        ctx.rotate(angleInRadians);
        
        // Draw the tile, but with coordinates adjusted to draw centered around origin
        ctx.drawImage(
          floorTilesetImage,
          sourceX, sourceY, TILE_SIZE, TILE_SIZE,
          -size/2, -size/2, size, size
        );
        
        // Restore the context to its original state
        ctx.restore();
        
        // Draw grid lines on top only if showGrid is true
        if (showGrid) {
          ctx.strokeStyle = '#44403c'; // Stone-700
          ctx.strokeRect(x, y, size, size);
        }
      } else {
        // No rotation, draw normally
        ctx.drawImage(
          floorTilesetImage,
          sourceX, sourceY, TILE_SIZE, TILE_SIZE,
          x, y, size, size
        );
        
        // Draw grid lines on top only if showGrid is true
        if (showGrid) {
          ctx.strokeStyle = '#44403c'; // Stone-700
          ctx.strokeRect(x, y, size, size);
        }
      }
      return;
    }
    
    // Handle wall tiles with tileset
    if (type === 'wall' && tileId !== undefined && wallTilesetImage) {
      // Calculate coordinates based on actual columns in the sheet
      const col = tileId % actualColumns;
      const row = Math.floor(tileId / actualColumns);
      const sourceX = col * TILE_SIZE;
      const sourceY = row * TILE_SIZE;
      
      // Handle rotation
      if (rotation !== 0) {
        // Save the current context state
        ctx.save();
        
        // Move to the center of the tile position
        ctx.translate(x + size/2, y + size/2);
        
        // Rotate the context by the specified angle (convert degrees to radians)
        const angleInRadians = (rotation * Math.PI) / 180;
        ctx.rotate(angleInRadians);
        
        // Draw the tile, but with coordinates adjusted to draw centered around origin
        ctx.drawImage(
          wallTilesetImage,
          sourceX, sourceY, TILE_SIZE, TILE_SIZE,
          -size/2, -size/2, size, size
        );
        
        // Restore the context to its original state
        ctx.restore();
        
        // Draw grid lines on top only if showGrid is true
        if (showGrid) {
          ctx.strokeStyle = '#44403c'; // Stone-700
          ctx.strokeRect(x, y, size, size);
        }
      } else {
        // No rotation, draw normally
        ctx.drawImage(
          wallTilesetImage,
          sourceX, sourceY, TILE_SIZE, TILE_SIZE,
          x, y, size, size
        );
        
        // Draw grid lines on top only if showGrid is true
        if (showGrid) {
          ctx.strokeStyle = '#44403c'; // Stone-700
          ctx.strokeRect(x, y, size, size);
        }
      }
      return;
    }

    // Handle shadow tiles with tileset
    console.log('Drawing tile:', { type, tileId, shadowTilesetImage: !!shadowTilesetImage });
    if (type === 'shadow' && shadowTilesetImage) {
      // Calculate coordinates based on actual columns in the sheet
      const effectiveTileId = tileId !== undefined ? tileId : 0;
      const col = effectiveTileId  % actualColumns;
      const row = Math.floor(effectiveTileId  / actualColumns);
      const sourceX = col * TILE_SIZE;
      const sourceY = row * TILE_SIZE;
      
      // Handle rotation
      if (rotation !== 0) {
        // Save the current context state
        ctx.save();
        
        // Move to the center of the tile position
        ctx.translate(x + size/2, y + size/2);
        
        // Rotate the context by the specified angle (convert degrees to radians)
        const angleInRadians = (rotation * Math.PI) / 180;
        ctx.rotate(angleInRadians);
        
        // Draw the tile, but with coordinates adjusted to draw centered around origin
        ctx.drawImage(
          shadowTilesetImage,
          sourceX, sourceY, TILE_SIZE, TILE_SIZE,
          -size/2, -size/2, size, size
        );
        
        // Restore the context to its original state
        ctx.restore();
        
        // Draw grid lines on top only if showGrid is true
        if (showGrid) {
          ctx.strokeStyle = '#44403c'; // Stone-700
          ctx.strokeRect(x, y, size, size);
        }
      } else {
        // No rotation, draw normally
        ctx.drawImage(
          shadowTilesetImage,
          sourceX, sourceY, TILE_SIZE, TILE_SIZE,
          x, y, size, size
        );
        
        // Draw grid lines on top only if showGrid is true
        if (showGrid) {
          ctx.strokeStyle = '#44403c'; // Stone-700
          ctx.strokeRect(x, y, size, size);
        }
      }
      return;
    }
    
    // Fall back to original color-based rendering for other types
    switch(type) {
      case 'wall':
        // Fallback if wall tileset image failed to load or tileId is undefined
        ctx.fillStyle = '#6b7280'; // Gray
        ctx.fillRect(x, y, size, size);
        break;
      case 'floor':
        // Default floor if no tileId or image failed to load
        ctx.fillStyle = '#1e293b'; // Slate-800
        ctx.fillRect(x, y, size, size);
        break;
      case 'shadow':
        // Default floor if no tileId or image failed to load
        ctx.fillStyle = '#BF40BF'; // Slate-800
        ctx.fillRect(x, y, size, size);
        break;
      case 'door':
        // For doors, apply rotation to the whole door element
        if (rotation !== 0) {
          // Save the current context state
          ctx.save();
          
          // Move to the center of the tile position
          ctx.translate(x + size/2, y + size/2);
          
          // Rotate the context by the specified angle (convert degrees to radians)
          const angleInRadians = (rotation * Math.PI) / 180;
          ctx.rotate(angleInRadians);
          
          // Draw floor background
          ctx.fillStyle = '#1e293b'; // Slate background
          ctx.fillRect(-size/2, -size/2, size, size);
          
          // Draw door centered
          ctx.fillStyle = '#b45309'; // Amber-700
          ctx.fillRect(-size/4, -size/4, size/2, size/2);
          
          // Restore the context to its original state
          ctx.restore();
        } else {
          // Draw floor first (no rotation)
          ctx.fillStyle = '#1e293b'; // Slate background
          ctx.fillRect(x, y, size, size);
          // Then draw door
          ctx.fillStyle = '#b45309'; // Amber-700
          ctx.fillRect(x + size/4, y + size/4, size/2, size/2);
        }
        break;
      // Add more tile types as needed
      default:
        // Unknown tile type, draw placeholder
        ctx.fillStyle = '#ef4444'; // Red-500
        ctx.fillRect(x, y, size, size);
    }
    
    // Draw grid lines on top only if showGrid is true
    if (showGrid) {
      ctx.strokeStyle = '#44403c'; // Stone-700
      ctx.strokeRect(x, y, size, size);
    }
  };

  /**
   * Handle cell editing with a specific tool or the current selected tool
   */
  const handleCellEdit = (e, overrideTool) => {
    if (!canvasRef.current || !mapData || !onEdit) return;
    
    // Get mouse position relative to canvas
    const rect = canvasRef.current.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Convert to grid coordinates
    const gridCoords = screenToGridCoordinates(mouseX, mouseY, gridSize, viewportOffset);
    
    console.log("Editing cell at", gridCoords, "with tool:", overrideTool || currentTool);
    console.log("Current selectedRotation value:", selectedRotation);
    
    // Basic validation if the center point is outside map boundaries
    if (gridCoords.x < 0 || gridCoords.x >= mapData.width || 
        gridCoords.y < 0 || gridCoords.y >= mapData.height) {
      // Coordinates outside map boundary - do nothing
      console.log(`Cell at (${gridCoords.x}, ${gridCoords.y}) is outside map boundaries (${mapData.width}x${mapData.height})`);
      return;
    }
    
    // Use the override tool if provided, otherwise use the current tool
    const toolToUse = overrideTool || currentTool;
    
    // Only edit if using a tool other than select
    if (toolToUse === 'select') return;
    
    // For brush size of 1, just edit the single cell
    if (brushSize === 1) {
  // Add more detailed logs about rotation
  console.log("=================== PLACING TILE ===================");
  console.log("About to call onEdit with rotation:", selectedRotation);
  console.log("Tool being used:", toolToUse);
  console.log("Current selected rotation value:", selectedRotation);
  console.log("At coordinates:", gridCoords);
  
  // Use the selectedRotation prop directly
  const rotation = parseInt(selectedRotation, 10) || 0;
  console.log("Using prop selectedRotation for placement:", rotation);
  
  // Pass rotation and selectedTileId
  console.log(`Calling onEdit with rotation: ${rotation}, tileId: ${selectedTileId}`);
  onEdit(gridCoords.x, gridCoords.y, toolToUse, rotation, selectedTileId);
  
  // This log should help us verify the call was made
  console.log("onEdit called with rotation:", rotation, "and tileId:", selectedTileId);
  console.log("=================================================");
      return;
    }
    
    // For larger brushes, always center around the hover cell
    // This matches the hover indicator logic for consistent behavior
    const halfBrush = Math.floor(brushSize / 2);
    
    // Calculate how to position the brush so the cursor is in the center
    // For even sizes, there's no true center cell, so we offset by half a cell
    const offset = brushSize % 2 === 0 ? 0.5 : 0;
    
    // Apply to all cells in the brush area
    for (let dy = -halfBrush + offset; dy < brushSize - halfBrush + offset; dy++) {
      for (let dx = -halfBrush + offset; dx < brushSize - halfBrush + offset; dx++) {
        const cellX = Math.floor(gridCoords.x + dx);
        const cellY = Math.floor(gridCoords.y + dy);
        
        // Skip if outside map boundaries
        if (cellX < 0 || cellX >= mapData.width || 
            cellY < 0 || cellY >= mapData.height) {
          continue;
        }
        
        // Edit this cell with the current rotation value from props
        const rotation = parseInt(selectedRotation, 10) || 0;
        
        console.log(`Placing brushed tile at (${cellX}, ${cellY}) with rotation: ${rotation}, tileId: ${selectedTileId}`);
        onEdit(cellX, cellY, toolToUse, rotation, selectedTileId);
      }
    }
  };

  // Set up ResizeObserver to update canvas dimensions
  useLayoutEffect(() => {
    if (!containerRef.current) return;
    
    const updateCanvasSize = () => {
      if (containerRef.current) {
        const { width, height } = containerRef.current.getBoundingClientRect();
        setCanvasSize({ width, height });
      }
    };
    
    // Initial size update
    updateCanvasSize();
    
    // Set up ResizeObserver
    const resizeObserver = new ResizeObserver(entries => {
      if (entries.length > 0) {
        updateCanvasSize();
      }
    });
    
    resizeObserver.observe(containerRef.current);
    
    // Clean up
    return () => {
      resizeObserver.disconnect();
    };
  }, []);
  
  // Update hover cell when mouse moves
  const updateHoverCell = (e) => {
    if (!canvasRef.current || !mapData) return;
    
    const rect = canvasRef.current.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    const gridCoords = screenToGridCoordinates(mouseX, mouseY, gridSize, viewportOffset);
    
    // Only set hover cell if it's within map boundaries
    if (gridCoords.x >= 0 && gridCoords.x < mapData.width && 
        gridCoords.y >= 0 && gridCoords.y < mapData.height) {
      setHoverCell(gridCoords);
    } else {
      // Clear hover cell when outside map boundaries
      setHoverCell(null);
    }
  };

  // Handle keyboard events for spacebar
  useEffect(() => {
    const handleKeyDown = (e) => {
      // Space key
      if (e.key === ' ' || e.keyCode === 32) {
        setIsSpacePressed(true);
      }
    };

    const handleKeyUp = (e) => {
      // Space key
      if (e.key === ' ' || e.keyCode === 32) {
        setIsSpacePressed(false);
        setIsDragging(false);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);

  // Reference to the canvas context
  const ctxRef = useRef(null);
  
  // Function to draw the canvas contents
  const drawCanvas = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas || !mapData) return;
    
    // Log current rotation when drawing canvas for debugging
    console.log("Drawing canvas with selectedRotation:", selectedRotation);

    const ctx = canvas.getContext('2d');
    ctxRef.current = ctx;
    
    const width = canvas.width;
    const height = canvas.height;

    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    
    // Background color
    ctx.fillStyle = '#1c1917'; // Stone-900 from Tailwind
    ctx.fillRect(0, 0, width, height);
    
    // Adjust for viewport offset
    const offsetX = viewportOffset.x;
    const offsetY = viewportOffset.y;
    
    // Draw default grid background - useful for visualizing empty spaces
    for (let x = 0; x < mapData.width; x++) {
      for (let y = 0; y < mapData.height; y++) {
        const screenX = Math.floor(x * gridSize + offsetX);
        const screenY = Math.floor(y * gridSize + offsetY);
        
        // Only draw if visible on screen
        if (screenX > -gridSize && screenX < width && 
            screenY > -gridSize && screenY < height) {
          // Draw a subtle background for all cells
          // ctx.fillStyle = '#0f172a'; // Very dark slate blue
          ctx.fillStyle = '#042f2e'; // Very dark slate blue
          ctx.fillRect(screenX, screenY, gridSize, gridSize);
        }
      }
    }
    
    // Draw a clear boundary around the map area
    const mapWidthPx = mapData.width * gridSize;
    const mapHeightPx = mapData.height * gridSize;
    const mapStartX = offsetX;
    const mapStartY = offsetY;
    
    // Draw boundary with more visible color
    ctx.strokeStyle = '#5eead4'; // Orange-500
    ctx.lineWidth = 2;
    ctx.strokeRect(mapStartX, mapStartY, mapWidthPx, mapHeightPx);
    
    // Add small corner markers for extra visibility
    const cornerSize = 8;
    ctx.fillStyle = '#5eead4'; // Orange-500
    
    // Top-left corner
    ctx.fillRect(mapStartX - 1, mapStartY - 1, cornerSize, cornerSize);
    
    // Top-right corner
    ctx.fillRect(mapStartX + mapWidthPx - cornerSize + 1, mapStartY - 1, cornerSize, cornerSize);
    
    // Bottom-left corner
    ctx.fillRect(mapStartX - 1, mapStartY + mapHeightPx - cornerSize + 1, cornerSize, cornerSize);
    
    // Bottom-right corner
    ctx.fillRect(mapStartX + mapWidthPx - cornerSize + 1, mapStartY + mapHeightPx - cornerSize + 1, cornerSize, cornerSize);
    
    // Draw map data (cells from each layer)
    if (mapData && mapData.layers && mapData.layers.length > 0) {
      // Render each visible layer from bottom to top
      mapData.layers.forEach((layer, layerIndex) => {
        if (!layer.visible) return;
        
        // Set layer opacity if defined, default to 1.0 (fully opaque)
        const layerOpacity = layer.opacity !== undefined ? layer.opacity : 1.0;
        ctx.globalAlpha = layerOpacity;
        
        // Draw cells
        layer.cells.forEach(cell => {
          // Calculate screen position for this cell
          const screenX = Math.floor(cell.x * gridSize + offsetX);
          const screenY = Math.floor(cell.y * gridSize + offsetY);
          
          // Draw the tile if it's visible on screen
          if (screenX > -gridSize && screenX < width && 
              screenY > -gridSize && screenY < height) {
            drawTile(ctx, screenX, screenY, gridSize, cell);
          }
        });
        
        // Highlight current layer with a subtle border if it matches the currentLayer (only if showGrid is true)
        if (layerIndex === currentLayer && showGrid) {
          // Make sure we use full opacity for the highlight, regardless of layer opacity
          ctx.globalAlpha = 1.0;
          ctx.strokeStyle = 'rgba(20, 184, 166, 0.5)'; // Teal with opacity
          ctx.lineWidth = 2;
          
          layer.cells.forEach(cell => {
            const screenX = Math.floor(cell.x * gridSize + offsetX);
            const screenY = Math.floor(cell.y * gridSize + offsetY);
            
            if (screenX > -gridSize && screenX < width && 
                screenY > -gridSize && screenY < height) {
              ctx.strokeRect(screenX, screenY, gridSize, gridSize);
            }
          });
        }
        
        // Reset global alpha to default (1.0) after drawing this layer
        ctx.globalAlpha = 1.0;
      });
    }
    
    // Draw grid on top (only if showGrid is true)
    if (showGrid) {
      ctx.strokeStyle = '#44403c'; // Stone-700 from Tailwind
      ctx.lineWidth = 1;
      
      // Calculate grid line positioning
      const gridOffsetX = offsetX % gridSize;
      const gridOffsetY = offsetY % gridSize;
      
      // Draw vertical lines
      for (let x = gridOffsetX; x < width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      
      // Draw horizontal lines
      for (let y = gridOffsetY; y < height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
    }
    
    // Draw hover highlight
    if (hoverCell) {
      // For brush size of 1, just highlight the single cell
      if (brushSize === 1) {
        const screenX = Math.floor(hoverCell.x * gridSize + offsetX);
        const screenY = Math.floor(hoverCell.y * gridSize + offsetY);
        
        ctx.fillStyle = 'rgba(20, 184, 166, 0.3)'; // Teal with opacity
        ctx.fillRect(screenX, screenY, gridSize, gridSize);
        
        // Show tool indicator
        ctx.fillStyle = '#14b8a6';
        ctx.font = '12px monospace';
        
        // If right mouse button is pressed, show "erase" as the tool
        const displayTool = activeMouseButton === 2 ? 'erase' : currentTool;
        ctx.fillText(displayTool, screenX + 5, screenY + 15);
      } else {
        // For larger brushes, always center around the hoverCell
        const halfBrush = Math.floor(brushSize / 2);
        
        // Calculate how to position the brush so the cursor is in the center
        // For even sizes, there's no true center cell, so we need to offset by half a cell
        const offset = brushSize % 2 === 0 ? 0.5 : 0;
        
        // Generate all cell positions that should be part of the brush
        for (let dy = -halfBrush + offset; dy < brushSize - halfBrush + offset; dy++) {
          for (let dx = -halfBrush + offset; dx < brushSize - halfBrush + offset; dx++) {
            const cellX = Math.floor(hoverCell.x + dx);
            const cellY = Math.floor(hoverCell.y + dy);
            
            // Skip if outside map boundaries
            if (cellX < 0 || cellX >= mapData.width || 
                cellY < 0 || cellY >= mapData.height) {
              continue;
            }
            
            // Calculate screen position (fixed to separate gridSize multiplication from offset)
            const screenX = Math.floor(cellX * gridSize) + offsetX;
            const screenY = Math.floor(cellY * gridSize) + offsetY;
            
            ctx.fillStyle = 'rgba(20, 184, 166, 0.3)'; // Teal with opacity
            ctx.fillRect(screenX, screenY, gridSize, gridSize);
          }
        }
        
        // Show tool indicator centered on the cursor position
        const indicatorX = Math.floor(hoverCell.x * gridSize) + offsetX;
        const indicatorY = Math.floor(hoverCell.y * gridSize) + offsetY;
        
        ctx.fillStyle = '#14b8a6';
        ctx.font = '12px monospace';
        
        // If right mouse button is pressed, show "erase" as the tool
        const displayTool = activeMouseButton === 2 ? 'erase' : currentTool;
        ctx.fillText(`${displayTool} (${brushSize}${brushSize})`, indicatorX + 5, indicatorY + 15);
      }
    }
  }, [
    gridSize, 
    viewportOffset, 
    mapData, 
    currentLayer, 
    hoverCell, 
    currentTool, 
    activeMouseButton, 
    showGrid, 
    floorTilesetImage,
    wallTilesetImage,
    shadowTilesetImage,
    actualColumns,
    // selectedRotation, // Removed: Toolbar rotation shouldn't trigger full canvas redraw
    brushSize  // Add brushSize as a dependency too for completeness
  ]);
  
  // Call drawCanvas whenever relevant dependencies change
  useEffect(() => {
    if (canvasRef.current && mapData) {
      drawCanvas();
    }
  }, [drawCanvas]);
  
  // Update canvas size when container size changes
  useEffect(() => {
    if (canvasRef.current && canvasSize.width > 0 && canvasSize.height > 0) {
      drawCanvas();
    }
  }, [canvasSize, drawCanvas]);

  // Manually trigger a redraw whenever tileset images are loaded
  // Breaking the circular dependency by removing drawCanvas from dependencies
  useEffect(() => {
    if ((floorTilesetImage || wallTilesetImage || shadowTilesetImage) && canvasRef.current && mapData) {
      // Call drawCanvas without adding it to dependency array
      drawCanvas();
    }
  }, [floorTilesetImage, wallTilesetImage, shadowTilesetImage, mapData]); // Removed drawCanvas dependency

  // Handle canvas mouse events
  const handleMouseDown = (e) => {
    // Prevent context menu on right click
    if (e.button === 2) {
      e.preventDefault();
    }
    
    setActiveMouseButton(e.button);
    
    // Middle mouse button (1) for panning
    if (e.button === 1) {
      setIsDragging(true);
      setDragStart({ x: e.clientX, y: e.clientY });
      e.preventDefault(); // Prevent default scrolling behavior for middle mouse button
    } 
    // Right mouse button (2) for erasing
    else if (e.button === 2 && !isSpacePressed) {
      handleCellEdit(e, 'erase');
    }
    // Left mouse button (0) for drawing with current tool
    else if (e.button === 0 && !isSpacePressed) {
      handleCellEdit(e);
    }
    // If space is pressed, start dragging regardless of which mouse button
    else if (isSpacePressed) {
      setIsDragging(true);
      setDragStart({ x: e.clientX, y: e.clientY });
    }
  };

  const handleMouseMove = (e) => {
    // Always update hover cell
    updateHoverCell(e);
    
    // Handle dragging for pan with middle mouse button (1),
    // or spacebar + any mouse button
    if (isDragging && (activeMouseButton === 1 || isSpacePressed)) {
      const dx = e.clientX - dragStart.x;
      const dy = e.clientY - dragStart.y;
      
      setViewportOffset({
        x: viewportOffset.x + dx,
        y: viewportOffset.y + dy
      });
      
      setDragStart({ x: e.clientX, y: e.clientY });
    }
    // Handle spacebar + mouse move (even without button press)
    else if (isSpacePressed && !isDragging) {
      // Start dragging when space is pressed and mouse moves
      setIsDragging(true);
      setDragStart({ x: e.clientX, y: e.clientY });
    }
    // Handle continuous drawing while left mouse button is down
    else if (activeMouseButton === 0 && !isSpacePressed) {
      handleCellEdit(e);
    }
    // Handle continuous erasing while right mouse button is down
    else if (activeMouseButton === 2 && !isSpacePressed) {
      handleCellEdit(e, 'erase');
    }
  };

  const handleMouseUp = () => {
    // Only stop dragging if we're not using spacebar navigation
    if (!isSpacePressed) {
      setIsDragging(false);
    }
    setActiveMouseButton(null);
  };

  const handleWheel = (e) => {
    // Get cursor position relative to canvas
    const rect = canvasRef.current.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    // Get grid coordinates under cursor before zoom
    const gridCoordsBefore = screenToGridCoordinates(mouseX, mouseY, gridSize, viewportOffset);
    
    // Calculate new grid size
    let newGridSize;
    if (e.deltaY < 0) {
      // Zoom in - increase grid size
      newGridSize = Math.min(gridSize + 4, 64);
    } else {
      // Zoom out - decrease grid size
      newGridSize = Math.max(gridSize - 4, 16);
    }
    
    // Calculate screen coordinates after zoom with the current viewport offset
    const screenCoordsAfter = {
      x: gridCoordsBefore.x * newGridSize + viewportOffset.x,
      y: gridCoordsBefore.y * newGridSize + viewportOffset.y
    };
    
    // Calculate the difference to maintain cursor position
    const dx = mouseX - screenCoordsAfter.x;
    const dy = mouseY - screenCoordsAfter.y;
    
    // Update grid size and adjust viewport offset
    setGridSize(newGridSize);
    setViewportOffset(prev => ({
      x: prev.x + dx,
      y: prev.y + dy
    }));
  };

  return (
    <div 
      ref={containerRef}
      className="flex-1 relative flex overflow-hidden bg-stone-900"
    >
      <div className="absolute top-2 left-2 bg-stone-800 p-2 rounded text-xs text-teal-400 flex items-center z-10">
        <Grid size={14} className="mr-1" />
        <span>Grid Size: {gridSize}px</span>
        {!showGrid && <span className="ml-2">(Grid Hidden)</span>}
      </div>
      
      <canvas 
        ref={canvasRef}
        width={canvasSize.width}
        height={canvasSize.height}
        className="w-full h-full border border-stone-700"
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseUp}
        onWheel={handleWheel}
        onContextMenu={(e) => e.preventDefault()} // Prevent context menu on right click
      />
      <div className="absolute bottom-2 right-2 bg-stone-800 p-2 rounded text-xs text-teal-400 z-10">
        {currentTool && <span>Tool: {activeMouseButton === 2 ? 'erase' : currentTool}</span>}
        {hoverCell && <span className="ml-2">Position: ({hoverCell.x}, {hoverCell.y})</span>}
      </div>
    </div>
  );
};

export default MapCanvas;

================
File: src/components/windows/mapeditor/MapPropertiesPanel.jsx
================
import React, { useState } from 'react';
import { Grid, Save, Settings, X } from 'lucide-react';

/**
 * Panel for editing map properties
 */
const MapPropertiesPanel = ({ mapData, onApply, onCancel }) => {
  const [width, setWidth] = useState(mapData ? mapData.width : 20);
  const [height, setHeight] = useState(mapData ? mapData.height : 15);
  const [gridSize, setGridSize] = useState(mapData ? mapData.gridSize : 32);
  const [name, setName] = useState(mapData ? mapData.name : 'New Map');
  const [error, setError] = useState(null);

  // Validate input and apply changes
  const handleApply = () => {
    // Validate width and height
    if (width < 1 || width > 100) {
      setError('Width must be between 1 and 100');
      return;
    }
    
    if (height < 1 || height > 100) {
      setError('Height must be between 1 and 100');
      return;
    }
    
    if (gridSize < 16 || gridSize > 64) {
      setError('Grid size must be between 16 and 64');
      return;
    }
    
    // Apply changes
    onApply({
      width: Number(width),
      height: Number(height),
      gridSize: Number(gridSize),
      name
    });
  };

  // Handle input changes
  const handleInputChange = (setter) => (e) => {
    const value = e.target.value;
    if (value === '' || /^\d+$/.test(value)) {
      setter(value === '' ? '' : Number(value));
    }
  };

  return (
    <div className="bg-stone-800 border border-stone-700 rounded-lg p-4 w-64">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-teal-400 text-sm font-semibold flex items-center">
          <Settings size={16} className="mr-1" />
          Map Properties
        </h2>
        <button
          onClick={onCancel}
          className="text-stone-500 hover:text-stone-300"
        >
          <X size={16} />
        </button>
      </div>
      
      {error && (
        <div className="bg-red-900/30 text-red-400 p-2 rounded mb-3 text-xs">
          {error}
        </div>
      )}
      
      <div className="space-y-3">
        <div>
          <label className="block text-xs text-stone-400 mb-1">Map Name</label>
          <input
            type="text"
            value={name}
            onChange={(e) => setName(e.target.value)}
            className="w-full bg-stone-900 border border-stone-700 rounded px-2 py-1 text-sm text-teal-100 focus:outline-none focus:border-teal-600"
          />
        </div>
        
        <div>
          <label className="block text-xs text-stone-400 mb-1">Width (cells)</label>
          <input
            type="text"
            value={width}
            onChange={handleInputChange(setWidth)}
            className="w-full bg-stone-900 border border-stone-700 rounded px-2 py-1 text-sm text-teal-100 focus:outline-none focus:border-teal-600"
          />
        </div>
        
        <div>
          <label className="block text-xs text-stone-400 mb-1">Height (cells)</label>
          <input
            type="text"
            value={height}
            onChange={handleInputChange(setHeight)}
            className="w-full bg-stone-900 border border-stone-700 rounded px-2 py-1 text-sm text-teal-100 focus:outline-none focus:border-teal-600"
          />
        </div>
        
        <div>
          <label className="block text-xs text-stone-400 mb-1">Grid Size (pixels)</label>
          <input
            type="text"
            value={gridSize}
            onChange={handleInputChange(setGridSize)}
            className="w-full bg-stone-900 border border-stone-700 rounded px-2 py-1 text-sm text-teal-100 focus:outline-none focus:border-teal-600"
          />
        </div>
        
        <div className="pt-2 flex justify-end">
          <button
            onClick={handleApply}
            className="bg-teal-700 hover:bg-teal-600 text-teal-100 px-3 py-1 rounded text-xs flex items-center"
          >
            <Save size={14} className="mr-1" />
            Apply Changes
          </button>
        </div>
      </div>
    </div>
  );
};

export default MapPropertiesPanel;

================
File: src/components/windows/mapeditor/MapToolbar.jsx
================
import React, { useState, useEffect } from 'react';
import { 
  Save, Undo, Redo, Trash2, Copy, Square, Circle, 
  Grid, ZoomIn, ZoomOut, Download, Upload, Plus, Minus,
  Layers, MousePointer, Hammer, Wand2, FileText, Settings,
  Home
} from 'lucide-react';

/**
 * Toolbar component for the Map Editor
 */
const MapToolbar = ({ 
  onSave, 
  onUndo, 
  onRedo, 
  onClear, 
  onExportAscii, 
  onImportAscii,
  onToggleGrid,
  onResetView,
  showGrid = true,
  saveStatus = 'saved', // default to 'saved'
  mapData,
  onApplyProperties
}) => {
  const [showProperties, setShowProperties] = useState(false);
  const [mapName, setMapName] = useState(mapData?.name || 'New Map');
  const [mapWidth, setMapWidth] = useState(mapData?.width || 20);
  const [mapHeight, setMapHeight] = useState(mapData?.height || 15);
  const [mapGridSize, setMapGridSize] = useState(mapData?.gridSize || 32);
  const [error, setError] = useState(null);

  // Update state when mapData changes
  useEffect(() => {
    if (mapData) {
      setMapName(mapData.name || 'New Map');
      setMapWidth(mapData.width || 20);
      setMapHeight(mapData.height || 15);
      setMapGridSize(mapData.gridSize || 32);
    }
  }, [mapData]);

  // Handle applying property changes
  const handleApplyProperties = () => {
    // Validate inputs
    if (mapWidth < 1 || mapWidth > 100) {
      setError('Width must be between 1 and 100');
      return;
    }
    if (mapHeight < 1 || mapHeight > 100) {
      setError('Height must be between 1 and 100');
      return;
    }
    if (mapGridSize < 16 || mapGridSize > 64) {
      setError('Grid size must be between 16 and 64');
      return;
    }

    // Clear any errors
    setError(null);

    // Apply changes
    onApplyProperties({
      name: mapName,
      width: Number(mapWidth),
      height: Number(mapHeight),
      gridSize: Number(mapGridSize)
    });
  };

  // Handle number input changes with validation
  const handleNumberChange = (setter) => (e) => {
    const value = e.target.value;
    if (value === '' || /^\d+$/.test(value)) {
      setter(value === '' ? '' : Number(value));
    }
  };

  // Toggle properties panel
  const toggleProperties = () => {
    setShowProperties(!showProperties);
  };

  return (
    <>
      <div className="flex justify-between items-center p-2 bg-stone-800 border-b border-stone-700">
        {/* File operations */}
        <div className="flex space-x-1 items-center">
          <button 
            onClick={onSave}
            className="p-2 hover:bg-stone-700 rounded text-teal-400"
            title="Save map"
          >
            <Save size={18} />
          </button>
          <button 
            className="p-2 hover:bg-stone-700 rounded text-teal-400"
            title="Clear map"
            onClick={onClear}
          >
            <Trash2 size={18} />
          </button>
          <button 
            className="p-2 hover:bg-stone-700 rounded text-teal-400"
            title="Export as PNG"
          >
            <Download size={18} />
          </button>
          <button 
            className="p-2 hover:bg-stone-700 rounded text-teal-400"
            title="Import tileset"
          >
            <Upload size={18} />
          </button>
          <div className="h-6 border-r border-stone-700 mx-1"></div>
          <button 
            className="p-2 hover:bg-stone-700 rounded text-teal-400"
            title="Export as ASCII"
            onClick={onExportAscii}
          >
            <FileText size={18} />
          </button>
          <button 
            className="p-2 hover:bg-stone-700 rounded text-teal-400"
            title="Import from ASCII"
            onClick={onImportAscii}
          >
            <Upload size={18} />
          </button>
        </div>

        {/* Empty space in the middle to maintain layout */}
        <div className="flex-1"></div>

        {/* View options */}
        <div className="flex space-x-1">
          <button
            onClick={onToggleGrid}
            className={`p-2 hover:bg-stone-700 rounded ${
              showGrid ? 'text-teal-400' : 'text-stone-500'
            }`}
            title={showGrid ? "Hide grid" : "Show grid"}
          >
            <Grid size={18} />
          </button>
          <button
            onClick={onResetView}
            className="p-2 hover:bg-stone-700 rounded text-teal-400"
            title="Return to origin (0,0)"
          >
            <Home size={18} />
          </button>
          <button 
            className={`p-2 hover:bg-stone-700 rounded ${showProperties ? 'bg-stone-700 text-teal-300' : 'text-teal-400'}`}
            title="Map Properties"
            onClick={toggleProperties}
          >
            <Settings size={18} />
          </button>
        </div>
      </div>
      
      {/* Properties Panel - Expandable */}
      {showProperties && (
        <div className="bg-stone-800 border-b border-stone-700 p-2 grid grid-cols-5 gap-2 items-center text-sm">
          {error && (
            <div className="col-span-5 bg-red-900/30 text-red-400 p-2 rounded mb-2 text-xs">
              {error}
            </div>
          )}
          
          <div className="flex items-center">
            <label className="mr-2 text-stone-400">Width:</label>
            <input
              type="text"
              value={mapWidth}
              onChange={handleNumberChange(setMapWidth)}
              className="w-16 bg-stone-900 border border-stone-700 rounded px-2 py-1 text-sm text-teal-100 focus:outline-none focus:border-teal-600"
            />
          </div>
          
          <div className="flex items-center">
            <label className="mr-2 text-stone-400">Height:</label>
            <input
              type="text"
              value={mapHeight}
              onChange={handleNumberChange(setMapHeight)}
              className="w-16 bg-stone-900 border border-stone-700 rounded px-2 py-1 text-sm text-teal-100 focus:outline-none focus:border-teal-600"
            />
          </div>
          
          <div className="flex items-center">
            <label className="mr-2 text-stone-400">Grid Size:</label>
            <input
              type="text"
              value={mapGridSize}
              onChange={handleNumberChange(setMapGridSize)}
              className="w-16 bg-stone-900 border border-stone-700 rounded px-2 py-1 text-sm text-teal-100 focus:outline-none focus:border-teal-600"
            />
          </div>
          
          <div className="flex justify-end">
            <button
              onClick={handleApplyProperties}
              className="bg-teal-700 hover:bg-teal-600 text-white px-3 py-1 rounded text-xs flex items-center"
            >
              <Save size={14} className="mr-1" />
              Apply
            </button>
          </div>
        </div>
      )}
    </>
  );
};

export default MapToolbar;

================
File: src/components/windows/mapeditor/README.md
================
# Gridmap Editor for SlumTerm

This directory contains the implementation of the Gridmap Editor for the SlumTerm virtual tabletop system. The editor allows users to create and edit grid-based maps for tabletop role-playing games.

## Components

- **MapEditorWindow.jsx**: Main window component that integrates all subcomponents
- **MapCanvas.jsx**: Canvas component for rendering and interacting with the grid map
- **MapToolbar.jsx**: Toolbar with editing tools and file operations
- **LayerPanel.jsx**: Panel for managing layers (create, toggle visibility, reorder)
- **utils/mapUtils.js**: Utility functions for map operations

## Integration with SlumTerm

The Gridmap Editor is integrated with the SlumTerm system in a similar way to the Markdown Editor:

1. When a user clicks on a file with the `.map` extension in the file explorer, the MapEditorWindow will open
2. The MapEditorWindow loads the map data from the file and displays it in the grid view
3. Users can edit the map using various tools and save the changes back to the file

## Map File Format (.map)

Map files use a JSON format to store the grid data:

```json
{
  "version": "1.0",
  "name": "Map Name",
  "gridSize": 32,
  "width": 20,
  "height": 15,
  "defaultTile": "floor",
  "layers": [
    {
      "name": "terrain",
      "visible": true,
      "cells": [
        { "x": 0, "y": 0, "type": "wall" },
        { "x": 1, "y": 0, "type": "wall" }
      ]
    },
    {
      "name": "objects",
      "visible": true,
      "cells": [
        { "x": 2, "y": 1, "type": "door" }
      ]
    }
  ],
  "tokenPositions": [],
  "metadata": {
    "author": "username",
    "created": "ISO date",
    "modified": "ISO date"
  }
}
```

## Features

- **Grid-based editing**: Place walls, floors, doors, and other map elements on a grid
- **Layer management**: Create, rename, reorder, and toggle visibility of layers
- **Zoom and pan**: Adjust the view to focus on different parts of the map
- **File operations**: Create new maps, open existing maps, save changes

## Future Plans

- **Multiplayer support**: Allow multiple players to view and interact with the map
- **Token placement**: Add player and monster tokens to the map
- **Line of sight**: Implement fog of war and dynamic lighting
- **Map scripting**: Add interactivity to map elements

## Usage

1. Create a new `.map` file in the file explorer
2. Click on the file to open it in the Gridmap Editor
3. Use the toolbar to select tools for editing the map
4. Save your changes

## Development Notes

- The grid map editor uses the HTML Canvas API for rendering
- Map data is stored in JSON format compatible with the server's file system
- Map editing operations use immutable data patterns to avoid direct state mutation

================
File: src/components/windows/mapeditor/styles/RangeSlider.css
================
/* Original Input Slider styling */
.opacity-slider {
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 6px;
  background: #44403c;
  border-radius: 5px;
  outline: none;
  margin: 10px 0;
  cursor: pointer;
}

.opacity-slider::-webkit-slider-runnable-track {
  -webkit-appearance: none;
  appearance: none;
  height: 6px;
  border-radius: 5px;
}

.opacity-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #14b8a6;
  cursor: pointer;
  border: 2px solid #f8fafc;
  margin-top: -6px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.opacity-slider::-moz-range-thumb {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #14b8a6;
  cursor: pointer;
  border: 2px solid #f8fafc;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
}

.opacity-slider::-moz-range-track {
  height: 6px;
  background: #44403c;
  border-radius: 5px;
}

.opacity-slider:focus {
  outline: none;
}

/* Custom Slider Component Styling */
.custom-slider-container {
  position: relative;
  width: 100%;
  padding: 6px 0;
  user-select: none;
  touch-action: none;
}

.custom-slider-track {
  position: relative;
  height: 6px;
  width: 100%;
  background: #44403c;
  border-radius: 4px;
  cursor: pointer;
  margin: 8px 0;
}

.custom-slider-thumb {
  position: absolute;
  top: 50%;
  width: 18px;
  height: 18px;
  background-color: #14b8a6;
  border-radius: 50%;
  border: 2px solid #f8fafc;
  transform: translate(-50%, -50%);
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  cursor: grab;
  z-index: 2;
  transition: transform 0.1s, background-color 0.2s;
}

.custom-slider-thumb:hover {
  background-color: #0d9488;
  transform: translate(-50%, -50%) scale(1.1);
}

.custom-slider-thumb:active {
  background-color: #0f766e;
  cursor: grabbing;
  transform: translate(-50%, -50%) scale(1.15);
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
}

================
File: src/components/windows/mapeditor/TilePalette.jsx
================
import React, { useEffect, useState, useMemo, useRef, useCallback } from 'react';
import { 
  FLOOR_TILESET_PATH,
  WALL_TILESET_PATH,
  SHADOW_TILESET_PATH, // Import the shadow path
  TILE_SIZE,
  TILESET_COLS,
  getTileCoordinates, 
  getTileName, 
  TILE_SECTIONS,
  WALL_TILE_SECTIONS,
  SHADOW_TILE_SECTIONS
} from './utils/tileRegistry';
import { Heart, RotateCw, CheckCircle, XCircle } from 'lucide-react';
import axios from 'axios';
import API_CONFIG from '../../../config/api';

// Debug helper to log API requests and responses
const logApiCall = (method, url, status, data) => {
  console.log(`API ${method} ${url} - Status: ${status}`);
  console.log('Data:', data);
};

/**
 * Component for displaying and selecting tiles from a tileset
 */
const TilePalette = ({ 
  onSelectTile, 
  selectedTileId = 0, 
  tileType = 'floor',
  onChangeTileType,
  selectedRotation = 0,
  onRotateTile
}) => {
  // Local state to track rotation, will sync back to parent
  const [localRotation, setLocalRotation] = useState(selectedRotation);
  
  // Sync with parent's rotation when it changes
  useEffect(() => {
    setLocalRotation(selectedRotation);
  }, [selectedRotation]);
  const [favoriteTiles, setFavoriteTiles] = useState([]);
  const [isAddingToFavorites, setIsAddingToFavorites] = useState(false);
  const [addFavoriteError, setAddFavoriteError] = useState(null);
  const [isFavorited, setIsFavorited] = useState(false);
  const [floorTilesetImage, setFloorTilesetImage] = useState(null);
  const [wallTilesetImage, setWallTilesetImage] = useState(null);
  const [shadowTilesetImage, setShadowTilesetImage] = useState(null);
  const [loading, setLoading] = useState(true);
  const [currentSection, setCurrentSection] = useState(null); // Filter by section for floor
  const [currentWallSection, setCurrentWallSection] = useState(null); // Filter by section for wall
  const [currentShadowSection, setCurrentShadowSection] = useState(null);
  const [totalFloorTiles, setTotalFloorTiles] = useState(0);
  const [totalWallTiles, setTotalWallTiles] = useState(0);
  const [totalShadowTiles, setTotalShadowTiles] = useState(0); // Add state for shadow tiles count
  const [isInitialized, setIsInitialized] = useState(false);
  const initialTileTypeRef = useRef(tileType);
  const [showFavoritesSection, setShowFavoritesSection] = useState(true);
  
  // Available tile types
  const tileTypes = [
    { id: 'floor', name: 'Floor' },
    { id: 'wall', name: 'Wall' },
    { id: 'shadow', name: 'Shadow' },
    { id: 'door', name: 'Door' }
  ];
  
  // Store the initial tile type to handle first render properly
  useEffect(() => {
    initialTileTypeRef.current = tileType;
  }, []);

  // Track the actual columns detected in the image
  const [actualColumns, setActualColumns] = useState(TILESET_COLS);

  // Load favorite tiles when component mounts
  useEffect(() => {
    loadFavoriteTiles();
  }, []);

  // Check if the currently selected tile is a favorite
  useEffect(() => {
    checkIsFavorite();
  }, [selectedTileId, tileType]);

// Function to load favorite tiles
const loadFavoriteTiles = async () => {
  try {
    const token = localStorage.getItem('auth_token');
    if (!token) return;

    console.log('Fetching favorite tiles from:', `${API_CONFIG.BASE_URL}/favorite-tiles`);
    const response = await axios.get(
      `${API_CONFIG.BASE_URL}/favorite-tiles`,
      { headers: { Authorization: `Bearer ${token}` } }
    );

    logApiCall('GET', '/favorite-tiles', response.status, response.data);
    
    // Ensure we have an array, even if the response is unexpected
    if (Array.isArray(response.data)) {
      setFavoriteTiles(response.data);
    } else if (response.data && Array.isArray(response.data.favorites)) {
      setFavoriteTiles(response.data.favorites);
    } else {
      console.error('Unexpected response format for favorite tiles:', response.data);
      setFavoriteTiles([]);
    }
  } catch (error) {
    console.error('Error loading favorite tiles from server:', error);
    setFavoriteTiles([]);
  }
};

const debugTileIndexes = () => {
  if (!shadowTilesetImage) return;
  
  const cols = Math.floor(shadowTilesetImage.width / TILE_SIZE);
  const rows = Math.floor(shadowTilesetImage.height / TILE_SIZE);
  
  console.log('==== SHADOW TILE INDEX MAP ====');
  let output = '';
  for (let row = 0; row < rows; row++) {
    let rowOutput = '';
    for (let col = 0; col < cols; col++) {
      const index = row * cols + col;
      // Format to ensure alignment
      rowOutput += index.toString().padStart(3, ' ') + ' ';
    }
    output += rowOutput + '\n';
  }
  console.log(output);
  console.log('===============================');
};

// Call this in useEffect after loading
useEffect(() => {
  if (shadowTilesetImage) {
    debugTileIndexes();
  }
}, [shadowTilesetImage]);

// Function to check if selected tile is a favorite
const checkIsFavorite = async () => {
  try {
    const token = localStorage.getItem('auth_token');
    if (!token) return;

    const response = await axios.get(
      `${API_CONFIG.BASE_URL}/favorite-tiles/check/${selectedTileId}/${tileType}`,
      { headers: { Authorization: `Bearer ${token}` } }
    );

    logApiCall('GET', `/favorite-tiles/check/${selectedTileId}/${tileType}`, response.status, response.data);
    setIsFavorited(response.data.isFavorite);
  } catch (error) {
    console.error('Error checking favorite status from server:', error);
    setIsFavorited(false);
  }
};

// Function to add a tile to favorites
const addToFavorites = async () => {
  setIsAddingToFavorites(true);
  setAddFavoriteError(null);
  
  try {
    const token = localStorage.getItem('auth_token');
    if (!token) {
      setAddFavoriteError('Authentication required');
      setIsAddingToFavorites(false);
      return;
    }

    const response = await axios.post(
      `${API_CONFIG.BASE_URL}/favorite-tiles`,
      { tileIndex: selectedTileId, tileType },
      { headers: { 
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}` 
        } 
      }
    );
    
    logApiCall('POST', '/favorite-tiles', response.status, response.data);
    
    // Reload favorite tiles
    await loadFavoriteTiles();
    setIsFavorited(true);
  } catch (error) {
    console.error('Error adding tile to favorites:', error);
    setAddFavoriteError(error.response?.data?.message || 'Failed to add to favorites');
  } finally {
    setIsAddingToFavorites(false);
  }
};

// Function to remove a tile from favorites
const removeFromFavorites = async () => {
  try {
    const token = localStorage.getItem('auth_token');
    if (!token) return;

    const response = await axios.delete(
      `${API_CONFIG.BASE_URL}/favorite-tiles/${selectedTileId}/${tileType}`,
      { headers: { Authorization: `Bearer ${token}` } }
    );
    
    logApiCall('DELETE', `/favorite-tiles/${selectedTileId}/${tileType}`, response.status, response.data);
    
    // Reload favorite tiles
    await loadFavoriteTiles();
    setIsFavorited(false);
  } catch (error) {
    console.error('Error removing tile from favorites:', error);
  }
};

  // Render a tile canvas
  const renderTileCanvas = (tileIndex, tileType, size = 40, rotation = 0) => {
    const image = tileType === 'floor' ? floorTilesetImage : 
    tileType === 'wall' ? wallTilesetImage : 
    shadowTilesetImage;
    
    if (!image) return null;
    
    return (
      <canvas
        ref={canvas => {
          if (canvas && image) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, size, size);
            
            // Calculate coordinates based on actual columns in the sheet
            const col = tileIndex % actualColumns;
            const row = Math.floor(tileIndex / actualColumns);
            const sourceX = col * TILE_SIZE;
            const sourceY = row * TILE_SIZE;
            
            // Save the context state before transformations
            ctx.save();
            
            // Move to the center of the canvas for rotation
            ctx.translate(size/2, size/2);
            
            // Convert degrees to radians and rotate
            const angleInRadians = (rotation * Math.PI) / 180;
            ctx.rotate(angleInRadians);
            
            // Draw the image centered and rotated
            ctx.drawImage(
              image,
              sourceX, // sourceX
              sourceY, // sourceY
              TILE_SIZE, // sourceWidth
              TILE_SIZE, // sourceHeight
              -size/2, // destX (negative half-size to center)
              -size/2, // destY (negative half-size to center)
              size, // destWidth
              size  // destHeight
            );
            
            // Restore the context to its original state
            ctx.restore();
          }
        }}
        width={size}
        height={size}
        className="mx-auto"
        style={{ display: 'block' }}
      />
    );
  };
  
  // Load the tileset images
  useEffect(() => {
    let floorLoaded = false;
    let wallLoaded = false;
    let shadowLoaded = false;

    const checkAllLoaded = () => {
      if (floorLoaded && wallLoaded && shadowLoaded) {
        setLoading(false);
        setIsInitialized(true);
      }
    };

    // Load floor tileset
    const floorImg = new Image();
    floorImg.onload = () => {
      setFloorTilesetImage(floorImg);
      
      // Calculate total available tiles based on image dimensions
      const cols = Math.floor(floorImg.width / TILE_SIZE);
      const rows = Math.floor(floorImg.height / TILE_SIZE);
      const total = cols * rows;
      
      console.log(`Detected ${total} floor tiles (${cols}x${rows}) in the sprite sheet`);
      setActualColumns(cols); // Store the actual number of columns
      setTotalFloorTiles(total);
      floorLoaded = true;
      checkAllLoaded();
    };
    floorImg.onerror = () => {
      console.error('Failed to load floor tileset image');
      floorLoaded = true; // Still mark as loaded to prevent blocking
      checkAllLoaded();
    };
    floorImg.src = FLOOR_TILESET_PATH;
    
    // Load wall tileset
    const wallImg = new Image();
    wallImg.onload = () => {
      setWallTilesetImage(wallImg);
      
      // Calculate total available tiles based on image dimensions
      const cols = Math.floor(wallImg.width / TILE_SIZE);
      const rows = Math.floor(wallImg.height / TILE_SIZE);
      const total = cols * rows;
      
      console.log(`Detected ${total} wall tiles (${cols}x${rows}) in the sprite sheet`);
      setTotalWallTiles(total);
      wallLoaded = true;
      checkAllLoaded();
    };
    wallImg.onerror = () => {
      console.error('Failed to load wall tileset image');
      wallLoaded = true; // Still mark as loaded
      checkAllLoaded();
    };
    wallImg.src = WALL_TILESET_PATH;

    // Load shadow tileset
    const shadowImg = new Image();
    shadowImg.onload = () => {
      setShadowTilesetImage(shadowImg);
    
      // Calculate total available tiles based on image dimensions
      const cols = Math.floor(shadowImg.width / TILE_SIZE);
      const rows = Math.floor(shadowImg.height / TILE_SIZE);
      const total = cols * rows;
    
      // Purple console logs for better visibility
      console.log("%c  SHADOW TILESET: Detected " + total + " shadow tiles (" + cols + "" + rows + ")", 
        "color: #9c27b0; font-weight: bold; background-color: #f3e5f5; padding: 5px; border-radius: 3px;");
      console.log("%c  SHADOW Image dimensions: " + shadowImg.width + "" + shadowImg.height + "px", 
        "color: #9c27b0; font-weight: bold; background-color: #f3e5f5; padding: 5px; border-radius: 3px;");
      
      setTotalShadowTiles(total);
      shadowLoaded = true;
      checkAllLoaded();
    };
    shadowImg.src = SHADOW_TILESET_PATH;

  }, []); // Empty dependency array ensures this runs only once on mount

  // Force a re-render when the component first mounts (removed, handled by checkAllLoaded)
  // useEffect(() => { ... });
  
  // Get floor tiles to display based on current section filter
  const displayFloorTiles = useMemo(() => {
    if (currentSection === null) {
      // Show all tiles from the tileset - all positions are valid
      if (totalFloorTiles > 0) {
        // Simply create an array of indices from 0 to totalFloorTiles-1
        return Array.from({ length: totalFloorTiles }, (_, i) => i);
      }
      return [];
    } else {
      // Show only tiles from the selected section
      const section = TILE_SECTIONS[currentSection];
      return Array.from({ length: section.count }, (_, i) => section.startIndex + i);
    }
  }, [currentSection, totalFloorTiles]);
  
  // Get wall tiles to display based on current section filter
  const displayWallTiles = useMemo(() => {
    if (currentWallSection === null) {
      // Show all tiles from the tileset - all positions are valid
      if (totalWallTiles > 0) {
        // Simply create an array of indices from 0 to totalWallTiles-1
        return Array.from({ length: totalWallTiles }, (_, i) => i);
      }
      return [];
    } else {
      // Show only tiles from the selected section
      const section = WALL_TILE_SECTIONS[currentWallSection];
      return Array.from({ length: section.count }, (_, i) => section.startIndex + i);
    }
  }, [currentWallSection, totalWallTiles]);

  // Get shadow tiles to display based on current section filter
  const displayShadowTiles = useMemo(() => {
    if (currentShadowSection === null) {
      // Show all tiles from the tileset
      if (totalShadowTiles > 0) {
        return Array.from({ length: totalShadowTiles }, (_, i) => i);
      }
      return [];
    } else {
      const section = SHADOW_TILE_SECTIONS[currentShadowSection];
      return Array.from({ length: section.count }, (_, i) => section.startIndex + i);
    }
  }, [currentShadowSection, totalShadowTiles]);


  return (
    <div className="bg-stone-800 border-t border-stone-700 p-2 max-h-64 overflow-y-auto">
      {/* Tile Type Selector */}
      <div className="flex flex-col space-y-2 mb-4">
        <div className="flex justify-between items-center">
          <h3 className="text-sm font-mono text-teal-400">TILE TYPE</h3>
          
          {/* Buttons for Selected Tile */}
          <div className="flex items-center">
            {/* Rotate Button */}
            <button 
              className="text-blue-400 hover:text-blue-300 flex items-center mr-2"
              onClick={() => {
                console.log("Rotate button clicked!");
                // Keep track of the previous value for debugging
                console.log("Previous rotation value (local):", localRotation);
                console.log("Previous rotation value (props):", selectedRotation);
                
                // Calculate the new rotation value
                const newRotation = (localRotation + 90) % 360;
                console.log("New rotation value:", newRotation);
                
                // Update local state immediately for visual feedback
                setLocalRotation(newRotation);
                
                // Force update of the DOM display (safely)
                const debugElement = document.getElementById('debug-rotation-value');
                if (debugElement) {
                  debugElement.textContent = `Rotation set to: ${newRotation}`;
                }
                
                // Update the local rotation display
                const tileRotationDisplay = document.getElementById('tile-rotation-display');
                if (tileRotationDisplay) {
                  tileRotationDisplay.textContent = `${newRotation}`;
                }
                
                // Then notify parent (if callback exists) 
                if (typeof onRotateTile === 'function') {
                  console.log("Calling parent onRotateTile with:", newRotation);
                  // Pass the value explicitly (not relying on state)
                  onRotateTile(newRotation);
                } else {
                  console.warn("onRotateTile is not a function");
                  // If no callback, the local state update handles the visual feedback
                }
              }}
              title="Rotate tile"
            >
              <RotateCw size={16} className="mr-1" />
              <span className="text-xs" id="tile-rotation-display">{localRotation}</span>
            </button>
            
            {/* Favorite Button */}
            {isFavorited ? (
              <button 
                className="text-pink-500 hover:text-pink-400 flex items-center mr-2"
                onClick={removeFromFavorites}
                title="Remove from favorites"
              >
                <Heart size={16} fill="currentColor" className="mr-1" />
                <span className="text-xs">Unfavorite</span>
              </button>
            ) : (
              <button 
                className="text-gray-400 hover:text-pink-500 flex items-center mr-2"
                onClick={addToFavorites}
                title="Add to favorites"
                disabled={isAddingToFavorites}
              >
                <Heart size={16} className="mr-1" />
                <span className="text-xs">{isAddingToFavorites ? 'Adding...' : 'Favorite'}</span>
              </button>
            )}
          </div>
        </div>
        
        {addFavoriteError && (
          <div className="text-red-500 text-xs mb-2">{addFavoriteError}</div>
        )}
        
        <select
          className="bg-stone-700 text-teal-300 text-sm rounded p-2 w-full border-none"
          value={tileType}
          onChange={(e) => onChangeTileType(e.target.value)}
        >
          {tileTypes.map(type => (
            <option key={type.id} value={type.id}>{type.name}</option>
          ))}
        </select>
      </div>
      
      {/* Favorite Tiles Section */}
      {Array.isArray(favoriteTiles) && favoriteTiles.length > 0 && (
        <div className="mb-4">
          <div className="flex justify-between items-center mb-2">
            <h3 className="text-sm font-mono text-stone-400">FAVORITE TILES</h3>
            <button 
              className="text-xs text-stone-400 hover:text-stone-300"
              onClick={() => setShowFavoritesSection(!showFavoritesSection)}
            >
              {showFavoritesSection ? 'Hide' : 'Show'}
            </button>
          </div>
          
          {showFavoritesSection && (
            <div className="grid grid-cols-5 gap-1 justify-items-center mb-3">
              {Array.isArray(favoriteTiles) && favoriteTiles.map((tile) => (
                <div
                  key={`fav-${tile.tile_type}-${tile.tile_index}`}
                  className={`rounded cursor-pointer border ${
                    selectedTileId === tile.tile_index && tileType === tile.tile_type 
                      ? 'bg-teal-900 border-teal-500' 
                      : 'hover:bg-stone-700 border-transparent'
                  }`}
                  onClick={() => {
                    onSelectTile(tile.tile_index);
                    if (tile.tile_type !== tileType) {
                      onChangeTileType(tile.tile_type);
                    }
                  }}
                  title={getTileName(tile.tile_index, tile.tile_type)}
                >
                  <div className="w-10 h-10 bg-stone-900 relative overflow-hidden flex items-center justify-center">
                    {(tile.tile_type === 'floor' && floorTilesetImage) || 
                     (tile.tile_type === 'wall' && wallTilesetImage) ||
                     (tile.tile_type === 'shadow' && shadowTilesetImage)
                      ? renderTileCanvas(tile.tile_index, tile.tile_type, 40, selectedTileId === tile.tile_index && tileType === tile.tile_type ? selectedRotation : 0)
                      : <div className="w-full h-full flex items-center justify-center text-xs text-stone-500">Loading</div>
                    }
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      )}
      
      {/* Always include the floor section headings when floor type is selected */}
      {tileType === 'floor' && (
        <>
          <div className="flex justify-between items-center mb-2">
            <h3 className="text-sm font-mono text-teal-400">FLOORS</h3>
            
            {/* Section filter dropdown */}
            <select 
              className="bg-stone-700 text-teal-300 text-xs rounded p-1 border-none"
              value={currentSection || ""}
              onChange={(e) => setCurrentSection(e.target.value || null)}
            >
              <option value="">All Tiles</option>
              {Object.entries(TILE_SECTIONS).map(([key, section]) => (
                <option key={key} value={key}>{section.name}</option>
              ))}
            </select>
          </div>
        </>
      )}
      
      {/* Wall tile palette - shown when wall type is selected */}
      {tileType === 'wall' && (
        <>
          <div className="flex justify-between items-center mb-2">
            <h3 className="text-sm font-mono text-teal-400">WALLS</h3>
            
            {/* Section filter dropdown */}
            <select 
              className="bg-stone-700 text-teal-300 text-xs rounded p-1 border-none"
              value={currentWallSection || ""}
              onChange={(e) => setCurrentWallSection(e.target.value || null)}
            >
              <option value="">All Wall Tiles</option>
              {Object.entries(WALL_TILE_SECTIONS).map(([key, section]) => (
                <option key={key} value={key}>{section.name}</option>
              ))}
            </select>
          </div>
          
          {loading ? (
            <div className="text-center p-4 text-stone-400">Loading wall tiles...</div>
          ) : !wallTilesetImage ? (
            <div className="text-center p-4 text-red-400">Failed to load wall tile set</div>
          ) : (
            <div key={`wall-grid-${isInitialized ? 'ready' : 'loading'}`} className="grid grid-cols-5 gap-1 justify-items-center">
              {displayWallTiles.map(tileIndex => (
                <div
                  key={tileIndex}
                  className={`rounded cursor-pointer border ${
                    selectedTileId === tileIndex ? 'bg-teal-900 border-teal-500' : 'hover:bg-stone-700 border-transparent'
                  }`}
                  onClick={() => onSelectTile(tileIndex)}
                  title={getTileName(tileIndex, 'wall')}
                >
                  <div className="w-10 h-10 bg-stone-900 relative overflow-hidden flex items-center justify-center">
                    {renderTileCanvas(tileIndex, 'wall', 40, selectedTileId === tileIndex ? selectedRotation : 0)}
                  </div>
                </div>
              ))}
            </div>
          )}
        </>
      )}

      {/* Shadow tile palette - shown when shadow type is selected */}
      {tileType === 'shadow' && (
        <>
          <div className="flex justify-between items-center mb-2">
            <h3 className="text-sm font-mono text-teal-400">SHADOWS</h3>
            
            {/* Section filter dropdown */}
            <select 
              className="bg-stone-700 text-teal-300 text-xs rounded p-1 border-none"
              value={currentShadowSection || ""}
              onChange={(e) => setCurrentShadowSection(e.target.value || null)}
            >
              <option value="">All Shadow Tiles</option>
              {Object.entries(SHADOW_TILE_SECTIONS).map(([key, section]) => (
                <option key={key} value={key}>{section.name}</option>
              ))}
            </select>
          </div>
          
          {loading ? (
            <div className="text-center p-4 text-stone-400">Loading shadow tiles...</div>
          ) : !shadowTilesetImage ? (
            <div className="text-center p-4 text-red-400">Failed to load shadow tile set</div>
          ) : (
            <div key={`shadow-grid-${currentShadowSection}-${isInitialized ? 'ready' : 'loading'}`} className="grid grid-cols-5 gap-1 justify-items-center">
              {/* Use the defined displayShadowTiles */}
              {displayShadowTiles.map(tileIndex => (
                <div
                  key={`shadow-${tileIndex}`}
                  className={`rounded cursor-pointer border ${
                    selectedTileId === tileIndex ? 'bg-teal-900 border-teal-500' : 'hover:bg-stone-700 border-transparent'
                  }`}
                  onClick={() => {
                    console.log(`Shadow tile ${tileIndex} clicked`);
                    // Ensure both the tile ID and type are propagated
                    onSelectTile(tileIndex);
                    // This shouldn't be necessary if tileType is already 'shadow', but just to be sure
                    if (tileType !== 'shadow') {
                      onChangeTileType('shadow');
                    }
                }}
                title={getTileName(tileIndex, 'shadow')}
              >
                <div className="w-10 h-10 bg-stone-900 relative overflow-hidden flex items-center justify-center">
                  {renderTileCanvas(tileIndex, 'shadow', 40, selectedTileId === tileIndex ? selectedRotation : 0)}
                </div>
              </div>
              ))}
            </div>
          )}
        </>
      )}
      
      {/* Door tile simple selector - shown when door type is selected */}
      {tileType === 'door' && (
        <div className="mb-2">
          <h3 className="text-sm font-mono text-teal-400 mb-2">DOOR STYLE</h3>
          <div className="grid grid-cols-2 gap-2">
            <div 
              className="bg-stone-700 p-3 rounded cursor-pointer border-2 border-teal-500 text-center"
              onClick={() => onSelectTile(0)}
            >
              <div className="bg-slate-900 h-10 w-full flex items-center justify-center">
                <div className="bg-amber-700 h-5 w-8"></div>
              </div>
              <div className="mt-1 text-xs text-teal-300">Basic Door</div>
            </div>
          </div>
        </div>
      )}
      
      {/* Floor tile palette - shown when floor type is selected 
          The key addition forces a re-render when initialized changes */}
      {tileType === 'floor' && (
        loading ? (
          <div className="text-center p-4 text-stone-400">Loading tile set...</div>
        ) : !floorTilesetImage ? (
          <div className="text-center p-4 text-red-400">Failed to load tile set</div>
        ) : (
          <div key={`floor-grid-${isInitialized ? 'ready' : 'loading'}`} className="grid grid-cols-5 gap-1 justify-items-center">
            {displayFloorTiles.map(tileIndex => (
              <div
                key={tileIndex}
                className={`rounded cursor-pointer border ${
                  selectedTileId === tileIndex ? 'bg-teal-900 border-teal-500' : 'hover:bg-stone-700 border-transparent'
                }`}
                onClick={() => onSelectTile(tileIndex)}
                title={getTileName(tileIndex)}
              >
                <div className="w-10 h-10 bg-stone-900 relative overflow-hidden flex items-center justify-center">
                  {renderTileCanvas(tileIndex, 'floor', 40, selectedTileId === tileIndex ? selectedRotation : 0)}
                </div>
              </div>
            ))}
          </div>
        )
      )}
    </div>
  );
};

export default TilePalette;

================
File: src/components/windows/mapeditor/TilesetSelector.jsx
================
import React, { useState, useEffect } from 'react';
import { Image, Check, X } from 'lucide-react';

/**
 * Component for selecting and previewing available tilesets
 */
const TilesetSelector = ({ 
  onSelectTileset, 
  onClose,
  currentTileset
}) => {
  const [tilesets, setTilesets] = useState([]);
  const [loading, setLoading] = useState(true);
  const [selectedTileset, setSelectedTileset] = useState(currentTileset || null);
  const [error, setError] = useState(null);

  // Predefined tilesets from the oryx_ultimate_fantasy_1.2 folder
  useEffect(() => {
    // In a real app, this would be fetched from the server or file system
    const availableTilesets = [
      {
        id: 'uf_terrain',
        name: 'Fantasy Terrain',
        path: '/oryx_ultimate_fantasy_1.2/uf_terrain.png',
        preview: '/oryx_ultimate_fantasy_1.2/uf_terrain.png',
        tileSize: 48,
        cols: 16
      },
      {
        id: 'uf_items',
        name: 'Fantasy Items',
        path: '/oryx_ultimate_fantasy_1.2/uf_items.png',
        preview: '/oryx_ultimate_fantasy_1.2/uf_items.png',
        tileSize: 48,
        cols: 16
      },
      {
        id: 'uf_heroes',
        name: 'Fantasy Heroes',
        path: '/oryx_ultimate_fantasy_1.2/uf_heroes.png',
        preview: '/oryx_ultimate_fantasy_1.2/uf_heroes.png',
        tileSize: 48,
        cols: 16
      }
    ];

    setTilesets(availableTilesets);
    setLoading(false);
  }, []);

  const handleSelectTileset = (tileset) => {
    setSelectedTileset(tileset);
  };

  const handleConfirm = () => {
    if (!selectedTileset) {
      setError('Please select a tileset first');
      return;
    }
    onSelectTileset(selectedTileset);
    onClose();
  };

  return (
    <div className="bg-stone-800 border border-stone-700 rounded-lg p-4 w-full max-w-3xl">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-teal-400 text-lg font-semibold flex items-center">
          <Image size={20} className="mr-2" />
          Select Tileset
        </h2>
        <button
          onClick={onClose}
          className="text-stone-500 hover:text-stone-300"
        >
          <X size={20} />
        </button>
      </div>
      
      {error && (
        <div className="bg-red-900/30 text-red-400 p-2 rounded mb-3 text-sm">
          {error}
        </div>
      )}
      
      {loading ? (
        <div className="p-4 text-center text-stone-400">Loading available tilesets...</div>
      ) : (
        <div className="grid grid-cols-2 gap-4 mb-4">
          {tilesets.map(tileset => (
            <div 
              key={tileset.id}
              className={`p-3 rounded-lg cursor-pointer border ${
                selectedTileset?.id === tileset.id 
                  ? 'border-teal-500 bg-stone-700' 
                  : 'border-stone-700 hover:bg-stone-700/50'
              }`}
              onClick={() => handleSelectTileset(tileset)}
            >
              <div className="flex justify-between items-start mb-2">
                <h3 className="text-teal-300 font-medium">{tileset.name}</h3>
                {selectedTileset?.id === tileset.id && (
                  <Check size={16} className="text-teal-400" />
                )}
              </div>
              
              <div className="bg-stone-900 rounded h-32 flex items-center justify-center overflow-hidden">
                <img 
                  src={tileset.preview} 
                  alt={tileset.name}
                  className="max-w-full max-h-full object-contain"
                />
              </div>
              
              <div className="mt-2 text-xs text-stone-400">
                <div>Tile Size: {tileset.tileSize}px</div>
                <div>Columns: {tileset.cols}</div>
              </div>
            </div>
          ))}
        </div>
      )}
      
      <div className="flex justify-end space-x-2 mt-4 pt-3 border-t border-stone-700">
        <button
          onClick={onClose}
          className="px-4 py-2 bg-stone-700 hover:bg-stone-600 text-stone-300 rounded text-sm"
        >
          Cancel
        </button>
        <button
          onClick={handleConfirm}
          className="px-4 py-2 bg-teal-700 hover:bg-teal-600 text-white rounded text-sm flex items-center"
          disabled={!selectedTileset}
        >
          <Check size={16} className="mr-1" />
          Select Tileset
        </button>
      </div>
    </div>
  );
};

export default TilesetSelector;

================
File: src/components/windows/mapeditor/utils/mapUtils.js
================
/**
 * Map editor utility functions
 */

/**
 * Creates a new empty map with default settings
 * @param {string} name - Name of the map
 * @param {number} width - Width of the map in cells
 * @param {number} height - Height of the map in cells
 * @param {number} gridSize - Size of each grid cell in pixels
 * @returns {Object} A new map object
 */
export const createEmptyMap = (name = 'New Map', width = 20, height = 15, gridSize = 32) => {
  return {
    version: '1.0',
    name,
    gridSize,
    width,
    height,
    defaultTile: 'floor',
    layers: [
      {
        name: 'terrain',
        visible: true,
        cells: []
      }
    ],
    tokenPositions: [],
    metadata: {
      author: 'user',
      created: new Date().toISOString(),
      modified: new Date().toISOString()
    }
  };
};

/**
 * Parses a map file string into a map object
 * @param {string} mapContent - The string content of the map file
 * @returns {Object} The parsed map object
 * @throws {Error} If the map file is invalid
 */
export const parseMapFile = (mapContent) => {
  try {
    const mapData = JSON.parse(mapContent);
    
    // Validate the map structure
    if (!mapData.version || !mapData.layers || !Array.isArray(mapData.layers)) {
      throw new Error('Invalid map file format');
    }
    
    // Ensure all cells have a rotation property
    mapData.layers.forEach(layer => {
      if (layer.cells && Array.isArray(layer.cells)) {
        layer.cells.forEach(cell => {
          // If rotation doesn't exist, add it with default value of 0
          if (cell.rotation === undefined) {
            cell.rotation = 0;
          } else {
            // Ensure rotation is a number
            cell.rotation = Number(cell.rotation);
          }
        });
      }
    });
    
    console.log("Parsed map data with proper rotation values:", mapData);
    return mapData;
  } catch (err) {
    console.error('Error parsing map file:', err);
    throw new Error('Failed to parse map file. It may be corrupted or in an invalid format.');
  }
};

/**
 * Serializes a map object to a string
 * @param {Object} mapData - The map object to serialize
 * @returns {string} The serialized map as a JSON string
 */
export const serializeMap = (mapData) => {
  try {
    // Update the modified timestamp
    const updatedMapData = {
      ...mapData,
      metadata: {
        ...mapData.metadata,
        modified: new Date().toISOString()
      }
    };
    
      // CRITICAL FIX: Process all cells to ensure they have rotation property
      if (updatedMapData.layers && Array.isArray(updatedMapData.layers)) {
        updatedMapData.layers = updatedMapData.layers.map(layer => {
          if (layer.cells && Array.isArray(layer.cells)) {
            layer.cells = layer.cells.map(cell => {
              // Get the most current rotation value - prioritize global state
              const globalRotation = window.currentMapRotation;
              
              // If rotation doesn't exist, add it with current global value or default to 0
              if (cell.rotation === undefined) {
                return { ...cell, rotation: globalRotation !== undefined ? Number(globalRotation) : 0 };
              }
              
              // If global rotation is set, use it to update existing cells
              if (globalRotation !== undefined) {
                return { ...cell, rotation: Number(globalRotation) };
              }
              
              // Otherwise ensure rotation is a number (not string)
              if (typeof cell.rotation !== 'number') {
                return { ...cell, rotation: Number(cell.rotation) };
              }
              
              return cell;
            });
          }
          return layer;
        });
      }
    
    // Use custom replacer function to ensure rotation values are preserved
    return JSON.stringify(updatedMapData, (key, value) => {
      // Always include rotation in the output
      if (key === 'rotation') {
        // If value is undefined, return 0
        return value === undefined ? 0 : Number(value);
      }
      return value;
    }, 2);
  } catch (err) {
    console.error('Error serializing map:', err);
    throw new Error('Failed to serialize map data.');
  }
};

/**
 * Finds a cell in a specific layer at the given coordinates
 * @param {Object} mapData - The map data
 * @param {number} layerIndex - The index of the layer to search in
 * @param {number} x - The x coordinate
 * @param {number} y - The y coordinate
 * @returns {Object|null} The cell object if found, null otherwise
 */
export const findCellInLayer = (mapData, layerIndex, x, y) => {
  if (!mapData || !mapData.layers || !mapData.layers[layerIndex]) return null;
  
  const layer = mapData.layers[layerIndex];
  return layer.cells.find(cell => cell.x === x && cell.y === y) || null;
};

/**
 * Adds or updates a cell in a layer
 * @param {Object} mapData - The map data
 * @param {number} layerIndex - The index of the layer to update
 * @param {number} x - The x coordinate
 * @param {number} y - The y coordinate
 * @param {string} type - The type of the cell
 * @param {number} tileId - The ID of the tile (optional)
 * @param {number} rotation - The rotation angle in degrees (0, 90, 180, 270) (optional)
 * @returns {Object} The updated map data
 */
export const setCellInLayer = (mapData, layerIndex, x, y, type, tileId, rotation = 0) => {
  if (!mapData || !mapData.layers || !mapData.layers[layerIndex]) return mapData;
  
  // Use global rotation state as fallback if available
  const rotationValue = rotation !== undefined ? rotation : (window.currentMapRotation || 0);
  
  // Ensure rotation is a number with explicit conversion
  const numRotation = parseInt(rotationValue, 10) || 0;
  
  console.log(`setCellInLayer called with: x=${x}, y=${y}, type=${type}, tileId=${tileId}`);
  console.log(`Using rotation: ${numRotation} (converted from ${rotation}, global=${window.currentMapRotation})`);
  
  // Clone the map data to avoid direct state mutation
  const newMapData = { ...mapData };
  const layerData = { ...newMapData.layers[layerIndex] };
  
  // Clone the cells array
  layerData.cells = [...layerData.cells];
  
  // Find if the cell already exists in this layer
  const existingCellIndex = layerData.cells.findIndex(cell => cell.x === x && cell.y === y);
  
  // Create cell data with required properties
  const cellData = { x, y, type };
  
  // Add tileId if provided
  if (tileId !== undefined) {
    cellData.tileId = tileId;
  }
  
  // Always include rotation in the cell data, even if it's 0
  // This ensures rotation is explicitly stored in the map file
  cellData.rotation = numRotation;
  
  if (existingCellIndex !== -1) {
    console.log(`Updating existing cell at (${x}, ${y}) with rotation=${rotation}`);
    // Update existing cell, preserving any properties not explicitly changed
    layerData.cells[existingCellIndex] = { 
      ...layerData.cells[existingCellIndex], 
      ...cellData 
    };
    
    // Log the updated cell to verify rotation was properly set
    console.log("Updated cell:", layerData.cells[existingCellIndex]);
  } else {
    console.log(`Adding new cell at (${x}, ${y}) with rotation=${rotation}`);
    // Add new cell
    layerData.cells.push(cellData);
    
    // Log the added cell to verify rotation was properly set
    console.log("Added cell:", cellData);
  }
  
  // Update the layer in the map data
  newMapData.layers[layerIndex] = layerData;
  
  return newMapData;
};

/**
 * Removes a cell from a layer
 * @param {Object} mapData - The map data
 * @param {number} layerIndex - The index of the layer to update
 * @param {number} x - The x coordinate
 * @param {number} y - The y coordinate
 * @returns {Object} The updated map data
 */
export const removeCellFromLayer = (mapData, layerIndex, x, y) => {
  if (!mapData || !mapData.layers || !mapData.layers[layerIndex]) return mapData;
  
  // Clone the map data to avoid direct state mutation
  const newMapData = { ...mapData };
  const layerData = { ...newMapData.layers[layerIndex] };
  
  // Remove the cell if it exists
  layerData.cells = layerData.cells.filter(cell => !(cell.x === x && cell.y === y));
  
  // Update the layer in the map data
  newMapData.layers[layerIndex] = layerData;
  
  return newMapData;
};

/**
 * Gets all visible cells at a specific coordinate across all layers
 * @param {Object} mapData - The map data
 * @param {number} x - The x coordinate
 * @param {number} y - The y coordinate
 * @returns {Array} Array of cells at the coordinate, from bottom to top layer
 */
export const getCellsAtCoordinate = (mapData, x, y) => {
  if (!mapData || !mapData.layers) return [];
  
  const cells = [];
  
  mapData.layers.forEach((layer, index) => {
    if (layer.visible) {
      const cell = findCellInLayer(mapData, index, x, y);
      if (cell) {
        cells.push({ ...cell, layerIndex: index });
      }
    }
  });
  
  return cells;
};

/**
 * Converts screen coordinates to grid coordinates
 * @param {number} screenX - The x screen coordinate
 * @param {number} screenY - The y screen coordinate
 * @param {number} gridSize - The size of each grid cell
 * @param {Object} viewportOffset - The viewport offset { x, y }
 * @returns {Object} The grid coordinates { x, y }
 */
export const screenToGridCoordinates = (screenX, screenY, gridSize, viewportOffset) => {
  const gridX = Math.floor((screenX - viewportOffset.x) / gridSize);
  const gridY = Math.floor((screenY - viewportOffset.y) / gridSize);
  return { x: gridX, y: gridY };
};

/**
 * Converts grid coordinates to screen coordinates
 * @param {number} gridX - The x grid coordinate
 * @param {number} gridY - The y grid coordinate
 * @param {number} gridSize - The size of each grid cell
 * @param {Object} viewportOffset - The viewport offset { x, y }
 * @returns {Object} The screen coordinates { x, y }
 */
export const gridToScreenCoordinates = (gridX, gridY, gridSize, viewportOffset) => {
  const screenX = gridX * gridSize + viewportOffset.x;
  const screenY = gridY * gridSize + viewportOffset.y;
  return { x: screenX, y: screenY };
};

/**
 * Converts JSON map data to ASCII format for the roguelike game engine
 * @param {Object} mapData - The map data in JSON format
 * @returns {string} The map data in ASCII format
 */
export const convertMapToAscii = (mapData) => {
  // Create a 2D array filled with void spaces
  const width = mapData.width;
  const height = mapData.height;
  const asciiMap = Array(height).fill().map(() => Array(width).fill(' ')); // ' ' for void
  
  // Process each layer from bottom to top
  mapData.layers.forEach(layer => {
    if (!layer.visible) return;
    
    // Process each cell in the layer
    layer.cells.forEach(cell => {
      // Skip cells outside the map bounds
      if (cell.x < 0 || cell.x >= width || cell.y < 0 || cell.y >= height) return;
      
      // Map cell types to ASCII characters
      let asciiChar;
      switch(cell.type) {
        case 'wall':
          asciiChar = '#';
          break;
        case 'floor':
          asciiChar = '.';
          break;
        case 'door':
          asciiChar = '+';
          break;
        case 'grass':
          asciiChar = '"';
          break;
        case 'ashes':
          asciiChar = "'";
          break;
        case 'stairs':
          asciiChar = '>';
          break;
        case 'spawn':
          asciiChar = '@';
          break;
        default:
          // For unknown types, use a default character
          asciiChar = '?';
      }
      
      // Place the character in the grid
      asciiMap[cell.y][cell.x] = asciiChar;
    });
  });
  
  // Convert 2D array to string with newlines
  return asciiMap.map(row => row.join('')).join('\n');
};

/**
 * Converts ASCII map to JSON format
 * @param {string} asciiMap - The map data in ASCII format
 * @param {string} name - Optional name for the map
 * @returns {Object} The map data in JSON format
 */
export const convertAsciiToMap = (asciiMap, name = 'Imported Map') => {
  const lines = asciiMap.trim().split('\n');
  const height = lines.length;
  const width = lines.reduce((max, line) => Math.max(max, line.length), 0);
  
  // Create a basic map structure
  const mapData = createEmptyMap(name, width, height);
  
  // Create a terrain layer
  const terrainCells = [];
  
  // Process each character in the ASCII map
  for (let y = 0; y < lines.length; y++) {
    const line = lines[y];
    for (let x = 0; x < line.length; x++) {
      const char = line[x];
      let cellType;
      
      // Map ASCII characters to cell types
      switch(char) {
        case '#':
          cellType = 'wall';
          break;
        case '.':
          cellType = 'floor';
          break;
        case '+':
          cellType = 'door';
          break;
        case '"':
          cellType = 'grass';
          break;
        case "'":
          cellType = 'ashes';
          break;
        case '>':
          cellType = 'stairs';
          break;
        case '@':
          cellType = 'spawn';
          // Could also mark this as a player spawn point
          break;
        case ' ':
          // Void/empty space, skip
          continue;
        default:
          // Unknown character, interpret as custom type
          cellType = `custom-${char}`;
      }
      
      // Add the cell to the terrain layer
      terrainCells.push({ x, y, type: cellType });
    }
  }
  
  // Update the terrain layer with the cells
  mapData.layers[0].cells = terrainCells;
  
  return mapData;
};

================
File: src/components/windows/mapeditor/utils/tileRegistry.js
================
/**
 * Tile registry and helper functions for managing sprite sheet tiles
 */

// Import the tilesets directly
import terrainTilesetImage from '../../../../assets/sheets/floors/uf_terrain_sheet.png';
import wallTilesetImage from '/sheets/walls/uf_terrain_sheet_walls.png'; // Using absolute path from public folder
import shadowTilesetImage from '/sheets/shadows/uf_terrain_shadows.png'

// Tile dimensions and sprite sheet configuration
export const TILE_SIZE = 48; // Size of each tile in pixels
export const TILESET_COLS = 16; // Number of columns in the sprite sheet (adjust based on actual width)

// Path to the tilesets (using imported images)
export const FLOOR_TILESET_PATH = terrainTilesetImage;
export const WALL_TILESET_PATH = wallTilesetImage;
export const SHADOW_TILESET_PATH = shadowTilesetImage;

// Named sections for better organization
export const TILE_SECTIONS = {
  BLUE_FLOORS: { startIndex: 0, count: 5, name: "Blue Stone Floors" },
  GRAY_FLOORS: { startIndex: 16, count: 5, name: "Gray Stone Floors" },
  DARK_FLOORS: { startIndex: 32, count: 5, name: "Dark Stone Floors" },
  DIRT: { startIndex: 48, count: 2, name: "Dirt" },
  GRASS: { startIndex: 64, count: 2, name: "Grass" },
  SAND: { startIndex: 80, count: 2, name: "Sand" },
  STONE_PATTERN: { startIndex: 96, count: 3, name: "Stone Pattern" },
  CHECKERED: { startIndex: 112, count: 3, name: "Checkered" },
  // Add more sections as needed
};

// Wall tile sections
export const WALL_TILE_SECTIONS = {
  STONE_WALLS: { startIndex: 0, count: 8, name: "Stone Walls" },
  BRICK_WALLS: { startIndex: 16, count: 8, name: "Brick Walls" },
  WOOD_WALLS: { startIndex: 32, count: 4, name: "Wooden Walls" },
  // Add more wall sections as needed
};

export const SHADOW_TILE_SECTIONS = {
  SHADOWS: { startIndex: 0, count: 4, name: "Shadows" }
};

/**
 * Calculates pixel coordinates in the sprite sheet for a given tile index
 * @param {number} tileIndex - The index of the tile
 * @returns {Object} Object with source coordinates for the tile
 */
export const getTileCoordinates = (tileIndex) => {
  const col = tileIndex % TILESET_COLS;
  const row = Math.floor(tileIndex / TILESET_COLS);
  
  return {
    sourceX: col * TILE_SIZE,
    sourceY: row * TILE_SIZE,
    sourceWidth: TILE_SIZE,
    sourceHeight: TILE_SIZE,
    // Include calculated positions for easier debugging
    col, row
  };
};

/**
 * Gets a descriptive name for a tile based on its index
 * @param {number} tileIndex - The index of the tile
 * @param {string} tileType - The type of tile ('floor', 'wall', etc.)
 * @returns {string} A human-readable name for the tile
 */
export const getTileName = (tileIndex, tileType = 'floor') => {
  // Find which section this tile belongs to
  if (tileType === 'floor') {
    for (const [sectionKey, section] of Object.entries(TILE_SECTIONS)) {
      if (tileIndex >= section.startIndex && tileIndex < section.startIndex + section.count) {
        const tileNumber = tileIndex - section.startIndex + 1;
        return `${section.name} ${tileNumber}`;
      }
    }
    return `Floor Tile ${tileIndex}`;
  } else if (tileType === 'wall') {
    for (const [sectionKey, section] of Object.entries(WALL_TILE_SECTIONS)) {
      if (tileIndex >= section.startIndex && tileIndex < section.startIndex + section.count) {
        const tileNumber = tileIndex - section.startIndex + 1;
        return `${section.name} ${tileNumber}`;
      }
    }
    return `Wall Tile ${tileIndex}`;
  } else if (tileType === 'shadow') {
    for (const [sectionKey, section] of Object.entries(SHADOW_TILE_SECTIONS)) {
      if (tileIndex >= section.startIndex && tileIndex < section.startIndex + section.count) {
        const tileNumber = tileIndex - section.startIndex + 1;
        return `${section.name} ${tileNumber}`;
      }
    }
    return `Shadow Tile ${tileIndex}`;
  } else if (tileType === 'door') {
    return `Door`;
  }
  
  // Fallback if not in a named section or unknown type
  return `Tile ${tileIndex}`;
};

================
File: src/components/windows/MapEditorWindow.jsx
================
import React, { useState, useEffect } from 'react';
import { Map } from 'lucide-react';
import MapCanvas from './mapeditor/MapCanvas';
import MapToolbar from './mapeditor/MapToolbar';
import LayerPanel from './mapeditor/LayerPanel';
import TilePalette from './mapeditor/TilePalette';
import { setCellInLayer, removeCellFromLayer } from './mapeditor/utils/mapUtils';

/**
 * Map Editor Window Component
 * This window allows users to create and edit grid-based maps
 */
const MapEditorWindow = ({ isActive, nodeId, onCommand, transformWindow, windowState, updateWindowState, focusRef }) => {
  // State for map data
  const [mapData, setMapData] = useState(null);
  const [currentLayer, setCurrentLayer] = useState(0);
  const [currentTool, setCurrentTool] = useState('select');
  const [isDirty, setIsDirty] = useState(false);
  const [error, setError] = useState(null);
  const [selectedTileId, setSelectedTileId] = useState(0);
  const [selectedTileType, setSelectedTileType] = useState('floor');
  const [selectedRotation, setSelectedRotation] = useState(0); // 0, 90, 180, 270 degrees

  // Load map data from file when selected
  useEffect(() => {
    if (windowState?.selectedFile?.path && windowState.selectedFile.name.endsWith('.map')) {
      loadMapFromFile(windowState.selectedFile.path);
    }
  }, [windowState?.selectedFile]);

  // Handler for loading a map file
  const loadMapFromFile = async (filePath) => {
    try {
      // Reset state for new file
      setError(null);
      
      // If there's no file path, create a new empty map
      if (!filePath) {
        createNewMap();
        return;
      }
      
      // This is a placeholder - in a real implementation, we would fetch the content
      // from the server using a similar approach to how the file explorer works
      
      // For now, create a simple map structure
      // In the future, this would parse the JSON from the file
      setMapData({
        version: "1.0",
        name: "Sample Map",
        gridSize: 32,
        width: 20,
        height: 15,
        defaultTile: "floor",
        layers: [
          {
            name: "terrain",
            visible: true,
            cells: []
          },
          {
            name: "objects",
            visible: true,
            cells: []
          }
        ],
        tokenPositions: [],
        metadata: {
          author: "user",
          created: new Date().toISOString(),
          modified: new Date().toISOString()
        }
      });
      
      setCurrentLayer(0);
      setIsDirty(false);
    } catch (err) {
      console.error('Error loading map:', err);
      setError('Failed to load map file. It may be corrupted or in an unsupported format.');
    }
  };

  // Create a new empty map
  const createNewMap = () => {
    setMapData({
      version: "1.0",
      name: "New Map",
      gridSize: 32,
      width: 20,
      height: 15,
      defaultTile: "floor",
      layers: [
        {
          name: "terrain",
          visible: true,
          cells: []
        }
      ],
      tokenPositions: [],
      metadata: {
        author: "user",
        created: new Date().toISOString(),
        modified: new Date().toISOString()
      }
    });
    setCurrentLayer(0);
    setIsDirty(true);
  };

  // Handler for saving the map
  const handleSaveMap = async () => {
    if (!mapData) return;
    if (!windowState?.selectedFile?.path) {
      // Would normally prompt for save location
      setError('No file path specified for saving.');
      return;
    }
    
    try {
      console.log("========== SAVING MAP ==========");
      console.log("Current window.currentMapRotation value:", window.currentMapRotation);
      console.log("Current selectedRotation state value:", selectedRotation);
      
      // Update modified timestamp
      const updatedMapData = {
        ...mapData,
        metadata: {
          ...mapData.metadata,
          modified: new Date().toISOString()
        }
      };
      
      // CRITICAL FIX: Ensure every cell has a rotation property BEFORE serialization
      // This guarantees rotation is always in the JSON output
      updatedMapData.layers.forEach(layer => {
        if (layer.cells && Array.isArray(layer.cells)) {
          layer.cells = layer.cells.map(cell => {
            // If rotation doesn't exist, add it with default value of 0
            if (cell.rotation === undefined) {
              return { ...cell, rotation: 0 };
            }
            // Ensure rotation is a number (not string)
            if (typeof cell.rotation !== 'number') {
              return { ...cell, rotation: Number(cell.rotation) };
            }
            return cell;
          });
        }
      });
      
      // Debug: Check if any cells have rotation values
      let rotationCount = 0;
      updatedMapData.layers.forEach(layer => {
        layer.cells.forEach(cell => {
          console.log(`Cell at (${cell.x}, ${cell.y}) has rotation: ${cell.rotation}`);
          rotationCount++;
        });
      });
      
      console.log(`Total cells with rotation property: ${rotationCount}`);
      
      // Use a custom replacer function to ensure rotation is always included in the JSON
      const serializedMap = JSON.stringify(updatedMapData, (key, value) => {
        // Always include rotation in the output
        if (key === 'rotation') {
          return value === undefined ? 0 : Number(value);
        }
        return value;
      }, 2);
      
      console.log('Saving map with explicit rotation values included');
      
      // Actually save the map data to localStorage for demo purposes
      localStorage.setItem('last_saved_map', serializedMap);
      localStorage.setItem('last_saved_map_pretty', JSON.stringify(JSON.parse(serializedMap), null, 2));
      console.log('Map saved to localStorage - check with: localStorage.getItem("last_saved_map_pretty")');
      
      // Update state
      setMapData(updatedMapData);
      setIsDirty(false);
    } catch (err) {
      console.error('Error saving map:', err);
      setError('Failed to save map file.');
    }
  };

  // Handler for map edits
  const handleEdit = (x, y, tool, rotation = 0, tileId = selectedTileId) => {
    if (!mapData || !mapData.layers || !mapData.layers[currentLayer]) return;
    
    // Log that we're receiving the rotation value
    console.log("============== EDIT CELL ==============");
    console.log("MapEditorWindow received edit with rotation:", rotation);
    console.log(`Cell coordinates: (${x}, ${y}), Tool: ${tool}`);
    
    // Ensure rotation is a number
    const numRotation = Number(rotation);
    console.log("Rotation converted to number:", numRotation);
    
    let newMapData;
    
    if (tool === 'erase') {
      // If erasing, remove the cell from the layer
      newMapData = removeCellFromLayer(mapData, currentLayer, x, y);
      console.log("Cell erased successfully");
    } else {
      // For tile placement tools (floor, wall, etc.), use the selected tile and rotation
      console.log(`Setting cell in layer ${currentLayer} with tileId: ${tileId}, rotation: ${numRotation}`);
      
      newMapData = setCellInLayer(
        mapData, 
        currentLayer, 
        x, 
        y, 
        tool,
        tileId, // Use the tileId passed from the component
        numRotation // Use the numeric rotation value
      );
      
      // Check if the rotation was stored correctly
      const updatedCell = newMapData.layers[currentLayer].cells.find(
        cell => cell.x === x && cell.y === y
      );
      
      if (updatedCell) {
        console.log("Cell updated:", updatedCell);
        if (updatedCell.rotation !== undefined) {
          console.log(`Rotation set successfully: ${updatedCell.rotation}`);
        } else {
          console.warn("Rotation was not stored in the cell data!");
        }
      } else {
        console.warn("Could not find the updated cell in the map data!");
      }
    }
    
    // Update state
    setMapData(newMapData);
    setIsDirty(true);
    
    // Store to localStorage for debugging
    localStorage.setItem('debug_mapData', JSON.stringify(newMapData));
    console.log("Map data stored to localStorage for debugging");
    console.log("=========================================");
  };
  
  // Handle tile selection
  const handleSelectTile = (tileId) => {
    console.log(`handleSelectTile called with: ${tileId} (previous: ${selectedTileId}), tileType: ${selectedTileType}`);
    
    // Update state
    setSelectedTileId(tileId);
    
    // When selecting a tile, switch to the corresponding tool
    if (currentTool === 'select' || currentTool === 'erase') {
      console.log(`Switching tool from ${currentTool} to ${selectedTileType}`);
      setCurrentTool(selectedTileType);
    }
    
    // Debug - check state immediately after update
    setTimeout(() => {
      console.log(`After update: selectedTileId: ${selectedTileId}, tileType: ${selectedTileType}`);
    }, 0);
  };
  
  // Handle tile type change
  const handleChangeTileType = (tileType) => {
    setSelectedTileType(tileType);

    // When changing to shadow type, always set a default shadow tile ID
    if (tileType === 'shadow') {
      console.log("Switching to shadow type, setting default tile ID 0");
      onSelectTile(0); // Set a default shadow tile ID
    }
    
    // When changing tile type, also change the current tool
    if (currentTool !== 'select' && currentTool !== 'erase') {
      setCurrentTool(tileType);
    }
  };
  
  // Handle tile rotation - fixes React async state update issue
  const handleRotateTile = (rotation) => {
    console.log("---------------------------------------");
    console.log("handleRotateTile called with rotation:", rotation);
    
    // Convert to number to ensure consistent handling
    const numRotation = Number(rotation);
    
    // Update the DOM immediately for visual feedback (safely)
    const debugElement = document.getElementById('debug-rotation-value');
    if (debugElement) {
      debugElement.textContent = `Rotation set to: ${numRotation}`;
    }
    
    // Set window-level variable to ensure it's globally accessible
    window.currentMapRotation = numRotation;
    
    // Update the state
    setSelectedRotation(numRotation);
    
    // Force update any tile displays
    if (document.getElementById('tile-rotation-display')) {
      document.getElementById('tile-rotation-display').textContent = `${numRotation}`;
    }
    
    // When rotating a tile, make sure we're in a tile placement mode
    if (currentTool === 'select' || currentTool === 'erase') {
      setCurrentTool(selectedTileType);
    }
    
    console.log("Rotation has been set to:", numRotation);
    console.log("Global rotation tracker:", window.currentMapRotation);
    console.log("---------------------------------------");
  };

  // Layer management functions
  const handleToggleLayerVisibility = (layerIndex) => {
    if (!mapData || !mapData.layers || !mapData.layers[layerIndex]) return;
    
    const newMapData = { ...mapData };
    newMapData.layers[layerIndex] = {
      ...newMapData.layers[layerIndex],
      visible: !newMapData.layers[layerIndex].visible
    };
    
    setMapData(newMapData);
    setIsDirty(true);
  };

  const handleAddLayer = () => {
    if (!mapData) return;
    
    const newLayerName = `Layer ${mapData.layers.length + 1}`;
    const newLayer = {
      name: newLayerName,
      visible: true,
      cells: []
    };
    
    const newMapData = { 
      ...mapData,
      layers: [...mapData.layers, newLayer]
    };
    
    setMapData(newMapData);
    setCurrentLayer(newMapData.layers.length - 1);
    setIsDirty(true);
  };

  const handleRemoveLayer = (layerIndex) => {
    if (!mapData || !mapData.layers || mapData.layers.length <= 1) return;
    
    const newMapData = { ...mapData };
    newMapData.layers = newMapData.layers.filter((_, index) => index !== layerIndex);
    
    setMapData(newMapData);
    
    // Adjust current layer if necessary
    if (currentLayer >= newMapData.layers.length) {
      setCurrentLayer(newMapData.layers.length - 1);
    }
    
    setIsDirty(true);
  };

  const handleMoveLayerUp = (layerIndex) => {
    if (!mapData || !mapData.layers || layerIndex >= mapData.layers.length - 1) return;
    
    const newMapData = { ...mapData };
    const layers = [...newMapData.layers];
    
    // Swap layers
    [layers[layerIndex], layers[layerIndex + 1]] = [layers[layerIndex + 1], layers[layerIndex]];
    
    newMapData.layers = layers;
    setMapData(newMapData);
    
    // Update current layer if necessary
    if (currentLayer === layerIndex) {
      setCurrentLayer(layerIndex + 1);
    } else if (currentLayer === layerIndex + 1) {
      setCurrentLayer(layerIndex);
    }
    
    setIsDirty(true);
  };

  const handleMoveLayerDown = (layerIndex) => {
    if (!mapData || !mapData.layers || layerIndex <= 0) return;
    
    const newMapData = { ...mapData };
    const layers = [...newMapData.layers];
    
    // Swap layers
    [layers[layerIndex], layers[layerIndex - 1]] = [layers[layerIndex - 1], layers[layerIndex]];
    
    newMapData.layers = layers;
    setMapData(newMapData);
    
    // Update current layer if necessary
    if (currentLayer === layerIndex) {
      setCurrentLayer(layerIndex - 1);
    } else if (currentLayer === layerIndex - 1) {
      setCurrentLayer(layerIndex);
    }
    
    setIsDirty(true);
  };

  const handleRenameLayer = (layerIndex, newName) => {
    if (!mapData || !mapData.layers || !mapData.layers[layerIndex]) return;
    
    // Use the provided name instead of prompting
    if (!newName || newName.trim() === '') return;
    
    const newMapData = { ...mapData };
    newMapData.layers[layerIndex] = {
      ...newMapData.layers[layerIndex],
      name: newName
    };
    
    setMapData(newMapData);
    setIsDirty(true);
    
    // Save the changes to the file
    handleSaveMap();
  };

  // Show placeholder if no file is loaded
  if (!mapData) {
    return (
      <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400 overflow-hidden">
        <div className="p-2 border-b border-stone-700">
          <h2 className="text-lg font-semibold flex items-center">
            <Map className="mr-2" size={18} />
            Map Editor
          </h2>
        </div>
        <div className="flex-1 overflow-auto p-4 flex items-center justify-center">
          <div className="text-center">
            <Map size={48} className="mx-auto mb-4 text-teal-500" />
            <h3 className="text-xl mb-2">Grid Map Editor</h3>
            <p className="text-stone-400">
              {error ? (
                <span className="text-red-400">{error}</span>
              ) : (
                <>
                  Select a .map file to edit, or create a new one.
                  <br />
                  <button 
                    className="mt-4 px-4 py-2 bg-teal-800 hover:bg-teal-700 rounded text-white"
                    onClick={createNewMap}
                  >
                    Create New Map
                  </button>
                </>
              )}
            </p>
          </div>
        </div>
      </div>
    );
  }

  // Render the map editor with all components
  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400 overflow-hidden">
      <div className="p-2 border-b border-stone-700 flex justify-between items-center">
        <h2 className="text-lg font-semibold flex items-center">
          <Map className="mr-2" size={18} />
          {mapData.name} {isDirty && '*'}
        </h2>
        {error && <div className="text-red-400 text-sm">{error}</div>}
      </div>
      
      {/* Toolbar */}
      <MapToolbar 
        currentTool={currentTool}
        setCurrentTool={setCurrentTool}
        onSave={handleSaveMap}
        onUndo={() => console.log('Undo not implemented')}
        onRedo={() => console.log('Redo not implemented')}
        onClear={() => createNewMap()}
      />
      
      {/* For debugging - hidden in production */}
      <div id="debug-rotation-value" className="p-1 bg-red-800 text-white text-xs">
        Rotation set to: {selectedRotation}
      </div>
      
      {/* Main content area */}
      <div className="flex-1 flex flex-col overflow-hidden">
        <div className="flex-1 flex overflow-hidden">
          {/* Canvas for map editing */}
          <MapCanvas 
            mapData={mapData}
            currentLayer={currentLayer}
            currentTool={currentTool}
            onEdit={handleEdit}
            selectedTileId={selectedTileId}
            selectedRotation={selectedRotation}
          />
          
          {/* Layer panel */}
          <LayerPanel 
            layers={mapData.layers}
            currentLayer={currentLayer}
            setCurrentLayer={setCurrentLayer}
            onToggleLayerVisibility={handleToggleLayerVisibility}
            onAddLayer={handleAddLayer}
            onRemoveLayer={handleRemoveLayer}
            onMoveLayerUp={handleMoveLayerUp}
            onMoveLayerDown={handleMoveLayerDown}
            onRenameLayer={handleRenameLayer}
          />
        </div>
        
        {/* Tile Palette */}
        <TilePalette 
          onSelectTile={handleSelectTile}
          selectedTileId={selectedTileId}
          tileType={selectedTileType}
          onChangeTileType={handleChangeTileType}
          selectedRotation={selectedRotation}
          onRotateTile={handleRotateTile}
        />
      </div>
    </div>
  );
};

export default MapEditorWindow;

================
File: src/components/windows/TerminalWindow.jsx
================
import React, { useState, useEffect, useRef, useReducer } from 'react';
import d20Gif from '../../assets/GIF/d20.gif';
import { WINDOW_TYPES } from '../../utils/windowTypes';
import { useAuth } from '../../context/AuthContext';
import { useAnnouncement } from '../../context/AnnouncementContext';
import { useWindowState } from '../../context/WindowStateContext';
import { useParty } from '../../context/PartyContext';
import { saveTerminalState, getTerminalState } from '../../services/indexedDBService';
import { parseDiceExpression, rollDice, formatRollResult, isValidDiceType } from '../../utils/diceUtils';
import DebugLogger from '../../utils/debugLogger';
import { executeCommand } from '../../utils/terminal/executor';
import { registerCommands } from '../../utils/terminal/commandLoader';

// Initialize the command system
registerCommands();

const TerminalWindow = ({ onCommand, isActive, nodeId, transformWindow, windowState, updateWindowState, focusRef }) => {
  // Get user authentication info
  const { user } = useAuth();
  // Get announcement context
  const { updateAnnouncement } = useAnnouncement();
  // Get window state context for additional persistence
  const { setActiveWindow } = useWindowState();
  // Get party context
  const { 
    currentParty, 
    parties, 
    joinParty, 
    leaveParty, 
    createParty, 
    refreshParty,
    refreshParties,
    deleteParty
  } = useParty();
  
  // Ref for managing scrolling
  const terminalRef = useRef(null);
  // Ref to track if state has been loaded from IndexedDB
  const stateLoadedRef = useRef(false);
  // Ref to store the dice roll animation timeout
  const diceTimeoutRef = useRef(null);

  // Terminal state - use windowState if available
  const [history, setHistory] = useState(
    windowState?.history || ['SLUMNET TERMINAL - Type "help" for available commands.']
  );
  const [commandHistory, setCommandHistory] = useState(windowState?.commandHistory || []);
  const [currentInput, setCurrentInput] = useState(windowState?.currentInput || '');
  const [historyIndex, setHistoryIndex] = useState(windowState?.historyIndex || -1);

  // Load terminal state from IndexedDB on mount if not already in windowState
  useEffect(() => {
    const loadTerminalState = async () => {
      // Skip if we already have state from the WindowStateContext
      if (windowState?.history && windowState?.commandHistory) {
        stateLoadedRef.current = true;
        return;
      }
      
      try {
        // Try to load terminal state from IndexedDB
        const savedState = await getTerminalState(nodeId);
        
        if (savedState && savedState.content && !stateLoadedRef.current) {
          console.log(`Loaded terminal state for window ${nodeId} from IndexedDB:`, savedState.content);
          
          // Update state with saved values
          if (savedState.content.history) {
            setHistory(savedState.content.history);
          }
          
          if (savedState.content.commandHistory) {
            setCommandHistory(savedState.content.commandHistory);
          }
          
          if (savedState.content.historyIndex !== undefined) {
            setHistoryIndex(savedState.content.historyIndex);
          }
          
          // Mark as loaded
          stateLoadedRef.current = true;
        }
      } catch (error) {
        console.error(`Failed to load terminal state for window ${nodeId} from IndexedDB:`, error);
      }
    };
    
    loadTerminalState();
  }, [nodeId, windowState]);

  // Auto-scroll to bottom when new output is added
  useEffect(() => {
    if (terminalRef.current) {
      terminalRef.current.scrollTop = terminalRef.current.scrollHeight;
    }
  }, [history]);
  
  // Clear input when window becomes active or when transformed back to terminal
  useEffect(() => {
    // Always clear the input when the component mounts or is transformed back to terminal
    setCurrentInput('');
  }, []);
  
  // Handle window activation
  useEffect(() => {
    if (isActive) {
      // Clear input when window becomes active
      setCurrentInput('');
      
      // Save this as the active terminal window
      setActiveWindow(nodeId, WINDOW_TYPES.TERMINAL);
    }
  }, [isActive, nodeId, setActiveWindow]);
  
  // Cleanup dice animation timeout when component unmounts
  useEffect(() => {
    // Return cleanup function
    return () => {
      // Clear any pending dice roll timeouts when unmounting
      if (diceTimeoutRef.current) {
        clearTimeout(diceTimeoutRef.current);
        diceTimeoutRef.current = null;
      }
    };
  }, []);
  
  // Create a reducer for forced updates - useReducer guarantees a re-render
  const [updateCounter, forceUpdate] = useReducer(state => state + 1, 0);
  
  // Force re-render to check dice GIFs that need to be replaced with results
  // This ensures the transition happens even when the component was unmounted and remounted
  useEffect(() => {
    // This checks and processes all dice GIFs that have completed their display duration
    const processDiceGifs = () => {
      let needsUpdate = false;
      
      // Process the history array to find and update dice GIFs
      const updatedHistory = history.map(item => {
        // Only process dice-gif items that have completed their duration
        if (typeof item === 'object' && 
            item.type === 'dice-gif' && 
            Date.now() - item.timestamp >= item.displayDuration) {
          
          needsUpdate = true;
          // Return the result instead of the GIF
          return item.result;
        }
        return item;
      });
      
      // If we found and updated any completed dice GIFs, update the history
      if (needsUpdate) {
        setHistory(updatedHistory);
      }
      
      // Check if there are still any active dice GIFs
      return history.some(item => 
        typeof item === 'object' && 
        item.type === 'dice-gif' && 
        Date.now() - item.timestamp < item.displayDuration
      );
    };
    
    // Initial check and processing
    const hasActiveDiceGifs = processDiceGifs();
    
    // If we have active dice GIFs, set up an interval to keep checking
    let intervalId;
    if (hasActiveDiceGifs) {
      intervalId = setInterval(() => {
        const stillHasActiveDiceGifs = processDiceGifs();
        
        // Force a render update regardless of whether we processed any GIFs
        forceUpdate();
        
        // If no more active dice GIFs, clear the interval
        if (!stillHasActiveDiceGifs && intervalId) {
          clearInterval(intervalId);
        }
      }, 200); // Check more frequently (200ms) for smoother transitions
    }
    
    return () => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [history]);

  // Update window state when terminal state changes
  useEffect(() => {
    if (updateWindowState) {
      const newState = {
        history,
        commandHistory,
        currentInput,
        historyIndex
      };
      
      // Update window state in context
      updateWindowState(newState);
      
      // Also save directly to IndexedDB for redundancy
      if (stateLoadedRef.current) { // Only save after initial load to avoid overwriting with empty state
        saveTerminalState({
          id: nodeId,
          content: newState
        }).catch(error => {
          console.error(`Failed to save terminal state for window ${nodeId} to IndexedDB:`, error);
        });
      }
    }
  }, [history, commandHistory, currentInput, historyIndex, updateWindowState, nodeId]);

  const handleTerminalClick = () => {
    focusRef.current?.focus();
  };

  const processCommand = async (command) => {
    setHistory(prev => [...prev, `$ ${command}`]);
    setCommandHistory(prev => [...prev, command]);
    
    // Legacy window transformation handling (direct conversion)
    const parts = command.split(' ');
    const cmd = parts[0].toLowerCase();
    
    if (Object.keys(WINDOW_TYPES).some(type => type.toLowerCase() === cmd)) {
      const requestedType = WINDOW_TYPES[cmd.toUpperCase()];
      transformWindow(nodeId, requestedType);
      return;
    }
    
    // Create recursive executeCommand function for legacy redirects
    const executeCommandFn = async (cmdStr) => {
      // Don't add the command to history since it's an internal redirect
      return await processCommand(cmdStr);
    };
    
    // Create the execution context with all necessary terminal state and functions
    const context = {
      // Original command text
      original: command,
      
      // User and authentication
      user,
      
      // Window management
      nodeId,
      transformWindow,
      
      // Announcement management
      updateAnnouncement,
      
      // Party system
      parties,
      currentParty,
      joinParty,
      leaveParty,
      createParty,
      refreshParty,
      refreshParties,
      deleteParty,
      
      // Dice utilities
      parseDiceExpression,
      rollDice,
      formatRollResult,
      isValidDiceType,
      
      // Debug utilities
      debugLogger: DebugLogger,
      
      // Terminal management
      clearTerminal: () => setHistory(['']),
      
      // Recursive command execution (for legacy redirects)
      executeCommand: executeCommandFn
    };
    
    try {
      // Execute the command using our new command system
      const response = await executeCommand(command, context);
      
      // Handle special return values
      if (response === '__CLEAR_TERMINAL__') {
        setHistory(['']);
        return;
      }
      
      // Handle response based on its type
      if (response) {
        if (typeof response === 'object' && response.type === 'dice-roll') {
          // Add the GIF to history with timestamp and result data
          setHistory(prev => [...prev, { 
            type: 'dice-gif', 
            src: d20Gif,
            timestamp: Date.now(), // Add current timestamp
            displayDuration: 2000, // Display for 2 seconds
            result: response.content // Store the result with the GIF
          }]);
        } else {
          // Handle regular text responses
          setHistory(prev => [...prev, response]);
        }
      }
    } catch (error) {
      console.error('Error executing command:', error);
      setHistory(prev => [...prev, `Error: ${error.message}`]);
    }
  };

  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && currentInput.trim()) {
      processCommand(currentInput.trim());
      setCurrentInput('');
      setHistoryIndex(-1);
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      if (historyIndex < commandHistory.length - 1) {
        const newIndex = historyIndex + 1;
        setHistoryIndex(newIndex);
        setCurrentInput(commandHistory[commandHistory.length - 1 - newIndex] || '');
      }
    } else if (e.key === 'ArrowDown') {
      e.preventDefault();
      if (historyIndex > -1) {
        const newIndex = historyIndex - 1;
        setHistoryIndex(newIndex);
        setCurrentInput(newIndex === -1 ? '' : commandHistory[commandHistory.length - 1 - newIndex] || '');
      }
    }
  };

  return (
    <div 
      className="bg-stone-900 text-white font-mono text-sm h-full flex flex-col"
      onClick={handleTerminalClick}
    >
<div ref={terminalRef} className="p-2 flex-1 overflow-auto whitespace-pre-wrap">
  {history.map((item, i) => {
    // If the item is an object with a type of 'dice-gif', handle it specially
    if (typeof item === 'object' && item.type === 'dice-gif') {
      // Check if enough time has passed since creation (2 seconds)
      const timeElapsed = Date.now() - item.timestamp;
      
      if (timeElapsed < item.displayDuration) {
        // If not enough time has passed, show the GIF
        return (
          <div key={i} className="mb-2">
            <img src={item.src} alt="Rolling dice" className="inline-block max-w-full h-32" />
          </div>
        );
      } else {
        // If enough time has passed, show the result instead
        return (
          <div key={i} className="mb-2">
            {item.result}
          </div>
        );
      }
    }
    // Keep backward compatibility with any 'gif' type items
    else if (typeof item === 'object' && item.type === 'gif') {
      return (
        <div key={i} className="mb-2">
          <img src={item.src} alt="Rolling dice" className="inline-block max-w-full h-32" />
        </div>
      );
    }
    // Otherwise, render as before
    return (
      <div key={i} className={`mb-2 ${typeof item === 'string' && item.startsWith('$ ') ? 'text-teal-400' : ''}`}>
        {item}
      </div>
    );
  })}
</div>

      <div className="p-2 flex items-center gap-2 border-t border-stone-700">
        <span className="mr-2">$</span>
        <input
          ref={focusRef}
          type="text"
          value={currentInput}
          onChange={(e) => setCurrentInput(e.target.value)}
          onKeyDown={handleKeyDown}
          className="flex-1 bg-stone-800 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
          autoFocus
        />
      </div>
    </div>
  );
};

export default TerminalWindow;

================
File: src/config/api.js
================
// API configuration
const API_CONFIG = {
  // Use environment variable with fallback
  BASE_URL: import.meta.env.VITE_API_BASE_URL || '/api',
  
  // Endpoints
  ENDPOINTS: {
    LOGIN: '/login',
    REGISTER: '/register',
    PROFILE: '/profile',
    LOGOUT: '/logout',
    ANNOUNCEMENT: '/announcement',
    // Chat endpoints
    CHAT_ROOMS: '/chat/rooms',
    CHAT_MESSAGES: '/chat/rooms/:id/messages',
    CHAT_JOIN: '/chat/rooms/:id/join',
    CHAT_DELETE_MESSAGE: '/chat/messages/:id',
    CHAT_DELETE_ROOM: '/chat/rooms/:id',
    // Voice chat endpoints
    VOICE_CHANNELS: '/chat/rooms/:id/voice-channels',
    VOICE_CHANNEL: '/chat/voice-channels/:id',
    VOICE_PARTICIPANTS: '/chat/voice-channels/:id/participants',
    VOICE_DELETE_CHANNEL: '/chat/voice-channels/:id',
    // Admin endpoints
    USERS: '/users',
    // Window state endpoints
    WINDOW_STATES: '/window-states',
    // Workspace endpoints
    WORKSPACES: '/workspaces',
    // File endpoints
    FILES_LIST: '/files',
    FILE_CONTENT: '/files/content',
    FILE_SAVE: '/files/content',
    FILE_CREATE: '/files/create',
    FILE_DELETE: '/files/delete',
    FILE_RENAME: '/files/rename',
    FILE_MOVE: '/files/move',
    // Public file endpoints
    PUBLIC_FILES_LIST: '/public-files',
    PUBLIC_FILE_CONTENT: '/public-files/content',
    // Storage endpoints
    STORAGE_STATS: '/files/storage',
    // Party endpoints
    PARTIES: '/parties',
    PARTIES_CURRENT: '/parties/current',
    PARTY_JOIN: '/parties/:id/join',
    PARTY_LEAVE: '/parties/:id/leave'
  }
};

export default API_CONFIG;

================
File: src/context/ActiveUsersContext.jsx
================
import React, { createContext, useContext, useState, useEffect, useRef } from 'react';
import axios from 'axios';
import API_CONFIG from '../config/api';
import { useAuth } from './AuthContext';
import io from 'socket.io-client';

// Create the active users context
const ActiveUsersContext = createContext();

// Events that count as user activity
const ACTIVITY_EVENTS = [
  'click', 'keydown', 'mousemove', 'wheel', 'touchstart', 'touchmove'
];

export function ActiveUsersProvider({ children }) {
  const [activeUserCount, setActiveUserCount] = useState(0);
  const { isAuthenticated, user } = useAuth();
  const socketRef = useRef(null);
  
  useEffect(() => {
    if (!isAuthenticated) return;
    
    // Initial fetch of active user count
    const fetchActiveUsers = async () => {
      try {
        const response = await axios.get(`${API_CONFIG.BASE_URL}/active-users`);
        setActiveUserCount(response.data.count);
      } catch (error) {
        console.error('Failed to fetch active users:', error);
      }
    };
    
    fetchActiveUsers();
    
    // Extract the origin from the BASE_URL or use window.location.origin
    const getSocketUrl = () => {
      // If BASE_URL is a full URL (starts with http)
      if (API_CONFIG.BASE_URL.startsWith('http')) {
        try {
          const url = new URL(API_CONFIG.BASE_URL);
          console.log('ActiveUsers using Socket.IO URL from BASE_URL origin:', url.origin);
          return url.origin; // Just the protocol, hostname, and port
        } catch (e) {
          console.error('ActiveUsers invalid BASE_URL format:', e);
        }
      }
      // Otherwise use the current origin
      console.log('ActiveUsers using Socket.IO URL from window.location.origin:', window.location.origin);
      return window.location.origin;
    };
    
    // Improved Socket.IO connection with correct URL
    const socketUrl = getSocketUrl();
    console.log('ActiveUsers connecting Socket.IO to:', socketUrl);
    
    const socket = io(socketUrl, {
      reconnectionAttempts: 5,
      reconnectionDelay: 1000,
      transports: ['websocket', 'polling'],
      path: '/socket.io' // Default Socket.IO path
    });
    
    // Store socket reference for external access
    socketRef.current = socket;
    
    socket.on('connect', () => {
      console.log('ActiveUsers Socket.IO connected, ID:', socket.id);
      
      // Send authentication token on connect
      const token = localStorage.getItem('auth_token');
      if (token) {
        console.log('Authenticating ActiveUsers socket connection');
        socket.emit('authenticate', token);
      } else {
        console.warn('No auth token available for socket authentication');
      }
    });
    
    socket.on('connect_error', (err) => {
      console.error('ActiveUsers Socket.IO connection error:', err);
      console.error('Connection details:', {
        url: socketUrl,
        transport: socket.io.engine?.transport?.name
      });
    });
    
    // Listen for active user count updates
    socket.on('active_users_update', (data) => {
      console.log('Received active users update:', data);
      setActiveUserCount(data.count);
    });
    
    // Track user activity
    let activityTimeout;
    
  const reportActivity = () => {
    // Clear any pending timeout
    if (activityTimeout) {
      clearTimeout(activityTimeout);
    }
    
    // Set a new timeout to report activity
    activityTimeout = setTimeout(() => {
      // Report activity via socket only for more efficient, real-time updates
      if (socketRef.current && socketRef.current.connected) {
        console.log('Reporting user activity via socket');
        socketRef.current.emit('user_activity');
      } else {
        console.warn('Socket not connected when trying to report activity');
        
        // If socket is disconnected, try to reconnect and then emit
        if (socketRef.current) {
          console.log('Attempting to reconnect socket...');
          socketRef.current.connect();
          
          // After reconnection attempt, try to emit activity again
          setTimeout(() => {
            if (socketRef.current && socketRef.current.connected) {
              console.log('Socket reconnected, reporting activity');
              socketRef.current.emit('user_activity');
            } else {
              console.error('Socket reconnection failed, falling back to HTTP API');
              // Fallback to HTTP API if socket reconnection fails
              const token = localStorage.getItem('auth_token');
              if (token) {
                axios.post(`${API_CONFIG.BASE_URL}/activity`, {}, {
                  headers: { Authorization: `Bearer ${token}` }
                }).catch(error => {
                  console.error('Failed to report activity via HTTP:', error);
                });
              }
            }
          }, 1000); // Wait 1 second for reconnection attempt
        }
      }
    }, 30000); // Wait 30 seconds before reporting activity to avoid flooding
    
    // Also report activity immediately if returning to app after a long time
    // This helps with faster updates when a user returns from being inactive
    if (socketRef.current && socketRef.current.connected && isAuthenticated) {
      const lastActive = localStorage.getItem('lastActiveTimestamp');
      const now = Date.now();
      
      if (lastActive) {
        const inactiveDuration = now - parseInt(lastActive, 10);
        // If user was inactive for more than 5 minutes (but less than timeout)
        if (inactiveDuration > 5 * 60 * 1000) {
          console.log(`User returning after ${Math.round(inactiveDuration/1000)}s inactivity, reporting activity immediately`);
          socketRef.current.emit('user_activity');
        }
      }
      
      // Update last active timestamp
      localStorage.setItem('lastActiveTimestamp', now.toString());
    }
  };
    
    // Add event listeners for user activity
    ACTIVITY_EVENTS.forEach(eventType => {
      window.addEventListener(eventType, reportActivity, { passive: true });
    });
    
    // Initial activity report
    reportActivity();
    
    // Cleanup
    return () => {
      socket.disconnect();
      ACTIVITY_EVENTS.forEach(eventType => {
        window.removeEventListener(eventType, reportActivity);
      });
      if (activityTimeout) {
        clearTimeout(activityTimeout);
      }
    };
  }, [isAuthenticated, user]);
  
  return (
    <ActiveUsersContext.Provider value={{ activeUserCount }}>
      {children}
    </ActiveUsersContext.Provider>
  );
}

export function useActiveUsers() {
  return useContext(ActiveUsersContext);
}

================
File: src/context/AnnouncementContext.jsx
================
import React, { createContext, useContext, useState, useEffect } from 'react';
import axios from 'axios';
import io from 'socket.io-client';
import API_CONFIG from '../config/api';

const AnnouncementContext = createContext();

export function AnnouncementProvider({ children }) {
  const [announcement, setAnnouncement] = useState('');
  
  // Fetch initial announcement when component mounts
  useEffect(() => {
    const fetchAnnouncement = async () => {
      try {
        const response = await axios.get(
          `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.ANNOUNCEMENT}`
        );
        setAnnouncement(response.data.announcement);
      } catch (error) {
        console.error('Failed to fetch announcement:', error);
      }
    };
    
    fetchAnnouncement();
    
    // Extract the origin from the BASE_URL or use window.location.origin
    const getSocketUrl = () => {
      // If BASE_URL is a full URL (starts with http)
      if (API_CONFIG.BASE_URL.startsWith('http')) {
        try {
          const url = new URL(API_CONFIG.BASE_URL);
          console.log('Using Socket.IO URL from BASE_URL origin:', url.origin);
          return url.origin; // Just the protocol, hostname, and port
        } catch (e) {
          console.error('Invalid BASE_URL format:', e);
        }
      }
      // Otherwise use the current origin
      console.log('Using Socket.IO URL from window.location.origin:', window.location.origin);
      return window.location.origin;
    };
    
    // Improved Socket.IO connection with correct URL
    const socketUrl = getSocketUrl();
    console.log('Connecting Socket.IO to:', socketUrl);
    
    const socket = io(socketUrl, {
      reconnectionAttempts: 5,
      reconnectionDelay: 1000,
      transports: ['websocket', 'polling'],
      path: '/socket.io' // Default Socket.IO path
    });
    
    socket.on('connect', () => {
      console.log('Socket.IO connected, ID:', socket.id);
    });
    
    socket.on('connect_error', (err) => {
      console.error('Socket.IO connection error:', err);
      console.error('Connection details:', {
        url: socketUrl,
        transport: socket.io.engine.transport.name
      });
    });
    
    socket.on('announcement_update', (data) => {
      console.log('Received announcement update:', data);
      setAnnouncement(data.announcement);
      
      // Send acknowledgment back to server
      socket.emit('announcement_received', { 
        received: true, 
        announcement: data.announcement,
        timestamp: new Date().toISOString()
      });
    });
    
    return () => {
      console.log('Disconnecting Socket.IO');
      socket.off('announcement_update');
      socket.disconnect();
    };
  }, []);
  
  // Function to set a new announcement (admin only)
  const updateAnnouncement = async (text) => {
    try {
      const token = localStorage.getItem('auth_token');
      await axios.post(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.ANNOUNCEMENT}`,
        { announcement: text },
        { headers: { Authorization: `Bearer ${token}` } }
      );
      return true;
    } catch (error) {
      console.error('Failed to update announcement:', error);
      return false;
    }
  };

  return (
    <AnnouncementContext.Provider value={{ announcement, updateAnnouncement }}>
      {children}
    </AnnouncementContext.Provider>
  );
}

export function useAnnouncement() {
  return useContext(AnnouncementContext);
}

================
File: src/context/AuthContext.jsx
================
import React, { createContext, useContext, useState, useEffect } from 'react';
import axios from 'axios';
import API_CONFIG from '../config/api';
import { useWindowState } from './WindowStateContext';
import { useWorkspace } from './WorkspaceContext';

// Create the authentication context
const AuthContext = createContext();

// Internal context for window state access
const InternalAuthContext = createContext();

// Main Auth Provider that doesn't depend on WindowStateContext
export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Check if user is already logged in on component mount
  useEffect(() => {
    const token = localStorage.getItem('auth_token');
    if (token) {
      fetchUserProfile(token);
    } else {
      setLoading(false);
    }
  }, []);

  // Fetch user profile using the token
  const fetchUserProfile = async (token) => {
    try {
      const response = await axios.get(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PROFILE}`, {
        headers: { Authorization: `Bearer ${token}` }
      });
      
      // If is_admin is not present in the response, default to false
      const userData = {
        ...response.data,
        is_admin: response.data.is_admin || false
      };
      
      setUser(userData);
      setError(null);
    } catch (err) {
      console.error('Failed to fetch user profile:', err);
      localStorage.removeItem('auth_token');
      setError('Session expired. Please login again.');
    } finally {
      setLoading(false);
    }
  };

  // Login function
  const login = async (username, password) => {
    setLoading(true);
    try {
      const response = await axios.post(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.LOGIN}`, {
        username,
        password
      });
      
      const { token } = response.data;
      localStorage.setItem('auth_token', token);
      
      await fetchUserProfile(token);
      return { success: true };
    } catch (err) {
      setLoading(false);
      const message = err.response?.data?.message || 'Login failed';
      setError(message);
      return { success: false, message };
    }
  };

  // Logout function (without window state clearing)
  const logout = async () => {
    const token = localStorage.getItem('auth_token');
    
    if (token) {
      try {
        // Call server logout endpoint to remove user from active users
        await axios.post(
          `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.LOGOUT}`, 
          {}, 
          { headers: { Authorization: `Bearer ${token}` } }
        );
        console.log('Logged out on server');
      } catch (err) {
        console.error('Error logging out on server:', err);
      }
    }
    
    localStorage.removeItem('auth_token');
    setUser(null);
    setError(null);
  };

  // Clear any authentication errors
  const clearError = () => {
    setError(null);
  };

  // Context value
  const value = {
    user,
    loading,
    error,
    login,
    logout,
    clearError,
    isAuthenticated: !!user
  };

  return (
    <InternalAuthContext.Provider value={value}>
      {children}
    </InternalAuthContext.Provider>
  );
}

// Wrapper component that connects AuthContext with WindowStateContext
export function AuthProviderWithWindowState({ children }) {
  // Get the window state context
  const { clearWindowStates, reloadWindowStates } = useWindowState();
  
  // Get the workspace context
  const { setWorkspaces, loadWorkspaces } = useWorkspace();
  
  // Initial workspaces state
  const initialWorkspaces = [
    { id: 1, name: 'Main', root: null, activeNodeId: null, terminalStates: {} },
    { id: 2, name: 'Code', root: null, activeNodeId: null, terminalStates: {} },
    { id: 3, name: 'Terminal', root: null, activeNodeId: null, terminalStates: {} },
    { id: 4, name: 'Preview', root: null, activeNodeId: null, terminalStates: {} }
  ];
  
  // Get the internal auth context
  const auth = useContext(InternalAuthContext);
  
  // Create a new logout function that also clears window states and workspaces
  const logoutWithClear = async () => {
    // First call the enhanced logout that includes API call
    await auth.logout();
    clearWindowStates();
    
    // Reset workspaces to initial state
    setWorkspaces(initialWorkspaces);
    
    // Force a refresh of the active users count
    // This will ensure the UI updates immediately
    setTimeout(() => {
      // After a small delay, force a refresh of the active users count via API
      axios.get(`${API_CONFIG.BASE_URL}/active-users`)
        .then(response => {
          // We don't need to do anything with the response
          // The ActiveUsersContext will handle the socket event
          console.log('Forced refresh of active users count after logout');
        })
        .catch(error => {
          console.error('Error refreshing active users after logout:', error);
        });
    }, 500);
  };
  
  // Create a new login function that also reloads window states and workspaces
  const loginWithReload = async (username, password) => {
    const result = await auth.login(username, password);
    
    if (result.success) {
      // Reload window states and workspaces after successful login
      console.log('Login successful, reloading window states and workspaces');
      await Promise.all([
        reloadWindowStates(),
        loadWorkspaces()
      ]);
    }
    
    return result;
  };
  
  // Create a new context value with the enhanced functions
  const enhancedValue = {
    ...auth,
    logout: logoutWithClear,
    login: loginWithReload
  };
  
  return (
    <AuthContext.Provider value={enhancedValue}>
      {children}
    </AuthContext.Provider>
  );
}

// Custom hook to use the auth context
export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProviderWithWindowState');
  }
  return context;
}

================
File: src/context/PartyContext.jsx
================
import React, { createContext, useContext, useState, useEffect } from 'react';
import axios from 'axios';
import { useAuth } from './AuthContext';
import API_CONFIG from '../config/api';

const PartyContext = createContext();

export const useParty = () => useContext(PartyContext);

export const PartyProvider = ({ children }) => {
  const { user, socket } = useAuth();
  const [currentParty, setCurrentParty] = useState(null);
  const [partyMembers, setPartyMembers] = useState([]);
  const [parties, setParties] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Fetch current party on mount or when user changes
  useEffect(() => {
    if (user) {
      fetchCurrentParty();
      fetchParties();
    } else {
      setCurrentParty(null);
      setPartyMembers([]);
    }
  }, [user]);

  // Listen for socket events
  useEffect(() => {
    if (socket) {
      // Listen for party member joins
      socket.on('party_member_joined', (data) => {
        if (currentParty && data.partyId === currentParty.id) {
          fetchPartyMembers(currentParty.id);
        }
      });

      // Listen for party member leaves
      socket.on('party_member_left', (data) => {
        if (currentParty && data.partyId === currentParty.id) {
          fetchPartyMembers(currentParty.id);
        }
      });

      // Listen for new parties being created
      socket.on('party_created', (party) => {
        setParties(prev => [party, ...prev]);
      });

      return () => {
        socket.off('party_member_joined');
        socket.off('party_member_left');
        socket.off('party_created');
      };
    }
  }, [socket, currentParty]);

  const fetchCurrentParty = async () => {
    setLoading(true);
    try {
      const token = localStorage.getItem('auth_token');
      const response = await axios.get(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PARTIES_CURRENT}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      if (response.data && !response.data.message) {
        setCurrentParty(response.data);
        setPartyMembers(response.data.members || []);
        
        // Join the party's socket room
        if (socket) {
          socket.emit('join_party', response.data.id);
        }
      } else {
        setCurrentParty(null);
        setPartyMembers([]);
      }
    } catch (err) {
      console.error('Error fetching current party:', err);
      setError('Failed to fetch current party');
      setCurrentParty(null);
    } finally {
      setLoading(false);
    }
  };

  const fetchParties = async () => {
    try {
      const token = localStorage.getItem('auth_token');
      const response = await axios.get(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PARTIES}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      setParties(response.data);
    } catch (err) {
      console.error('Error fetching parties:', err);
      setError('Failed to fetch parties');
    }
  };

  const fetchPartyMembers = async (partyId) => {
    try {
      const token = localStorage.getItem('auth_token');
      const response = await axios.get(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PARTIES}/${partyId}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      if (currentParty && currentParty.id === partyId) {
        setPartyMembers(response.data.members || []);
      }
    } catch (err) {
      console.error('Error fetching party members:', err);
    }
  };

  const joinParty = async (partyId) => {
    try {
      const token = localStorage.getItem('auth_token');
      const url = `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PARTY_JOIN.replace(':id', partyId)}`;
      const response = await axios.post(url, {}, 
        { headers: { Authorization: `Bearer ${token}` } }
      );
      fetchCurrentParty();
      return response.data;
    } catch (err) {
      console.error('Error joining party:', err);
      setError('Failed to join party');
      throw err;
    }
  };

  const leaveParty = async () => {
    if (!currentParty) return;
    
    try {
      const token = localStorage.getItem('auth_token');
      const url = `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PARTY_LEAVE.replace(':id', currentParty.id)}`;
      await axios.post(url, {}, 
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      // Leave the party's socket room
      if (socket) {
        socket.emit('leave_party', currentParty.id);
      }
      
      setCurrentParty(null);
      setPartyMembers([]);
    } catch (err) {
      console.error('Error leaving party:', err);
      setError('Failed to leave party');
      throw err;
    }
  };

  const createParty = async (name) => {
    try {
      const token = localStorage.getItem('auth_token');
      const response = await axios.post(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PARTIES}`,
        { name },
        { headers: { Authorization: `Bearer ${token}` } }
      );
      fetchParties();
      return response.data;
    } catch (err) {
      console.error('Error creating party:', err);
      setError('Failed to create party');
      throw err;
    }
  };

  const deleteParty = async (partyId) => {
    try {
      const token = localStorage.getItem('auth_token');
      await axios.delete(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PARTIES}/${partyId}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      // Remove the party from the local state
      setParties(prev => prev.filter(party => party.id !== partyId));
      
      // If user is in this party, clear the current party
      if (currentParty && currentParty.id === partyId) {
        setCurrentParty(null);
        setPartyMembers([]);
      }
      
      return { success: true };
    } catch (err) {
      console.error('Error deleting party:', err);
      const errorMessage = err.response?.data?.message || 'Failed to delete party';
      setError(errorMessage);
      return { success: false, message: errorMessage };
    }
  };

  // Listen for party deleted events
  useEffect(() => {
    if (socket) {
      socket.on('party_deleted', (data) => {
        // Update parties list
        setParties(prev => prev.filter(party => party.id !== data.id));
        
        // If user was in this party, clear current party
        if (currentParty && currentParty.id === data.id) {
          setCurrentParty(null);
          setPartyMembers([]);
        }
      });
      
      return () => {
        socket.off('party_deleted');
      };
    }
  }, [socket, currentParty]);

  const value = {
    currentParty,
    partyMembers,
    parties,
    loading,
    error,
    joinParty,
    leaveParty,
    createParty,
    deleteParty,
    refreshParty: fetchCurrentParty,
    refreshParties: fetchParties
  };

  return (
    <PartyContext.Provider value={value}>
      {children}
    </PartyContext.Provider>
  );
};

export default PartyProvider;

================
File: src/context/WindowStateContext.jsx
================
import React, { createContext, useContext, useState, useEffect, useCallback, useMemo, useRef } from 'react';
import axios from 'axios';
import API_CONFIG from '../config/api';
import { WINDOW_TYPES } from '../utils/windowTypes';
import {
  saveWindowState as saveWindowStateToIndexedDB,
  getWindowState as getWindowStateFromIndexedDB,
  getAllWindowStates as getAllWindowStatesFromIndexedDB,
  deleteWindowState as deleteWindowStateFromIndexedDB,
  saveTerminalState,
  getTerminalState,
  saveChatState,
  getChatState,
  saveExplorerState,
  getExplorerState,
  saveActiveWindow,
  getActiveWindow as getActiveWindowFromIndexedDB,
  deleteActiveWindow
} from '../services/indexedDBService';

// Create context
const WindowStateContext = createContext();

// Initial state with different content types
const initialState = {
  windowStates: {}
};

// Context provider component
export function WindowStateProvider({ children }) {
  // Use a ref to store the state to avoid re-renders
  const stateRef = useRef(initialState);
  
  // Use useState just to trigger re-renders when needed
  const [, forceUpdate] = useState({});
  
  // Add a ref to track if we should update API
  const isInitialMount = useRef(true);
  const saveTimeoutRef = useRef(null);
  const indexedDBTimeoutRef = useRef(null);

  // Load initial state from IndexedDB and API once on mount
  useEffect(() => {
    const loadWindowStates = async () => {
      try {
        console.log('Loading window states from IndexedDB and API...');
        
        // First try to load from IndexedDB (works even when offline)
        const indexedDBStates = await getAllWindowStatesFromIndexedDB();
        if (indexedDBStates && indexedDBStates.length > 0) {
          console.log('Loaded window states from IndexedDB:', indexedDBStates);
          
          // Convert array to object with windowId as key
          const windowStatesObj = {};
          indexedDBStates.forEach(state => {
            windowStatesObj[state.id] = {
              type: state.type,
              content: state.content
            };
          });
          
          // Update the state ref
          stateRef.current = {
            windowStates: windowStatesObj
          };
          
          // Force a re-render
          forceUpdate({});
        }
        
        // Then try to load from API (if authenticated)
        const token = localStorage.getItem('auth_token');
        if (!token) {
          isInitialMount.current = false;
          return; // No token, use IndexedDB state
        }
        
        const response = await axios.get(
          `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.WINDOW_STATES}`, 
          { headers: { Authorization: `Bearer ${token}` } }
        );
        
        if (response.data.windowStates) {
          console.log('Loaded window states from API:', response.data.windowStates);
          
          // Update the state ref directly
          stateRef.current = {
            windowStates: response.data.windowStates
          };
          
          // Force a re-render
          forceUpdate({});
          
          // Also update IndexedDB with the API data
          Object.entries(response.data.windowStates).forEach(([windowId, state]) => {
            saveWindowStateToIndexedDB({
              id: windowId,
              type: state.type,
              content: state.content
            });
            
            // Also save to type-specific stores
            saveTypeSpecificState(windowId, state.type, state.content);
          });
        }
      } catch (error) {
        console.error('Failed to load window states:', error);
      } finally {
        // Mark initial load as complete
        isInitialMount.current = false;
      }
    };
    
    loadWindowStates();
  }, []); // Empty dependency array means this runs once on mount

  // Helper function to save state to type-specific IndexedDB stores
  const saveTypeSpecificState = useCallback(async (windowId, windowType, content) => {
    try {
      switch (windowType) {
        case WINDOW_TYPES.TERMINAL:
          await saveTerminalState({
            id: windowId,
            content
          });
          break;
        case WINDOW_TYPES.CHAT:
          await saveChatState({
            id: windowId,
            content
          });
          break;
        case WINDOW_TYPES.EXPLORER:
          await saveExplorerState({
            id: windowId,
            content
          });
          break;
        default:
          // No type-specific handling needed
          break;
      }
    } catch (error) {
      console.error(`Failed to save ${windowType} state to IndexedDB:`, error);
    }
  }, []);

  // Save to IndexedDB with debounce
  const saveToIndexedDB = useCallback((windowId, windowType, content) => {
    // Clear any existing timeout
    if (indexedDBTimeoutRef.current) {
      clearTimeout(indexedDBTimeoutRef.current);
    }
    
    // Set a new timeout to save the state after a delay
    indexedDBTimeoutRef.current = setTimeout(async () => {
      try {
        // Save to general window states store
        await saveWindowStateToIndexedDB({
          id: windowId,
          type: windowType,
          content
        });
        
        // Save to type-specific store
        await saveTypeSpecificState(windowId, windowType, content);
        
        console.log(`Saved ${windowType} state to IndexedDB for window ${windowId}`);
      } catch (error) {
        console.error('Failed to save window state to IndexedDB:', error);
      }
    }, 300); // 300ms debounce
  }, [saveTypeSpecificState]);

  // Save to API with debounce
  const saveToAPI = useCallback(() => {
    // Skip saving on initial load
    if (isInitialMount.current) {
      return;
    }
    
    // Clear any existing timeout
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
    }
    
    // Set a new timeout to save the state after a delay
    saveTimeoutRef.current = setTimeout(async () => {
      try {
        const token = localStorage.getItem('auth_token');
        if (!token) return; // No token, don't save to API
        
        await axios.post(
          `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.WINDOW_STATES}`, 
          { windowStates: stateRef.current.windowStates },
          { headers: { Authorization: `Bearer ${token}` } }
        );
        
        console.log('Saved window states to API');
      } catch (error) {
        console.error('Failed to save window states to API:', error);
      }
    }, 500); // 500ms debounce
  }, []);

  // Clear window states (used during logout)
  const clearWindowStates = useCallback(() => {
    stateRef.current = initialState;
    forceUpdate({});
  }, []);

  // Reload window states from API (used after login)
  const reloadWindowStates = useCallback(async () => {
    try {
      const token = localStorage.getItem('auth_token');
      if (!token) {
        return; // No token, use default empty state
      }
      
      const response = await axios.get(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.WINDOW_STATES}`, 
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      if (response.data.windowStates) {
        // Update the state ref directly
        stateRef.current = {
          windowStates: response.data.windowStates
        };
        
        // Force a re-render
        forceUpdate({});
        
        // Also update IndexedDB with the API data
        Object.entries(response.data.windowStates).forEach(([windowId, state]) => {
          saveWindowStateToIndexedDB({
            id: windowId,
            type: state.type,
            content: state.content
          });
          
          // Also save to type-specific stores
          saveTypeSpecificState(windowId, state.type, state.content);
        });
        
        console.log('Window states reloaded after login');
      }
    } catch (error) {
      console.error('Failed to reload window states from API:', error);
    }
  }, [saveTypeSpecificState]);

  // Action creators
  const setWindowState = useCallback((windowId, windowType, content) => {
    // Update the state ref directly
    stateRef.current = {
      ...stateRef.current,
      windowStates: {
        ...stateRef.current.windowStates,
        [windowId]: {
          type: windowType,
          content
        }
      }
    };
    
    // Save to IndexedDB
    saveToIndexedDB(windowId, windowType, content);
    
    // Save to API
    saveToAPI();
    
    // Force a re-render
    forceUpdate({});
  }, [saveToAPI, saveToIndexedDB]);

  const removeWindowState = useCallback((windowId) => {
    // Create a new state object
    const newState = {
      ...stateRef.current,
      windowStates: { ...stateRef.current.windowStates }
    };
    
    // Get the window type before deleting
    const windowType = newState.windowStates[windowId]?.type;
    
    // Delete the window state
    delete newState.windowStates[windowId];
    
    // Update the state ref
    stateRef.current = newState;
    
    // Delete from IndexedDB
    deleteWindowStateFromIndexedDB(windowId);
    
    // Delete active window reference if it exists
    deleteActiveWindow(windowId);
    
    // Save to API
    saveToAPI();
    
    // Force a re-render
    forceUpdate({});
    
    console.log(`Removed window state for window ${windowId}`);
  }, [saveToAPI]);

  const getWindowState = useCallback(async (windowId) => {
    // First check in-memory state
    const memoryState = stateRef.current.windowStates[windowId];
    if (memoryState) {
      return memoryState;
    }
    
    // If not in memory, try to get from IndexedDB
    try {
      const dbState = await getWindowStateFromIndexedDB(windowId);
      if (dbState) {
        // Update in-memory state
        stateRef.current = {
          ...stateRef.current,
          windowStates: {
            ...stateRef.current.windowStates,
            [windowId]: {
              type: dbState.type,
              content: dbState.content
            }
          }
        };
        
        // Force a re-render
        forceUpdate({});
        
        return {
          type: dbState.type,
          content: dbState.content
        };
      }
    } catch (error) {
      console.error(`Failed to get window state for window ${windowId} from IndexedDB:`, error);
    }
    
    return null;
  }, []);

  // Function to save active window reference
  const setActiveWindow = useCallback(async (windowId, windowType) => {
    try {
      await saveActiveWindow({
        id: windowType,
        activeWindowId: windowId
      });
      
      console.log(`Saved active window reference for ${windowType}: ${windowId}`);
    } catch (error) {
      console.error(`Failed to save active window reference for ${windowType}:`, error);
    }
  }, []);

  // Function to get active window reference
  const getActiveWindow = useCallback(async (windowType) => {
    try {
      const activeWindow = await getActiveWindowFromIndexedDB(windowType);
      return activeWindow?.activeWindowId || null;
    } catch (error) {
      console.error(`Failed to get active window reference for ${windowType}:`, error);
      return null;
    }
  }, []);

  // Create a stable context value
  const contextValue = useMemo(() => ({
    windowStates: stateRef.current.windowStates,
    setWindowState,
    removeWindowState,
    getWindowState,
    clearWindowStates,
    reloadWindowStates,
    setActiveWindow,
    getActiveWindow
  }), [
    setWindowState, 
    removeWindowState, 
    getWindowState, 
    clearWindowStates, 
    reloadWindowStates,
    setActiveWindow,
    getActiveWindow
  ]);

  return (
    <WindowStateContext.Provider value={contextValue}>
      {children}
    </WindowStateContext.Provider>
  );
}

// Custom hook to use the window state context
export function useWindowState() {
  const context = useContext(WindowStateContext);
  if (!context) {
    throw new Error('useWindowState must be used within a WindowStateProvider');
  }
  return context;
}

================
File: src/context/WorkspaceContext.jsx
================
import React, { createContext, useContext, useState, useEffect, useCallback, useMemo } from 'react';
import axios from 'axios';
import API_CONFIG from '../config/api';

// Create context
const WorkspaceContext = createContext();

// Initial workspaces
const initialWorkspaces = [
  { id: 1, name: 'Main', root: null, activeNodeId: null, terminalStates: {} },
  { id: 2, name: 'Code', root: null, activeNodeId: null, terminalStates: {} },
  { id: 3, name: 'Terminal', root: null, activeNodeId: null, terminalStates: {} },
  { id: 4, name: 'Preview', root: null, activeNodeId: null, terminalStates: {} }
];

/**
 * WorkspaceProvider component for managing workspace state
 * This handles the persistence of window layouts across page refreshes
 */
export function WorkspaceProvider({ children }) {
  const [workspaces, setWorkspaces] = useState(initialWorkspaces);
  const [currentWorkspaceIndex, setCurrentWorkspaceIndex] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  
  // Function to load workspaces from server
  const loadWorkspaces = useCallback(async () => {
    try {
      setIsLoading(true);
      
      // Get auth token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        console.log('No auth token found, using initial workspaces');
        setIsLoading(false);
        return;
      }
      
      // Fetch workspaces from server
      const response = await axios.get(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.WORKSPACES}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      if (response.data && response.data.workspaces) {
        console.log('Loaded workspaces from server:', response.data.workspaces);
        setWorkspaces(response.data.workspaces);
      } else {
        console.log('No saved workspaces found, using initial workspaces');
      }
    } catch (error) {
      console.error('Failed to load workspaces from server:', error);
    } finally {
      setIsLoading(false);
    }
  }, []);
  
  // Load workspaces from server API on mount
  useEffect(() => {
    loadWorkspaces();
  }, [loadWorkspaces]);
  
  // Save workspaces to server API whenever they change
  useEffect(() => {
    if (isLoading) return; // Skip saving during initial load
    
    const saveWorkspaces = async () => {
      try {
        // Get auth token
        const token = localStorage.getItem('auth_token');
        if (!token) return; // Don't save if not authenticated
        
        // Ensure we're only saving the array of workspaces
        // Create a clean copy without any non-array properties
        const workspacesToSave = [...workspaces].map(workspace => ({
          id: workspace.id,
          name: workspace.name,
          root: workspace.root,
          activeNodeId: workspace.activeNodeId,
          terminalStates: workspace.terminalStates || {}
        }));
        
        console.log('Saving workspaces to server:', workspacesToSave);
        
        // Save workspaces to server
        await axios.post(
          `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.WORKSPACES}`,
          { workspaces: workspacesToSave },
          { headers: { Authorization: `Bearer ${token}` } }
        );
      } catch (error) {
        console.error('Failed to save workspaces to server:', error);
      }
    };
    
    const timeoutId = setTimeout(saveWorkspaces, 500); // Debounce
    return () => clearTimeout(timeoutId);
  }, [workspaces, isLoading]);
  
  // Update a specific workspace
  const updateWorkspace = useCallback((index, updater) => {
    setWorkspaces(prev => {
      const updated = [...prev];
      if (typeof updater === 'function') {
        updated[index] = {
          ...updated[index],
          ...updater(updated[index])
        };
      } else {
        updated[index] = {
          ...updated[index],
          ...updater
        };
      }
      return updated;
    });
  }, []);
  
  // Switch to a different workspace
  const switchWorkspace = useCallback((target) => {
    if (typeof target === 'number' && target >= 0 && target < workspaces.length) {
      setCurrentWorkspaceIndex(target);
    } else if (target === 'right' || target === 'left') {
      setCurrentWorkspaceIndex(prev => {
        const newIndex = target === 'right' 
          ? (prev + 1) % workspaces.length 
          : prev - 1 < 0 ? workspaces.length - 1 : prev - 1;
        return newIndex;
      });
    }
  }, [workspaces.length]);
  
  // Context value
  const value = useMemo(() => ({
    workspaces,
    setWorkspaces,
    currentWorkspaceIndex,
    currentWorkspace: workspaces[currentWorkspaceIndex],
    updateWorkspace,
    switchWorkspace,
    isLoading,
    loadWorkspaces
  }), [workspaces, setWorkspaces, currentWorkspaceIndex, updateWorkspace, switchWorkspace, isLoading, loadWorkspaces]);
  
  return (
    <WorkspaceContext.Provider value={value}>
      {children}
    </WorkspaceContext.Provider>
  );
}

// Custom hook to use the workspace context
export function useWorkspace() {
  const context = useContext(WorkspaceContext);
  if (!context) {
    throw new Error('useWorkspace must be used within a WorkspaceProvider');
  }
  return context;
}

================
File: src/db/db-config.js
================
/**
 * IndexedDB configuration for the window manager
 */

const DB_NAME = 'WindowManagerDB';
const DB_VERSION = 3; // Increment version to trigger database upgrade
const STORES = {
  WORKSPACES: 'workspaces',
  WINDOW_STATES: 'windowStates',
  TERMINAL_STATES: 'terminalStates',
  CHAT_STATES: 'chatStates',
  EXPLORER_STATES: 'explorerStates',
  CANVAS_STATES: 'canvasStates', // Add canvas states store
  ACTIVE_WINDOWS: 'activeWindows'
};

export { DB_NAME, DB_VERSION, STORES };

================
File: src/db/db-operations.js
================
/**
 * Basic CRUD operations for IndexedDB
 */
import { getDB } from './db';

/**
 * Save data to a store
 * @param {string} storeName - The name of the object store
 * @param {Object} data - The data to save
 * @returns {Promise<any>} A promise that resolves to the result of the operation
 */
export const saveData = async (storeName, data) => {
  const db = await getDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readwrite');
    const store = transaction.objectStore(storeName);
    const request = store.put(data);
    
    request.onerror = (event) => reject(event.target.error);
    request.onsuccess = (event) => resolve(event.target.result);
    
    // Close the database when the transaction is complete
    transaction.oncomplete = () => db.close();
  });
};

/**
 * Get data from a store
 * @param {string} storeName - The name of the object store
 * @param {string|number} id - The ID of the data to retrieve
 * @returns {Promise<any>} A promise that resolves to the retrieved data
 */
export const getData = async (storeName, id) => {
  const db = await getDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readonly');
    const store = transaction.objectStore(storeName);
    const request = store.get(id);
    
    request.onerror = (event) => reject(event.target.error);
    request.onsuccess = (event) => resolve(request.result);
    
    // Close the database when the transaction is complete
    transaction.oncomplete = () => db.close();
  });
};

/**
 * Delete data from a store
 * @param {string} storeName - The name of the object store
 * @param {string|number} id - The ID of the data to delete
 * @returns {Promise<void>} A promise that resolves when the data is deleted
 */
export const deleteData = async (storeName, id) => {
  const db = await getDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readwrite');
    const store = transaction.objectStore(storeName);
    const request = store.delete(id);
    
    request.onerror = (event) => reject(event.target.error);
    request.onsuccess = (event) => resolve();
    
    // Close the database when the transaction is complete
    transaction.oncomplete = () => db.close();
  });
};

/**
 * Get all data from a store
 * @param {string} storeName - The name of the object store
 * @returns {Promise<Array>} A promise that resolves to an array of all data in the store
 */
export const getAllData = async (storeName) => {
  const db = await getDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readonly');
    const store = transaction.objectStore(storeName);
    const request = store.getAll();
    
    request.onerror = (event) => reject(event.target.error);
    request.onsuccess = (event) => resolve(request.result);
    
    // Close the database when the transaction is complete
    transaction.oncomplete = () => db.close();
  });
};

/**
 * Clear all data from a store
 * @param {string} storeName - The name of the object store
 * @returns {Promise<void>} A promise that resolves when the store is cleared
 */
export const clearStore = async (storeName) => {
  const db = await getDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readwrite');
    const store = transaction.objectStore(storeName);
    const request = store.clear();
    
    request.onerror = (event) => reject(event.target.error);
    request.onsuccess = (event) => resolve();
    
    // Close the database when the transaction is complete
    transaction.oncomplete = () => db.close();
  });
};

================
File: src/db/db.js
================
/**
 * IndexedDB initialization and core functionality
 */
import { DB_NAME, DB_VERSION, STORES } from './db-config';

/**
 * Initialize the IndexedDB database
 * @returns {Promise<IDBDatabase>} A promise that resolves to the database instance
 */
export const initDB = () => {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);
    
    request.onerror = (event) => {
      console.error('IndexedDB error:', event.target.error);
      reject('Error opening IndexedDB');
    };
    
    request.onsuccess = (event) => {
      const db = event.target.result;
      console.log('IndexedDB opened successfully');
      resolve(db);
    };
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      const oldVersion = event.oldVersion;
      
      console.log(`Upgrading IndexedDB from version ${oldVersion} to ${DB_VERSION}`);
      
      // Create object stores if they don't exist
      if (oldVersion < 1) {
        // Initial stores from version 1
        if (!db.objectStoreNames.contains(STORES.WORKSPACES)) {
          db.createObjectStore(STORES.WORKSPACES, { keyPath: 'id' });
          console.log(`Created ${STORES.WORKSPACES} object store`);
        }
        
        if (!db.objectStoreNames.contains(STORES.WINDOW_STATES)) {
          db.createObjectStore(STORES.WINDOW_STATES, { keyPath: 'id' });
          console.log(`Created ${STORES.WINDOW_STATES} object store`);
        }
      }
      
      if (oldVersion < 2) {
        // New stores added in version 2
        if (!db.objectStoreNames.contains(STORES.TERMINAL_STATES)) {
          db.createObjectStore(STORES.TERMINAL_STATES, { keyPath: 'id' });
          console.log(`Created ${STORES.TERMINAL_STATES} object store`);
        }
        
        if (!db.objectStoreNames.contains(STORES.CHAT_STATES)) {
          db.createObjectStore(STORES.CHAT_STATES, { keyPath: 'id' });
          console.log(`Created ${STORES.CHAT_STATES} object store`);
        }
        
        if (!db.objectStoreNames.contains(STORES.EXPLORER_STATES)) {
          db.createObjectStore(STORES.EXPLORER_STATES, { keyPath: 'id' });
          console.log(`Created ${STORES.EXPLORER_STATES} object store`);
        }
        
        if (!db.objectStoreNames.contains(STORES.ACTIVE_WINDOWS)) {
          db.createObjectStore(STORES.ACTIVE_WINDOWS, { keyPath: 'id' });
          console.log(`Created ${STORES.ACTIVE_WINDOWS} object store`);
        }
      }
      
      if (oldVersion < 3) {
        // New stores added in version 3
        if (!db.objectStoreNames.contains(STORES.CANVAS_STATES)) {
          db.createObjectStore(STORES.CANVAS_STATES, { keyPath: 'id' });
          console.log(`Created ${STORES.CANVAS_STATES} object store`);
        }
      }
    };
  });
};

/**
 * Get a database connection
 * @returns {Promise<IDBDatabase>} A promise that resolves to the database instance
 */
export const getDB = () => {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);
    request.onerror = (event) => reject(event.target.error);
    request.onsuccess = (event) => resolve(event.target.result);
  });
};

================
File: src/hocs/withCommandHandling.jsx
================
import React from 'react';
import { WINDOW_TYPES } from '../utils/windowTypes';
import { COMMAND_ALIASES } from '../utils/commandAliases';

/**
 * Higher-Order Component that adds command handling capabilities to window components.
 * This HOC provides a standardized way to handle commands across different window types,
 * particularly focusing on window transformation commands.
 *
 * @param {React.Component} WrappedComponent - The window component to enhance with command handling
 * @returns {React.Component} - A new component with command handling capabilities
 */
const withCommandHandling = (WrappedComponent) => {
  // Return a new component that includes the command handling functionality
  return function WithCommandHandling({ 
    transformWindow, // Function to change window type
    nodeId,         // Unique identifier for the window
    ...props        // All other props passed to the window
  }) {
    /**
     * Handles commands entered in the window.
     * Currently supports window transformation commands (e.g., 'terminal', 'editor', etc.)
     * Can be extended to handle other command types in the future.
     *
     * @param {string} command - The command string to process
     * @returns {boolean} - Whether the command was handled
     */
    const handleCommand = (command) => {
      // Convert command to lowercase for case-insensitive comparison
      const cmdParts = command.toLowerCase().split(' ');
      let cmd = cmdParts[0];
      
      // Check if the command is an alias and replace it
      if (COMMAND_ALIASES[cmd]) {
        cmd = COMMAND_ALIASES[cmd];
        // If this was the first word of a multi-word command, replace it
        if (cmdParts.length > 1) {
          cmdParts[0] = cmd;
          command = cmdParts.join(' ');
        }
      }
      
      // Check if the command matches any window type
      // This allows commands like 'terminal', 'editor', 'explorer', 'preview'
      const isWindowTypeCommand = Object.keys(WINDOW_TYPES).some(
        type => type.toLowerCase() === cmd
      );

      if (isWindowTypeCommand) {
        // Get the actual window type constant from our types enum
        const requestedType = WINDOW_TYPES[cmd.toUpperCase()];
        
        // Log the transformation request for debugging
        console.log(`Transforming window ${nodeId} to ${requestedType}`);
        
        // Execute the transformation
        transformWindow(nodeId, requestedType);
        
        // Return true to indicate the command was handled
        return true;
      }
      
      // Return false if the command wasn't handled by this HOC
      // This allows the wrapped component to handle other commands if needed
      return false;
    };
    
    // Render the wrapped component with both the original props
    // and our new command handler
    return (
      <WrappedComponent 
        {...props} 
        transformWindow={transformWindow}
        nodeId={nodeId}
        onCommand={handleCommand}
      />
    );
  };
};

export default withCommandHandling;

================
File: src/hocs/withCommandInput.jsx
================
import React, { useState, useRef } from 'react';

/**
 * Higher-Order Component that adds a command input field to any window component.
 * This HOC provides a standardized way to input commands across different window types.
 * The command input is added at the bottom of the window, after any existing content.
 *
 * @param {React.Component} WrappedComponent - The window component to enhance with a command input
 * @returns {React.Component} - A new component with a command input field
 */
const withCommandInput = (WrappedComponent) => {
  return function WithCommandInput({
    onCommand,
    focusRef,
    ...props
  }) {
    const [command, setCommand] = useState('');
    const commandInputRef = useRef(null);

    // Use the provided focusRef for the command input
    const combinedRef = (el) => {
      commandInputRef.current = el;
      if (focusRef) {
        focusRef.current = el;
      }
    };

    const handleKeyDown = (e) => {
      if (e.key === 'Enter' && command.trim()) {
        onCommand(command.trim());
        setCommand('');
      }
    };

    return (
      <div className="h-full flex flex-col">
        {/* Original component takes most of the space */}
        <div className="flex-1 overflow-auto">
          <WrappedComponent
            {...props}
            onCommand={onCommand}
          />
        </div>
        
        {/* Command input - always at the bottom */}
        <div className="p-2 flex items-center gap-2 border-t border-stone-700 bg-stone-900">
          <span className="text-teal-400 mr-2">$</span>
          <input
            ref={combinedRef}
            type="text"
            value={command}
            onChange={(e) => setCommand(e.target.value)}
            onKeyDown={handleKeyDown}
            className="flex-1 bg-stone-800 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
          />
        </div>
      </div>
    );
  };
};

export default withCommandInput;

================
File: src/hocs/withWindowState.jsx
================
import React, { useCallback, useMemo, useRef, useEffect } from 'react';
import { useWindowState } from '../context/WindowStateContext';

/**
 * Higher-Order Component that adds state management capabilities to window components.
 * This HOC provides a standardized way to manage window state across different window types.
 *
 * @param {React.Component} WrappedComponent - The window component to enhance with state management
 * @param {string} windowType - The type of window from WINDOW_TYPES
 * @returns {React.Component} - A new component with state management capabilities
 */
const withWindowState = (WrappedComponent, windowType) => {
  return function WithWindowState({ 
    nodeId,
    isActive,
    ...props
  }) {
    // Create a ref for auto-focusing input elements
    const focusRef = useRef(null);
    
    // Auto-focus when window becomes active
    useEffect(() => {
      if (isActive && focusRef.current) {
        focusRef.current.focus();
      }
    }, [isActive]);
    // Access the window state context
    const { getWindowState, setWindowState } = useWindowState();
    
    // Get the current state or use an empty object if none exists
    // Use useMemo to avoid recreating the object on every render
    const currentState = useMemo(() => {
      return getWindowState(nodeId)?.content || {};
    }, [getWindowState, nodeId]);
    
    // Create an updater function for the component to use
    // Use useCallback to avoid recreating the function on every render
    const updateWindowState = useCallback((updates) => {
      // Get the latest state to ensure we're working with current data
      const latestState = getWindowState(nodeId)?.content || {};
      
      // Allow both object and function updaters
      const newContent = typeof updates === 'function'
        ? updates(latestState)
        : { ...latestState, ...updates };
        
      setWindowState(nodeId, windowType, newContent);
    }, [getWindowState, setWindowState, nodeId, windowType]);
    
    return (
      <WrappedComponent
        {...props}
        nodeId={nodeId}
        windowState={currentState}
        updateWindowState={updateWindowState}
        isActive={isActive}
        focusRef={focusRef}
      />
    );
  };
};

export default withWindowState;

================
File: src/hooks/swapWindows.js
================
// Function to swap two windows in the tree
const swapWindows = useCallback((sourceId, targetId) => {
  if (!sourceId || !targetId || sourceId === targetId) return;

  console.log('Swapping windows:', sourceId, targetId);

  updateWorkspace(workspace => {
    const newRoot = JSON.parse(JSON.stringify(workspace.root));
    
    // Find the nodes to swap
    const sourceNode = findNodeById(newRoot, sourceId);
    const targetNode = findNodeById(newRoot, targetId);
    
    if (!sourceNode || !targetNode) {
      console.log('Could not find one or both nodes to swap');
      return workspace;
    }
    
    // Swap the window types and states
    const tempWindowType = sourceNode.windowType;
    const tempState = sourceNode.state;
    
    sourceNode.windowType = targetNode.windowType;
    sourceNode.state = targetNode.state;
    
    targetNode.windowType = tempWindowType;
    targetNode.state = tempState;
    
    return { ...workspace, root: newRoot };
  });
  
  // Exit move mode after swapping
  setIsMoveMode(false);
  setMoveSourceWindowId(null);
}, [updateWorkspace]);

// Add direct keyboard event listener for move mode
useEffect(() => {
  const handleMoveKeyDown = (e) => {
    // Handle move mode toggle
    if (e.ctrlKey && e.key === 'm') {
      e.preventDefault();
      e.stopPropagation(); // Stop event propagation to prevent multiple handlers
      console.log('Move mode toggle pressed directly in useWindowManager');
      console.log('Current isMoveMode:', isMoveMode);
      
      // Toggle move mode
      setIsMoveMode(!isMoveMode);
      
      // Reset source window when toggling off
      if (isMoveMode) {
        setMoveSourceWindowId(null);
      }
    }
    
    // Handle move mode Enter key
    if (isMoveMode && e.key === 'Enter') {
      e.preventDefault();
      e.stopPropagation();
      console.log('Enter key pressed in move mode');
      
      if (!moveSourceWindowId) {
        // First window selection
        console.log('Selected first window for move:', activeNodeId);
        setMoveSourceWindowId(activeNodeId);
      } else {
        // Second window selection - perform the swap
        console.log('Selected second window for move:', activeNodeId);
        swapWindows(moveSourceWindowId, activeNodeId);
      }
    }
  };
  
  // Add the event listener with capture: true to ensure it runs before other listeners
  window.addEventListener('keydown', handleMoveKeyDown, { capture: true });
  return () => window.removeEventListener('keydown', handleMoveKeyDown, { capture: true });
}, [isMoveMode, moveSourceWindowId, activeNodeId, setIsMoveMode, setMoveSourceWindowId, swapWindows]);

// Debug checks for modes
useEffect(() => {
  console.log('Resize mode:', isResizeMode);
}, [isResizeMode]);

useEffect(() => {
  console.log('Move mode:', isMoveMode);
  if (!isMoveMode) {
    setMoveSourceWindowId(null);
  }
}, [isMoveMode]);

// Function to update terminal state
const updateTerminalState = useCallback((terminalId, newState) => {
  updateWorkspace(workspace => ({
    ...workspace,
    terminalStates: {
      ...workspace.terminalStates,
      [terminalId]: newState
    }
  }));
}, [updateWorkspace]);

return {
  rootNode,
  activeNodeId,
  setActiveNodeId,
  terminalStates,
  updateTerminalState,
  createNewWindow,
  splitWindow,
  closeWindow,
  transformWindow,
  handleCommand,
  navigateToWindow,
  hasActiveWindow: Boolean(activeNodeId),
  hasRootNode: Boolean(rootNode),
  currentWorkspaceIndex,
  workspaceCount: 4,
  switchWorkspace,
  isResizeMode,
  setIsResizeMode,
  resizeActiveWindow,
  isMoveMode,
  setIsMoveMode,
  moveSourceWindowId,
  setMoveSourceWindowId,
  swapWindows
};

================
File: src/hooks/useForceUpdate.js
================
import { useState } from 'react';

export function useForceUpdate() {
    const [state, setState] = useState(0);
    return () => setState((state) => state + 1);
  }

================
File: src/hooks/useKeyboardShortcuts.js
================
import { useEffect } from 'react';
import { WINDOW_TYPES } from '../utils/windowTypes';

/**
 * A custom hook that manages keyboard shortcuts for window operations.
 * This hook centralizes all keyboard-related logic for the window manager.
 * 
 * @param {Object} handlers - Object containing callback functions for various window operations
 * @param {Function} handlers.onSplitVertical - Handler for vertical split command
 * @param {Function} handlers.onSplitHorizontal - Handler for horizontal split command
 * @param {Function} handlers.onClose - Handler for window close command
 * @param {Function} handlers.createNewWindow - Handler for creating new windows
 * @param {boolean} hasActiveWindow - Whether there is currently an active window
 * @param {boolean} hasRootNode - Whether there is a root node in the tree
 */
export const useKeyboardShortcuts = ({
  onSplitVertical,
  onSplitHorizontal,
  onClose,
  createNewWindow,
  hasActiveWindow,
  hasRootNode,
  isResizeMode = false,
  setIsResizeMode = () => console.warn('setIsResizeMode not provided'),
  resizeActiveWindow = () => console.warn('resizeActiveWindow not provided'),
  isMoveMode = false,
  setIsMoveMode = () => console.warn('setIsMoveMode not provided'),
  moveSourceWindowId = null,
  setMoveSourceWindowId = () => console.warn('setMoveSourceWindowId not provided'),
  swapWindows = () => console.warn('swapWindows not provided'),
  activeNodeId = null
}) => {
  // Log the props for debugging
  console.log('useKeyboardShortcuts props:', {
    isResizeMode,
    isMoveMode,
    moveSourceWindowId,
    activeNodeId,
    hasSetIsResizeMode: typeof setIsResizeMode === 'function',
    hasSetIsMoveMode: typeof setIsMoveMode === 'function',
    hasSetMoveSourceWindowId: typeof setMoveSourceWindowId === 'function',
    hasSwapWindows: typeof swapWindows === 'function'
  });
  useEffect(() => {
    const handleKeyDown = (e) => {
      // Handle resize mode toggle
      if (e.ctrlKey && e.key === 'q') {
        e.preventDefault();
        setIsResizeMode(!isResizeMode);
        // Exit move mode if it's active
        if (isMoveMode) {
          setIsMoveMode(false);
          setMoveSourceWindowId(null);
        }
        return;
      }

      // Handle move mode toggle
      if (e.ctrlKey && e.key === 'm') {
        e.preventDefault();
        e.stopPropagation(); // Stop event propagation to prevent multiple handlers
        console.log('Move mode toggle pressed in useKeyboardShortcuts');
        console.log('setIsMoveMode type:', typeof setIsMoveMode);
        console.log('Current isMoveMode:', isMoveMode);
        console.log('Component ID:', Math.random()); // Add a random ID to identify which instance is handling the event
        
        // Check if setIsMoveMode is a function before calling it
        if (typeof setIsMoveMode === 'function') {
          // Toggle move mode with a direct call to ensure it works
          const newMoveMode = !isMoveMode;
          console.log('Setting move mode to:', newMoveMode);
          setIsMoveMode(newMoveMode);
          
          // Reset source window when toggling off
          if (isMoveMode && typeof setMoveSourceWindowId === 'function') {
            setMoveSourceWindowId(null);
          }
          
          // Exit resize mode if it's active
          if (isResizeMode && typeof setIsResizeMode === 'function') {
            setIsResizeMode(false);
          }
        } else {
          console.error('setIsMoveMode is not a function');
        }
        return;
      }

      // Handle move mode Enter key
      if (isMoveMode && e.key === 'Enter') {
        e.preventDefault();
        console.log('Enter key pressed in move mode');
        
        if (!moveSourceWindowId) {
          // First window selection
          console.log('Selected first window for move:', activeNodeId);
          if (typeof setMoveSourceWindowId === 'function') {
            setMoveSourceWindowId(activeNodeId);
          } else {
            console.error('setMoveSourceWindowId is not a function');
          }
        } else {
          // Second window selection - perform the swap
          console.log('Selected second window for move:', activeNodeId);
          if (typeof swapWindows === 'function') {
            swapWindows(moveSourceWindowId, activeNodeId);
          } else {
            console.error('swapWindows is not a function');
          }
        }
        return;
      }

      // Handle resize mode arrow keys
      if (isResizeMode && !e.ctrlKey) {
        switch (e.key) {
          case 'ArrowLeft':
            e.preventDefault();
            resizeActiveWindow('left');
            break;
          case 'ArrowRight':
            e.preventDefault();
            resizeActiveWindow('right');
            break;
          case 'ArrowUp':
            e.preventDefault();
            resizeActiveWindow('up');
            break;
          case 'ArrowDown':
            e.preventDefault();
            resizeActiveWindow('down');
            break;
        }
        return;
      }

      // Handle other keyboard shortcuts...
      if (e.ctrlKey) {
        if (e.key === 'Enter') {
          e.preventDefault();
          if (e.shiftKey) {
            hasActiveWindow ? onSplitVertical() : createNewWindow();
          } else {
            hasActiveWindow ? onSplitHorizontal() : createNewWindow();
          }
        } else if ((e.key === 'Backspace' || e.key === 'Delete') && hasActiveWindow && hasRootNode) {
          e.preventDefault();
          onClose();
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [
    onSplitVertical,
    onSplitHorizontal,
    onClose,
    createNewWindow,
    hasActiveWindow,
    hasRootNode,
    isResizeMode,
    setIsResizeMode,
    resizeActiveWindow,
    isMoveMode,
    setIsMoveMode,
    moveSourceWindowId,
    setMoveSourceWindowId,
    swapWindows,
    activeNodeId
  ]);
};

================
File: src/hooks/useWindowManager.js
================
import { useState, useCallback, useEffect, useRef } from 'react';
import { Node } from '../models/Node';
import { WINDOW_TYPES } from '../utils/windowTypes';
import { 
  splitNodeById, 
  removeNodeById, 
  findNodeById, 
  findAllWindowIds,
  updateSplitRatio,
  findSiblingWindowId,
  findFirstWindowId
} from '../utils/treeUtils';
import { getWindowBounds } from '../utils/windowUtils';
import { useWindowState } from '../context/WindowStateContext';
import { useWorkspace } from '../context/WorkspaceContext';
import { 
  MIN_WINDOW_WIDTH_PX, 
  MIN_WINDOW_HEIGHT_PX 
} from '../utils/windowSizeConstants';
import { 
  saveActiveWindow, 
  getActiveWindow,
  // Include these imports for easier access in our swapWindows function
  getWindowState
} from '../services/indexedDBService';

export const useWindowManager = ({ defaultLayout = null, onFlashBorder = null } = {}) => {
  // Use workspace context instead of internal state
  const { 
    workspaces,
    currentWorkspaceIndex,
    currentWorkspace,
    updateWorkspace,
    switchWorkspace
  } = useWorkspace();
  
  // Get current workspace data
  const rootNode = currentWorkspace.root;
  const activeNodeId = currentWorkspace.activeNodeId;
  const terminalStates = currentWorkspace.terminalStates;
  
  const [isResizeMode, setIsResizeMode] = useState(false);
  const [isMoveMode, setIsMoveMode] = useState(false);
  const [moveSourceWindowId, setMoveSourceWindowId] = useState(null);

  // Create setActiveNodeId function that updates the workspace
  const setActiveNodeId = useCallback((nodeId) => {
    updateWorkspace(currentWorkspaceIndex, workspace => ({
      ...workspace,
      activeNodeId: nodeId
    }));
    
    // Save the active window ID to IndexedDB for persistence across refreshes
    if (nodeId) {
      // Get the window type from the node
      const node = findNodeById(rootNode, nodeId);
      if (node && node.windowType) {
        // Save the active window ID for this window type
        saveActiveWindow({
          id: 'activeWindow',
          activeNodeId: nodeId,
          windowType: node.windowType
        }).catch(error => {
          console.error('Failed to save active window ID to IndexedDB:', error);
        });
      }
    }
  }, [updateWorkspace, currentWorkspaceIndex, rootNode]);
  
  // Load the active window ID from IndexedDB on mount
  useEffect(() => {
    const loadActiveWindow = async () => {
      try {
        // Try to load the active window ID from IndexedDB
        const savedActiveWindow = await getActiveWindow('activeWindow');
        
        if (savedActiveWindow && savedActiveWindow.activeNodeId) {
          console.log('Loaded active window ID from IndexedDB:', savedActiveWindow.activeNodeId);
          
          // Check if the window still exists in the current workspace
          if (rootNode && findNodeById(rootNode, savedActiveWindow.activeNodeId)) {
            // Update the active window ID
            setActiveNodeId(savedActiveWindow.activeNodeId);
          }
        }
      } catch (error) {
        console.error('Failed to load active window ID from IndexedDB:', error);
      }
    };
    
    // Only load if we have a root node but no active node
    if (rootNode && !activeNodeId) {
      loadActiveWindow();
    }
  }, [rootNode, activeNodeId, setActiveNodeId]);

  useEffect(() => {
    const handleWorkspaceKeys = (e) => {
      if (e.ctrlKey && e.altKey) {
        switch (e.key) {
          case 'ArrowRight':
            e.preventDefault();
            switchWorkspace('right');
            break;
          case 'ArrowLeft':
            e.preventDefault();
            switchWorkspace('left');
            break;
          // Removed 'n' key handler for creating new workspaces
        }
      }
    };

    window.addEventListener('keydown', handleWorkspaceKeys);
    return () => window.removeEventListener('keydown', handleWorkspaceKeys);
  }, [switchWorkspace]);

  // Window navigation functions
  const navigateToWindow = useCallback((direction) => {
    if (!activeNodeId || !rootNode) return;
  
    const allWindows = getWindowBounds(rootNode);
    const activeWindow = allWindows.find(w => w.id === activeNodeId);
    if (!activeWindow) return;
  
    // Filter out the active window
    const otherWindows = allWindows.filter(w => w.id !== activeNodeId);
    
    // If no other windows, nothing to navigate to
    if (otherWindows.length === 0) return;
    
    // Calculate the active window's center
    const activeBounds = activeWindow.bounds;
    
    // Helper function to calculate overlap percentage between windows
    const calculateOverlap = (window1, window2, isHorizontal) => {
      if (isHorizontal) {
        // Calculate horizontal overlap
        const overlapStart = Math.max(window1.left, window2.left);
        const overlapEnd = Math.min(window1.right, window2.right);
        if (overlapEnd <= overlapStart) return 0; // No overlap
        
        const overlapWidth = overlapEnd - overlapStart;
        const window1Width = window1.right - window1.left;
        
        return overlapWidth / window1Width;
      } else {
        // Calculate vertical overlap
        const overlapStart = Math.max(window1.top, window2.top);
        const overlapEnd = Math.min(window1.bottom, window2.bottom);
        if (overlapEnd <= overlapStart) return 0; // No overlap
        
        const overlapHeight = overlapEnd - overlapStart;
        const window1Height = window1.bottom - window1.top;
        
        return overlapHeight / window1Height;
      }
    };
    
    // Find windows in the specified direction with a more relaxed approach
    let candidateWindows = [];
    const tolerance = 0.1; // 10% tolerance for adjacency
    
    switch (direction) {
      case 'up':
        // Windows that are above the active window
        candidateWindows = otherWindows.filter(w => {
          const bounds = w.bounds;
          // Window must be above the active window
          if (bounds.bottom > activeBounds.top) return false;
          
          // Calculate horizontal overlap
          const overlap = calculateOverlap(activeBounds, bounds, true);
          return overlap > 0; // Any overlap makes it a candidate
        });
        break;
        
      case 'down':
        // Windows that are below the active window
        candidateWindows = otherWindows.filter(w => {
          const bounds = w.bounds;
          // Window must be below the active window
          if (bounds.top < activeBounds.bottom) return false;
          
          // Calculate horizontal overlap
          const overlap = calculateOverlap(activeBounds, bounds, true);
          return overlap > 0; // Any overlap makes it a candidate
        });
        break;
        
      case 'left':
        // Windows that are to the left of the active window
        candidateWindows = otherWindows.filter(w => {
          const bounds = w.bounds;
          // Window must be to the left of the active window
          if (bounds.right > activeBounds.left) return false;
          
          // Calculate vertical overlap
          const overlap = calculateOverlap(activeBounds, bounds, false);
          return overlap > 0; // Any overlap makes it a candidate
        });
        break;
        
      case 'right':
        // Windows that are to the right of the active window
        candidateWindows = otherWindows.filter(w => {
          const bounds = w.bounds;
          // Window must be to the right of the active window
          if (bounds.left < activeBounds.right) return false;
          
          // Calculate vertical overlap
          const overlap = calculateOverlap(activeBounds, bounds, false);
          return overlap > 0; // Any overlap makes it a candidate
        });
        break;
    }
    
    // If no candidates found, return
    if (candidateWindows.length === 0) return;
    
    // Calculate scores for each candidate window based on:
    // 1. Overlap percentage (higher is better)
    // 2. Distance from active window (lower is better)
    const scoredWindows = candidateWindows.map(window => {
      const bounds = window.bounds;
      let overlapScore = 0;
      let distanceScore = 0;
      
      switch (direction) {
        case 'up':
          overlapScore = calculateOverlap(activeBounds, bounds, true);
          distanceScore = activeBounds.top - bounds.bottom;
          break;
          
        case 'down':
          overlapScore = calculateOverlap(activeBounds, bounds, true);
          distanceScore = bounds.top - activeBounds.bottom;
          break;
          
        case 'left':
          overlapScore = calculateOverlap(activeBounds, bounds, false);
          distanceScore = activeBounds.left - bounds.right;
          break;
          
        case 'right':
          overlapScore = calculateOverlap(activeBounds, bounds, false);
          distanceScore = bounds.left - activeBounds.right;
          break;
      }
      
      // Normalize distance score (closer is better)
      const normalizedDistanceScore = 1 / (1 + distanceScore);
      
      // Calculate final score with higher weight on overlap
      const finalScore = (overlapScore * 0.7) + (normalizedDistanceScore * 0.3);
      
      return {
        window,
        overlapScore,
        distanceScore,
        finalScore
      };
    });
    
    // Sort by final score (higher is better)
    scoredWindows.sort((a, b) => b.finalScore - a.finalScore);
    
    // Select the window with the highest score
    const nextWindow = scoredWindows[0].window;
    
    if (nextWindow) {
      setActiveNodeId(nextWindow.id);
    }
  }, [activeNodeId, rootNode, setActiveNodeId]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (!e.ctrlKey) return;
  
      switch (e.key) {
        case 'ArrowLeft':
          e.preventDefault();
          navigateToWindow('left');
          break;
        case 'ArrowRight':
          e.preventDefault();
          navigateToWindow('right');
          break;
        case 'ArrowUp':
          e.preventDefault();
          navigateToWindow('up');
          break;
        case 'ArrowDown':
          e.preventDefault();
          navigateToWindow('down');
          break;
      }
    };
  
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [navigateToWindow]);

  // Get window state management functions
  const { getWindowState, setWindowState, removeWindowState } = useWindowState();

  // Helper function to convert percentage-based bounds to pixel dimensions
  const calculatePixelDimensions = useCallback((bounds) => {
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    
    const pixelDimensions = {
      width: (bounds.width / 100) * windowWidth,
      height: (bounds.height / 100) * windowHeight
    };
    
    console.log('Window dimensions (percentage):', bounds);
    console.log('Window dimensions (pixels):', pixelDimensions);
    console.log('Minimum required:', MIN_WINDOW_WIDTH_PX, 'x', MIN_WINDOW_HEIGHT_PX);
    console.log('Is too small:', 
      pixelDimensions.width < MIN_WINDOW_WIDTH_PX || 
      pixelDimensions.height < MIN_WINDOW_HEIGHT_PX
    );
    
    return pixelDimensions;
  }, []);

  // Helper function to check if a resize operation would result in windows that are too small
  const wouldViolateMinSize = useCallback((root, direction, affectedSplits, resizeStep) => {
    console.log('Checking if resize would violate minimum size...');
    console.log('Direction:', direction);
    console.log('Affected splits:', affectedSplits.length);
    console.log('Browser window size:', window.innerWidth, 'x', window.innerHeight);
    
    // Create a deep copy of the root to simulate the resize
    const simulatedRoot = JSON.parse(JSON.stringify(root));
    
    // Apply the resize to the simulated root
    affectedSplits.forEach(({ node: originalNode, targetInFirst, isRightSide, isBottomSide }) => {
      // Find the corresponding node in the simulated root
      const simulatedNode = findNodeById(simulatedRoot, originalNode.id);
      if (!simulatedNode) return;
      
      console.log('Simulating resize on node:', simulatedNode.id);
      console.log('Original split ratio:', simulatedNode.splitRatio);
      
      // Determine effective direction
      let effectiveDirection = direction;
      if (isRightSide && (direction === 'left' || direction === 'right')) {
        effectiveDirection = direction === 'left' ? 'right' : 'left';
      }
      if (isBottomSide && (direction === 'up' || direction === 'down')) {
        effectiveDirection = direction === 'up' ? 'down' : 'up';
      }
      
      console.log('Effective direction:', effectiveDirection);
      
      // Apply the resize
      switch (effectiveDirection) {
        case 'left': // Shrink width
          if (targetInFirst) {
            simulatedNode.splitRatio = Math.max(0.1, simulatedNode.splitRatio - resizeStep);
          } else {
            simulatedNode.splitRatio = Math.min(0.9, simulatedNode.splitRatio + resizeStep);
          }
          break;
          
        case 'right': // Grow width
          if (targetInFirst) {
            simulatedNode.splitRatio = Math.min(0.9, simulatedNode.splitRatio + resizeStep);
          } else {
            simulatedNode.splitRatio = Math.max(0.1, simulatedNode.splitRatio - resizeStep);
          }
          break;
          
        case 'up': // Shrink height
          if (targetInFirst) {
            simulatedNode.splitRatio = Math.max(0.1, simulatedNode.splitRatio - resizeStep);
          } else {
            simulatedNode.splitRatio = Math.min(0.9, simulatedNode.splitRatio + resizeStep);
          }
          break;
          
        case 'down': // Grow height
          if (targetInFirst) {
            simulatedNode.splitRatio = Math.min(0.9, simulatedNode.splitRatio + resizeStep);
          } else {
            simulatedNode.splitRatio = Math.max(0.1, simulatedNode.splitRatio - resizeStep);
          }
          break;
      }
      
      console.log('New split ratio:', simulatedNode.splitRatio);
    });
    
    // Calculate the bounds of all windows after the simulated resize
    const simulatedWindows = getWindowBounds(simulatedRoot);
    console.log('Number of windows to check:', simulatedWindows.length);
    
    // Check if any window would be smaller than the minimum size
    const tooSmallWindows = simulatedWindows.filter(window => {
      const pixelDimensions = calculatePixelDimensions(window.bounds);
      return pixelDimensions.width < MIN_WINDOW_WIDTH_PX || 
             pixelDimensions.height < MIN_WINDOW_HEIGHT_PX;
    });
    
    const wouldViolate = tooSmallWindows.length > 0;
    console.log('Windows that would be too small:', tooSmallWindows.length);
    console.log('Would violate minimum size:', wouldViolate);
    
    return wouldViolate;
  }, [calculatePixelDimensions]);

  // Define splitWindow before createNewWindow since createNewWindow depends on it
  const splitWindow = useCallback((nodeId, direction, newWindow = null) => {
    // Create a new terminal window if one wasn't provided
    if (!newWindow) {
      newWindow = Node.createWindow(Date.now(), WINDOW_TYPES.TERMINAL);
      
      // Initialize terminal state with default content
      const initialContent = {
        history: ['Welcome to the Terminal! Type "help" for available commands.'],
        commandHistory: []
      };
      
      // Set the initial window state for the terminal
      setWindowState(newWindow.id, WINDOW_TYPES.TERMINAL, initialContent);
      
      // Also update the workspace terminal states
      updateWorkspace(currentWorkspaceIndex, workspace => ({
        ...workspace,
        terminalStates: {
          ...workspace.terminalStates,
          [newWindow.id]: {
            history: initialContent.history,
            commandHistory: initialContent.commandHistory
          }
        }
      }));
    }
    
    // Check if splitting would result in windows that are too small
    const simulatedRoot = JSON.parse(JSON.stringify(rootNode));
    const simulatedSplitRoot = splitNodeById(simulatedRoot, nodeId, direction, JSON.parse(JSON.stringify(newWindow)));
    
    // Calculate the bounds of all windows after the simulated split
    const simulatedWindows = getWindowBounds(simulatedSplitRoot);
    console.log('Simulating split - number of windows:', simulatedWindows.length);
    
    // Check if any window would be smaller than the minimum size
    const tooSmallWindows = simulatedWindows.filter(window => {
      const pixelDimensions = calculatePixelDimensions(window.bounds);
      return pixelDimensions.width < MIN_WINDOW_WIDTH_PX || 
             pixelDimensions.height < MIN_WINDOW_HEIGHT_PX;
    });
    
    const wouldViolate = tooSmallWindows.length > 0;
    console.log('Split would create windows that are too small:', wouldViolate);
    
    if (wouldViolate) {
      console.log('Split blocked: would result in windows smaller than minimum size');
      // Flash the window being split to indicate we've hit the minimum size
      if (onFlashBorder && nodeId) {
        onFlashBorder(nodeId);
      }
      return;
    }
  
  // Update workspace with the new split and set the new window as active
  updateWorkspace(currentWorkspaceIndex, workspace => ({
    ...workspace,
    root: splitNodeById(workspace.root, nodeId, direction, newWindow),
    activeNodeId: newWindow.id // Automatically make the new window active
  }));
  }, [updateWorkspace, getWindowState, setWindowState, rootNode, calculatePixelDimensions, currentWorkspaceIndex]);

  const createNewWindow = useCallback((windowType) => {
    const newNode = Node.createWindow(Date.now(), windowType || WINDOW_TYPES.TERMINAL);
    
    // Initialize window state based on window type
    const initialContent = {};
    
    if (windowType === WINDOW_TYPES.TERMINAL) {
      // Initialize terminal state
      initialContent.history = ['Welcome to the Terminal! Type "help" for available commands.'];
      initialContent.commandHistory = [];
      
      updateWorkspace(currentWorkspaceIndex, workspace => ({
        ...workspace,
        terminalStates: {
          ...workspace.terminalStates,
          [newNode.id]: {
            history: initialContent.history,
            commandHistory: initialContent.commandHistory
          }
        }
      }));
    } else if (windowType === WINDOW_TYPES.EDITOR) {
      // Initialize editor state with default content
      initialContent.text = `function hello() {\n  console.log("Hello, World!");\n}\n\n// Call the function\nhello();`;
    } else if (windowType === WINDOW_TYPES.EXPLORER) {
      // Initialize explorer state
      initialContent.currentPath = '/';
      initialContent.selectedItem = null;
    }
    
    // Set the initial window state
    setWindowState(newNode.id, newNode.windowType, initialContent);
    
    if (!rootNode) {
      // First window, always allowed
      updateWorkspace(currentWorkspaceIndex, {
        root: newNode,
        activeNodeId: newNode.id
      });
      return;
    }
    
    if (!activeNodeId) {
      // No active window, but we have a root - this is unusual
      // Let's check if we can add a window without violating minimum size
      const simulatedRoot = JSON.parse(JSON.stringify(rootNode));
      const simulatedWindows = getWindowBounds(simulatedRoot);
      
      // Check if existing windows are already too small
      const tooSmallWindows = simulatedWindows.filter(window => {
        const pixelDimensions = calculatePixelDimensions(window.bounds);
        return pixelDimensions.width < MIN_WINDOW_WIDTH_PX || 
               pixelDimensions.height < MIN_WINDOW_HEIGHT_PX;
      });
      
      if (tooSmallWindows.length > 0) {
        console.log('Cannot create new window: existing windows are already too small');
        // Flash the window that would be affected
        if (onFlashBorder && rootNode) {
          // If there's no active window but there's a root node, flash the root node
          const nodeToFlash = rootNode.type === 'window' ? rootNode.id : null;
          if (nodeToFlash) {
            onFlashBorder(nodeToFlash);
          }
        }
        return;
      }
      
      updateWorkspace(currentWorkspaceIndex, {
        root: newNode,
        activeNodeId: newNode.id
      });
      return;
    }
    
    // Use splitWindow which already has minimum size checks and now automatically sets the new window as active
    splitWindow(activeNodeId, 'vertical', newNode);
    // setActiveNodeId call is removed as splitWindow now handles this automatically
  }, [rootNode, activeNodeId, updateWorkspace, setActiveNodeId, setWindowState, calculatePixelDimensions, splitWindow, currentWorkspaceIndex]);

  const closeWindow = useCallback((nodeId) => {
    // Clean up window state when closing a window
    removeWindowState(nodeId);
    
    // Special case: If closing the only window in the workspace
    if (rootNode.type === 'window' && rootNode.id === nodeId) {
      updateWorkspace(currentWorkspaceIndex, {
        root: null,
        activeNodeId: null
      });
      return;
    }

    // Before removing the node, try to find its sibling for activating it later
    const siblingWindowId = findSiblingWindowId(rootNode, nodeId);
    console.log(`Found sibling window ID for ${nodeId}: ${siblingWindowId}`);
    
    const newRoot = JSON.parse(JSON.stringify(rootNode));
    const result = removeNodeById(newRoot, nodeId);
    
    if (activeNodeId === nodeId && result) {
      // If the closed window was active, activate its sibling if possible
      // Otherwise fall back to the first window in the tree
      const nextWindowId = siblingWindowId || findAllWindowIds(result)[0] || null;
      updateWorkspace(currentWorkspaceIndex, {
        root: result,
        activeNodeId: nextWindowId
      });
    } else {
      updateWorkspace(currentWorkspaceIndex, {
        root: result
      });
    }
  }, [rootNode, activeNodeId, updateWorkspace, removeWindowState, currentWorkspaceIndex]);

  const transformWindow = useCallback((nodeId, newType) => {
    const newRoot = JSON.parse(JSON.stringify(rootNode));
    
    // Get the current window state before transformation
    const currentWindowState = getWindowState(nodeId);
    
    const updateNodeInTree = (node) => {
      if (!node) return null;
      
      if (node.type === 'window' && node.id === nodeId) {
        // Update the window type
        node.windowType = newType;
        
        // Update the window state with the new type but preserve content
        if (currentWindowState) {
          // If transforming to a terminal window, clear the currentInput field
          if (newType === WINDOW_TYPES.TERMINAL) {
            const updatedContent = { 
              ...currentWindowState.content,
              currentInput: '' // Clear the input field
            };
            setWindowState(nodeId, newType, updatedContent);
          } else {
            setWindowState(nodeId, newType, currentWindowState.content);
          }
        }
        
        return true;
      }
      
      if (node.type === 'split') {
        return updateNodeInTree(node.first) || updateNodeInTree(node.second);
      }
      
      return false;
    };
    
    const updated = updateNodeInTree(newRoot);
    if (updated) {
      updateWorkspace(currentWorkspaceIndex, {
        root: newRoot
      });
    }
  }, [rootNode, updateWorkspace, getWindowState, setWindowState, currentWorkspaceIndex]);

  const handleCommand = useCallback((command) => {
    const parts = command.split(' ');
    const cmd = parts[0].toLowerCase();

    switch (cmd) {
      case 'split':
        if (activeNodeId) {
          const direction = parts[1] === 'vertical' ? 'vertical' : 'horizontal';
          // splitWindow automatically makes the new window active
          splitWindow(activeNodeId, direction);
        }
        break;
      case 'close':
        if (activeNodeId) {
          closeWindow(activeNodeId);
        }
        break;
    }
  }, [activeNodeId, splitWindow, closeWindow, currentWorkspaceIndex]);

  const resizeActiveWindow = useCallback((direction) => {
    if (!activeNodeId || !rootNode || !isResizeMode) return;
  
    updateWorkspace(currentWorkspaceIndex, workspace => {
      const newRoot = JSON.parse(JSON.stringify(workspace.root));
      
      // Helper function to find all affected splits and determine if window is in second child
      const findAffectedSplits = (node, targetId) => {
        if (!node) return [];
        
        const splits = [];
        if (node.type === 'split') {
          const targetInFirst = findNodeById(node.first, targetId);
          const targetInSecond = findNodeById(node.second, targetId);
          
          if (targetInFirst || targetInSecond) {
            // Add this split if it matches our resize direction
            if ((direction === 'left' || direction === 'right') && node.direction === 'horizontal') {
              splits.push({ 
                node, 
                targetInFirst: !!targetInFirst,
                // If this is a horizontal split and window is in second child, it's on the right side
                isRightSide: !!targetInSecond && node.direction === 'horizontal'
              });
            }
            if ((direction === 'up' || direction === 'down') && node.direction === 'vertical') {
              splits.push({ 
                node, 
                targetInFirst: !!targetInFirst,
                isRightSide: !!targetInSecond && node.direction === 'horizontal',
                isBottomSide: !!targetInSecond && node.direction === 'vertical'
              });
            }
          }
          
          splits.push(...findAffectedSplits(node.first, targetId));
          splits.push(...findAffectedSplits(node.second, targetId));
        }
        
        return splits;
      };
  
      const affectedSplits = findAffectedSplits(newRoot, activeNodeId);
      const resizeStep = 0.05;
      
      // We no longer block resize operations based on minimum size
      // Just log that windows will be below minimum size
      const willViolateMinSize = wouldViolateMinSize(newRoot, direction, affectedSplits, resizeStep);
      if (willViolateMinSize) {
        console.log('Windows will be below minimum size, but resize is allowed');
      }
  
      // Apply resize to all affected splits
      affectedSplits.forEach(({ node, targetInFirst, isRightSide, isBottomSide }) => {
        // Determine if we need to invert the direction based on window position
        let effectiveDirection = direction;
        if (isRightSide && (direction === 'left' || direction === 'right')) {
          effectiveDirection = direction === 'left' ? 'right' : 'left';
        }
        if (isBottomSide && (direction === 'up' || direction === 'down')) {
          effectiveDirection = direction === 'up' ? 'down' : 'up';
        }
        
        switch (effectiveDirection) {
          case 'left': // Shrink width
            if (targetInFirst) {
              node.splitRatio = Math.max(0.1, node.splitRatio - resizeStep);
            } else {
              node.splitRatio = Math.min(0.9, node.splitRatio + resizeStep);
            }
            break;
            
          case 'right': // Grow width
            if (targetInFirst) {
              node.splitRatio = Math.min(0.9, node.splitRatio + resizeStep);
            } else {
              node.splitRatio = Math.max(0.1, node.splitRatio - resizeStep);
            }
            break;
            
          case 'up': // Shrink height
            if (targetInFirst) {
              node.splitRatio = Math.max(0.1, node.splitRatio - resizeStep);
            } else {
              node.splitRatio = Math.min(0.9, node.splitRatio + resizeStep);
            }
            break;
            
          case 'down': // Grow height
            if (targetInFirst) {
              node.splitRatio = Math.min(0.9, node.splitRatio + resizeStep);
            } else {
              node.splitRatio = Math.max(0.1, node.splitRatio - resizeStep);
            }
            break;
        }
      });
  
      return { ...workspace, root: newRoot };
    });
  }, [activeNodeId, rootNode, isResizeMode, updateWorkspace, wouldViolateMinSize, currentWorkspaceIndex]);
  
  // Function to swap two windows in the tree
  const swapWindows = useCallback(async (sourceId, targetId) => {
    if (!sourceId || !targetId || sourceId === targetId) return;

    console.log('Swapping windows:', sourceId, targetId);

    // First, get the window types and existing IndexedDB states before we modify anything
    const sourceNode = findNodeById(rootNode, sourceId);
    const targetNode = findNodeById(rootNode, targetId);
    
    if (!sourceNode || !targetNode) {
      console.log('Could not find one or both nodes to swap');
      return;
    }
    
    const sourceWindowType = sourceNode.windowType;
    const targetWindowType = targetNode.windowType;
    
    // Create a map to store window states that will be preserved across swaps
    const stateMap = {};
    
    // Handle sessionStorage and localStorage swapping for chat windows
    if (sourceWindowType === WINDOW_TYPES.CHAT || targetWindowType === WINDOW_TYPES.CHAT) {
      console.log('Swapping chat window sessionStorage and localStorage entries');
      
      // Swap active room selections in sessionStorage
      const sourceActiveRoom = sessionStorage.getItem(`chat_active_room_${sourceId}`);
      const targetActiveRoom = sessionStorage.getItem(`chat_active_room_${targetId}`);
      
      console.log('Chat active rooms before swap:', { sourceActiveRoom, targetActiveRoom });
      
      if (sourceActiveRoom && targetWindowType === WINDOW_TYPES.CHAT) {
        sessionStorage.setItem(`chat_active_room_${targetId}`, sourceActiveRoom);
      }
      
      if (targetActiveRoom && sourceWindowType === WINDOW_TYPES.CHAT) {
        sessionStorage.setItem(`chat_active_room_${sourceId}`, targetActiveRoom);
      }
      
      // Get a list of all localStorage keys that might contain draft messages
      const allKeys = [];
      for (let i = 0; i < localStorage.length; i++) {
        allKeys.push(localStorage.key(i));
      }
      
      // Filter keys related to each window
      const sourceKeys = allKeys.filter(key => key.startsWith(`chat_draft_${sourceId}_`));
      const targetKeys = allKeys.filter(key => key.startsWith(`chat_draft_${targetId}_`));
      
      console.log('Draft message keys before swap:', { sourceKeys, targetKeys });
      
      // Swap draft messages in localStorage
      if (targetWindowType === WINDOW_TYPES.CHAT) {
        sourceKeys.forEach(key => {
          const value = localStorage.getItem(key);
          const roomId = key.split('_')[3]; // Extract room ID from key format "chat_draft_nodeId_roomId"
          localStorage.setItem(`chat_draft_${targetId}_${roomId}`, value);
        });
      }
      
      if (sourceWindowType === WINDOW_TYPES.CHAT) {
        targetKeys.forEach(key => {
          const value = localStorage.getItem(key);
          const roomId = key.split('_')[3]; // Extract room ID from key format "chat_draft_nodeId_roomId"
          localStorage.setItem(`chat_draft_${sourceId}_${roomId}`, value);
        });
      }
      
      console.log('Successfully swapped chat window storage entries');
    }
    
    // Wait for IndexedDB operations to complete before continuing
    try {
      console.log('Starting IndexedDB state swap, waiting for completion...');
      
      // Import necessary functions to handle specific window types
      const { 
        getExplorerState, saveExplorerState,
        getTerminalState, saveTerminalState,
        getChatState, saveChatState,
        getCanvasState, saveCanvasState,
        getWindowState, saveWindowState,
        deleteExplorerState, deleteWindowState
      } = await import('../services/indexedDBService');
      
      console.log('Swapping IndexedDB states for window types:', sourceWindowType, targetWindowType);
      
      // Get current states from IndexedDB and store in our state map
      // This ensures we don't lose state during the swap process
      
      // Get Explorer states if applicable
      if (sourceWindowType === WINDOW_TYPES.EXPLORER) {
        const state = await getExplorerState(sourceId);
        if (state && state.content) {
          stateMap[`explorer_${sourceId}`] = state.content;
          console.log('Saved source explorer state:', state.content);
        }
      }
      
      if (targetWindowType === WINDOW_TYPES.EXPLORER) {
        const state = await getExplorerState(targetId);
        if (state && state.content) {
          stateMap[`explorer_${targetId}`] = state.content;
          console.log('Saved target explorer state:', state.content);
        }
      }
      
      // Get Terminal states if applicable
      if (sourceWindowType === WINDOW_TYPES.TERMINAL) {
        const state = await getTerminalState(sourceId);
        if (state && state.content) {
          stateMap[`terminal_${sourceId}`] = state.content;
          console.log('Saved source terminal state:', state.content);
        }
      }
      
      if (targetWindowType === WINDOW_TYPES.TERMINAL) {
        const state = await getTerminalState(targetId);
        if (state && state.content) {
          stateMap[`terminal_${targetId}`] = state.content;
          console.log('Saved target terminal state:', state.content);
        }
      }
      
      // Get Chat states if applicable
      if (sourceWindowType === WINDOW_TYPES.CHAT) {
        const state = await getChatState(sourceId);
        if (state && state.content) {
          stateMap[`chat_${sourceId}`] = state.content;
          console.log('Saved source chat state:', state.content);
        }
      }
      
      if (targetWindowType === WINDOW_TYPES.CHAT) {
        const state = await getChatState(targetId);
        if (state && state.content) {
          stateMap[`chat_${targetId}`] = state.content;
          console.log('Saved target chat state:', state.content);
        }
      }
      
      // Get Canvas states if applicable
      if (sourceWindowType === WINDOW_TYPES.CANVAS) {
        const state = await getCanvasState(sourceId);
        if (state && state.content) {
          stateMap[`canvas_${sourceId}`] = state.content;
          console.log('Saved source canvas state:', state.content);
        }
      }
      
      if (targetWindowType === WINDOW_TYPES.CANVAS) {
        const state = await getCanvasState(targetId);
        if (state && state.content) {
          stateMap[`canvas_${targetId}`] = state.content;
          console.log('Saved target canvas state:', state.content);
        }
      }
      
      // Get generic window states
      const sourceGenericState = await getWindowState(sourceId);
      if (sourceGenericState && sourceGenericState.content) {
        stateMap[`generic_${sourceId}`] = sourceGenericState.content;
        console.log('Saved source generic state:', sourceGenericState.content);
      }
      
      const targetGenericState = await getWindowState(targetId);
      if (targetGenericState && targetGenericState.content) {
        stateMap[`generic_${targetId}`] = targetGenericState.content;
        console.log('Saved target generic state:', targetGenericState.content);
      }
      
      // We now have all states backed up in our stateMap
      // Next, we'll remove existing states to prepare for swapping
      
      // Remove explorer states
      if (sourceWindowType === WINDOW_TYPES.EXPLORER) {
        await deleteExplorerState(sourceId);
      }
      if (targetWindowType === WINDOW_TYPES.EXPLORER) {
        await deleteExplorerState(targetId);
      }
      
      // Remove generic states
      await deleteWindowState(sourceId);
      await deleteWindowState(targetId);
      
      // Now we'll write back the swapped states
      
      // Swap Explorer states
      if (sourceWindowType === WINDOW_TYPES.EXPLORER && stateMap[`explorer_${sourceId}`]) {
        await saveExplorerState({
          id: targetId,
          content: stateMap[`explorer_${sourceId}`]
        });
        console.log('Saved source explorer state to target');
      }
      
      if (targetWindowType === WINDOW_TYPES.EXPLORER && stateMap[`explorer_${targetId}`]) {
        await saveExplorerState({
          id: sourceId,
          content: stateMap[`explorer_${targetId}`]
        });
        console.log('Saved target explorer state to source');
      }
      
      // Swap Terminal states
      if (sourceWindowType === WINDOW_TYPES.TERMINAL && stateMap[`terminal_${sourceId}`]) {
        await saveTerminalState({
          id: targetId,
          content: stateMap[`terminal_${sourceId}`]
        });
        console.log('Saved source terminal state to target');
      }
      
      if (targetWindowType === WINDOW_TYPES.TERMINAL && stateMap[`terminal_${targetId}`]) {
        await saveTerminalState({
          id: sourceId,
          content: stateMap[`terminal_${targetId}`]
        });
        console.log('Saved target terminal state to source');
      }
      
      // Swap Chat states
      if (sourceWindowType === WINDOW_TYPES.CHAT && stateMap[`chat_${sourceId}`]) {
        await saveChatState({
          id: targetId,
          content: stateMap[`chat_${sourceId}`]
        });
        console.log('Saved source chat state to target');
      }
      
      if (targetWindowType === WINDOW_TYPES.CHAT && stateMap[`chat_${targetId}`]) {
        await saveChatState({
          id: sourceId,
          content: stateMap[`chat_${targetId}`]
        });
        console.log('Saved target chat state to source');
      }
      
      // Swap Canvas states
      if (sourceWindowType === WINDOW_TYPES.CANVAS && stateMap[`canvas_${sourceId}`]) {
        await saveCanvasState({
          id: targetId,
          content: stateMap[`canvas_${sourceId}`]
        });
        console.log('Saved source canvas state to target');
      }
      
      if (targetWindowType === WINDOW_TYPES.CANVAS && stateMap[`canvas_${targetId}`]) {
        await saveCanvasState({
          id: sourceId,
          content: stateMap[`canvas_${targetId}`]
        });
        console.log('Saved target canvas state to source');
      }
      
      // Swap generic window states
      if (stateMap[`generic_${sourceId}`]) {
        await saveWindowState({
          id: targetId,
          type: sourceWindowType,
          content: stateMap[`generic_${sourceId}`]
        });
        console.log('Saved source generic state to target');
      }
      
      if (stateMap[`generic_${targetId}`]) {
        await saveWindowState({
          id: sourceId,
          type: targetWindowType,
          content: stateMap[`generic_${targetId}`]
        });
        console.log('Saved target generic state to source');
      }
      
      console.log('Successfully swapped all IndexedDB states');
    } catch (error) {
      console.error('Error swapping IndexedDB states:', error);
    }

    // Update the in-memory workspace state
    updateWorkspace(currentWorkspaceIndex, workspace => {
      const newRoot = JSON.parse(JSON.stringify(workspace.root));
      
      // Find the nodes to swap again in the new root
      const sourceNode = findNodeById(newRoot, sourceId);
      const targetNode = findNodeById(newRoot, targetId);
      
      if (!sourceNode || !targetNode) {
        console.log('Could not find one or both nodes to swap in new root');
        return workspace;
      }
      
      // Swap the window types and states
      const tempWindowType = sourceNode.windowType;
      const tempState = sourceNode.state;
      
      sourceNode.windowType = targetNode.windowType;
      sourceNode.state = targetNode.state;
      
      targetNode.windowType = tempWindowType;
      targetNode.state = tempState;
      
      return { ...workspace, root: newRoot };
    });
    
    // Exit move mode after swapping
    setIsMoveMode(false);
    setMoveSourceWindowId(null);
    
    // Add small delay to ensure state changes propagate correctly
    await new Promise(resolve => setTimeout(resolve, 100));
    
    console.log('Window swap complete');
  }, [updateWorkspace, currentWorkspaceIndex, rootNode]);

  // Add direct keyboard event listener for move mode
  useEffect(() => {
    const handleMoveKeyDown = (e) => {
      // Handle move mode toggle
      if (e.ctrlKey && e.key === 'm') {
        e.preventDefault();
        e.stopPropagation(); // Stop event propagation to prevent multiple handlers
        console.log('Move mode toggle pressed directly in useWindowManager');
        console.log('Current isMoveMode:', isMoveMode);
        
        // Toggle move mode
        setIsMoveMode(!isMoveMode);
        
        // Reset source window when toggling off
        if (isMoveMode) {
          setMoveSourceWindowId(null);
        }
      }
      
      // Handle move mode Enter key
      if (isMoveMode && e.key === 'Enter') {
        e.preventDefault();
        e.stopPropagation();
        console.log('Enter key pressed in move mode');
        
        if (!moveSourceWindowId) {
          // First window selection
          console.log('Selected first window for move:', activeNodeId);
          setMoveSourceWindowId(activeNodeId);
        } else {
          // Second window selection - perform the swap
          console.log('Selected second window for move:', activeNodeId);
          swapWindows(moveSourceWindowId, activeNodeId);
        }
      }
    };
    
    // Add the event listener with capture: true to ensure it runs before other listeners
    window.addEventListener('keydown', handleMoveKeyDown, { capture: true });
    return () => window.removeEventListener('keydown', handleMoveKeyDown, { capture: true });
  }, [isMoveMode, moveSourceWindowId, activeNodeId, setIsMoveMode, setMoveSourceWindowId, swapWindows]);

  // Debug checks for modes
  useEffect(() => {
    console.log('Resize mode:', isResizeMode);
  }, [isResizeMode]);

  useEffect(() => {
    console.log('Move mode:', isMoveMode);
    if (!isMoveMode) {
      setMoveSourceWindowId(null);
    }
  }, [isMoveMode]);

  // Function to update terminal state
  const updateTerminalState = useCallback((terminalId, newState) => {
    updateWorkspace(currentWorkspaceIndex, workspace => ({
      ...workspace,
      terminalStates: {
        ...workspace.terminalStates,
        [terminalId]: newState
      }
    }));
  }, [updateWorkspace, currentWorkspaceIndex]);

  return {
    rootNode,
    activeNodeId,
    setActiveNodeId,
    terminalStates,
    updateTerminalState,
    createNewWindow,
    splitWindow,
    closeWindow,
    transformWindow,
    handleCommand,
    navigateToWindow,
    hasActiveWindow: Boolean(activeNodeId),
    hasRootNode: Boolean(rootNode),
    currentWorkspaceIndex,
    workspaceCount: 4,
    switchWorkspace,
    isResizeMode,
    setIsResizeMode,
    resizeActiveWindow,
    isMoveMode,
    setIsMoveMode,
    moveSourceWindowId,
    setMoveSourceWindowId,
    swapWindows
  };
};

================
File: src/index.html
================
// index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oxygen+Mono&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SLUMTERM</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

================
File: src/main.jsx
================
// Import polyfill for simple-peer library
import './utils/globalPolyfill.js'

// Import the cache manager utility
import cacheManager from './utils/cacheManager.js'

import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './styles.css'
import './App.css'
import { WindowStateProvider } from './context/WindowStateContext'
import { WorkspaceProvider } from './context/WorkspaceContext'
import { AuthProvider, AuthProviderWithWindowState } from './context/AuthContext'
import { AnnouncementProvider } from './context/AnnouncementContext'
import PartyProvider from './context/PartyContext'
import DebugLogger from './utils/debugLogger'

// Initialize debug logger (disables logs by default)
DebugLogger.init();

// Check for application updates and clear cache if needed
const cacheCleared = cacheManager.checkAndUpdateVersion();
if (cacheCleared) {
  console.log('Cache cleared due to application update');
  // We don't force reload here to avoid infinite reload loops
  // The new version will be used naturally
}

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <AuthProvider>
      <WindowStateProvider>
        <WorkspaceProvider>
          <AuthProviderWithWindowState>
            <AnnouncementProvider>
              <PartyProvider>
                <App />
              </PartyProvider>
            </AnnouncementProvider>
          </AuthProviderWithWindowState>
        </WorkspaceProvider>
      </WindowStateProvider>
    </AuthProvider>
  </React.StrictMode>,
)

================
File: src/models/Node.js
================
/**
 * Node class representing a window or split in the window management system.
 * Forms the foundation of our tree-based window layout structure.
 */
export class Node {
  constructor(id, type) {
    this.id = id;
    this.type = type;
    this.windowType = null;
    this.direction = null;
    this.first = null;
    this.second = null;
    this.splitRatio = 0.5;
    this.minimumSize = 20;
    this.state = null;
  }

  static createWindow(id, windowType, state = null) {
    const node = new Node(id, 'window');
    node.windowType = windowType;
    node.state = state;
    return node;
  }

  static createSplit(direction, first, second, ratio = 0.5) {
    const node = new Node(Date.now(), 'split');
    node.direction = direction;
    node.first = first;
    node.second = second;
    node.splitRatio = ratio;
    return node;
  }
}

================
File: src/repomix-output.txt
================
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
App.css
App.jsx
assets/react.svg
assets/SVG/emptyState.svg
components/auth/AuthScreen.jsx
components/auth/index.js
components/auth/Login.jsx
components/auth/Register.jsx
components/CommandBar.jsx
components/EmptyState.jsx
components/WindowManager.jsx
components/windows/AdminWindow.jsx
components/windows/AudioWindow.jsx
components/windows/ChatWindow.jsx
components/windows/EditorWindow.jsx
components/windows/ExplorerWindow.css
components/windows/ExplorerWindow.jsx
components/windows/index.js
components/windows/TerminalWindow.jsx
config/api.js
context/AnnouncementContext.jsx
context/AuthContext.jsx
context/WindowStateContext.jsx
context/WorkspaceContext.jsx
db/db-config.js
db/db-operations.js
db/db.js
hocs/withCommandHandling.jsx
hocs/withCommandInput.jsx
hocs/withWindowState.jsx
hooks/swapWindows.js
hooks/useForceUpdate.js
hooks/useKeyboardShortcuts.js
hooks/useWindowManager.js
hooks/useWindowManagerCompletion.js
index.html
main.jsx
models/Node.js
services/indexedDBService.js
styles.css
styles/main.css
utils/constants.js
utils/globalPolyfill.js
utils/treeUtils.js
utils/windowSizeConstants.js
utils/windowTypes.js
utils/windowUtils.js

================================================================
Files
================================================================

================
File: App.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

#root {
  width: 100%;
  height: 100%;
}

================
File: App.jsx
================
import React, { useState, useCallback } from 'react';
import { WindowManager } from './components/WindowManager';
import { CommandBar } from './components/CommandBar';
import { EmptyState } from './components/EmptyState';
import { AuthScreen } from './components/auth';
import { useWindowManager } from './hooks/useWindowManager';
import { useKeyboardShortcuts } from './hooks/useKeyboardShortcuts';
import { useAuth } from './context/AuthContext';
import { WINDOW_CONTENT, WINDOW_TYPES } from './utils/windowTypes';

/**
 * Main application component that composes our window management system.
 * This component is intentionally kept simple, delegating most functionality
 * to specialized components and hooks.
 */
function App() {
  const { isAuthenticated, loading, user, logout } = useAuth();
  
  // State for tracking which windows are currently flashing
  const [flashingWindowIds, setFlashingWindowIds] = useState(new Set());
  
  // Function to flash a window's border red
  const flashWindowBorder = useCallback((windowId) => {
    setFlashingWindowIds(prev => {
      const newSet = new Set(prev);
      newSet.add(windowId);
      return newSet;
    });
    
    // Remove the window from flashing state after 500ms
    setTimeout(() => {
      setFlashingWindowIds(prev => {
        const newSet = new Set(prev);
        newSet.delete(windowId);
        return newSet;
      });
    }, 200);
  }, []);
  
  // Call all hooks at the top level, before any conditional returns
  const {
    rootNode,
    activeNodeId,
    setActiveNodeId,
    createNewWindow,
    splitWindow,
    closeWindow,
    transformWindow,
    handleCommand,
    handleResizeStart,
    handleResizeMove,
    handleResizeEnd,
    hasActiveWindow,
    hasRootNode,
    currentWorkspaceIndex,
    switchWorkspace,
    isResizeMode,
    isMoveMode,
    setIsResizeMode,
    resizeActiveWindow,
    moveSourceWindowId
  } = useWindowManager({
    onFlashBorder: flashWindowBorder
  });

  // Set up keyboard shortcuts - always call this hook, even if we'll return early
  // But don't include move mode props to avoid conflicts with WindowManager
  useKeyboardShortcuts({
    onSplitVertical: () => splitWindow(activeNodeId, 'vertical'),
    onSplitHorizontal: () => splitWindow(activeNodeId, 'horizontal'),
    onClose: () => closeWindow(activeNodeId),
    createNewWindow,
    hasActiveWindow,
    hasRootNode,
    isResizeMode,
    isMoveMode,
    setIsResizeMode,
    resizeActiveWindow,
    activeNodeId
  });
  
  // If authentication is still loading, show a loading screen
  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-stone-900">
        <div className="text-teal-500 text-2xl font-mono">Loading...</div>
      </div>
    );
  }
  
  // If not authenticated, show the auth screen
  if (!isAuthenticated) {
    return <AuthScreen />;
  }

  // Define component to render based on whether we have a root node
  const renderContent = () => {
    if (!rootNode) {
      return <EmptyState />;
    }

    // Render the window tree with all necessary props
    return (
      <WindowTreeRenderer
        node={rootNode}
        activeNodeId={activeNodeId}
        setActiveNodeId={setActiveNodeId}
        transformWindow={transformWindow}
        onResizeStart={handleResizeStart}
        onResizeMove={handleResizeMove}
        onResizeEnd={handleResizeEnd}
        isResizeMode={isResizeMode} // Pass isResizeMode to WindowTreeRenderer
        isMoveMode={isMoveMode}
        moveSourceWindowId={moveSourceWindowId} // Pass moveSourceWindowId to WindowTreeRenderer
        flashingWindowIds={flashingWindowIds} // Pass flashingWindowIds to WindowTreeRenderer
      />
    );
  };

  return (
    <div className="w-full h-screen flex flex-col">
      {/* Global command bar with user info */}
      <CommandBar 
        onCommand={handleCommand}
        currentWorkspaceIndex={currentWorkspaceIndex}
        switchWorkspace={switchWorkspace}
        user={user}
        onLogout={logout}
      />
      
      {/* Main content area */}
      <div className="flex-1 relative">
        {renderContent()}
      </div>
    </div>
  );
}

/**
 * Renders the window tree recursively. This component is kept within App.jsx
 * since it's tightly coupled with the WindowManager's functionality.
 */
const WindowTreeRenderer = ({
  node,
  depth = 0,
  available = { x: 0, y: 0, width: 100, height: 100 },
  activeNodeId,
  setActiveNodeId,
  transformWindow,
  onResizeStart,
  onResizeMove,
  onResizeEnd,
  isResizeMode, // Add isResizeMode prop
  isMoveMode,
  moveSourceWindowId,
  flashingWindowIds
}) => {
  if (node.type === 'window') {
    const windowContent = WINDOW_CONTENT[node.windowType];
    
    // Check if window content exists (window type might have been removed)
    if (!windowContent) {
      console.warn(`Window type "${node.windowType}" is no longer supported`);
      return (
        <div
          className="absolute overflow-hidden border-2 border-red-500"
          style={{
            left: `${available.x}%`,
            top: `${available.y}%`,
            width: `${available.width}%`,
            height: `${available.height}%`,
          }}
          onClick={() => setActiveNodeId(node.id)}
        >
          <div className="flex h-full items-center justify-center bg-stone-800 text-red-400 p-4 text-center">
            <div>
              <p className="font-bold mb-2">Unsupported Window Type</p>
              <p className="text-sm">Window type "{node.windowType}" is no longer available</p>
              <button 
                className="mt-4 px-3 py-1 bg-stone-700 hover:bg-stone-600 rounded text-xs text-teal-400"
                onClick={(e) => {
                  e.stopPropagation();
                  // Convert to terminal window
                  transformWindow(node.id, WINDOW_TYPES.TERMINAL);
                }}
              >
                Convert to Terminal
              </button>
            </div>
          </div>
        </div>
      );
    }
    
    const Component = windowContent.component;
    const isActive = node.id === activeNodeId;
    // Check if this is the first selected window in move mode
    const isFirstSelectedWindow = isMoveMode && moveSourceWindowId === node.id;
    // Check if this window is currently flashing
    const isFlashing = flashingWindowIds.has(node.id);

    return (
      <div
        className={`absolute overflow-hidden border-2 ${
          isFlashing ? 'border-red-600' : 
          isFirstSelectedWindow 
            ? 'border-blue-300' 
            : isActive 
              ? isResizeMode 
                ? 'border-yellow-500'
                : isMoveMode
                  ? 'border-blue-500'
                  : 'border-teal-500'
              : 'border-stone-600'
        } $`}
        style={{
          left: `${available.x}%`,
          top: `${available.y}%`,
          width: `${available.width}%`,
          height: `${available.height}%`,
        }}
        onClick={() => setActiveNodeId(node.id)}
      >
        <Component
          key={`window-${node.id}-${node.windowType}`}
          isActive={isActive}
          nodeId={node.id}
          transformWindow={transformWindow}
        />
      </div>
    );
  }

  // Handle split nodes...
  let firstDimensions, secondDimensions;
  if (node.direction === 'horizontal') {
    firstDimensions = {
      x: available.x,
      y: available.y,
      width: available.width * node.splitRatio,
      height: available.height
    };
    secondDimensions = {
      x: available.x + (available.width * node.splitRatio),
      y: available.y,
      width: available.width * (1 - node.splitRatio),
      height: available.height
    };
  } else {
    firstDimensions = {
      x: available.x,
      y: available.y,
      width: available.width,
      height: available.height * node.splitRatio
    };
    secondDimensions = {
      x: available.x,
      y: available.y + (available.height * node.splitRatio),
      width: available.width,
      height: available.height * (1 - node.splitRatio)
    };
  }

  return (
    <>
      <WindowTreeRenderer
        node={node.first}
        depth={depth + 1}
        available={firstDimensions}
        activeNodeId={activeNodeId}
        setActiveNodeId={setActiveNodeId}
        transformWindow={transformWindow}
        onResizeStart={onResizeStart}
        onResizeMove={onResizeMove}
        onResizeEnd={onResizeEnd}
        isResizeMode={isResizeMode} // Pass down isResizeMode
        isMoveMode={isMoveMode} // Pass down isMoveMode
        moveSourceWindowId={moveSourceWindowId} // Pass down moveSourceWindowId
        flashingWindowIds={flashingWindowIds} // Pass down flashingWindowIds
      />
      
      <div
        className={`absolute z-10 ${
          node.direction === 'horizontal' 
            ? 'w-1 cursor-col-resize hover:bg-teal-500' 
            : 'h-1 cursor-row-resize hover:bg-teal-500'
        }`}
        style={{
          left: node.direction === 'horizontal' ? `${available.x + (available.width * node.splitRatio)}%` : `${available.x}%`,
          top: node.direction === 'horizontal' ? `${available.y}%` : `${available.y + (available.height * node.splitRatio)}%`,
          height: node.direction === 'horizontal' ? `${available.height}%` : '2px',
          width: node.direction === 'horizontal' ? '2px' : `${available.width}%`,
        }}
        onMouseDown={(e) => onResizeStart(e, node)}
      />
      
      <WindowTreeRenderer
        node={node.second}
        depth={depth + 1}
        available={secondDimensions}
        activeNodeId={activeNodeId}
        setActiveNodeId={setActiveNodeId}
        transformWindow={transformWindow}
        onResizeStart={onResizeStart}
        onResizeMove={onResizeMove}
        onResizeEnd={onResizeEnd}
        isResizeMode={isResizeMode} // Pass down isResizeMode
        isMoveMode={isMoveMode} // Pass down isMoveMode
        moveSourceWindowId={moveSourceWindowId} // Pass down moveSourceWindowId
        flashingWindowIds={flashingWindowIds} // Pass down flashingWindowIds
      />
    </>
  );
};

export default App;

================
File: assets/react.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================
File: assets/SVG/emptyState.svg
================
<?xml version="1.0" encoding="UTF-8"?>
<svg id="Layer_2" data-name="Layer 2" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1781 1145.9">
  <defs>
    <style>
      .cls-1, .cls-2 {
        fill: none;
        stroke: #48c0b2;
        stroke-miterlimit: 10;
      }

      .cls-2 {
        stroke-width: 3px;
      }

      .cls-3 {
        clip-path: url(#clippath);
      }
    </style>
    <clipPath id="clippath">
      <polyline class="cls-1" points="270.6 1145.4 .5 1145.4 .5 .5 1780.5 .5 1780.5 1145.4 270.6 1145.4"/>
    </clipPath>
  </defs>
  <g id="Layer_1-2" data-name="Layer 1">
    <g>
      <g class="cls-3">
        <path class="cls-2" d="M1029.18,973.3c-1.01-7.48-1.99-14.93-2.93-22.34M1044.76,1073.01c1.48,8.41,3.02,16.87,4.6,25.35,2.18,11.57,4.39,23.05,6.69,34.42M1056.05,1132.78v.03M1029.72,972.17l9.78,59.68M982,1151.26c13.28,18.04,34.44,25.19,50.69,18.7,11.91-4.77,17.69-15.46,19.61-19.55M1217.44,708.86c.02-.74.07-1.44.12-2.11.05-.58.1-1.12.17-1.61.93-6.9,3.48-6.88,4.77-14.78,2.69-16.44-6.71-26.62-1.32-32.23,1.75-1.82,4-2.04,6.02-2.45,1.77-.36,3.35-.88,4.27-2.69,1.32-2.64-.39-4.74-.82-11.84-.26-4.19.14-6.95.24-8.56.84-12.18-3.72-37.43-7.1-53.92-.55-2.68-1.06-5.13-1.53-7.26M1211.99,522.22c-2.45-14.09-2.63-17.86-6.16-24.45M1196.66,484.67c-3.5-4.44-9.15-11.86-19.34-25.98-14.91-20.68-15.39-22.33-20.4-26.89-14.95-13.63-23.29-10.35-45.73-24.06-17.35-10.59-13.64-13.32-33.58-27.04-26.08-17.95-45.17-22.03-44.24-29.17.98-7.48,22.53-7.31,25.17-18.88,1.2-5.23-2.13-10.09-3.81-12.58-9.61-14.16-17.61-29.36-26.74-43.83-2.49-3.95-5.06-7.84-7.77-11.65-16.66-23.34-26.02-44-30.13-53.2-7.71-17.25-5.34-16.44-18.12-49.2-14.71-37.72-20.82-46.4-26.12-52.72-10.14-12.08-20.56-19.24-29.17-25.17-12.84-8.84-20.03-13.66-30.03-14.29-9.64-.62-17.93,2.9-31.16,11.43-26.53,17.09-41.13,26.51-52.92,45.48-8.29,13.37-12.96,35.99-22.31,81.24-5.34,25.88-4.14,25.07-6.57,30.31-1.44,3.09-3.21,6.26-5.18,9.46-3.02,4.84-6.56,9.71-10.31,14.43-12.77,16.11-27.83,30.29-32.12,34.32-1.24,1.15-4.56,4.26-6.25,9.34-.14.45-2.76,8.73,1.08,16.47,5.56,11.19,19.1,10.18,19.61,15.24.55,5.66-16.25,9.7-45.48,23.44-21.18,9.95-31.95,15.14-41.77,24.88-7.69,7.65-8.68,11.45-16.9,16.7-4.58,2.92-7.52,3.81-29.82,12.1-13.92,5.17-15.08,5.68-17.04,7.24-8.82,7.07-9.71,16.46-13.45,26.03-6.8,17.47-18.09,22.98-27.73,33.84-9.85,11.09-10.64,19.48-15.41,50.76M1097.89,709.58c-7.45-10.83-12.61-19.96-17.04-31.52-5.23-13.68-5.1-25.4-9.44-25.74-1.49-.12-2.75,1.13-8.44,10.74-1.03,1.75-2.21,3.78-3.57,6.13-4.99,8.63-7.89,13.87-9.64,17.21M1110.05,726.36c1.97,2.63,4.05,5.39,6.26,8.32,2.59,3.45,5.65,7.43,9.18,11.88M706.52,665.13c-5.59-9.99-8.25-15.34-10.43-17.92-1.27-1.53-2.39-2.09-3.84-2.06-.58.02-1.13.12-1.68.31-6.97,2.4-11.34,18.55-17.09,34.2M613.79,672.74c13.47-6.56,26.87-14.26,37.86-23.37,24.39-20.25,34.08-45.2,36.93-53.44.6-1.73,1.15-3.45,1.65-5.13,4.55-15.36,5.13-28.88,4.86-38.04M1062.96,663.06c-10,4.63-17.62,9.58-23.22,13.8M795.98,693.24c-3.57-1.63-7.52-3.47-11.93-5.46-.48-.21-.94-.43-1.41-.62M696.09,647.22c3.81,2.32,9.35,5.63,16.18,9.39,3.64,2.01,6.92,3.74,9.95,5.29M1203.78,571.06c6.04,2.69,12.68,5.25,20.01,7.6h.02M1160.75,541.54c-1.15-1.2-2.23-2.39-3.24-3.54-9.49-10.83-18.21-24.92-36.04-29.57-6.4-1.66-7.43-.41-20.46-.05-2.49.07-5.42.1-8.92.07-19.12-.15-33.41-.38-48.62-6.11-4.67-1.75-6.93-3.09-22.24-12.51-25.4-15.62-46.11-28.5-68.14-40.69-4.55-2.52-8.37-4.58-11.63-6.26-13.2-6.83-17.04-7.62-20.76-7.95-1.77-.15-3.48-.21-5.17-.17-16.53.39-29.31,9.76-43.74,19.01-63.15,40.45-111.87,49.35-130.57,49.53-14.52.12-23.32.21-32.42-5.39-6.16-3.81-11.94-9.92-15.77-7.91-2.08,1.08-1.54,3.48-5.71,10.3-1.9,3.09-2.9,4.67-4.72,6.14-1.25,1-3.64,2.59-10.16,3.72-6.04,1.05-10.74.86-11.1.84-11.57-.43-26.34,11.07-33.65,16.32-4.93,3.52-16.94,9.66-40.96,21.93-9.11,4.65-21.04,10.11-35.85,15.29M1101.01,508.39c-.53,1.06-1.39,2.66-2.57,4.5-2.33,3.62-3.84,4.89-5.01,6.73-2.33,3.64-2.13,7.57-1.99,11.15.21,5.65.38,10.28.46,14.16.17,6.98.1,11.51-.46,15.02-.57,3.57-2.73,7.5-6.74,13.44M967.14,541.29c1.17.14,2.4.31,3.69.53,1.44.24,5.22.7,10.71,2.28,5.51,1.58,12.73,4.27,21.12,8.97,6.88,3.84,19.37,10.74,30.61,24.02,14.74,17.42,14.31,30.41,21.97,30.89,4.99.31,10.86-8.05,22.6-24.75,2.69-3.84,4.98-7.05,6.85-9.85M938.31,526.87c-1.08-4.38-2.32-9.3-6.98-14.35-3.6-3.91-6.21-4.72-7.88-4.96-6.74-.96-12.53,5.54-13.21,6.32-.12.14-.24.27-.34.43M788,582.42c-1.92,1.6-3.76,3.12-5.42,4.53-4.87,4.1-8.36,7.05-8.48,7.16-10.9,9.2-11.81,15.6-16.35,16.17-3.02.38-5.27-1.87-6.57-2.95-29.43-24.39-44.14-36.57-48.24-45.66-1.25-2.78-3.02-6.35-6.68-8.39-.39-.22-.79-.39-1.18-.51-4.19-1.46-9.04,1.41-18.28,4.89-19.15,7.26-21.4,4.12-26.12,9.16-6.09,6.5-2.3,11.84-8.39,24.11-4.2,8.48-9.73,13.45-15.34,18.5-4.77,4.29-12.48,10.31-33.09,19.55-12.8,5.73-20.71,8.25-28.04,10.79-6.45,2.23-12.46,4.48-20.97,8.97-3.35,1.75-6.44,3.5-9.23,5.18M1091.9,544.92c2.76.98,7.19,2.51,12.68,4.29,12.42,4,14.29,4.08,16.46,6.44,4.48,4.89,1.12,9.75,4.05,19.82,2.4,8.27,7.14,13.52,11.53,18.36,7.46,8.24,15.17,12.29,26.03,17.86,10.07,5.18,10.78,4.2,22.58,10.16,8.12,4.08,14.72,7.41,22.03,13.01,5.3,4.07,12.73,10.67,19.94,20.8M1071.41,652.32c2.47-12.17,4.8-24.69,7-37.62.6-3.57,1.2-7.12,1.77-10.66,1.66-10.42,3.17-20.64,4.51-30.65v-.02M690.22,590.79c-.07,7.71-.1,15.48-.07,23.34.05,10.61.19,21.04.41,31.34v.02M1080.18,604.04c3.83,9.52,8.36,16.49,11.82,21.11,7.02,9.35,14.36,15.32,23.46,22.74,5.44,4.43,9.16,7.46,14.59,10.86,9.22,5.78,14.55,7.14,32.31,13.87,18.21,6.92,27.46,10.45,34.89,15.17,9.59,6.07,16.34,12.72,20.49,17.35M923.91,520.13c-.05-3.69-.21-7.83-.46-12.56-.33-6.11-.86-13.2-1.63-21.61-1.27-13.8-3.21-31.13-6.3-51.17M1027.99,276.24c-7.21-4.51-17.85-11.75-29.52-22.05-16.44-14.5-21.67-23.36-41.89-49.87-2.06-2.73-4.31-5.65-6.73-8.77-6.69-8.61-29.7-37.98-64.08-68.06-11.38-9.97-15.27-12.36-20.59-12.6-24.26-1.03-48.62,44.41-59.38,67.25-2.63,5.56-4.44,9.78-5.25,11.69-1.73,4.02-5.42,12.99-12.01,24.61-7.45,13.09-14.9,23.06-20.06,29.46M886.64,70.01c-1.18,1.68-3.91,5.58-7.43,10.57-8.34,11.86-10.16,14.36-11.72,18.6-1.24,3.31-2.63,8.56-2.3,15.72M852.13,375.95c29.5,11.43,40.5,16.54,59.68,15.24,7.6-.51,12.82-1.77,20.64-4.56,2.63-.94,5.56-2.06,8.99-3.38,7.62-2.92,17.66-6.83,32.24-12.06,25.38-9.1,46.26-15.62,59.67-19.65M852.11,375.93c-5.29-2.04-11.17-4.31-17.81-6.76-18.6-6.9-45.66-16.34-79.5-26.03M932.46,386.6c3-2.44,5.99-4.87,8.99-7.31,9.08-7.38,18.14-14.76,27.22-22.14,5.44-4.41,10.86-8.84,16.3-13.25,4.89-3.98,9.76-7.95,14.66-11.93M852.13,375.95s-.02,0-.02-.02c-14.69-10.5-29.38-20.99-44.09-31.49-9.15-6.54-18.31-13.09-27.47-19.63-2.39-1.7-4.79-3.41-7.17-5.11M805.81,182.15c.76,39.26,2.99,64.35,5.89,80.19,1.73,9.58,3.72,15.79,5.77,19.72,1.22,2.35,2.47,3.88,3.69,4.84.58.45,9.32,7.17,16.58,12.96,13.02,10.38,11.74,9.85,13.73,11.07,18.62,11.31,41.97,3.98,44.81,3.04,4.77-1.56,2.32-1.42,16.41-8.37,13.97-6.9,22.77-10.24,28.78-13.45,4.93-2.61,7.96-5.15,10.4-9.49,1.92-3.38,2.66-7.1,4.15-14.59,1.96-9.82,1.9-17.31,1.72-26.87-.27-14.16-.69-26.56-1.13-36.86M951.85,282.64c.14,14.31.43,25.81.84,34.97.02.5.03,1,.07,1.48.55,11.74,1.32,19.51,2.18,24.44.86,4.79,1.8,6.88,2.78,7.34.14.07,1.77.82,3.95,1.99,2.95,1.6,5.3,3.12,7,4.29M808.03,344.44c1.54-.79,3.62-2.15,5.25-4.44.55-.79.98-1.56,1.3-2.33.89-2.02,1.12-3.9,1.22-5.01.33-3.23.7-10.43,1.03-20.59,0-.31.02-.62.03-.94.24-8.08.46-17.93.6-29.05M816.85,311.11c-5.1.45-12.1,1.61-19.92,4.67-7.04,2.75-12.49,6.18-16.37,9.03M984.66,343.53c-1.7-3.59-5.65-10.71-13.64-16.59-7.26-5.34-14.41-7.16-18.26-7.84M1219.69,741.04c.55.12,1.12.26,1.68.43,4.74,1.39,9.11,4.26,10.11,3.04.57-.7-.55-2.15-1.9-6.09-.84-2.42-1.32-4.53-1.63-6.09M803.7,448.11c-32.14-.02-55.62-6.71-71.51-13.16-17.18-6.95-31.16-15.92-49.18-12.01-7.05,1.54-12.49,4.56-27.18,16.59-39.47,32.35-49.7,51.1-78.65,67.22-10.52,5.85-19.65,9.2-24.59,10.86M790.83,429.79c8.37.58,18.91.6,30.89-1.13,10.95-1.6,20.3-4.22,27.75-6.86M845.18,436.66c10.59-3.31,21.91-7.34,33.74-12.29,8.01-3.35,15.55-6.81,22.6-10.3M1085.7,452.69c-45.54.55-72.66-6.23-86.08-10.59-30.31-9.83-45.46-14.74-56.06-20.88-.41-.24-1.13-.65-2.11-1.17-1.9-.96-4.8-2.25-8.48-3.12-10.45-2.49-19.46.15-24.59,1.72-4.55,1.39-11.67,4.19-19.17,10.02M1142.62,457.84c-2.57-3.35-6.49-8.12-11.72-13.45-5.73-5.83-8.6-8.75-11.45-10-9.04-3.98-17.16,2.56-31.18,6.57-7.34,2.11-18.6,4.2-33.74,2.57M1108.68,415.21c9.51,6.06,16.47,10.64,22.12,14.5,3.67,2.51,6.07,4.2,9.92,4.91,5.56,1.01,8.6-1.05,12.8.72,3.41,1.42,5.44,4.48,6.64,6.95M1076.26,416.55c-8.15,1.44-20.23,2.71-34.51.77-11.65-1.6-17.85-4.41-26.17-6.49-11.53-2.87-28.56-4.7-51.62.76M1053.2,403.01c-20.27-.12-41.05.05-62.36.58-16.8.41-33.26,1.01-49.39,1.82-.63.02-1.27.05-1.89.09M1046.52,390.05c-5.97.17-15.05.41-26.12.57-14.23.21-22.63.15-26.89.19-11.74.12-28.95,1.25-52.07,6.09-.62.12-1.25.26-1.89.39M813.52,415.41c14.4-4.75,25.81-5.06,33.75-4.39,9.66.82,19.65,3.55,33.36.19,3.95-.96,7.09-2.16,9.16-3.05M884.84,399.58c-13.92-1.51-28.09-2.92-42.52-4.19-17.25-1.53-34.15-2.78-50.73-3.81M687.68,396.73c28.19,4.46,40.93.76,47.28-3.83,1.18-.84,4.62-3.48,9.92-6.28,7.58-4,14.47-5.89,19.07-6.86M749.08,484.43c-19,.62-29.4-4.72-35.47-10.11-5.89-5.23-8.53-11.26-13.35-10.86-5.73.46-6.14,9.34-14.48,18.1-5.97,6.26-13.3,8.79-27.99,13.85-7.95,2.75-19.13,5.99-33.03,8.08M1184.96,520.09c-1.39-.93-2.63-1.87-3.72-2.78-8.8-7.33-9.92-14.11-18.88-22.02-9.88-8.73-21.45-11.88-29.74-13.16M1038.73,719.52c.65-.12,1.32-.24,1.99-.38h.02M959.76,769.11c12.97-3.09,25.95-6.18,38.9-9.27M816.81,312.06h.02c20.18,5.95,30.96,15.02,37.12,22.5,4.17,5.08,8.31,12,17.35,15.44,5.23,2.01,9.78,1.97,18.1,1.92,8.68-.07,15.55-.12,22.89-3.24,6.42-2.75,8.68-5.9,16.39-12.78,3.28-2.93,7.52-6.5,12.77-10.43,3.35-2.51,7.09-5.15,11.24-7.84M814.58,337.66c9.25,3.31,16.63,7.02,22.02,10.06,12.34,6.98,21.24,14.48,23.25,16.22,7.48,6.38,6.95,7.28,10.86,9.34,2.23,1.17,6.49,3,25.55,2.87,11.79-.1,17.78-.17,21.93-2.11,6.32-2.92,7.95-6.61,15.07-13.73,2.15-2.15,4.86-4.65,8.19-7.38,3.69-2.97,8.15-6.19,13.49-9.39M836.87,202.14c-9.22-2.3-19.58,2.15-19.73,6.01-.26,6.83,31.34,16.77,34.9,11.15,2.13-3.36-4.43-14.5-15.17-17.16ZM835.42,182.7c-6.33-1.06-13.45,1.7-13.44,4,0,4.24,23.9,9.64,25.69,5.9,1.01-2.18-4.77-8.65-12.25-9.9ZM890.26,215.67c3.55,5.61,35.14-4.31,34.9-11.15-.15-3.86-10.52-8.31-19.73-6.01-10.74,2.68-17.3,13.8-15.17,17.16ZM894.64,188.96c1.77,3.74,25.67-1.66,25.69-5.89.02-2.32-7.1-5.06-13.44-4.02-7.5,1.25-13.28,7.74-12.25,9.9ZM482.05,567.99v.02M453.7,901.42l.02.02.15.14M404,611.9h.02M309.46,1053.08h.02M453.71,901.43c-1.73-7.83-4.94-18.17-11.26-29.16-3.55-6.18-7.36-11.31-10.9-15.43M267.4,1153.44c4.29-6.97,7.26-12.78,9.04-16.47,7.1-14.64,8.53-22.5,16.05-43.04,1.13-3.09,2.4-6.47,3.86-10.21,2.25-5.82,3.38-8.72,4.62-11.67,1.46-3.47,2.87-6.64,4.2-9.54,1.58-3.48,3.04-6.59,4.31-9.4v-.02c4.19-9.27,6.28-15.24,3.95-20.63-.34-.81-.82-1.65-1.24-2.75-.33-.84-.6-1.84-.77-3.07-.43-3.28.45-5.01,2.01-11.86,1.15-4.96,1.72-7.43,1.54-8.82-.27-2.32-1.05-3.64-1.92-5.25-.7-1.29-1.46-2.78-2.08-5.1-.79-2.99-.88-5.59-.77-7.4,0-.14,0-.26.02-.38M643.12,699.87c.7-3.83,1.06-7.48-.89-11.67-4.58-9.78-17.47-13.11-22.72-14.47-1.08-.29-2.08-.5-2.99-.65-1-.19-1.89-.29-2.73-.34-5.95-.46-8.96,1.37-18.4-.41-8.73-1.66-9.59-4-21.14-7.69-1.39-.45-2.95-.93-4.68-1.41-10.54-2.97-16.03-3.38-20.2-.6-.7.46-2.4,2.2-5.83,5.68-6.02,6.13-7.71,8.2-8.56,8.24h-.02c-.07,0-.14-.02-.21-.05-1.7-.84,4.63-9.35,1.96-19-.27-1.01-.72-2.18-1.08-3.59-.46-1.7-.79-3.72-.57-6.21.24-2.66.36-4.05,1.2-5.35.55-.84,1.25-1.44,2.11-1.87,2.93-1.54,7.64-1.22,13.32-1.82,3.86-.39,9.1-.77,13.52-2.06,3.98-1.15,7.31-3,8.37-6.28,1.75-5.37.43-13.14-3.71-15.38-2.49-1.34-4.63,1.27-5.83-.7-1.03-1.68-.67-5.71-.31-6.52,1.78-4.07,5.39-4.12,6.44-7.45.31-.98-.03-2.52-.76-5.58-1.46-6.28-2.28-9.58-4.77-10.69-1.8-.82-2.49.41-4.32,0-5.37-1.22-6.37-13.49-9.46-19.44-.91-1.73-1.99-2.93-3.4-3.17-.96-.15-6.62-.65-7.24-1.3-.05-.05-.1-.12-.1-.12-.19-.31-.15-.82-.79-3.6-.21-.82-.27-1.39-.29-1.73-.03-.31-.02-.45-.02-.45,1.73.26,3.48.51,5.22.77-.24-1.66-.65-3.66-1.41-5.82-.84-2.49-1.87-4.53-2.8-6.13-1.48-.63-2.95-1.27-4.43-1.92,0,0-1.01-3.23-2.71-8.37-1.56-4.8-3.69-11.29-6.13-18.4-.84-2.45-1.53-4.5-2.88-7.14,0,0-3.67-7.31-10.19-13.51-4.46-4.26-19.91-14.33-47.12-16.78-4.74-.43-9.82-.62-15.27-.51-3.52.07-8.56.19-14.38.58-19.84,1.32-48.62,5.89-55.91,22.89-1.27,2.97-10.69,26.87-12.2,34.92-.17.94-.86,5.11-1.03,6.14-.02.14-.03.22-.03.22-2.16.65-4.32,1.29-6.49,1.94-1.13,4.32-2.28,8.67-3.41,12.99,1.3-.22,2.59-.45,3.9-.67.6-.1,1.22-.21,1.82-.31.02,3.14-.86,4.68-1.89,5.49-1.68,1.34-3.29.27-6.02,1.51-2.11.96-3.28,2.54-4.74,4.53-.69.94-1.66,2.52-3.6,6.93-2.83,6.37-3.29,9.85-5.63,10.35-1.17.24-1.58-.5-2.71-.1-1.63.57-2.13,2.54-3.23,6.02-2.42,7.76-2.99,7.96-2.51,9.15,1.18,2.97,5.15,2.66,5.82,5.94.17.77.05,1.65-.19,3.41-.36,2.63-.57,4.1-1.61,5.03-1.39,1.2-2.75.1-4.43.89-1.36.65-1.9,2.09-3.31,10.06-1.12,6.3-1.12,7.46-.39,8.73.77,1.39,1.99,2.23,5.11,3.62.43.19.86.38,1.27.55,6.33,2.71,10.09,3.36,10.09,3.36,10.9,1.82,17.38.53,21.21,1.3,1.41.27,2.45.84,3.21,1.92.53.76.7,3.67,1.05,9.49.31,4.93.39,7.38.19,8.97-.93,7.21-4.91,12.58-7.36,15.41-.5.57-.93,1.03-1.25,1.39-1.73,1.87-2.59,2.8-3.23,3.04-.24.09-.48.15-.72.19-8.37,1.48-17.57-23.46-32.38-23.01-3.47.09-7.79,1.6-12.77,3.72-2.3.98-4.75,2.11-7.33,3.29-4.8,2.23-7.41,3.07-10.26,3.86-3.6,1-7.58,1.9-16.87,5.39-3.54,1.32-6.61,2.49-9.28,3.52-15.43,5.95-17.73,7.48-19.46,9.75-5.73,7.52-2.04,15.63-3.64,24.99-.03.27-.09.55-.14.82-1.03,5.11-2.97,6.5-7.28,13.78-2.93,4.94-8.49,14.33-12.08,25.45-2.39,7.36-3.9,15.5-3.19,23.6.88,10.18,4.48,11.65,7.02,18.76.72,2.02,1.36,4.51,1.82,7.77.88,6.19.22,10.54-.98,14.5-2.06,6.93-5.75,12.75-5.65,25.48.05,6.56,1,10.3,1.9,14.11,1,4.2,1.97,8.46,1.7,16.65-.33,10.16-2.01,9.04-3.91,24.42-2.01,16.23-1.49,28.57-.91,42.7.48,11.6,1.15,14,1.51,15.19.41,1.39,2.99,9.68,9.87,16.87,2.18,2.28,4.8,4.46,7.93,6.26.77.46,1.58.89,2.4,1.29,9.73,4.63,20.82,3.79,27.13,3.31,22.84-1.75,25.17-2.27,25.17-2.27,2.57-1.53,5.37-1.77,7.52-1.01,1.05.36,1.94.96,2.57,1.77,1.48,1.85,1.2,4.26,1.1,4.99M585.25,1000.59c-2.32.63-4.05,1.68-4.93,3.64-.7,1.56-.96,3.96-1.01,4.32-.29,2.15.29,4.93,1.61,10.45.82,3.4,1.7,5.83,2.11,7.88.17.81.27,1.53.27,2.25,0,.93-.17,1.82-.58,2.73-1.13,2.51-2.75,2.32-3.81,4.62-2.11,4.53,1.66,10.43,2.95,12.56.33.55.65,1.12.94,1.66.41.77.79,1.56,1.12,2.35M630.16,1163.78c-1.29-2.57-3.19-6.04-5.83-9.92-.72-1.06-1.37-1.97-1.84-2.61M535.6,541.08c-1.3-.26-2.59-.5-3.9-.76-1.82-.34-3.64-.7-5.46-1.05l3.02,12.87c.17.05.34.09.51.14,3.07.77,6.16,1.56,9.23,2.33M313.07,1000.71c13.95,1.75,25.67,2.99,34.63,3.91,2.32.24,6.23.6,10.45-1.2,5.59-2.4,8.41-7.17,9.04-8.13,3.67-5.61,19.19-13.47,67.82-23.97.22-.05.46-.1.7-.15M583.04,1026.88c-4.46,1.08-11.7,2.95-20.52,5.78-15.77,5.05-21.11,8.22-28.61,6.73-7.76-1.56-11.63-6.9-16.7-11.75-24.51-23.56-62.84-22.63-68.01-22.51-6.28.15-23.66.76-41.72,10.45-19.07,10.26-25.52,23.48-43.21,24.13-3.26.12-8.67-.82-19.49-2.81-13.78-2.54-24.97-5.22-32.57-7.17M309.48,1053.1c16.68,4.41,30,8.82,39.31,12.12,13.81,4.89,18.89,7.4,26.74,6.23,11.24-1.66,14.23-8.77,26.92-17.49,3.98-2.71,24.68-16.92,49.23-15.67,21.24,1.08,37.92,13.32,42.21,16.47,14.57,10.71,16.23,19.15,26.92,20.51,8.41,1.06,13.23-3.43,29.74-11.46,13.45-6.54,24.87-10.67,32.24-13.11M451.16,1171.94c25.83,0,47.33-18.53,51.94-43.02.6-3.17.91-6.47.91-9.83,0-29.19-23.66-52.85-52.85-52.85s-52.85,23.66-52.85,52.85c0,4.12.48,8.13,1.37,12,5.42,23.41,26.41,40.86,51.48,40.86ZM584.15,1064.7c-27.03,21.4-54.02,42.8-81.05,64.21M399.68,1131.08c-31.51-22.86-63-45.72-94.5-68.57M411.1,1194.24c-39.54-33.45-79.08-66.89-118.61-100.32M586.33,1100.48c-30.27,29.31-60.56,58.62-90.81,87.93M267.4,1153.44c41.89,67.85,116.18,108.21,194,104.92,104.39-4.43,162.27-85.18,168.76-94.57M388.4,949.48c11.67,6.4,24.3,12.58,37.92,18.31,2.9,1.22,5.8,2.4,8.68,3.52,10.23,4.03,20.34,7.52,30.29,10.55,44.65,13.57,86.09,17.8,120.02,18.17M589.4,905.48c-6.66-1.2-17.02-3.09-29.79-5.46-21.83-4.07-26.14-4.98-33.17-5.71-9.08-.94-22.14-1.56-38.32.34M473.43,897.93c-2.97,6.45-5.8,14.04-7.95,22.67-1.56,6.33-2.54,12.44-3.09,18.28-.81,8.24-.74,15.91-.19,22.81.62,7.83,1.84,14.66,3.09,20.16M601.4,937.56c-12.29-3.41-28.3-7.62-47.21-11.91-10.09-2.3-15.79-3.59-22.46-4.68-15.12-2.49-37.53-4.38-66.24-.36M594.21,961.94c-43.93-7.69-87.86-15.38-131.81-23.06h-.02M462.21,961.69c20.46,3.93,41.22,7.74,62.29,11.43,21.42,3.76,42.58,7.28,63.51,10.59M387.03,741.45c-10.45,4.8-24.01,12.61-36.65,25.07-6.04,5.95-9.7,10.85-15.36,18.41-8.49,11.31-9.68,15.12-10.18,18.02-1.3,7.93,2.04,14,3.86,18.89,3.07,8.22,5.9,21.52,4.26,43.43M541.44,705.39c4.65-6.85,6.9-11.1,6.57-13.99-.31-2.75-1.78-5.34-4.2-7.71-2.3-2.3-5.44-4.41-9.25-6.35-1.1-.55-2.25-1.1-3.45-1.61-6.45-2.87-14.38-5.29-23.03-7.26-17.19-3.96-37.29-6.16-54.78-6.4h-.93c-19.01-.21-36.24,1.87-51.28,4.94-14.64,3-27.18,6.93-37.22,10.64M358.68,682.28c-1.42,1.56-3.23,4.03-3.84,7.33-.03.17-.07.33-.07.5-1.2,7.88,5.22,14.79,11.46,22.41.67.82,1.32,1.61,1.92,2.37,14.93,18.64,11.67,20.49,18.88,26.56,10.83,9.15,19.63,5.18,62.86,5.89,36.26.58,48.34,3.67,59.1-2.25,1.3-.7,2.61-1.56,3.91-2.57,2.27-1.75,4.51-4.17,7.31-7.72,2.32-2.93,5.01-6.62,8.41-11.34.7-.98,1.44-2.01,2.21-3.09.5-.7,1-1.37,1.48-2.04,2.09-2.92,3.98-5.56,5.66-7.95,1.29-1.8,2.44-3.45,3.45-4.96M508.99,745.09c.55,1.01,1.17,2.13,1.85,3.33,2.81,4.99,6.64,11.5,11.48,18.95.94,1.44,1.92,2.93,2.93,4.44,14.16,21.07,17.97,21.79,20.9,31.95,4.99,17.31.34,37.31-.6,41.39-.38,1.6-1.84,7.64-3.12,15.94-.24,1.54-.45,2.97-.65,4.31-1.25,8.46-1.68,13.02-.1,15.41.62.94,1.37,1.63,2.23,2.15,5.42,3.28,15.34-.57,27.37,5.01,5.99,2.78,10.07,7.84,18.12,17.52.31.38.63.77.96,1.17,5.18,6.25,9.76,11.75,13.28,17.52M374.31,629.97c.22,9.11,3.11,13.66,5.73,16.11,1.15,1.08,5.08,3.33,12.97,7.84,3.48,2.01,5.94,3.36,7.31,5.78.19.31.34.65.48,1.01.94,2.37.63,4.72.27,6.21M531.33,630.62c.88,7.04-.69,11.33-2.76,14.07-3.4,4.46-8.67,5.47-13.18,7.04-3.11,1.08-5.87,2.42-7.41,5.32-.33.6-.57,1.22-.74,1.85-.88,3.11-.15,6.52.88,9.39M404,611.9c.09,2.42.46,5.42,1.12,9.27,1.72,10.02,2.99,16.83,4.91,21.62,1.2,2.95,2.64,5.13,4.6,6.81,1.8,1.56,7,2.75,17.38,5.13,10.33,2.37,15.5,3.55,20.39,3.52h.02c8.61-.07,15.1-2.3,20.7-4.22,7.79-2.68,11.69-4,14.76-6.93.91-.86,1.9-1.9,3.45-5.46,1.53-3.45,3.55-9.32,6.5-19.72,1.13-3.95,1.94-7,2.49-9.46,1.2-5.51,1.01-7.93-.38-10.19-2.25-3.67-6.38-4.93-9.58-5.82-18.33-5.18-27.51-7.77-39.45-7.74-1.29,0-19.77.22-36.65,7.65-2.54,1.13-5.97,2.81-8.27,6.42-1.46,2.27-2.15,4.8-1.97,9.11ZM384.27,629.58c-4.19-.14-7.45-.09-9.97.1v.02c-5.92.45-7.81,1.61-8.13,2.85-.17.63.1,1.15.38,3.93.22,2.28.26,4.15.26,5.39M538.37,641.23v-.76c-.02-1.12-.02-2.57.03-4.27.1-3.04.1-3.57.03-3.9-.02-.05-.03-.09-.03-.1-.14-.45-1.1-1.24-7.05-1.8-2.95-.29-7.12-.51-13.02-.63M400.33,659.71c1.01-3.19,1.94-7.07,2.45-11.55.36-3.09.45-5.9.39-8.41M502.57,635.65c0,.12.02.22.03.34.21,2.88.57,6.04,1.17,9.37.91,5.11,2.16,9.64,3.47,13.54v.02M566.27,636.7c-.05,0-.1,0-.17-.02-.27-.02-.58-.05-.89-.09-2.42-.26-5.73-.89-9.4-2.45-2.2-.94-3.62-1.56-5.23-2.95-.86-.76-2.59-2.63-6.09-10.54-1.15-2.61-1.85-4.63-2.11-5.44-1.48-4.32-8.97-25.71-14.83-43.52-.09-.27-.17-.53-.26-.79-.15-.46-.29-.91-.45-1.36-1.63-5.01-2.8-8.77-3.66-11.6-2.81-9.28-2.28-8.79-3.16-9.94-6.64-8.7-18.07-12.03-66.62-11.75-58.12.34-65.83,5.39-70.72,10.93-1.49,1.7-2.81,6.64-4.27,12.84-1.75,7.45-3.71,16.7-6.38,24.21-5.11,14.41-12.39,28.09-16.27,42.88-.36,1.39-1.3,4.86-4.31,6.83-1.46.96-2.73,1.12-7.07,1.78-1.92.31-4.99.79-8.89,1.46M436.93,477.14c.02,15.91.05,31.82.07,47.72h30.07c-.17-15.99-.33-31.99-.5-47.98M404,611.9c-3.81.07-6.59.45-8.27.74-1.15.19-2.11.43-3.21.79-1.73.58-2.81,1.29-3.72,1.82-.51.31-1.03.6-1.61.91-1.01.53-2.23,1.1-4.08,1.73l-.74.27c-.12,2.52.05,7.31,2.16,11.27.38.72.82,1.42,1.36,2.08,1.82,2.27,3.55,2.54,10.57,5.41,1.84.76,4.1,1.7,6.73,2.83,2.08.89,4.36,1.9,6.85,3.04.21.09.39.19.6.27M491.57,641.78s.02,0,.02-.02c2.15-1.42,5.59-3.5,10.11-5.41.31-.14.62-.26.91-.36,6.57-2.69,11.7-3.54,14.59-5.35.45-.26.82-.55,1.13-.88.57-.53.96-1.15,1.2-1.89.39-1.18.96-4.14.98-7.31,0-.94-.03-1.73-.07-2.3l-.72-.51c-.26-.1-.51-.22-.76-.33-.77-.34-1.48-.65-2.09-.96-.89-.41-1.65-.81-2.27-1.12-2.32-1.2-2.92-1.66-4.43-2.01-.82-.21-1.49-.33-3.91-.51-1.51-.1-3.54-.24-5.95-.36M378.41,560.03c1.15,11.57,2.76,23.75,4.96,36.45,1.17,6.78,2.45,13.33,3.81,19.68M516.87,616.47c.6-2.27,1.46-5.68,2.27-9.87,1.82-9.66,1.87-15.99,2.61-28.54.27-4.77.72-11.67,1.44-20.11M361.63,554.84l11.89-3c.07,0,2.92-12.66,2.92-12.66-2.9.58-5.78,1.15-8.67,1.73-.38.07-.76.15-1.13.22M543.91,882.95c-8.8-1.15-16.22-1.51-21.67-1.63-21.83-.43-26.07,3.21-27.53,4.43-.84.7-1.46,1.37-1.94,2.02-1.87,2.47-1.82,4.67-4.65,6.88-.31.24-.65.5-1.05.74-2.18,1.39-4,1.75-13.64,2.54-.46.05-.93.09-1.42.12-13.06,1.03-14.93.91-17.3,2.76-.31.24-.6.5-.84.76-2.92,2.9-2.45,6.38-4.98,11.31-3.24,6.3-7.84,8.13-18.7,14.67-12.78,7.72-34.22,21.93-41.79,21.93-.76,0-1.36-.14-1.82-.43-.21-.12-.91-.63-1.92-.91-.34-.1-.72-.15-1.13-.17-2.51-.1-4.43,1.78-4.79,2.09-2.25,1.97-19.63,9.94-72.21,31.39M541.78,865.4c-9.22-3.74-16.92-5.25-22.26-5.92-15.55-1.97-23.34-2.97-30.44-1.46-1.37.29-4.82,1.12-8.46.24-1.06-.26-2.15-.65-3.19-1.25-1.32-.74-1.78-1.36-2.63-2.01-4.6-3.59-10-.38-19.89,0-10.33.41-17.8-2.56-22.51,1.22-.19.15-.46.38-.84.63-.26.19-.58.38-.96.57-4.46,2.18-9.73-.27-11.02-.82-1.85-.79-11.93-.6-31.99-.19-20.11.43-31.85.86-37.19,6.44-.21.21-.53.57-1.01,1.05-.17.15-.34.34-.55.53-.67.63-1.44,1.3-1.75,1.54-1.89,1.36-5.46-.12-5.94-.31-1.73-.69-4.62-.74-8.2-.38-8.92.93-22.24,4.53-32.98,7.62-15.07,4.34-22.6,6.5-24.59,7.6-10.02,5.49-16.61,13.16-21.31,20.4M254.05,900.9c-2.47,3.76-4.43,7.43-6.13,10.61-2.92,5.53-5.18,11.03-6.9,16.42-3.14,9.75-4.53,19.03-4.99,27.11-.45,7.53-.12,14.02.34,18.83M492.77,887.78c-1.12-5.73-3.12-12.82-6.86-20.39-1.7-3.43-3.5-6.47-5.29-9.13M351.8,873.55c-7.5.67-16.58,1.51-26.91,2.56-12.84,1.29-17.56,1.87-23.99,3.69-4.46,1.29-8.01,2.68-16.2,6.35-7.71,3.47-18.16,8.36-30.63,14.76h-.02M356.4,888.84c-7.58,1.66-18.76,4.15-32.31,7.36-17.42,4.12-20.92,5.2-22.91,5.83-9.28,2.95-13.97,5.27-33.96,14.26-5.97,2.68-15,6.71-26.19,11.63M365.08,911.39c-43.02,14.55-86.04,29.1-129.05,43.66M244.3,980.13c21.83-7.22,44.36-15.2,67.53-24.04,21.78-8.31,42.66-16.82,62.62-25.4M349.4,863.89c.72,3.12,1.53,6.35,2.42,9.66,1.3,4.93,2.83,10.02,4.58,15.29.84,2.49,1.72,5.01,2.66,7.57,1.9,5.22,3.93,10.21,6.02,14.98,3,6.9,6.18,13.33,9.37,19.31,3.41,6.35,6.85,12.17,10.21,17.45M368.15,714.88c-2.57.53-5.17,1.06-7.77,1.63-2.42.51-4.86,1.05-7.31,1.6-.96.21-1.9.41-2.87.63-6.21,1.41-12.32,2.87-18.29,4.36-.02-.02-.02,0-.02,0-2.4.58-4.79,1.2-7.16,1.8M228.11,858.05h.02c15.22-7.17,27.83-11.69,36.67-14.5,11.12-3.55,18.09-5.03,22.91-11.67,4.08-5.59,2.42-9.1,4.63-21.5.34-1.92.76-3.81,1.3-5.71,2.45-8.63,7.29-17.78,17.57-33.07,1.61-2.39,2.97-4.29,3.86-5.49M331.91,723.09c-6.44-7.28-15.22-15.99-26.75-24.39-1.73-1.27-3.54-2.52-5.39-3.78-10.91-7.29-21.28-12.36-29.98-15.87M353.05,718.06c-7.02-8.46-16.23-18.19-27.97-27.85-10.36-8.53-20.39-15.08-29.14-20.06M354.75,690.1c-5.87-5.85-13.85-12.65-24.23-18.79-6.04-3.57-11.81-6.26-16.99-8.32M348.67,730.69c-7.62-2.02-15.6-3.96-23.94-5.78-12.49-2.71-25.76-5.15-39.74-7.12-9.08-1.27-17.9-2.27-26.43-3.04-4.02-.38-7.98-.69-11.86-.96M305.16,698.7c-7.53,1.58-15.98,3.79-25,6.95-8.05,2.8-15.26,5.89-21.55,8.94M336.83,747.8c-10.69-3.64-38.94-12.34-63.44-8.31-2.28.38-9.04,1.61-17.49,3.93-12.17,3.33-21.91,7.31-28.71,10.42M231.02,796.19c7.41-6.26,32.95-27.03,55.77-29.72,17.66-2.08,22.46-1.2,22.46-1.2,2.01.22,3.96.53,5.82.84,6.78,1.12,12.41,2.23,14.88-.89.55-.69.46-.96,1.17-3.47.6-2.16,2.32-8.1,5.71-13.95.67-1.13,1.39-2.28,2.18-3.38,2.59-3.59,5.17-6.38,5.17-6.38,2.21-2.4,4.84-4.86,4.55-7.4-.02-.1-.03-.22-.05-.33-.02-.14-.05-.24-.07-.31M293.4,804.6c-8.44-.43-20.22-.12-33.74,3.17-11.62,2.83-20.99,7.02-27.8,10.69M348.67,730.69l.05-.05c3.88-4.7,7.77-9.4,11.65-14.12.03-.03.07-.09.1-.12M574.25,664.64c-5.2,2.15-11.26,5.13-17.64,9.28-5.03,3.29-9.28,6.66-12.8,9.78M595.39,672.32c-9.11,4.34-19,9.63-29.31,16.03-9.2,5.71-17.38,11.48-24.64,17.04l-.02.02M528.62,723.45c.72.07,1.54.15,2.47.26,2.52.24,5.77.58,9.54,1.01.88.1,1.7.19,2.44.27,6.02.7,8,1,10.97,1.1,7.24.22,12.6-.93,14.93-1.37,6.04-1.12,19.82-2.76,51.67-5.22M616.52,673.08c-14.21,8.67-29.02,18.45-44.17,29.45-1.12.81-2.25,1.63-3.38,2.45-9.11,6.69-17.73,13.37-25.9,20.01l-.02.02M572.33,702.53h.02M559.05,770.89c-.45,9.56-.91,16.95-1.24,21.66-.43,6.33-.94,12.73,1.96,14.17,2.08,1.03,6.5-.17,8.24,1.24.72.58,1.37,1.34,1.37,1.34.31.36.67.81,1.1,1.49,2.61,4.17,2.68,8.19,2.81,15.07.29,14.81.34,16.03,1.6,17.49,2.45,2.87,5.66,2.35,13.47,3.83,4.36,0,8.13.91,11.31,2.09s5.71,2.64,7.58,3.72c1.89,1.1,4.39,2.75,7.43,4.91M520.21,734.79c1.1,1.32,2.08,2.63,2.95,3.9.51.72.98,1.42,1.41,2.11,2.59,4.15,4.14,7.89,5.1,10.91.1.31.19.6.27.89,2.11,7.09,1.58,11.33,4.51,14.26.26.24.53.48.84.72,1.61,1.2,2.9,1.32,14.07,2.37,5.56.51,3.21.51,9.68.94.48.03,1,.07,1.58.1,9.1.57,27.34,4.63,43.26,10.91,4.53,1.78,8.84,3.74,12.92,5.82M603.17,747.04c-10.12-1.48-18.45-1.01-32.35.24-1.68.15-3.45.33-5.32.5-9.15.86-21.28,2.28-35.56,4.82M629.1,828.71c-4.99-3.23-10.55-6.37-16.71-9.18-17.66-8.08-33.65-10.69-44.38-11.57M424.34,568.4c3.93.81,8.29,1.51,12.87,2.01,4.43.48,9.06.79,13.71.82h.02c.36.02.74.02,1.1.02h.46c4.56,0,9.11-.26,13.47-.7,5.87-.57,11.38-1.48,16.08-2.52v-.02c9.15-2.02,15.29-4.62,15.17-6.5-.15-2.08-7.79-3.33-16.73-4.08-4.75-.41-9.88-.67-14.43-.84-6.85-.26-12.41-.31-13.49-.31h-.89c-3.78-.02-9.13.02-14.84.21-4.84.12-9.94.36-14.55.74M422.28,557.21c-8.79.7-15.8,1.9-15.96,3.9-.15,2.09,7.29,5.1,18.02,7.29M482.03,567.99h.02s.04-.04.06-.06M436.83,556.53s-.03.07-.05.11M466.17,557.03c-.04-.11-.08-.23-.12-.34l-.02-.02M465.97,570.49c.11-.29.21-.57.3-.84M451.69,556.32s-.05.07-.08.11M452.5,571.09c-.03-.06-.09-.18-.16-.34M1425.55,888.82l.07-.19M1165.74,535.26l.02.02M1497.52,1015c-.29-.05-.55-.03-.74.1-.15.12-.22.27-.26.33-.72,1.49-5.85,7.05-14.88,19.92-2.83,4.05-5.25,7.64-7.19,10.59-.69,1.05-2.54,3.88-4.99,7.77-2.85,4.55-6.68,10.78-11.15,18.58-.07.1-.1.19-.12.29-.26,1.1.07,2.16.22,2.59.02.05.03.09.05.12.58,1.24,1.68,1.9,2.92,2.61,2.61,1.46,3.91,2.2,5.15,2.63,2.52.89,3.71,18.5.31,78.75-.05.84-.1,1.7-.15,2.56M1497.56,1015.02c.63.12,1.44.58,2.11,1,1.44.86,1.58,1.25,2.15,1.2.89-.07,1.78-1.17,1.66-2.01-.07-.45-.39-.6-1.82-1.75-.91-.76-1.36-1.15-1.56-1.41M1553.53,1039.37c.41-.98.89-2.09,1.46-3.38,3.31-7.55,4.96-11.33,7.31-14.09.5-.58,1.96-2.21,1.56-3.84-.02-.07-.03-.14-.07-.19-.21-.62-.65-1.15-1.12-1.44-1.72-1.08-4.03.69-7.33,1.94-6.76,2.56-13.76,1.39-18.38,1.77-.09.02-.6.05-1.29.05-.46-.02-.79-.02-1.13-.09-.65-.12-1.15-.41-1.48-.65-13.51-9.18-15.48-10.93-15.48-10.93-1.03-.91-2.47-2.23-4.39-2.18-.09.02-.22.02-.43.05-.46.12-1.29.41-2.92,1.3-3.6,1.96-4.36,3.16-5.73,2.83-1.29-.31-1.56-1.48-2.57-1.32-.24.03-.48.15-.7.31-.65.5-1.12,1.41-.98,2.13.02.1.07.22.21.39M1553.53,1039.39c-1.13,2.76-1.58,4.55-1.08,6.25.82,2.76,3.74,4.53,9.54,7.96,4.96,2.93,7.43,4.41,9.64,4.58,3.24.26,6.37-1.13,14.84-8.97,9.97-9.22,17.3-18.17,22.82-25.23,2.11-2.69,4.2-5.54,6.4-8.73,5.94-8.63,4.14-7.04,11.69-19.07.19-.31,2.33-3.72,4.34-8.63,1.32-3.24,1.99-4.91,1.84-6.45-.09-.86-.5-3.21-8.6-9.54-4.96-3.86-7.6-5.89-10.54-6.13-.12,0-.26-.02-.38-.02-.72-.02-3.26-.02-8.08,3.07-8.87,5.7-12.46,13.51-15.62,14.93-.5.24-1,.29-1.51.15-1.18-.33-1.78-1.58-1.84-1.7-.5-1.08-.36-2.59,2.75-7.89,2.61-4.44,3.31-4.77,3.5-6.52.09-1-.62-2.81-2.04-6.38-2.01-5.08-2.93-6.47-4.02-7.64-.82-.91-1.54-1.46-2.61-2.25-6.06-4.51-9.3-6.45-9.3-6.45-9.39-5.61-12.92-7.43-14.48-8.85M1560.79,935.86c-.67-.6-.98-1.13-1.22-1.87-.45-1.34-.43-3.86-.39-8.91.03-3.66-.86-5.73.17-7,.03-.07.1-.14.17-.21.96-.93,2.95-1.36,4.19-1.63,1.42-.31,2.01-.21,2.51-.72.91-.93.46-2.71.14-4.12-1.73-7.62-.74-9.64-2.4-10.45-.96-.48-1.48.12-6.21,1.73-5.47,1.85-6.62,1.65-7.4,2.99-1.24,2.13.89,4.08.07,6.32-.07.14-.12.29-.21.43-.82,1.53-2.16,1.05-6.92,3.33-4.14,1.99-4.75,2.78-6.47,2.73-.77-.02-1.44-.21-2.09-.51M1534.67,917.93c-1.18-.58-2.28-1.61-3.72-2.87-2.54-2.2-6.93-5.1-15.72-10.93-1.08-.72-2.99-2.49-6.06-3.54-1.61-.55-2.99-.76-4.03-.89-1.97-.27-3.21-.22-7.45-.1-5.54.17-5.53.14-5.68.22-2.78,1.53-3.78,6.13-6.02,9.82-.29.48-.89,1.41-1.66,1.65-.14.05-.27.07-.41.07-.15,0-.27-.03-.33-.05-3.79-1.13-3.79-1.92-15.31-5.49-.82-.26-3.11-.94-3.35-2.35-.02-.1-.03-.19-.03-.29-.02-1.75,2.61-2.83,2.61-4.91-.02-1.8-2.06-2.32-9.13-7.1-1.68-1.15-4.58-3.16-8.82-4.96-2.2-.94-2.97-1.06-3.74-.82-1.51.46-2.81,2.45-5.35,6.38-.5.79-1.01,1.6-1.92,1.82-.91.21-1.53-.34-2.97-1.15,0,0-3.59-2.04-8.24-3.28-.41-.1-.65-.17-1.15-.33-.21-.07-.39-.14-.57-.19-1.15-.39-1.41-.58-1.51-.67-.63-.53-.81-1.27-.91-1.61-.5-1.9-1.73-3.62-3.07-6.09-1.36-2.47-2.81-5.66-3.79-10.52-.48-2.44-.65-4.5-.65-6.19,0-4.44,1.18-6.5,1.18-6.5v-.02s.02-.07.02-.07c0-.07,1.96-11.84,2.44-16.15.46-4.1.22-7.1-.09-11.27-.15-2.16-.58-6.64-1.85-12.32-1.8-7.96-3.21-9.1-4.79-15.84-.98-4.24-.51-4.19-1.72-13.99-.07-.5-.12-.98-.17-1.46-1.42-11.43-2.27-17.45-4.82-22.5-3.29-6.56-7.5-10.23-8.72-11.26-3.31-2.76-6.35-4.22-7.36-4.67-5.94-2.69-9.25-1.8-16.71-2.57-.51-.03-1.06-.1-1.63-.17-4.74-.58-12.06-1.56-19.46-5.78-1.2-.69-5.06-2.9-7.76-5.59-1.77-1.77-3.02-3.76-2.69-5.66.46-2.64,3.69-3.41,7.4-5.58,5.99-3.47,10-10.3,17.8-23.82,6.52-11.31,9.78-16.97,11.03-21.42,4.03-14.17,1.39-26.46,6.57-34.58.62-1,1.36-1.9,2.23-2.76.93-.88,2.18-1.9,3.38-3.91,1.7-2.85,1.54-4.82,2.18-16.11.21-3.74.41-6.81,1.46-10.4.51-1.73,1.24-3.6,1.24-3.6,1.22-3.23,2.42-5.41,2.73-6.02,4.03-7.88-.36-24.87-.79-26.46-.53-2.02-.94-3.16-1.03-4.02-.05-.55.02-.98.26-1.44,2.54-5.1,18.04-1.97,23.48-1.05,29.12,4.94,66.21-2.93,89.84-16.41,10.07-5.75,18.81-14.72,36.28-32.66,21-21.57,34.85-40.77,33.53-41.97-1.94-1.78-32.93,37.96-77.93,52.6-5.61,1.82-13.71,4.39-24.69,4.98-11.14.6-13.2-1.49-45.41-6.56-16.85-2.64-25.28-3.96-30.27-3.86-2.63.07-7.26-.33-16.53-1.08-2.51-.21-4.77-.41-7.33-1.49v-.02c-.14-.03-.26-.09-.39-.15-4.67-2.09-7.16-5.66-8.17-6.98-3.83-5.01-9.59-7.69-21.14-13.06-17.9-8.34-44.94-11.51-67.15-3.45-5.49,2.01-11.89,4.32-18.21,10.07-7.16,6.52-6.14,10.06-11.81,13.16-.1.05-.21.1-.29.15-7.09,3.72-10.42-1.2-26.17.63-5.34.63-8.96,1.66-11.65,1.77-1.75.09-3.12-.22-4.34-1.27-.36-.31-.69-.65-.94-1.05-1.65-2.3-1.58-5.82-1.39-10.38.12-3.05.31-7.14.51-11.75.58-12.25,1.32-28.19,1.32-38.3,0-3.47-.09-7.09-.88-7.21-1.18-.17-3.24,7.64-5.15,14.96-1.7,6.57-3.17,12.36-4.46,17.45-5.08,19.97-7.58,29.57-11.7,35.42-.34.48-.69.93-1.05,1.36-1.17,1.41-2.49,2.59-4.02,3.67-3.67,2.59-5.73,2.59-10.21,6.52-1.18,1.03-2.56,2.23-3.93,3.64-1.8,1.77-3.6,3.86-5.01,6.26-1.7,2.92-2.83,6.32-2.64,10.19.36,8.01,6.09,14.88,11.98,17.95.72.38,1.25.6,1.82.84,6.64,2.73,12.05,2.06,19.72,1.29,2.49-.24,5.23-.5,8.34-.65,1.46-.07,2.73-.1,3.83-.1,6.42-.05,8.27.76,16.56.34.63-.03,1.29-.03,1.92,0,3.36.07,6.73.65,10.02.12,1.48-.22,3.83-.7,4.82.5.26.31.39.72.45,1.13.1.93-.22,1.9-.33,2.23,0,.02.21,6.81.6,20.39.6,19.68,1.25,17.52,1.08,26.53-.03,1.34-.07,2.93-.03,4.84,0,1.89.09,4.08.29,6.64.57,6.78.89,10.31,3.14,13.99,2.76,4.56,5.18,3.96,5.9,7.36.81,3.83-2.08,5.42-1.68,11.58.1,1.73.45,3.5.67,4.44.1.46.17.74.17.74.55,2.09,1.08,3.19,1.36,4.03,1.03,3.05-.34,6.09-2.69,11.12-3.21,6.9-7.07,11.27-8.61,12.94-2.59,2.78-4.86,4.55-5.73,5.22-1.82,1.37-3.28,2.47-4.75,3.26-.55.29-1.1.55-1.68.76-2.71.98-4.74.55-7.19-.17-.21-.07-.41-.12-.62-.19-2.61-.79-5.77-1.8-10.69-1.89-5.61-.1-8.41,1.1-9.16,1.44-3.86,1.75-5.65,4.43-7.09,5.95-2.68,2.85-5.95,3.64-9.83,3.83-5.27.24-11.62-.63-18.95,1-10.4,2.32-17.06,8.39-26.7,17.21-3.81,3.48-6.78,6.74-9.52,10.16-2.59,3.23-4.96,6.61-7.69,10.43-5.2,7.31-10.18,14.35-14.55,23.06M1037.38,947.99c-.07.33-.12.62-.17.89-.14.82-.98,5.37-2.68,10.55-1.61,4.91-2.73,8.31-4.8,12.73-.17.36-.36.74-.55,1.13-1.27,2.63-2.9,5.65-5.15,9.52-8.99,15.55-18.45,51.76-4.19,70.77,1.17,1.54.09-.22,20.51,15.92,1.17.93,2.64,2.09,4.41,3.48.53.41,1.1.86,1.7,1.32,3.14,2.44,7.04,5.44,11.6,8.85M1110.77,1115.17c4.6,1.84,8.94,4.34,13.54,6.23,1.1.45,3.57,1.46,4.82,3.86.5.91.69,1.82.74,2.75.05,1.17-.1,2.39-.22,3.72-.33,3.71.38,7.43.46,11.14.1,5.1,39.16,27.49,155.66,83.3M1285.79,1226.16l1.39.67M1441.59,936.46c.03.22.07.43.1.65,1.97,13.01,2.3,20.52,2.15,25.12-.03,1.24-.21,5.97.24,12.22.14,1.94.34,4.05.67,6.37.72,5.3,1.72,9.66,2.51,12.7.45,1.66.82,2.97,1.01,3.59.05.19.1.33.1.34,5.32,17.56,7.4,43.73,7.4,43.73.09.98.21,2.63.34,4.75v.02M1163.18,1030.88c1.48-.72,3.16-1.9,3.6-3.71.43-1.75-.43-3.62-3.04-6.52-1.08-1.2-2.47-2.57-4.2-4.2-7.26-6.81-8.32-6.47-11.34-9.66-2.61-2.76-3.26-4.55-9.71-20.52M1130.75,970.49c-.36-.22-.72-.34-1.12-.38-3.45-.34-7.02,4.82-8.44,8.44-.5,1.24-2.02,5.15-.5,8.94,1.12,2.73,2.85,2.97,5.56,6.5,2.39,3.12,3.26,5.82,3.86,7.24,1.41,3.36,4.07,6.04,7.45,8.67,6.95,5.39,16.95,10.55,25.62,20.97,5.94,7.17,9.64,14.88,14.21,14.04.98-.19,1.78-.72,2.59-1.34M1369.71,1165.93c-103.48-69.21-173-116.26-178.07-121.26-.58-.58-3.24-3.48-6.76-3.38-2.18.07-3.52,1.25-4.84,2.25M1137.6,966.42c1.3-.88,2.37-1.65,3.19-2.28,22.24-16.89,34.56-47.33,36.21-64.47.21-2.11.48-6.5,3.21-11.1,3.12-5.25,7.09-6.83,13.35-11.74,0,0,3.26-2.54,12.56-12.24,25.14-26.19,27.82-56.77,27.82-56.77,1.36-15.48-1.94-30.37-7.84-42.71-3.62-7.65-8.25-14.33-13.39-19.55-.79-.79-2.39-2.42-4.6-4.32-4.94-4.22-12.94-9.78-21.74-10.31-5.8-.34-10.81.81-10.81.81-4.74,1.08-6.5,2.52-12.06,4.34-5.42,1.77-9.35,2.23-11.26,2.57-4.75.84-12.12,3.57-24.04,11.22-3.12,2.01-6.57,4.38-10.38,7.12M1226.93,708.46c3.78,1.99,9.03,4.93,15.03,8.89,21.69,14.29,33.72,28.98,55.19,44.94,0,0,4.36,3.24,15.55,9.44,10.26,5.68,12.65,5.97,14.84,5.53,4.93-1.01,7.71-5.49,12.39-13.02,3.64-5.87,3.43-8.1,3.05-9.34-.88-2.88-3.29-2.63-5.15-5.95-2.28-4.1-1.06-8.92-.15-12.54.51-2.06,1.56-5.22,3.86-8.68M1430.97,1165.07c-.07-.67-.14-1.32-.21-1.99-.14-1.48-.29-2.97-.45-4.44-1.36-13.63-2.75-27.23-4.12-40.86M1410.79,785.45c-.03.15-.05.33-.09.48-1.32,7.21-2.37,13.59-3.21,19-2.78,17.85-2.11,18.09-3.9,24.47-2.27,8.15-4.29,11.24-4.96,18.96-.1,1.3-.15,2.54-.15,3.69-.07,3.96.34,6.9.53,8.27.38,2.81,1.54,15.98,3.26,35.09,3.05,33.94,7.79,86.68,12.84,133.65,1.24,11.6,3.02,27.71,5.39,47.26.74,6.07,1.53,12.48,2.37,19.19M1398.47,852.05c-1.65-.65-3.54-1.36-5.63-2.06-5.18-1.77-11.7-3.6-19.29-4.86-4.29-.7-7.5-1-10.95-1.06-6.07-.15-12.85.39-27.41.58-21.61.27-32.74-.62-41.96.05-4.7.34-8.92,1.1-13.78,2.61-1.99.62-8.56,2.75-15.68,5.18-1.61.55-3.02,1.03-4.26,1.46-9.95,3.47-9.2,3.55-15.65,5.54-1.82.57-1.9.63-2.2.79-7.36,3.88-6.74,18.31-6.28,26.99,1.39,26.58,1.68,53.2,3.05,79.78.6,11.7.51,13.8-.74,16.82-4.31,10.45-15.56,14.05-52.12,28.38-8.7,3.41-16.15,6.25-21.85,8.39M1259.52,853.97v-.02c-1.22-8.51-3.04-20.64-5.53-35.23-3.4-20.09-4.68-25.04-5.78-28.71-1.15-3.86-4.19-13.85-9.95-24.64-1.82-3.41-3.93-6.93-6.33-10.35-3.76-5.34-7.91-9.97-12.24-13.99-14-13.06-29.7-19.65-39.02-22.84M1293.24,844.7c-2.73-17.57-6.9-38.44-13.54-61.57-2.09-7.28-3.84-12.78-5.32-16.99-1.89-5.41-3.29-8.68-4.31-10.78-.45-.91-.81-1.61-1.12-2.16-5.61-10.36-18.89-29.65-50.9-44.15-.15-.09-.31-.15-.46-.22M1392.84,849.99c-1.6-18.69-3.33-35.28-4.98-49.41-1.6-13.83-2.93-23.61-6.92-36.04-2.68-8.36-5.65-15.05-7.86-19.6M1362.6,844.05c-.55-18.64-1.99-34.27-3.36-46.04-1.44-12.29-2.64-22.19-5.8-35.23-.19-.77-.38-1.54-.57-2.3-2.81-11.15-6.02-20.35-8.63-27.1l-.15-.41M1135,948.57c12.54-10.02,17.73-19.63,19.96-24.78,3.45-7.98,5.78-17.01,5.78-17.01,2.08-8.03,2.15-11.75,4.41-18.77,2.08-6.42,4.63-11.38,6.45-14.53M1116.15,866.2c12.25,6.97,20.76,5.92,24.09,5.23,4.44-.91,7.55-2.78,21.73-13.28,17.42-12.92,26.14-19.37,29.67-22.67,8.61-8.03,23-23.9,33.77-51.64M1247.2,671.16c10.9,23.58,19.92,30.79,26.34,32.81,1.56.48,6.11,1.65,11.79,4.68,5.83,3.12,7.65,5.42,12.22,8.44,7.89,5.23,15.48,6.98,19.22,7.81,13.49,2.95,25.38-.24,32.18-2.76M1333.05,668.89c3.04,1.77,7.41-4.27,14.55-3.14,4.08.65,4.99,3,7.12,2.28,3.93-1.36,4.75-10.78,3.33-17.73-.27-1.41-2.85-14.02-9.39-15.07-7.12-1.13-14.84,12.1-16.82,22.39-.34,1.75-1.84,9.49,1.2,11.26ZM1302.3,611.82c-.05.6,3.31,1.25,18.81,3.86,22.65,3.83,24.35,3.91,26.68,3.88,6.11-.1,4.77-.91,24.64-3.84,11.48-1.7,17.14-2.21,17.13-2.92-.03-.91-9.22-1.7-17.04-1.82-12.22-.17-17.59,1.39-20.2-2.04-.39-.51-.94-3.26-2.06-8.75-1.3-6.49-1.6-8.31-2.16-8.32-.86,0-1.68,4.12-2.54,8.51-1.41,7.14-.79,7.38-1.61,8.56-2.63,3.76-9.37,1.82-23.05,1.56-8.25-.15-18.53.33-18.6,1.32ZM1165.76,535.28c-.45,1.66-1,4.48.22,5.37,1.97,1.44,7.34-3.05,8.24-3.81,2.78-2.33,7.09-6.9,9.7-15.39M1191.55,571.13c1.82-.81,3.76-1.89,5.42-3.31,1.73-1.44,3.19-3.26,3.98-5.53.45-1.3.53-2.35.57-2.75.41-4.48,1.87-15.65,4.07-31.59.36-2.56.72-5.25,1.12-8.05M1297.55,717.1c.36-5.46.48-10.28.48-14.31.02-4.14,0-6.23-.36-7.72-1.68-7.02-6.09-7.71-6.26-13.27-.02-.53.43-3.05,1.32-8.08.94-5.29,1-4.99.98-5.34-.07-4.94-8.8-9.66-36.5-21.5-2.92-1.25-7.02-3-10.91-7-4.27-4.39-6.25-9.37-7.22-12.73M1385.98,641.04c-.57.43-1.1.86-1.63,1.29-11.63,9.4-13.99,16.11-13.71,20.7.14,2.59,1.32,7.52-.22,13.69-.36,1.48-.88,3.05-1.53,6.19-.55,2.66-.84,4.74-1.24,7.69-.27,1.99-.6,4.62-.91,7.72M1237.56,573.15c1.12-.29,2.76-.84,4.56-1.87,6.07-3.47,8.37-9.35,12-19.05,2.71-7.24,3.45-11.81,4.89-20.94.53-3.35,1.42-9.7-1.03-10.98-.38-.21-.72-.21-3.24-.29-2.27-.09-4.02-.15-4.93-.21M1395.4,569.72c-.02-.21-.05-.41-.07-.63-1.12-9.87-3.9-22.91-10.91-36.64-2.37-4.63-4.91-8.75-7.45-12.36M1219.62,961.19c-2.59-10-5.63-20.47-9.16-31.37-3.19-9.76-6.52-19.01-9.9-27.75M1211.9,956.13c-1.78-3.76-4-7.83-6.76-12.06-4.8-7.38-9.94-13.2-14.47-17.62M1170.65,935.86c5.8,8.1,11.09,14.16,14.71,18.09,7.38,7.98,12.05,11.63,24.37,23.65,5.71,5.56,10.23,10.16,13.04,13.02M1179.57,963.13c6.44,5.15,10.67,10.04,13.37,13.56,3.26,4.27,4.8,7.29,8.82,11.05,4.03,3.74,8.1,5.95,10.86,7.22M1193.08,1001.48c-1.72-3.93-3.78-8.15-6.26-12.54-3.43-6.04-6.98-11.26-10.38-15.68M1279.7,761.42s.02.02.03.03c1.92,1.73,3.81,3.36,5.66,4.91,7.71,6.42,14.67,11.17,20.11,14.59,19.41,12.17,24.92,10.5,26.55,9.9,5.95-2.23,9.37-8.96,13.27-16.65,2.75-5.42,4.24-10.24,5.06-13.52M1320.96,824.62c-2.76-4.36-5.65-8.79-8.68-13.27-6.42-9.47-12.89-18.31-19.31-26.55M1195.98,884.7c5.75-.93,16.68-3.59,25.57-12.54,5.44-5.49,7.77-10.97,11.82-20.51,2.02-4.75,6.4-15.89,8.68-31.13,1.18-7.88,2.09-18.72.98-31.61M1050.25,1010.88c-3.45,5.73-6.85,13.25-5.9,20.18.19,1.34.53,2.66,1.08,3.95,1.8,4.27,5.29,7.02,9.95,9.23M1180.03,1043.54s-.03.03-.05.03c-6.97,6.49-14.53,14.57-21.81,24.51-16.3,22.26-24.23,44.27-28.3,59.92,0,.02-.02.03-.02.05M1485.95,987.87c.07.1.14.21.19.33.5,1.06-.12,1.9-.74,4.14-.76,2.69-1.22,4.36-.46,5.61.82,1.32,2.52,1.22,2.57,2.35.03.69-.38,1.44-1,1.72-.12.05-.29.1-.65.05-.38-.03-.98-.21-2.01-.58-1.72-.65-2.02-.94-2.59-.79-.88.24-1.61,1.3-1.42,2.02.14.51.7.67,1.61,1.17.69.39,1.65,1.05,2.66,2.09-.03.03-.24.34-.27.39-7.57,11.15-15.82,22.96-15.96,23.13-1.39,2.02-3.12,4.56-5.15,7.53-1.84,2.73-3.91,5.82-6.18,9.2-.21.33-.43.63-.63.96,0,0-.17.26-.46.69-.88,1.32-2.83,4.29-4.65,7.09-4.27,6.56-8.68,13.02-13.14,19.46-4.87,7.05-9.83,14.07-14.79,21.07-13.93,19.75-27.83,39.54-39.92,60.44-.41.7-1.96,3.45-4.02,3.45-1.68,0-2.35-1.85-3.83-1.65-.96.12-1.34,1.01-3.33,4.55-.93,1.63-1.61,2.78-2.08,3.64-.77,1.42-.94,2.02-.67,2.71.53,1.32,2.06,1.48,2.25,2.9.14,1.01-.5,1.87-.79,2.25-8.63,11.45-17.81,23.68-24.13,35.3v.02c-6.44,11.81-8.72,14.09-16.32,24.16-.91,1.2-1.9,2.52-2.99,3.98-.26.36-.6.82-1.2,1.29-2.37,1.84-4.51.43-7,1.68-1.29.65-2.13,2.04-3.78,4.82-1.56,2.63-2.35,3.95-2.42,5.23-.22,4.22,5.08,7.58,9.1,10.12,4.08,2.61,6.33,4.03,9.16,3.47,2.28-.46,4.03-2.4,7.57-6.28,1.44-1.6,2.04-2.51,2.18-3.69.24-1.96-.79-4.19-1.36-4.79-.02-.03-.07-.09-.12-.17-.41-.74.46-1.92.74-2.3,2.15-2.99,30.85-45.7,32-47.43,8.03-12,12.06-17.98,12.06-18.02.05-.19.24-.98.77-1.15,1.15-.38,2.21,2.59,3.9,2.59,1.32,0,1.65-1.82,4.43-5.54,2.25-3,3.36-3.6,3.14-4.84-.31-1.68-2.59-1.73-3.31-3.6-.82-2.18,1.24-4.84,1.82-5.63.55-.72,1.68-2.32,3.35-4.7,5.01-7.14,14.88-21.36,28.11-40.53,8.56-12.41,18.55-26.89,29.58-42.85.81-1.2,1.65-2.42,2.49-3.64M1460.15,947.15c-.26.53-.88.72-1.34,1.61-1.54,2.99-.55,6.35.12,8.53,3.19,10.31,4.79,15.48,6.14,16.8,1.37,1.34,4.63,3.17,11.14,6.88.46.26,2.51,1.41,4.93,3.12,1.75,1.24,1.01.88,3.28,2.54.89.65,1.29.91,1.53,1.22M1425.58,888.84h-.03v-.02c-2.08-.67-5.39-1.48-9.34-1-5.44.65-12.3,3.71-12.34,7.12,0,.1,0,.21.02.31.15,1.27,1.42,2.21,4.53,4.65,10.43,8.22,17.47,11.45,17.09,15.27-.09.81-.48,1.65-1.18,3.12-1.37,2.9-2.66,3.72-2.44,5.18.17,1.25,1.2,2.06,2.08,2.71,8.58,6.5,10.83,7.83,12.01,8.34.12.05.55.19,1.1.45,1.15.53,2.04,1.13,2.71,1.65l.19.12c.81.43,1.36.45,1.72.36.07-.02.14-.03.21-.07.69-.29.74-1,1.75-2.25.58-.72.88-1.08,1.2-1.24.07-.03.15-.05.22-.07,1.49-.31,3.79,2.9,7.69,6.23,4.56,3.86,7.79,5.15,7.48,7.1-.02.1-.03.19-.07.27M1455.34,1044.67c.03,1.06.09,2.15.12,3.21M1484.12,1005.98c4.46,3.02,8.94,6.01,13.4,9.03.02,0,.02.02.03.02M1500.09,1012.05s-.02,0-.02-.02c-4.74-3.31-9.47-6.64-14.21-9.95M1500.85,1009.51c-4.44-3.07-8.89-6.14-13.33-9.22M1485.94,987.86s.02,0,.02.02c8.94,6.18,17.88,12.36,26.82,18.52,0,.02.02.02.02.02M1460.15,947.15s.02-.03.03-.05c8.05-11.94,16.11-23.87,24.14-35.81M1445.08,933.49l19.82-30.32M1563.79,1017.87c3.57-.27,6.13-1.34,7.84-2.32,1.1-.62,2.83-1.77,9.46-10.33,3.38-4.38,4.53-6.13,5.15-7.12,3.28-5.22,3.84-7.69,4.07-8.84.43-2.45.26-4.53.05-5.85M1553.53,1039.37v.02c.39,1.41,1.25,3.55,3.07,4.24,2.75,1.03,6.13-1.87,7.96-3.54,12.63-11.5,26.29-31.13,26.29-31.13,11.57-16.61,14.93-19.77,19.15-30,2.27-5.51,3.62-10.26,4.43-13.54M1550.41,911.99c2.95,1.97,5.9,3.93,8.87,5.89M1534.67,917.93s.03.02.05.03c8.7,5.97,17.37,11.94,26.07,17.9,0,.02.02.02.02.02M1398.88,787.71c-1.96-2.42-4.58-5.22-6.02-4.58-1.77.77-.81,6.32-.24,10.86.77,6.19,1.41,15.29.48,27.01M1437.66,1074.43c-2.2-.07-4.67-.03-7.34.22-3.54.33-6.66.93-9.3,1.61M1455.67,1074.91s.09,0,.12.02c.89.09,1.75.17,2.63.26M1274.79,733.83c-2.18-6.26-5.18-13.47-9.34-21.18-4.41-8.13-9.08-14.9-13.35-20.32M1289.76,749.1c-1.03-2.39-2.54-6.14-4.03-10.93-1.34-4.34-1.61-6.13-2.73-9.42-1-2.95-2.73-7.21-5.78-12.13M1328.03,738.02c-.74,1.87-1.94,4.7-3.69,8.03-2.63,4.99-3.95,6.32-4.99,9.01-1.08,2.8-1.89,7.12-.15,13.52M1419.15,1003.16c5.06-1.37,7.95-3.64,9.66-5.54,1.39-1.53,1.94-2.75,4.1-5.3,2.13-2.52,4.14-4.36,5.54-5.56M1415.68,973.73c-.65-8.72-1.06-15.8-1.32-20.51-.76-13.49-.72-17.76-1.82-24.85-1.27-8.24-3.21-14.76-4.58-18.81M1430.25,1163.13c-10.71-1.61-21.43-3.21-32.16-4.82M1330.05,1233.27c-14.76-2.37-29.5-4.74-44.26-7.1h-.02M1466.84,1159.29c-12.18-.22-24.33-.45-36.52-.65h-.02M619.21,791.71c.46-.69.91-1.36,1.34-2.02,7.72-11.63,13.44-21.31,17.38-28.33.46-.81.93-1.61,1.41-2.44,1.82-3.11,3.91-6.47,7.07-11.5.72-1.15,1.51-2.4,2.37-3.76,2.39-3.76,4.22-6.61,5.75-8.8,2.83-4.05,4.63-5.9,6.88-7.17.34-.22.7-.39,1.08-.58,7.86-3.76,16.11-1.1,17.69-.57.91.31,1.73.65,2.47,1.03,2.32,1.15,3.98,2.59,5.85,4.34,1.75,1.65,3.69,3.57,6.52,5.77,6.42,4.99,10.95,6.4,20.56,10.55,2.21.96,4,1.75,5.54,2.47,5.34,2.51,7.72,4.02,14.31,7.46,3.57,1.87,8.37,4.31,15.53,7.77,1,.48,2.01.96,3,1.46,23.39,11.27,46.52,22.12,66.93,26.79,11.34,2.61,22.17,4.08,22.17,4.08,6.78.93,9.13.98,13.56,1.48.79.09,1.63.19,2.57.33,12.89,1.73,18.07,4.08,28.13,6.35,10.76,2.4,18.5,2.8,32.33,3.47,6.8.33,13.99.69,21.79.58,9.25-.12,19.39-.88,30.85-3.04,7.86-1.48,20.37-3.93,35.26-10.67,14.43-6.54,23.9-13.87,28.26-17.13,4.79-3.59,10.57-7.64,17.57-12.08l1.13-.72c4.74-2.97,10-6.11,15.89-9.39,9.73-5.42,21.14-11.24,34.48-17.31M663.3,1069.47c4.63,9.88,6.18,18.34,6.61,24.69.79,11.21-1.58,19.91,2.57,22.27,3.83,2.18,8.8-3.5,13.27-.86.67.39,1.13.84,1.46,1.37,1.39,2.13.82,5.25,3.91,8.8,3.43,3.91,6.69,3,12.61,6.95,3.98,2.63,6.59,5.73,8.19,7.98M967.83,1086.75c6.83,1.42,10.43.03,12.48-1.58,4.15-3.28,3.35-8.63,8.56-12.41,2.73-1.97,5.29-.53,6.86-2.57,1.85-2.42.55-6.26.17-7.48-3.91-12.9,8.51-25.72,6.81-50.45-.74-10.73-3.35-12.39-1.85-20.42,1.51-8.13,5.49-13.33,10.71-20.4,3.69-5.03,8.65-11.86,14.67-20.47,2.39-3.43,4.94-7.12,7.65-11.1M658.35,720.41c-1.42-.09-3.17-.12-5.2-.03-2.44.12-5.27.43-8.36,1.13-2.13.46-4.36,1.12-6.68,1.99-3.52,1.34-6.57,2.99-9.22,4.72-5.41,3.52-8.99,7.38-10.95,9.75M657.7,695.58c-.72,4.2-1.22,9.71-.57,15.99.07.65.15,1.3.24,1.97.31,2.18.76,4.43,1.41,6.74.72,2.68,1.61,5.11,2.56,7.28M657.14,711.57c-2.56-.03-5.63.12-9.06.7-2.23.36-4.26.86-6.06,1.41-1.22.38-2.35.76-3.36,1.15M694.63,702.96c-2.97-2.3-6.38-4.72-10.28-7.07-3.09-1.87-6.07-3.47-8.87-4.8M682.65,727.56c5.41-3.59,11.12-7.67,16.99-12.29,1.25-.96,2.51-1.97,3.78-3,3.93-3.21,7.62-6.42,11.07-9.56,2.66-2.42,5.18-4.8,7.55-7.14M727.7,702c-6.4,4.51-12.94,9.28-19.58,14.35-.86.65-1.7,1.29-2.54,1.96-5.83,4.46-11.45,8.92-16.83,13.35M668.2,693.33c2.59,3.5,6.5,7.98,12.08,12.2,7.36,5.54,14.53,8.32,19.36,9.75M692.38,686.16c2.51,2.73,5.73,5.82,9.73,8.85.43.33.86.65,1.3.98,3.96,2.92,7.76,5.1,11.07,6.73h.02M702.11,695.01c1-.79,2.11-1.78,3.23-2.97,1.58-1.72,2.76-3.38,3.64-4.82M694.63,669.66c7.36,9.03,13.97,11.63,18.65,12.34,1.22.19,2.25.22,3.21.24,2.59.03,4.56-.24,7.79,1.08,6.11,2.52,6.02,6.38,12.41,9.11,2.71,1.13,5.66,1.37,11.57,1.85,6.92.55,10.59.19,13.27.27,5.41.19,13.01,2.39,22.38,11.5M722.04,668.81c1.13,2.95,2.76,5.92,4.96,6.07,2.18.15,2.92-2.63,5.85-3.29,4-.91,6.3,3.38,9.85,3.43,1.24.02,2.76-.48,4.53-2.23,1.96-1.92,4.2-5.35,6.76-11.27M854.82,686.16c1.56,1.94,3.6,4.19,6.25,6.42,3.35,2.81,6.59,4.72,9.22,5.99M849.75,691.08c4.8,5.35,9.46,8.03,12.78,9.47,4.68,2.04,7.67,2.06,15.67,4.43,5.11,1.53,9.18,3.09,11.77,4.15M876.28,711.57c-4.48.81-10.12,2.25-16.3,4.96-4.94,2.18-9.03,4.63-12.24,6.86M960.46,691.08c-6.06,2.75-12.42,5.9-19.01,9.49-2.21,1.22-4.46,2.47-6.73,3.79-8.46,4.91-16.17,9.94-23.13,14.93-3.91,2.78-7.6,5.56-11.05,8.27M935.93,713.2c1.51-.27,3.38-.69,5.53-1.3,5.05-1.44,11.53-4.05,18.09-8.84,8.12-5.9,12.92-12.66,15.5-16.9M930.5,757.44c4.26.17,7.89-.19,10.95-.81,2.92-.58,5.29-1.41,7.17-2.2,8.32-3.48,8.49-7.1,19.7-12.63,6.37-3.14,8.82-3.21,13.61-6.76,1.39-1.03,2.64-2.09,3.74-3.16,2.52-2.44,4.36-4.86,5.63-6.76M987.6,711.57c10.93-.5,14.79-3.59,16.27-6.37.72-1.34.86-2.57,1.03-5.2.14-1.77.29-4.17.67-7.65.41-3.66.84-6.66,1.15-8.63M928.22,791.9c3.07-1.72,7.55-3.98,13.23-6.02.81-.27,1.63-.55,2.47-.82,6.73-2.18,9.56-2.18,15.41-3.64,12.75-3.17,21.9-8.77,25.69-11.14,3.76-2.35,8.55-5.71,13.64-10.43,2.16-1.99,4.39-4.24,6.62-6.76M727.7,716.82c1.48.41,3.17.93,5.06,1.54,3.78,1.25,8.32,2.93,13.35,5.18,9.16,4.07,15.31,7.96,18.41,9.83,8.01,4.84,20.39,11.09,38.95,16.56M705.56,718.28l.02.02c5.68,5.01,13.73,11.6,24.02,18.45.43.29.84.57,1.27.86,1.54,1,3.12,1.99,4.75,3,18.14,11.22,32.83,16.59,61.43,26.89,23.94,8.61,38.13,13.64,58.88,17.78,32.07,6.4,46.99,4.1,50.95,3.41,14.83-2.54,26.55-7.98,34.56-12.6.94-.55,1.84-1.08,2.68-1.6M938.41,803.24c.89-.34,1.9-.72,3.04-1.1,2.99-1,6.8-2.01,11.24-2.54,5.53-.65,9.13-.26,11.34-.21,6.19.12,12.7-2.39,32.76-19.07,6.86-5.7,15.36-13.09,24.78-22.17M1023.55,725.13c4.84-1.63,9.92-3.48,15.19-5.61.67-.26,1.34-.53,2.02-.81,2.78-1.15,5.61-2.37,8.48-3.66,11.07-5.01,20.87-10.31,29.4-15.46M1049.27,685.71c-5.23,2.68-10.69,5.66-16.3,9.01-8.12,4.84-15.46,9.78-22.05,14.6M1048.64,693.86c-1.1.88-2.15,1.66-3.14,2.37-1.96,1.37-3.69,2.42-5.03,3.19-3.5,1.99-5.37,2.61-8.56,4.72-2.83,1.85-4.91,3.71-6.21,4.99M772.99,657.17c-.31,4.96.02,12.27,3.41,20.01,1.68,3.83,3.83,7.14,6.25,9.99,5.58,6.57,12.58,10.74,18.5,13.32,5.94,2.59,10.78,3.59,11.98,3.81M801.15,700.49c.94-.7,2.28-1.75,3.76-3.21,2.73-2.66,5.92-6.68,8-12.2,2.04-5.41,2.27-10.23,2.15-13.27M997.15,697.52c-.6-2.54-1.41-5.49-2.56-8.68-2.27-6.3-5.83-13.54-11.57-20.47-.05-.07-.1-.12-.15-.19-8.25-9.9-13.13-9.71-20.76-19.48-3.04-3.9-4.72-7.07-5.95-10.24-2.45-6.35-3.07-12.66-8.84-24.47-.89-1.84-1.78-3.64-2.64-5.37-.38-.76-.76-1.49-1.13-2.23-.69-1.34-1.39-2.64-2.09-3.91-1.27-2.32-2.59-4.53-4.03-6.62-.93-1.39-1.9-2.71-2.95-4-2.93-3.62-6.35-6.85-10.62-9.63-5.85-3.81-12.06-6.01-19.44-7.53-6.56-1.37-14.04-2.25-23-3.28-7.12-.82-12.06-.96-15.84-.86-13.4.38-23.39,2.99-26.55,3.86-3.86,1.06-12.39,3.66-22.26,8.99-.58.31-1.15.62-1.68.91-.69.38-1.34.72-1.96,1.06-4.74,2.61-7.34,4.29-8.79,6.59-2.51,4-1.82,12.05-.34,28.01.62,6.61,1.24,11.36-.29,17.8-.86,3.62-1.58,4.38-2.78,8.36-.57,1.89-2.04,7.16-2.35,19.27-.17,6.5-.02,15.24,1.27,25.69M815.08,584.31c.12,1.12.24,2.2.34,3.24,1.08,10.79.91,18,.48,22.82-.46,5.22-.31,8.25,0,14.33.09,1.82.26,4.17,1.06,7.07.94,3.29,2.27,5.68,3.21,7.28,7.74,12.96,14,20.34,16.13,22.7.51.57.79.84.79.84,11.63,11.89,21.86,22.34,37.03,23.77,7.91.76,15.15-1.99,27.82-7.65,1.82-.82,3.74-1.7,5.8-2.63,11.38-5.15,20.11-9.46,26.32-19.05,2.8-4.31,4.56-8.91,5.56-12.08.65-2.06.98-3.5,1.06-3.88.36-1.68.58-3.12.76-4.56.31-3,.36-6.06.86-11.34.65-6.98,1.61-12.68,2.35-16.56M868.88,617.24c3.95,1.06,7.24,1.41,9.35,1.53.94.05,1.63.05,2.04.05,1.2,0,4.1-.05,7.91-.77,3.81-.7,8.55-2.09,13.4-4.74,1.9-1.03,3.83-2.09,5.42-3.23,2.23-1.6,3.84-3.4,3.96-5.61.21-3.81-4.05-6.98-7.81-9.25-.89-.55-1.75-1.05-2.52-1.48-4.86-2.78-9.59-4.1-13.45-4.77-2.95-.5-5.39-.62-6.95-.67-.5-.02-1.05-.03-1.65-.03-2.68-.02-6.19.17-10.18,1-2.95.6-6.16,1.54-9.47,3-5.46,2.37-12.18,5.32-12.41,9.78-.22,4.75,7.05,8.58,12.29,11.31,3.35,1.75,6.59,2.95,9.52,3.74.17.07.36.1.53.14ZM868.47,589.46h-.02c-.88.82-6.45,6.19-6.11,14.66.29,7.22,4.72,11.77,6.01,12.99.09.07.15.14.21.19M888.17,617.93c.77-.76,4.75-4.79,5.66-11.24.15-.96.22-1.96.21-3.02-.02-.65-.05-1.29-.15-1.9-.86-7.46-5.89-11.91-6.71-12.63M878.69,503.22c-.07.17-.15.34-.22.53-.79,1.77-2.01,4.14-3.88,6.69-5.06,6.9-8.6,6.49-10.59,11.15-1.32,3.05-.31,4.43.57,15.7.19,2.39.31,4.53.39,6.38.09,1.78.14,3.29.17,4.46M966.75,633.97c-.21-7.72-1.97-13.3-3.48-16.9-.96-2.3-1.77-3.64-2.76-5.22-1.3-2.01-2.93-4.41-5.68-9.66-2.76-5.27-4.67-9.64-6.44-13.68-2.13-4.86-3.81-9.11-5.1-12.48M877.29,613.22c.14.63.53.79.82,1.94.12.53.15.96.27.96s.21-.43.39-.98c.38-1.18.63-1.27.77-1.85.27-1.08-.57-1.41-.69-2.76,0-.05-.02-.1,0-.14-.1-1.49.91-1.68.98-3.47.07-1.63-.77-1.8-.69-3.52.09-1.48.72-1.51.77-2.95.07-1.77-.96-1.96-.82-3.55.17-1.97,1.32-2.75.94-3.71-.22-.53-.69-.45-1.1-1.32-.22-.5-.26-.93-.39-.93-.14.02-.15.45-.34.94-.38,1.01-.98,1.08-1.18,1.66-.38,1.05,1.17,1.66,1.41,3.31.22,1.49-1.17,1.84-1.1,3.55.03,1.41,1.01,1.49,1.1,2.88.1,1.6-1.1,1.85-1.15,3.57-.07,1.73,1.13,2.01.89,3.62-.02.14-.05.26-.09.38-.27,1.05-1.03,1.37-.81,2.35ZM847.74,862.39c.69-3.78,1.36-7.58,1.99-11.41,2.57-15.43,4.75-31.18,6.49-47.26.14-1.32.27-2.64.41-3.98M858.93,828.3c.93,4.75,2.11,9.85,3.64,15.19,1.06,3.69,2.18,7.17,3.36,10.49,1.2,3.41,2.44,6.62,3.71,9.64M703.09,811.17c.84,5.82,3.62,22.7,11.46,38.37,5.71,11.39,14.12,22.15,26.43,27.56,7.81,3.43,17.38,4.77,26.12,5.99,19.41,2.73,34.99,1.17,44.31.17,7.4-.79,17.23-2.23,28.69-5.1M849.75,1103.59c.22-68.78,3.17-105.81,6.13-127.19.46-3.35,1.84-12.9,2.85-26.08,1.92-25.23,1.17-45.9.21-59.51M783.37,898.09c-2.42,6.25-5.58,15.48-8.13,26.96-3.33,14.96-4.91,22.53-1.29,27.83,4.2,6.16,12.73,7.33,27.83,9.42,10.3,1.42,13.56.41,22.26,2.57,7.98,1.97,14.12,5.05,17.98,7.28M867.28,973.87c3.57-1.82,8.97-4.14,15.84-5.58,7.1-1.48,11.63-1.13,15.84-1.29,2.49-.09,27.01-1.22,36.4-14.98,1.2-1.77,3.48-5.68,2.99-29.1-.27-13.33-1.25-24.37-2.13-32.12M777.81,976.43c2.27,7.21,5.41,18.4,7.64,32.35,4.03,25.35,1.6,37.96,3.48,54.57,1.63,14.35,6.86,34.89,23.77,59.08M842.02,1032.95c-3.23-1.77-7.79-4.08-13.42-6.44-4.1-1.7-7.98-3.31-13.04-4.62-4.17-1.06-10.33-2.25-18.07-2.23M907.52,1026.31c-8.68.57-18.43,1.75-28.97,3.93-6.85,1.41-13.18,3.07-18.98,4.84M886.13,1124.57c15.22-21.5,21.48-40.22,24.4-53.09,3.79-16.77,2.54-26.22,6.85-48.38,3.78-19.39,9.11-34.61,12.84-44.1M952.91,1011.11l-11.46,8.32-15.51,11.27M943.36,1072.77c-.6.74-1.25,1.53-1.9,2.39-3.41,4.41-7.38,10.45-10.67,18.12-2.69,6.26-3.26,9.71-6.13,17.59-2.08,5.71-5.3,13.57-10.28,22.7M783.37,1131.42c-5.49-10.52-8.53-19.41-10.28-25.48-3-10.36-3.41-16.66-7.98-25.95-3.4-6.88-7.33-11.89-10-14.93M752.55,1006.41c2.44,3.47,5.53,7.36,9.4,11.34,3.35,3.43,6.64,6.25,9.64,8.56M874.99,874.96c20.3,3.91,37.46,5.41,50.09,6.01,6.33.29,11.72.36,16.37.26,15.74-.29,22.75-2.51,27.73-4.55,4.89-2.01,14.29-6.54,23.12-15.41,9.27-9.32,14.41-19.96,17.3-29.21,2.4-7.67,3.23-14.38,3.55-18.6.07-.88.1-1.63.14-2.28M794.51,1056.07c4.07,3.5,10.31,8.07,18.83,11.55,11.07,4.55,20.95,5.22,26.98,5.15M859.15,1073.62c9.94-.19,17.66-.29,24.83-.34,4.62-.03,9.64-.03,15.41-2.66,3.28-1.49,5.7-3.33,7.28-4.7M722.14,1125c31.28,8.7,75.71,17.47,129.3,16.7,23-.33,44.22-2.39,63.36-5.35,9.4-1.46,18.29-3.14,26.65-4.96,11.72-2.54,22.38-5.32,31.87-8.1M755.1,905.21l10.42,9.71M763.24,924.34l-13.69-12.85M760.32,937.75l-14.21-14.83M965.9,898.09c-3.17.53-7.24,1.51-11.7,3.41-4.2,1.8-7.57,3.9-10.07,5.71M949.05,916.64l7.43-5.15M949.05,928.91l19.97-12.27M739.44,893.04c-.89,6.42-1.66,13.08-2.28,19.97-1.25,13.88-1.75,26.99-1.72,39.23M1009.54,831.71l.05.34,11.98,75.54M709.18,910.44l5.37-60.9.1-1.2M985.18,943.2v-53.18M637.37,834.71c1.48,3.09,3.72,7.05,7.14,11.14,3.21,3.83,6.49,6.61,9.13,8.56M633.95,924.34c1.12-2.78,2.93-7.09,5.42-12.27,1-2.08,1.9-3.91,2.76-5.58,4.6-8.85,7.62-12.77,12.22-21.98,3.84-7.71,5.94-13.45,9.7-23.72,3.74-10.19,6.47-19.1,8.43-26.08M642.82,928.57c3.59-9.23,7.24-16.53,10.24-21.91,4.03-7.28,5.99-9.54,9.06-16.71,3.76-8.79,4.19-13.23,8.07-23.25,2.76-7.12,5.56-12.68,7.41-16.13M653.21,982c-4.26-11.17-9.63-16.7-13.83-19.7-.96-.69-2.27-1.51-3.9-2.66-1.42-1.03-3.12-2.28-5.1-3.91-4-3.29-6.97-6.35-8.85-8.41M613.39,964.65c-1.06,1.05-2.35,2.4-3.59,4.12-1.12,1.48-2.2,3.23-3.12,5.23-2.33,5.05-2.63,9.37-2.85,11.55-.02.21-.05.41-.09.62-.38,3.28-1.27,7.34-3.21,12.24-1.34,3.41-3.21,7.21-5.77,11.41M591.56,1073.62c1.39-15.36,5.1-24.21,8.41-29.55,1-1.58,3.52-5.37,4.14-10.85.21-1.77.19-3.45.02-5.03-.33-2.99-1.18-5.58-2.01-7.53M611.9,1083.04c1.53-3.6,3.59-9.78,3.05-17.42-.63-9.4-5.11-20.47-8.84-20.27-2.56.14-5.8,5.61-8.79,29.55M621.53,964.65c-2.42,3.23-5.58,8-8.27,14.21-1.41,3.23-2.45,6.32-3.26,9.32-.69,2.63-1.2,5.18-1.56,7.71-.72,4.93-.98,9.71-1.18,14.66-.27,6.37-.51,11.94-.03,17.37.46,5.03,1.53,9.92,3.76,15.17,2.63,6.19,5.95,10.78,8.41,13.69M1112.18,983.93c-.57,5.68-.76,12.03-.29,18.91.05.86.12,1.7.21,2.54.74,8.01,2.27,15.41,4.24,22.07,3.43,11.58,8.15,21.02,12.24,27.92M1107.46,1086.75c1.12-.22,9.94-8,13.83-11.46,1.06-.94,1.75-1.58,1.84-1.65l.02-.02M1103.48,1082.75c2.33-.89,5.68-2.47,9.13-5.29,1.99-1.61,3.57-3.31,4.77-4.84.86-1.05,1.54-2.02,2.08-2.87,4.17-8.15,4.02-13.95,3.14-17.69-1.39-5.9-4.58-6.88-7.71-15.27-1.65-4.43-2.13-7.83-2.52-10.19-.36-2.16-.67-3.43-1.77-3.79-.79-.26-1.94,0-3.64,1.49-2.09,1.84-5.03,5.56-9.2,12.49M1078.24,937.75c-.89-6.02-2.49-15.24-5.44-26.26-2.92-10.78-6.02-19.2-12.94-35.13-3.29-7.62-7.46-16.95-12.9-29.09-4.44-9.95-9.8-21.9-13.56-30.25M1091.62,943.2c-.41-7.02-1.7-18.1-6.13-30.85-5.1-14.62-10.64-20.73-17.56-35.81-.91-1.97-1.89-4.22-2.9-6.71-3.14-7.72-6.59-17.88-9.23-30.41M1085.63,818.88c-2.88,2.71-5.92,5.85-8.99,9.42-3.33,3.88-6.16,7.64-8.56,11.12M1070.65,973.87c7.76-7.55,14.62-11.79,19.55-14.28,2.57-1.3,6.25-2.93,10.31-6.5,4.02-3.5,6.57-7.24,8.1-9.88M1090.63,1037.23c2.15-1.72,4.93-4.24,7.71-7.71,1.2-1.49,2.97-3.74,4.68-6.86M611.25,1098.23c2.11-4.74,4.26-10.43,6.01-16.97,1.92-7.26,2.92-13.85,3.41-19.41M735.44,758.16c-4.58,3.31-9.52,7.24-14.59,11.91-1.63,1.51-3.19,3-4.68,4.5-3.91,3.93-7.34,7.76-10.3,11.34M723.86,793.19c2.21-1.46,4.53-3.07,6.92-4.82,3.07-2.28,6.25-4.8,9.49-7.6,5.32-4.6,9.87-9.13,13.71-13.37l.02-.02M1078.24,799.74c.38-6.64-.15-12.05-.74-15.84-.7-4.58-1.7-8.15-3.6-14.96-1.34-4.79-2.56-8.73-3.47-11.5M671.48,735.96c-2.85,1.73-6.92,4.6-10.71,9.13-.31.38-.67.82-1.05,1.32-1.54,2.01-3.52,5.08-5.39,9.71-1.06,2.66-2.11,5.83-2.99,9.63-.1.39-.19.79-.27,1.18-3.79,17.13-1.82,33.43.19,43.69.19.84.34,1.65.51,2.4M627.57,813.02c1.9,7.09,2.35,12.63,1.53,15.68v.02c-.76,2.78-1.77,5.03-1.77,5.03-2.13,4.5-5.01,6.8-9.64,16.66-1.2,2.56-2.16,4.96-3,7.48-1.92,5.89-3.07,12.42-4.8,23.24-3.83,23.9-4.98,34.24-6.23,43.04-.55,3.91-1.12,7.52-1.96,11.88-.1.51-.21,1.03-.29,1.51-2.59,13.01-4.82,18.12-7.19,24.39-1.73,4.58-3.54,9.8-5.65,19.2-.19.86-.38,1.72-.55,2.56-1.18,5.65-2.06,10.98-2.69,16.34-.02.19-.03.38-.07.55-1.03,8.96-1.41,17.98-1.48,28.54-.05,7.12.03,14.95.15,23.92.03,1.32.05,2.66.07,4.02.03,2.61.09,5.17.15,7.64.39,14.28,1.29,26.39,2.18,35.78.86,8.94,1.73,15.38,2.23,18.81,1.82,12.8,3.91,23.66,5.71,31.97h40.52c8.7-16.82,14.45-31.8,18.28-43.38,2.21-6.71,6.81-21.26,10.23-38.41,1.99-10.07,3.59-21.02,4.05-31.82.17-4.27.46-15.1,0-28.54-.41-11.89-.93-12.01-.86-15.99.43-25.62,22.07-30.94,34.53-66.22,2.39-6.71,4.77-15.51,8-15.41,3.04.1,3.78,8.08,10.28,17.69,4.02,5.95,8.49,9.97,11.62,12.42,3.09,7.93,6.64,18.83,8.92,32.11,2.64,15.29,4.55,26.41,2.01,40.53-2.76,15.31-8.85,23.46-5.42,37.1,1.22,4.84,3.16,8.55,4.56,10.85.48,5.23.51,12.15-1.15,19.99-.77,3.72-1.82,7.05-2.9,9.92-3.52,4.1-8.12,10.47-11.36,19.19-1.92,5.13-2.92,9.83-3.43,13.71-3.41,5.23-6.83,10.45-10.23,15.68-2.3,3.52-4.6,7.05-6.9,10.57h279.15l-.02-.03-10.83-27.94c1.41-14.09-.91-24.4-3.43-31.4-.67-1.85-1.37-3.55-2.06-5.13-3.43-7.81-6.69-12.7-4.79-19.41,1.65-5.77,5.46-7.02,8.29-15.14,1.94-5.59,2.09-10.67,1.92-14.12-1.65-8.82-2.73-16.22-3.43-21.62-1.63-12.51-1.37-15.14-1.06-17.06.6-3.74,1.41-4.99,5.94-17.73,1.75-4.89,2.97-7.98,3.76-10.81,4.65-16.58,1.99-21.38,6.73-27.66.26-.34.53-.69.84-1.03,6.01-6.95,10.74-4.02,19.55-11.55,11.69-10,11.5-22.15,15.86-21.98,4.51.17,5.94,14.26,12.48,31.21,1,2.57,2.11,5.22,3.36,7.89.03.09.07.17.12.24,6.9,14.55,15.87,24.97,22.7,31.73-2.99,12.12-4.46,22.77-5.15,31.56-.34,4.19-.5,7.95-.55,11.24-.14,8.12.29,13.52,1,21.73.65,7.53,1.54,17.44,2.42,33.94.09,1.77.19,3.43.26,4.99.6,11.38.91,17.95.6,24.69-.39,8.97-1.34,17.31-2.61,24.9-1.06,6.42-2.35,12.32-3.74,17.64-.07.29-.14.57-.21.84h47.95l10.73-36.09,12.36-41.53,5.44-18.28,4.58-15.43c1.75-8.32,3.45-18.43,4.41-30.03.34-4.26.6-8.72.74-13.35.09-3.02.19-6.47.19-10.3,0-5.77-.19-12.41-.89-19.84-.53-5.53-1.36-11.5-2.59-17.85-.27-1.36-.55-2.73-.86-4.12-2.59-11.91-3.48-10.35-7.95-27.13-6.25-23.46-6.38-33.51-10.06-51.12-.29-1.46-.62-2.95-.98-4.51-2.52-11.19-6.95-27.39-15.12-46.68,1.85-6.16,3.86-15.08,3.78-25.9-.03-3.59-.26-6.38-.57-9.06-.43-3.88-.98-7.52-1.13-12.99-.21-6.62.19-15.8,2.78-26.94,2.83-5.66,4.43-10.18,5.15-13.76,1.18-5.75.19-9.18-1.44-11.36-1.65-2.2-3.16-2.06-10.73-5.42-.41-.17-.82-.36-1.27-.57-10.62-4.84-11.51-6.74-17.98-9.42-.45-.19-.91-.38-1.42-.57-10.23-3.93-11.21-1.36-18.26-4.56-5.01-2.28-7.17-5.13-9.2-8.07-2.21-3.21-4.26-6.54-9.64-9.35-.12-.07-.24-.12-.36-.19-4.94-2.49-9.63-3.04-18.76-4.08-7.24-.84-13.35-.81-17.71-.58-2.85-6.37-6.71-15.43-10.85-26.55-4.84-13.04-7.28-19.58-8.27-25.96-.91-5.8-.39-6.73-.86-32.83-.24-13.42-.39-14.67-.63-16.1-.81-4.68-3.04-17.78-12.78-27.58-.46-.46-1.37-1.08-2.75-1.89-4.07-2.37-12.24-6.35-25.23-12.66-.15-.07-.31-.15-.46-.22-1.12-.55-2.16-1.05-3.14-1.53-7.34-3.57-10.86-5.18-14.4-6.74l-.82-.36c-5.27-2.3-9.87-4.15-13.2-5.46-2.44-.96-4.2-1.63-5.08-1.96-6.95-2.59-15.8-5.63-26.34-8.6-.63-.17-1.27-.36-1.92-.53-16.53,11.05-30.82,17.8-41.1,21.97-12.99,5.29-23.87,8.22-33.39,19.13-5.9,6.76-8.58,13.52-9.99,17.13-2.9,7.45-3.88,14.14-4.07,20.97-.19,6.33.33,12.8.65,20.13.48,11.19.63,27.49-1.15,47.95-3.83,2.18-8.7,4.62-14.52,6.68-4.58,1.65-9.75,3.04-15.44,3.9-1.24.19-2.42.34-3.55.45-12.03,1.25-19.05-.98-31.76.38-.86.09-1.75.19-2.66.31-4.8.67-8.96,1.63-13.04,2.93-3.88,1.22-7.67,2.73-11.89,4.53-2.02.88-4.17,1.8-6.45,2.81-5.25,2.3-10.16,4.74-14.71,7.19-13.42,7.26-23.66,14.78-30.36,20.2-2.21,1.78-4.03,3.35-5.46,4.58-4.14,3.6-7.96,6.92-11.46,10-1.97,1.75-3.83,3.43-5.56,5.05-10.49,9.78-16.85,17.78-17.47,27.54-.05.63-.05,1.27-.05,1.92.07,4.86,1.48,10.45,2.88,14.91.86,2.73,1.72,5.03,2.27,6.5,2.64,7.16,5.8,12.96,8.55,17.35.6.94,1.17,1.82,1.72,2.63.24.46.46.91.69,1.36,3.96,7.88,6.71,15.19,8.36,21.31ZM687.2,1116.95c.31,6.86.33,14.43-.15,22.58-.74,12.65-4.91,19.32-2.28,21.43,1.78,1.42,6.52.86,20.25-9.71"/>
      </g>
      <polyline class="cls-1" points="270.6 1145.4 .5 1145.4 .5 .5 1780.5 .5 1780.5 1145.4 270.6 1145.4"/>
    </g>
  </g>
</svg>

================
File: components/auth/AuthScreen.jsx
================
import React from 'react';
import { Login } from './Login';

export function AuthScreen() {
  return <Login />;
}

================
File: components/auth/index.js
================
export { AuthScreen } from './AuthScreen';
export { Login } from './Login';

================
File: components/auth/Login.jsx
================
import React, { useState } from 'react';
import { useAuth } from '../../context/AuthContext';
import emptyStateSvg from '../../assets/SVG/emptyState.svg';

export function Login() {
  const { login, error, clearError, loading } = useAuth();
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = async (e) => {
    e.preventDefault();
    clearError();
    await login(username, password);
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-stone-950">
      <div className="bg-stone-950 p-8 rounded-lg w-full max-w-md">
      <div className="flex justify-center mb-4">
          <img 
            src={emptyStateSvg} 
            alt="Empty State" 
            className="h-auto"
          />
        </div>
        <h2 className="text-2xl font-bold text-teal-500 mb-6 text-center">SLUMNET</h2>
        
        {error && (
          <div className="bg-red-900 text-white p-3 rounded mb-4">
            {error}
          </div>
        )}
        
        
        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label className="block text-stone-300 mb-2 font-mono text-sm" htmlFor="username">
              Username
            </label>
            <input
              id="username"
              type="text"
              className="w-full p-2 rounded bg-stone-800 text-white border border-stone-600 focus:border-teal-500 focus:outline-none font-mono text-sm"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              required
            />
          </div>
          
          <div className="mb-6">
            <label className="block text-stone-300 mb-2 font-mono text-sm" htmlFor="password">
              Password
            </label>
            <input
              id="password"
              type="password"
              className="w-full p-2 rounded bg-stone-800 text-white border border-stone-600 focus:border-teal-500 focus:outline-none font-mono text-sm"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
          </div>
          
          <button
            type="submit"
            className="w-full bg-teal-600 hover:bg-teal-700 text-white font-mono text-sm py-2 px-4 rounded focus:outline-none focus:shadow-outline"
            disabled={loading}
          >
            {loading ? 'Logging in...' : 'Login'}
          </button>
        </form>
        
        <div className="mt-4 text-center">
          <p className="text-stone-400 text-sm font-mono">
            Are ya in the know?
          </p>
        </div>
      </div>
    </div>
  );
}

================
File: components/auth/Register.jsx
================
import React, { useState } from 'react';
import { useAuth } from '../../context/AuthContext';

export function Register({ onSwitchToLogin }) {
  const { register, error, clearError, loading } = useAuth();
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [passwordError, setPasswordError] = useState('');
  const [success, setSuccess] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    clearError();
    setPasswordError('');
    
    // Validate passwords match
    if (password !== confirmPassword) {
      setPasswordError('Passwords do not match');
      return;
    }
    
    // Validate password strength
    if (password.length < 8) {
      setPasswordError('Password must be at least 8 characters long');
      return;
    }
    
    const result = await register(username, email, password);
    if (result.success) {
      setSuccess(true);
      // Reset form
      setUsername('');
      setEmail('');
      setPassword('');
      setConfirmPassword('');
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-900">
      <div className="bg-gray-800 p-8 rounded-lg shadow-lg w-full max-w-md">
        <h2 className="text-2xl font-bold text-teal-500 mb-6 text-center">Create an Account</h2>
        
        {error && (
          <div className="bg-red-900 text-white p-3 rounded mb-4">
            {error}
          </div>
        )}
        
        {passwordError && (
          <div className="bg-red-900 text-white p-3 rounded mb-4">
            {passwordError}
          </div>
        )}
        
        {success && (
          <div className="bg-green-900 text-white p-3 rounded mb-4">
            Registration successful! You can now login.
          </div>
        )}
        
        <form onSubmit={handleSubmit}>
          <div className="mb-4">
            <label className="block text-gray-300 mb-2" htmlFor="username">
              Username
            </label>
            <input
              id="username"
              type="text"
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:border-teal-500 focus:outline-none"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              required
            />
          </div>
          
          <div className="mb-4">
            <label className="block text-gray-300 mb-2" htmlFor="email">
              Email
            </label>
            <input
              id="email"
              type="email"
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:border-teal-500 focus:outline-none"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              required
            />
          </div>
          
          <div className="mb-4">
            <label className="block text-gray-300 mb-2" htmlFor="password">
              Password
            </label>
            <input
              id="password"
              type="password"
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:border-teal-500 focus:outline-none"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
            />
            <p className="text-gray-400 text-xs mt-1">Must be at least 8 characters long</p>
          </div>
          
          <div className="mb-6">
            <label className="block text-gray-300 mb-2" htmlFor="confirmPassword">
              Confirm Password
            </label>
            <input
              id="confirmPassword"
              type="password"
              className="w-full p-2 rounded bg-gray-700 text-white border border-gray-600 focus:border-teal-500 focus:outline-none"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              required
            />
          </div>
          
          <button
            type="submit"
            className="w-full bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
            disabled={loading}
          >
            {loading ? 'Registering...' : 'Register'}
          </button>
        </form>
        
        <div className="mt-4 text-center">
          <button
            onClick={onSwitchToLogin}
            className="text-teal-400 hover:text-teal-300 text-sm"
          >
            Already have an account? Login
          </button>
        </div>
      </div>
    </div>
  );
}

================
File: components/CommandBar.jsx
================
import React, { useEffect, useRef } from 'react';
import { useAnnouncement } from '../context/AnnouncementContext';

export const CommandBar = ({ 
  currentWorkspaceIndex = 0,
  switchWorkspace,
  user,
  onLogout
}) => {
  console.log('CommandBar render, currentWorkspaceIndex:', currentWorkspaceIndex);
  const { announcement } = useAnnouncement();
  const announcementRef = useRef(null);
  const containerRef = useRef(null);

  // Carousel effect for long announcements with consistent speed
  useEffect(() => {
    if (!announcement || !announcementRef.current || !containerRef.current) return;
    
    const textElement = announcementRef.current;
    const containerElement = containerRef.current;
    const isOverflowing = textElement.scrollWidth > containerElement.clientWidth;
    
    if (isOverflowing) {
      // Fixed animation duration of 15 seconds
      textElement.style.animation = 'scroll-text 40s linear infinite';
    } else {
      textElement.style.animation = 'none';
    }
  }, [announcement]);

  return (
    <div className="w-full bg-stone-800 p-2 flex items-center gap-2">
      <div className="flex gap-2 items-center pr-2 border-r border-stone-600">
        <div className={`rounded-full cursor-pointer ${currentWorkspaceIndex === 0 ? 'w-3 h-3 bg-teal-400' : 'w-2 h-2 bg-stone-600 hover:bg-stone-500'}`} onClick={() => typeof switchWorkspace === 'function' && switchWorkspace(0)} />
        <div className={`rounded-full cursor-pointer ${currentWorkspaceIndex === 1 ? 'w-3 h-3 bg-teal-400' : 'w-2 h-2 bg-stone-600 hover:bg-stone-500'}`} onClick={() => typeof switchWorkspace === 'function' && switchWorkspace(1)} />
        <div className={`rounded-full cursor-pointer ${currentWorkspaceIndex === 2 ? 'w-3 h-3 bg-teal-400' : 'w-2 h-2 bg-stone-600 hover:bg-stone-500'}`} onClick={() => typeof switchWorkspace === 'function' && switchWorkspace(2)} />
        <div className={`rounded-full cursor-pointer ${currentWorkspaceIndex === 3 ? 'w-3 h-3 bg-teal-400' : 'w-2 h-2 bg-stone-600 hover:bg-stone-500'}`} onClick={() => typeof switchWorkspace === 'function' && switchWorkspace(3)} />
      </div>
      
      {/* Announcement section with improved container */}
      <div ref={containerRef} className="flex-1 announcement-container">
        {announcement ? (
          <div 
            ref={announcementRef}
            className="announcement-text text-teal-300 text-sm font-mono"
          >
            {announcement}
          </div>
        ) : (
          <div className="text-gray-500 text-sm font-mono italic">No announcements</div>
        )}
      </div>
      
      {/* User info and logout */}
      {user && (
        <div className="flex items-center border-l border-stone-600 ml-2 pl-2">
          <span className="text-white text-sm font-mono mr-2">
            {user?.username || 'User'}
          </span>
          <button 
            onClick={onLogout}
            className="bg-stone-700 hover:bg-stone-600 text-white text-sm px-2 py-1 rounded"
          >
            Logout
          </button>
        </div>
      )}
    </div>
  );
};

export default CommandBar;

================
File: components/EmptyState.jsx
================
import React from 'react';
import emptyStateSvg from '../assets/SVG/emptyState.svg';

export const EmptyState = () => (
  <div className="absolute inset-0 flex flex-col items-center justify-center bg-stone-950">
    <img 
      src={emptyStateSvg} 
      alt="Empty State" 
      className="w-1/4 h-auto"
    />
    <h2 className="text-xl font-semibold text-teal-400 mt-4">SLUMNET</h2>
  </div>
);

export default EmptyState;

================
File: components/WindowManager.jsx
================
import React, { useState, useCallback, useEffect } from 'react';
import { WINDOW_CONTENT, WINDOW_TYPES } from '../utils/windowTypes';
import { getWindowBounds } from '../utils/windowUtils';
import { useWindowManager } from '../hooks/useWindowManager';
import { useKeyboardShortcuts } from '../hooks/useKeyboardShortcuts';
import { CommandBar } from './CommandBar';
import EmptyState from './EmptyState';

export const WindowManager = ({ defaultLayout = null }) => {
  const [dragState, setDragState] = useState(null);
  const [notification, setNotification] = useState(null);
  const [flashingWindowIds, setFlashingWindowIds] = useState(new Set());
  
  // Function to flash a window's border red
  const flashWindowBorder = useCallback((windowId) => {
    setFlashingWindowIds(prev => {
      const newSet = new Set(prev);
      newSet.add(windowId);
      return newSet;
    });
    
    // Remove the window from flashing state after 500ms
    setTimeout(() => {
      setFlashingWindowIds(prev => {
        const newSet = new Set(prev);
        newSet.delete(windowId);
        return newSet;
      });
    }, 200);
  }, []);

  const {
    rootNode,
    activeNodeId,
    setActiveNodeId,
    terminalStates,
    updateTerminalState,
    splitWindow,
    createNewWindow,
    closeWindow,
    transformWindow,
    currentWorkspaceIndex,
    workspaceCount,
    switchWorkspace,
    isResizeMode,
    setIsResizeMode,
    resizeActiveWindow,
    isMoveMode,
    setIsMoveMode,
    moveSourceWindowId,
    setMoveSourceWindowId,
    swapWindows
  } = useWindowManager({ 
    defaultLayout,
    onFlashBorder: flashWindowBorder
  });
  
  // Override window.alert to use our notification system
  useEffect(() => {
    const originalAlert = window.alert;
    window.alert = (message) => {
      console.log('Alert:', message);
      
      // If the message is about splitting or creating windows, flash the active window border
      if (message.includes('split') || message.includes('create')) {
        if (activeNodeId) {
          flashWindowBorder(activeNodeId);
        }
      } else {
        // For other alerts, show the notification
        setNotification(message);
        setTimeout(() => setNotification(null), 3000); // Hide after 3 seconds
      }
    };
    
    return () => {
      window.alert = originalAlert;
    };
  }, [activeNodeId, flashWindowBorder]);

  // Log when component mounts
  useEffect(() => {
    console.log('WindowManager component mounted');
    console.log('setIsMoveMode is a function:', typeof setIsMoveMode === 'function');
    console.log('Initial isMoveMode state:', isMoveMode);
  }, [isMoveMode]);
  
  // Log move mode state changes
  useEffect(() => {
    console.log('Move mode changed to:', isMoveMode);
  }, [isMoveMode]);

  // Add keyboard shortcuts
  useKeyboardShortcuts({
    onSplitVertical: () => splitWindow(activeNodeId, 'vertical'),
    onSplitHorizontal: () => splitWindow(activeNodeId, 'horizontal'),
    onClose: () => closeWindow(activeNodeId),
    createNewWindow,
    hasActiveWindow: Boolean(activeNodeId),
    hasRootNode: Boolean(rootNode),
    isResizeMode,
    setIsResizeMode,
    resizeActiveWindow,
    isMoveMode,
    setIsMoveMode,
    moveSourceWindowId,
    setMoveSourceWindowId,
    swapWindows,
    activeNodeId
  });

  // Command handling for terminal
  const handleCommand = useCallback((command) => {
    const parts = command.split(' ');
    const cmd = parts[0].toLowerCase();

    switch (cmd) {
      case 'split':
        if (activeNodeId) {
          const direction = parts[1] === 'vertical' ? 'vertical' : 'horizontal';
          splitWindow(activeNodeId, direction);
        }
        break;
      case 'close':
        if (activeNodeId) {
          closeWindow(activeNodeId);
        }
        break;
    }
  }, [activeNodeId, splitWindow, closeWindow]);

  // Resize handling
  const handleResizeStart = useCallback((e, split) => {
    e.preventDefault();
    e.stopPropagation();
    const rect = e.currentTarget.getBoundingClientRect();
    setDragState({
      split,
      initialPos: {
        x: e.clientX,
        y: e.clientY
      },
      initialRatio: split.splitRatio
    });
  }, []);

  // Helper function to convert percentage-based bounds to pixel dimensions
  const calculatePixelDimensions = useCallback((bounds) => {
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    
    return {
      width: (bounds.width / 100) * windowWidth,
      height: (bounds.height / 100) * windowHeight
    };
  }, []);
  
  // Helper function to check if a window tree would have any windows smaller than the minimum size
  const hasWindowsBelowMinSize = useCallback((root) => {
    if (!root) return false;
    
    // Import constants directly here to avoid dependency issues
    const MIN_WINDOW_WIDTH_PX = 300;
    const MIN_WINDOW_HEIGHT_PX = 200;
    
    // Calculate the bounds of all windows
    const allWindows = getWindowBounds(root);
    
    // Check if any window would be smaller than the minimum size
    return allWindows.some(window => {
      const pixelDimensions = calculatePixelDimensions(window.bounds);
      const isTooSmall = pixelDimensions.width < MIN_WINDOW_WIDTH_PX || 
                         pixelDimensions.height < MIN_WINDOW_HEIGHT_PX;
      
      if (isTooSmall) {
        console.log('Window too small:', window.id);
        console.log('Dimensions:', pixelDimensions);
      }
      
      return isTooSmall;
    });
  }, [calculatePixelDimensions]);

  const handleResizeMove = useCallback((e) => {
    if (!dragState) return;

    const { split, initialPos, initialRatio } = dragState;
    const delta = split.direction === 'horizontal' 
      ? (e.clientX - initialPos.x) / window.innerWidth 
      : (e.clientY - initialPos.y) / window.innerHeight;

    const newRatio = Math.max(0.1, Math.min(0.9, initialRatio + delta));
    
    // Store the original ratio
    const originalRatio = split.splitRatio;
    
    // Apply the new ratio
    split.splitRatio = newRatio;
    
    // Check if this would result in windows that are too small, but don't block the resize
    if (hasWindowsBelowMinSize(rootNode)) {
      console.log('Windows are below minimum size, but resize is allowed');
    }
    
    // If we get here, the resize is allowed
    // Force a re-render
    setDragState(prev => ({ ...prev }));
  }, [dragState, rootNode, hasWindowsBelowMinSize, activeNodeId, flashWindowBorder]);

  const handleResizeEnd = useCallback(() => {
    setDragState(null);
  }, []);

  useEffect(() => {
    if (dragState) {
      window.addEventListener('mousemove', handleResizeMove);
      window.addEventListener('mouseup', handleResizeEnd);
      return () => {
        window.removeEventListener('mousemove', handleResizeMove);
        window.removeEventListener('mouseup', handleResizeEnd);
      };
    }
  }, [dragState, handleResizeMove, handleResizeEnd]);

  // Window tree renderer
  const WindowTreeRenderer = ({ node, depth = 0, available = { x: 0, y: 0, width: 100, height: 100 } }) => {
    if (!node) return null;

    if (node.type === 'window') {
      const windowContent = WINDOW_CONTENT[node.windowType];
      if (!windowContent) {
        console.error('No window content found for type:', node.windowType);
        return null;
      }
      const Component = windowContent.component;
      const isActive = node.id === activeNodeId;
  
      // Check if this window is currently flashing
      const isFlashing = flashingWindowIds.has(node.id);
      
      // Check if this is the first selected window in move mode
      const isFirstSelectedWindow = isMoveMode && moveSourceWindowId === node.id;
      
      return (
        <div
          className={`absolute overflow-hidden border-2 ${
            isFlashing ? 'border-red-600' : 
            isFirstSelectedWindow ? 'border-blue-300' :
            isActive ? (
              isMoveMode ? 'border-green-500' : 
              isResizeMode ? 'border-yellow-500' : 
              'border-teal-500'
            ) : 'border-stone-600'
          } ${isFlashing ? 'animate-pulse' : ''}`}
          style={{
            left: `${available.x}%`,
            top: `${available.y}%`,
            width: `${available.width}%`,
            height: `${available.height}%`,
            transition: 'border-color 0.2s ease-in-out'
          }}
          onClick={() => setActiveNodeId(node.id)}
        >
          <Component 
            key={`window-${node.id}-${node.windowType}`}
            onCommand={handleCommand} 
            isActive={isActive}
            nodeState={node.state}
            nodeId={node.id}
            transformWindow={transformWindow}
            windowState={node.windowType === WINDOW_TYPES.TERMINAL ? terminalStates[node.id] : node.state}
            updateWindowState={(newState) => {
              updateTerminalState(node.id, newState);
            }}
          />
        </div>
      );
    }

    // Calculate split dimensions
    let firstDimensions, secondDimensions;
    if (node.direction === 'horizontal') {
      firstDimensions = {
        x: available.x,
        y: available.y,
        width: available.width * node.splitRatio,
        height: available.height
      };
      secondDimensions = {
        x: available.x + (available.width * node.splitRatio),
        y: available.y,
        width: available.width * (1 - node.splitRatio),
        height: available.height
      };
    } else {
      firstDimensions = {
        x: available.x,
        y: available.y,
        width: available.width,
        height: available.height * node.splitRatio
      };
      secondDimensions = {
        x: available.x,
        y: available.y + (available.height * node.splitRatio),
        width: available.width,
        height: available.height * (1 - node.splitRatio)
      };
    }

    return (
      <div className="absolute inset-0" style={{ pointerEvents: 'none' }}>
        <WindowTreeRenderer 
          node={node.first} 
          depth={depth + 1} 
          available={firstDimensions} 
        />
        <div
          className="absolute bg-stone-700 hover:bg-stone-500 transition-colors"
          style={{
            left: node.direction === 'horizontal' ? `${firstDimensions.width}%` : 0,
            top: node.direction === 'vertical' ? `${firstDimensions.height}%` : 0,
            width: node.direction === 'horizontal' ? '4px' : '100%',
            height: node.direction === 'vertical' ? '4px' : '100%',
            cursor: node.direction === 'horizontal' ? 'col-resize' : 'row-resize',
            pointerEvents: 'auto',
            zIndex: 10
          }}
          onMouseDown={(e) => handleResizeStart(e, node)}
        />
        <WindowTreeRenderer 
          node={node.second} 
          depth={depth + 1} 
          available={secondDimensions}
        />
      </div>
    );
  };

  return (
    <div className="w-full h-screen flex flex-col">
      <CommandBar
        onCommand={handleCommand}
        currentWorkspaceIndex={currentWorkspaceIndex}
        switchWorkspace={switchWorkspace}
      />
      <div className="flex-1 relative bg-stone-900">
        {rootNode ? (
          <WindowTreeRenderer
            node={rootNode}
            terminalStates={terminalStates}
            updateTerminalState={updateTerminalState}
          />
        ) : (
          <EmptyState />
        )}
        
        {/* Notification system */}
        {notification && (
          <div 
            className="absolute top-4 left-1/2 transform -translate-x-1/2 bg-red-500 text-white px-4 py-2 rounded shadow-lg z-50"
            style={{ maxWidth: '80%' }}
          >
            {notification}
          </div>
        )}
      </div>
    </div>
  );
};

export default WindowManager;

================
File: components/windows/AdminWindow.jsx
================
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import API_CONFIG from '../../config/api';
import { useAuth } from '../../context/AuthContext';
import { Trash } from 'lucide-react'; // Import Trash icon

const AdminWindow = ({ isActive }) => {
  const { user } = useAuth();
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [editingUser, setEditingUser] = useState(null);
  const [showCreateForm, setShowCreateForm] = useState(false);
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    is_admin: false
  });
  const [createFormData, setCreateFormData] = useState({
    username: '',
    email: '',
    password: '',
    is_admin: false
  });
  
  // Chat channels state
  const [activeTab, setActiveTab] = useState('users'); // 'users' or 'channels'
  const [channels, setChannels] = useState([]);
  const [channelLoading, setChannelLoading] = useState(false);
  const [channelError, setChannelError] = useState(null);
  const [newChannelName, setNewChannelName] = useState('');
  const [showCreateChannelForm, setShowCreateChannelForm] = useState(false);

  // Fetch users when component mounts or becomes active
  useEffect(() => {
    if (isActive) {
      fetchUsers();
    }
  }, [isActive]);
  
  // Load channels when tab changes to channels
  useEffect(() => {
    if (isActive && activeTab === 'channels') {
      fetchChannels();
    }
  }, [isActive, activeTab]);
  
  // Reset form visibility when switching tabs
  useEffect(() => {
    // Hide forms when switching tabs
    setShowCreateForm(false);
    setShowCreateChannelForm(false);
  }, [activeTab]);

  // Fetch all users from the API
  const fetchUsers = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem('auth_token');
      const response = await axios.get(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.USERS}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      setUsers(response.data);
      setError(null);
    } catch (err) {
      console.error('Failed to fetch users:', err);
      setError('Failed to load users. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Start editing a user
  const handleEdit = (user) => {
    setEditingUser(user.id);
    setFormData({
      username: user.username,
      email: user.email || '', // Include email for editing
      password: '', // Don't populate password for security
      is_admin: user.is_admin === 1 || user.is_admin === true
    });
  };

  // Cancel editing
  const handleCancel = () => {
    setEditingUser(null);
    setFormData({
      username: '',
      email: '',
      password: '',
      is_admin: false
    });
  };

  // Handle form input changes for editing
  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  // Handle form input changes for creating
  const handleCreateChange = (e) => {
    const { name, value, type, checked } = e.target;
    setCreateFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };

  // Save user changes
  const handleSave = async (userId) => {
    try {
      setLoading(true);
      const token = localStorage.getItem('auth_token');
      
      // Include all editable fields
      const userData = {
        username: formData.username,
        email: formData.email,
        is_admin: formData.is_admin
      };
      
      // Only include password in the request if it was changed
      if (formData.password) {
        userData.password = formData.password;
      }
      
      await axios.put(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.USERS}/${userId}`,
        userData,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      // Refresh the user list
      await fetchUsers();
      setEditingUser(null);
      setFormData({
        username: '',
        email: '',
        password: '',
        is_admin: false
      });
    } catch (err) {
      console.error('Failed to update user:', err);
      setError('Failed to update user. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Create a new user
  const handleCreateUser = async () => {
    try {
      setLoading(true);
      const token = localStorage.getItem('auth_token');
      
      // Validate form data - only username and password are required
      if (!createFormData.username || !createFormData.password) {
        setError('Username and password are required.');
        setLoading(false);
        return;
      }
      
      // Use the register endpoint instead of users endpoint
      // If email is not provided, use a default placeholder
      const email = createFormData.email || `${createFormData.username}@example.com`;
      
      await axios.post(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.REGISTER}`,
        {
          username: createFormData.username,
          email: email, // Use the email or placeholder
          password: createFormData.password
        }
      );
      
      // If admin status needs to be set, we need to do that in a separate request
      if (createFormData.is_admin) {
        try {
          // Get the newly created user
          const usersResponse = await axios.get(
            `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.USERS}`,
            { headers: { Authorization: `Bearer ${token}` } }
          );
          
          const newUser = usersResponse.data.find(u => u.username === createFormData.username);
          
          if (newUser) {
            // Update the user to make them an admin
            await axios.put(
              `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.USERS}/${newUser.id}`,
              { is_admin: true },
              { headers: { Authorization: `Bearer ${token}` } }
            );
          }
        } catch (adminErr) {
          console.error('Failed to set admin status:', adminErr);
          // Don't fail the whole operation if just the admin part fails
        }
      }
      
      // Refresh the user list
      await fetchUsers();
      
      // Reset form and hide it
      setCreateFormData({
        username: '',
        email: '',
        password: '',
        is_admin: false
      });
      setShowCreateForm(false);
      setError(null);
    } catch (err) {
      console.error('Failed to create user:', err);
      setError(err.response?.data?.message || 'Failed to create user. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Toggle create form visibility
  const toggleCreateForm = () => {
    setShowCreateForm(!showCreateForm);
    if (!showCreateForm) {
      // Reset form data when opening
      setCreateFormData({
        username: '',
        email: '',
        password: '',
        is_admin: false
      });
    }
  };
  
  // Toggle create channel form visibility
  const toggleCreateChannelForm = () => {
    setShowCreateChannelForm(!showCreateChannelForm);
    if (!showCreateChannelForm) {
      // Reset channel name when opening the form
      setNewChannelName('');
    }
  };

  // Render loading state
  if (loading && users.length === 0) {
    return (
      <div className="bg-stone-900 text-white p-4 h-full flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-teal-500 mx-auto mb-4"></div>
          <p>Loading users...</p>
        </div>
      </div>
    );
  }

  // Render error state
  if (error && users.length === 0) {
    return (
      <div className="bg-stone-900 text-white p-4 h-full flex items-center justify-center">
        <div className="text-center text-red-500">
          <p>{error}</p>
          <button 
            onClick={fetchUsers}
            className="mt-4 px-4 py-2 bg-stone-700 hover:bg-stone-600 rounded"
          >
            Try Again
          </button>
        </div>
      </div>
    );
  }

  // Fetch chat channels
  const fetchChannels = async () => {
    try {
      setChannelLoading(true);
      const token = localStorage.getItem('auth_token');
      const response = await axios.get(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.CHAT_ROOMS}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      setChannels(response.data);
      setChannelError(null);
    } catch (err) {
      console.error('Failed to fetch channels:', err);
      setChannelError('Failed to load chat channels. Please try again.');
    } finally {
      setChannelLoading(false);
    }
  };

  // Create a new chat channel
  const handleCreateChannel = async (e) => {
    e.preventDefault();
    if (!newChannelName.trim()) return;

    try {
      setChannelLoading(true);
      const token = localStorage.getItem('auth_token');
      await axios.post(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.CHAT_ROOMS}`,
        { name: newChannelName },
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      // Refresh the channel list
      await fetchChannels();
      
      // Reset form and hide it
      setNewChannelName('');
      setShowCreateChannelForm(false);
      setChannelError(null);
    } catch (err) {
      console.error('Failed to create channel:', err);
      setChannelError('Failed to create channel. Please try again.');
    } finally {
      setChannelLoading(false);
    }
  };

  // Delete a chat channel
  const handleDeleteChannel = async (channelId) => {
    try {
      setChannelLoading(true);
      const token = localStorage.getItem('auth_token');
      const endpoint = API_CONFIG.ENDPOINTS.CHAT_DELETE_ROOM.replace(':id', channelId);
      await axios.delete(
        `${API_CONFIG.BASE_URL}${endpoint}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      // Refresh the channel list
      await fetchChannels();
      setChannelError(null);
    } catch (err) {
      console.error('Failed to delete channel:', err);
      setChannelError('Failed to delete channel. Please try again.');
    } finally {
      setChannelLoading(false);
    }
  };
  
  // Delete a user (or deactivate if delete endpoint is not available)
  const handleDeleteUser = async (userId) => {
    // Confirm deletion
    if (!window.confirm('Are you sure you want to delete this user? This action cannot be undone.')) {
      return;
    }
    
    try {
      setLoading(true);
      const token = localStorage.getItem('auth_token');
      
      // First try the DELETE endpoint
      try {
        await axios.delete(
          `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.USERS}/${userId}`,
          { headers: { Authorization: `Bearer ${token}` } }
        );
      } catch (deleteErr) {
        // If DELETE fails, try to "deactivate" the user using PUT instead
        // This is a workaround since the DELETE endpoint might not be available
        console.log('Delete endpoint failed, trying deactivation via PUT instead');
        
        // Find the user to get their current data
        const userToDeactivate = users.find(u => u.id === userId);
        if (!userToDeactivate) {
          throw new Error('User not found');
        }
        
        // Update the user with a deactivated flag or similar
        // We'll prepend "DEACTIVATED_" to the username to mark it as deleted
        await axios.put(
          `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.USERS}/${userId}`,
          {
            username: `DEACTIVATED_${userToDeactivate.username}`,
            is_admin: false // Remove admin privileges
          },
          { headers: { Authorization: `Bearer ${token}` } }
        );
      }
      
      // Refresh the user list
      await fetchUsers();
      setError(null);
    } catch (err) {
      console.error('Failed to delete/deactivate user:', err);
      setError(err.response?.data?.message || 'Failed to delete user. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="bg-stone-900 text-white h-full overflow-auto flex flex-col">
      {/* Header Bar */}
      <div className="p-2 border-b border-stone-700 font-mono text-sm flex items-center justify-between">
        <h2 className="text-teal-400 font-medium">ADMIN PANEL</h2>
        
        {/* Tab Navigation */}
        <div className="flex">
          <button
            className={`px-3 py-1 rounded-t text-xs flex items-center ${
              activeTab === 'users'
                ? 'bg-stone-800 text-teal-300'
                : 'text-stone-400 hover:text-white'
            }`}
            onClick={() => setActiveTab('users')}
          >
            Users
          </button>
          <button
            className={`px-3 py-1 rounded-t text-xs flex items-center ml-1 ${
              activeTab === 'channels'
                ? 'bg-stone-800 text-teal-300'
                : 'text-stone-400 hover:text-white'
            }`}
            onClick={() => setActiveTab('channels')}
          >
            Chat Channels
          </button>
        </div>
      </div>
      
      {/* Create User/Channel Button - Only shown when respective tab is active */}
      {activeTab === 'users' && (
        <div className="p-2 border-b border-stone-700 flex justify-end">
          <button
            onClick={toggleCreateForm}
            className="px-3 py-1 bg-teal-600 hover:bg-teal-500 rounded text-sm"
          >
            {showCreateForm ? 'Cancel' : 'Create User'}
          </button>
        </div>
      )}
      
      {activeTab === 'channels' && (
        <div className="p-2 border-b border-stone-700 flex justify-end">
          <button
            onClick={toggleCreateChannelForm}
            className="px-3 py-1 bg-teal-600 hover:bg-teal-500 rounded text-sm"
          >
            {showCreateChannelForm ? 'Cancel' : 'Create Channel'}
          </button>
        </div>
      )}
      
      {/* Main Content Area */}
      <div className="p-4 flex-1 overflow-auto">
        {activeTab === 'users' && error && <p className="text-red-500 mb-4">{error}</p>}
        {activeTab === 'channels' && channelError && <p className="text-red-500 mb-4">{channelError}</p>}
        
        {/* Show users tab content */}
        {activeTab === 'users' && (
          <>
            {/* Create User Form */}
            {showCreateForm && (
              <div className="mb-6 p-4 bg-stone-800 rounded">
                <h3 className="text-lg mb-3 text-teal-400">Create New User</h3>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm text-gray-400 mb-1">Username: <span className="text-red-500">*</span></label>
                    <input
                      type="text"
                      name="username"
                      value={createFormData.username}
                      onChange={handleCreateChange}
                      className="bg-stone-700 text-white px-2 py-1 rounded w-full"
                      placeholder="Enter username"
                    />
                  </div>
                  <div>
                    <label className="block text-sm text-gray-400 mb-1">Email:</label>
                    <input
                      type="email"
                      name="email"
                      value={createFormData.email}
                      onChange={handleCreateChange}
                      className="bg-stone-700 text-white px-2 py-1 rounded w-full"
                      placeholder="Enter email (optional)"
                    />
                  </div>
                  <div>
                    <label className="block text-sm text-gray-400 mb-1">Password: <span className="text-red-500">*</span></label>
                    <input
                      type="password"
                      name="password"
                      value={createFormData.password}
                      onChange={handleCreateChange}
                      className="bg-stone-700 text-white px-2 py-1 rounded w-full"
                      placeholder="Enter password"
                    />
                  </div>
                  <div className="flex items-center">
                    <label className="flex items-center text-sm text-gray-400">
                      <input
                        type="checkbox"
                        name="is_admin"
                        checked={createFormData.is_admin}
                        onChange={handleCreateChange}
                        className="form-checkbox h-5 w-5 text-teal-500 mr-2"
                      />
                      Admin User
                    </label>
                  </div>
                </div>
                <div className="mt-4">
                  <button
                    onClick={handleCreateUser}
                    className="px-4 py-2 bg-teal-600 hover:bg-teal-500 rounded text-sm"
                    disabled={loading}
                  >
                    {loading ? 'Creating...' : 'Create User'}
                  </button>
                </div>
              </div>
            )}
            
            {/* Users Table */}
            <table className="w-full border-collapse">
              <thead>
                <tr className="border-b border-stone-700">
                  <th className="text-left p-2">Username</th>
                  <th className="text-left p-2">Email</th>
                  <th className="text-left p-2">Admin</th>
                  <th className="text-left p-2">Actions</th>
                </tr>
              </thead>
              <tbody>
                {users.map(userItem => (
                  <tr key={userItem.id} className="border-b border-stone-800 hover:bg-stone-800">
                    <td className="p-2">
                      {editingUser === userItem.id ? (
                        <input
                          type="text"
                          name="username"
                          value={formData.username}
                          onChange={handleChange}
                          className="bg-stone-700 text-white px-2 py-1 rounded w-full"
                        />
                      ) : (
                        userItem.username
                      )}
                    </td>
                    <td className="p-2">
                      {editingUser === userItem.id ? (
                        <input
                          type="email"
                          name="email"
                          value={formData.email}
                          onChange={handleChange}
                          className="bg-stone-700 text-white px-2 py-1 rounded w-full"
                          placeholder="Email (optional)"
                        />
                      ) : (
                        userItem.email || '-'
                      )}
                    </td>
                    <td className="p-2">
                      {editingUser === userItem.id ? (
                        <input
                          type="checkbox"
                          name="is_admin"
                          checked={formData.is_admin}
                          onChange={handleChange}
                          className="form-checkbox h-5 w-5 text-teal-500"
                        />
                      ) : (
                        userItem.is_admin === 1 || userItem.is_admin === true ? 'Yes' : 'No'
                      )}
                    </td>
                    <td className="p-2">
                      {editingUser === userItem.id ? (
                        <div className="flex flex-col space-y-2">
                          <div className="mb-2">
                            <label className="block text-sm text-gray-400">New Password:</label>
                            <input
                              type="password"
                              name="password"
                              value={formData.password}
                              onChange={handleChange}
                              placeholder="Leave blank to keep current"
                              className="bg-stone-700 text-white px-2 py-1 rounded w-full"
                            />
                          </div>
                          <div className="flex space-x-2">
                            <button
                              onClick={() => handleSave(userItem.id)}
                              className="px-3 py-1 bg-teal-600 hover:bg-teal-500 rounded text-sm"
                            >
                              Save
                            </button>
                            <button
                              onClick={handleCancel}
                              className="px-3 py-1 bg-stone-600 hover:bg-stone-500 rounded text-sm"
                            >
                              Cancel
                            </button>
                            <button
                              onClick={() => {
                                handleCancel();
                                handleDeleteUser(userItem.id);
                              }}
                              className="px-3 py-1 bg-stone-600 hover:bg-stone-500 rounded text-sm text-red-400 hover:text-red-300"
                            >
                              Delete
                            </button>
                          </div>
                        </div>
                      ) : (
                        <div className="flex space-x-2">
                          <button
                            onClick={() => handleEdit(userItem)}
                            className="px-3 py-1 bg-stone-700 hover:bg-stone-600 rounded text-sm"
                            disabled={loading}
                          >
                            Edit
                          </button>
                          <button
                            onClick={() => handleDeleteUser(userItem.id)}
                            className="px-3 py-1 hover:bg-stone-600 rounded text-sm"
                            disabled={loading}
                            title="Delete user"
                          >
                            <Trash size={16} className="text-stone-400 hover:text-stone-300" />
                          </button>
                        </div>
                      )}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
            
            {loading && users.length > 0 && (
              <div className="mt-4 text-center">
                <div className="animate-spin rounded-full h-6 w-6 border-t-2 border-b-2 border-teal-500 mx-auto"></div>
              </div>
            )}
          </>
        )}
        
        {/* Show channels tab content */}
        {activeTab === 'channels' && (
          <>
            {/* Create Channel Form - Only shown when showCreateChannelForm is true */}
            {showCreateChannelForm && (
              <div className="mb-6 p-4 bg-stone-800 rounded">
                <h3 className="text-lg mb-3 text-teal-400">Create New Channel</h3>
                <form onSubmit={handleCreateChannel} className="flex items-end gap-4">
                  <div className="flex-1">
                    <label className="block text-sm text-gray-400 mb-1">Channel Name:</label>
                    <input
                      type="text"
                      value={newChannelName}
                      onChange={(e) => setNewChannelName(e.target.value)}
                      className="bg-stone-700 text-white px-2 py-1 rounded w-full"
                      placeholder="Enter channel name"
                    />
                  </div>
                  <button
                    type="submit"
                    className="px-4 py-1 bg-teal-600 hover:bg-teal-500 rounded text-sm"
                    disabled={channelLoading}
                  >
                    {channelLoading ? 'Creating...' : 'Create Channel'}
                  </button>
                </form>
              </div>
            )}
            
            {/* Channels Table */}
            <table className="w-full border-collapse">
              <thead>
                <tr className="border-b border-stone-700">
                  <th className="text-left p-2">Channel Name</th>
                  <th className="text-left p-2">Created By</th>
                  <th className="text-left p-2">Created At</th>
                  <th className="text-left p-2">Actions</th>
                </tr>
              </thead>
              <tbody>
                {channels.map(channel => (
                  <tr key={channel.id} className="border-b border-stone-800 hover:bg-stone-800">
                    <td className="p-2">{channel.name}</td>
                    <td className="p-2">{channel.created_by || '-'}</td>
                    <td className="p-2">
                      {new Date(channel.created_at).toLocaleString()}
                    </td>
                    <td className="p-2">
                      <button
                        onClick={() => handleDeleteChannel(channel.id)}
                        className="focus:outline-none"
                        title="Delete channel"
                        disabled={channelLoading}
                      >
                        <Trash size={16} className="text-stone-400 hover:text-stone-300" />
                      </button>
                    </td>
                  </tr>
                ))}
                {channels.length === 0 && !channelLoading && (
                  <tr>
                    <td colSpan="4" className="p-4 text-center text-stone-500">
                      No channels found. Create one above.
                    </td>
                  </tr>
                )}
              </tbody>
            </table>
            
            {channelLoading && (
              <div className="mt-4 text-center">
                <div className="animate-spin rounded-full h-6 w-6 border-t-2 border-b-2 border-teal-500 mx-auto"></div>
              </div>
            )}
          </>
        )}
      </div>
    </div>
  );
};

export default AdminWindow;

================
File: components/windows/AudioWindow.jsx
================
import React, { useRef, useState, useEffect, useCallback } from 'react';
import { Play, Pause, Volume2 } from 'lucide-react';

const AudioWindow = ({ nodeId, onCommand, windowState, updateWindowState }) => {
  const canvasRef = useRef(null);
  const audioRef = useRef(null);
  const audioContextRef = useRef(null);
  const analyserRef = useRef(null);
  const animationRef = useRef(null);
  const [isPlaying, setIsPlaying] = useState(windowState?.isPlaying || false);
  const [currentTime, setCurrentTime] = useState(windowState?.currentTime || 0);

  // Define draw function outside of other functions to avoid dependency issues
  const draw = useCallback(() => {
    if (!canvasRef.current || !analyserRef.current) {
      console.error('Cannot draw: canvas or analyser is null');
      return;
    }

    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const analyser = analyserRef.current;
    
    // Make sure canvas dimensions are set correctly
    if (canvas.width === 0 || canvas.height === 0) {
      canvas.width = canvas.offsetWidth || 300;
      canvas.height = canvas.offsetHeight || 150;
    }
    
    // Use a smaller FFT size for better visualization
    analyser.fftSize = 512;
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    const drawFrame = () => {
      // Cancel any existing animation frame
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
      
      // Request next frame
      animationRef.current = requestAnimationFrame(drawFrame);
      
      // Get frequency data
      analyser.getByteFrequencyData(dataArray);

      // Clear canvas
      ctx.fillStyle = 'rgb(28, 25, 23)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw visualizer
      const barWidth = (canvas.width / bufferLength) * 2.5;
      let barHeight;
      let x = 0;

      for (let i = 0; i < bufferLength; i++) {
        barHeight = dataArray[i] * 1.5;
        
        // Make sure we have a minimum height for bars
        if (barHeight < 1) barHeight = 1;
        
        const gradient = ctx.createLinearGradient(0, canvas.height, 0, 0);
        gradient.addColorStop(0, '#14b8a6');
        gradient.addColorStop(1, '#2dd4bf');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);

        x += barWidth + 1;
      }
    };

    // Start the animation
    drawFrame();
    
    console.log('Visualization started');
    
    // Return a cleanup function
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
        animationRef.current = null;
      }
    };
  }, []);

  // Track if audio element has been connected to a source
  const sourceConnectedRef = useRef(false);

  // Setup audio with Web Audio API for visualization
  const setupAudio = useCallback(async () => {
    try {
      const audio = audioRef.current;
      if (!audio) {
        console.error('Audio element reference is null');
        return false;
      }
      
      // Force reset the sourceConnected flag if we're having issues
      if (audioContextRef.current?.state === 'closed') {
        sourceConnectedRef.current = false;
      }
      
      // Create new AudioContext if needed
      if (!audioContextRef.current || audioContextRef.current.state === 'closed') {
        console.log('Creating new AudioContext');
        
        // Create new AudioContext
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Create and configure analyser
        const analyser = audioContext.createAnalyser();
        analyser.fftSize = 256; // Smaller FFT size for better visualization
        analyser.smoothingTimeConstant = 0.8; // Add smoothing
        
        // Resume audio context (needed due to browser autoplay policies)
        await audioContext.resume();
        
        // Create a new MediaElementSource and connect it
        try {
          console.log('Creating new MediaElementSource');
          const source = audioContext.createMediaElementSource(audio);
          source.connect(analyser);
          analyser.connect(audioContext.destination);
          sourceConnectedRef.current = true;
          
          // Store references
          audioContextRef.current = audioContext;
          analyserRef.current = analyser;
          
          console.log('Audio setup complete with new AudioContext');
        } catch (sourceError) {
          console.error('Error creating MediaElementSource:', sourceError);
          return false;
        }
      } else {
        // If AudioContext exists but is suspended, resume it
        if (audioContextRef.current.state === 'suspended') {
          console.log('Resuming suspended AudioContext');
          await audioContextRef.current.resume();
        }
        
        console.log('Using existing AudioContext');
      }
      
      // Restore playback position from window state
      if (windowState?.currentTime) {
        audio.currentTime = windowState.currentTime;
      }
      
      return true;
    } catch (error) {
      console.error('Error setting up audio:', error);
      return false;
    }
  }, [windowState]);

  // Initialize audio on mount or when windowState changes
  useEffect(() => {
    const initializeAudio = async () => {
      // Set up the audio context
      const success = await setupAudio();
      
      // If setup was successful and we should be playing, start playback
      if (success && windowState?.isPlaying) {
        try {
          await audioRef.current.play();
          draw();
        } catch (error) {
          console.error('Error auto-playing audio:', error);
          setIsPlaying(false);
        }
      }
    };

    if (audioRef.current && 
        (!audioContextRef.current || audioContextRef.current.state === 'closed')) {
      initializeAudio();
    }

    return () => {
      if (audioContextRef.current && audioContextRef.current.state !== 'closed') {
        try {
          audioContextRef.current.close();
        } catch (error) {
          console.error('Error closing AudioContext:', error);
        }
      }
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [windowState, setupAudio, draw]);

  // Toggle play/pause
  const togglePlay = useCallback(async () => {
    if (!audioRef.current) return;

    try {
      console.log('Toggle play clicked, current state:', isPlaying);
      
      // Make sure audio context is initialized and running
      if (!audioContextRef.current || audioContextRef.current.state === 'closed') {
        console.log('Setting up audio again');
        const success = await setupAudio();
        if (!success) {
          console.error('Failed to set up audio');
          return;
        }
      } else if (audioContextRef.current.state === 'suspended') {
        console.log('Resuming suspended AudioContext');
        await audioContextRef.current.resume();
      }

      if (isPlaying) {
        console.log('Pausing audio');
        audioRef.current.pause();
        if (animationRef.current) {
          cancelAnimationFrame(animationRef.current);
          animationRef.current = null;
        }
      } else {
        console.log('Starting audio playback');
        try {
          // Start visualization before playing to ensure it's ready
          if (analyserRef.current && !animationRef.current) {
            console.log('Starting visualization');
            draw();
          }
          
          // Play the audio
          const playPromise = audioRef.current.play();
          if (playPromise) {
            await playPromise;
            console.log('Audio playback started successfully');
            
            // Make sure visualization is running
            if (!animationRef.current && analyserRef.current) {
              console.log('Starting visualization after successful play');
              draw();
            }
          }
        } catch (playError) {
          console.error('Error playing audio:', playError);
        }
      }
      
      setIsPlaying(!isPlaying);
    } catch (error) {
      console.error('Error in togglePlay:', error);
    }
  }, [isPlaying, setupAudio, draw]);

  // Handle canvas resize
  useEffect(() => {
    const resizeCanvas = () => {
      const canvas = canvasRef.current;
      if (!canvas) return;
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
    };

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    return () => window.removeEventListener('resize', resizeCanvas);
  }, []);

  // Update current time when playing
  useEffect(() => {
    if (!audioRef.current) return;
    
    const updateTime = () => {
      setCurrentTime(audioRef.current.currentTime);
    };
    
    audioRef.current.addEventListener('timeupdate', updateTime);
    return () => {
      audioRef.current?.removeEventListener('timeupdate', updateTime);
    };
  }, []);
  
  // Start visualization when audio is playing
  useEffect(() => {
    // If audio is playing but visualization is not running, start it
    if (isPlaying && audioRef.current && analyserRef.current && !animationRef.current) {
      console.log('Starting visualization due to isPlaying state change');
      draw();
    }
    
    // If audio is not playing but visualization is running, stop it
    if (!isPlaying && animationRef.current) {
      console.log('Stopping visualization due to isPlaying state change');
      cancelAnimationFrame(animationRef.current);
      animationRef.current = null;
    }
  }, [isPlaying, draw]);

  // Update window state when relevant state changes
  useEffect(() => {
    if (updateWindowState) {
      updateWindowState({
        isPlaying,
        currentTime
      });
    }
  }, [isPlaying, currentTime, updateWindowState]);

  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400">
      <div className="flex-1 relative">
        <canvas 
          ref={canvasRef}
          className="absolute inset-0 w-full h-full"
        />
      </div>

      <div className="border-t border-stone-700">
        <div className="flex items-center gap-4 mb-4">
          <button 
            onClick={togglePlay}
            className="p-2 hover:bg-stone-800 rounded-full transition-colors"
          >
            {isPlaying ? <Pause size={24} /> : <Play size={24} />}
          </button>
          <Volume2 size={24} />
        </div>

        <audio
          ref={audioRef}
          src="scamming-on-runescape.mp3"
          preload="auto"
          crossOrigin="anonymous"
          onPlay={() => setIsPlaying(true)}
          onPause={() => setIsPlaying(false)}
          onEnded={() => setIsPlaying(false)}
        />

        <div className="p-2 flex items-center gap-2 border-t border-stone-700">
          <span>$</span>
          <input
            type="text"
            className="flex-1 bg-stone-800 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
            onKeyDown={(e) => {
              if (e.key === 'Enter' && e.target.value.trim()) {
                onCommand(e.target.value.trim());
                e.target.value = '';
              }
            }}
          />
        </div>
      </div>
    </div>
  );
};

export default AudioWindow;

================
File: components/windows/ChatWindow.jsx
================
import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';
import { io } from 'socket.io-client';
import axios from 'axios';
import API_CONFIG from '../../config/api';
import { useAuth } from '../../context/AuthContext';
import { MoreVertical, Trash, Mic, MicOff, Phone, PhoneOff, Plus } from 'lucide-react'; // Import additional icons
import SimplePeer from 'simple-peer';

// Helper function to safely destroy a peer connection
const safelyDestroyPeer = (peer) => {
  if (!peer) return;
  
  try {
    // Stop any tracks in the peer's stream
    if (peer._localStream) {
      try {
        peer._localStream.getTracks().forEach(track => track.stop());
      } catch (err) {
        console.error('Error stopping local stream tracks:', err);
      }
    }
    
    // Destroy the peer
    if (peer.destroy) {
      peer.destroy();
    }
  } catch (err) {
    console.error('Error safely destroying peer:', err);
  }
};

const ChatWindow = ({ isActive, nodeId }) => {
  const { user } = useAuth();
  const [rooms, setRooms] = useState([]);
  const [activeRoom, setActiveRoom] = useState(null);
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');
  const [charCount, setCharCount] = useState(0);
  const [newRoomName, setNewRoomName] = useState('');
  const [socket, setSocket] = useState(null);
  const messagesEndRef = useRef(null);
  
  // Voice chat state
  const [voiceChannels, setVoiceChannels] = useState([]);
  const [activeVoiceChannel, setActiveVoiceChannel] = useState(null);
  const [voiceParticipants, setVoiceParticipants] = useState([]);
  const [isMuted, setIsMuted] = useState(false);
  const [localStream, setLocalStream] = useState(null);
  const [peers, setPeers] = useState({});
  const [newVoiceChannelName, setNewVoiceChannelName] = useState('');
  const [speakingUsers, setSpeakingUsers] = useState(new Set());
  const audioContextRef = useRef(null);
  const analyserRef = useRef(null);
  const speakingTimeoutRef = useRef(null);
  const joinSoundRef = useRef(null);
  
  // Helper function to create audio elements for remote streams
  const createAudioElement = (userId, stream) => {
    console.log('Creating audio element for user:', userId);
    const existingAudio = document.getElementById(`remote-audio-${userId}`);
    if (existingAudio) {
      console.log('Audio element already exists, removing it first');
      existingAudio.remove();
    }
    
    const audio = document.createElement('audio');
    audio.id = `remote-audio-${userId}`;
    audio.srcObject = stream;
    audio.autoplay = true;
    audio.controls = false; // Hide controls
    audio.volume = 1.0; // Full volume
    document.body.appendChild(audio);
    
    // Verify the audio element was created and is working
    console.log('Audio element created:', audio);
    console.log('Audio element autoplay:', audio.autoplay);
    console.log('Audio element srcObject:', audio.srcObject);
    
    return audio;
  };
  
  const MAX_CHARS = 500; // Maximum character limit

  // New state for tracking which message's menu is open
  const [activeMenu, setActiveMenu] = useState(null);

  // Initialize join sound
  useEffect(() => {
    // Create the audio element for the join sound
    const joinSound = new Audio('/audio/vine-boom.mp3');
    joinSound.volume = 0.5; // Set volume to 50%
    joinSoundRef.current = joinSound;
    
    return () => {
      // Clean up
      if (joinSoundRef.current) {
        joinSoundRef.current.pause();
        joinSoundRef.current.src = '';
      }
    };
  }, []);
  
  // Connect to WebSocket server
  useEffect(() => {
    const socketInstance = io(API_CONFIG.BASE_URL.replace('/api', ''));
    setSocket(socketInstance);

    // Authenticate the socket connection
    const token = localStorage.getItem('auth_token');
    if (token) {
      socketInstance.emit('authenticate', token);
    }

    return () => {
      // Clean up voice chat if active
      if (localStream) {
        try {
          localStream.getTracks().forEach(track => track.stop());
        } catch (err) {
          console.error('Error stopping local stream tracks on unmount:', err);
        }
      }
      
      // Clean up peer connections safely using our helper function
      try {
        Object.values(peers).forEach(peer => {
          safelyDestroyPeer(peer);
        });
      } catch (err) {
        console.error('Error cleaning up peer connections on unmount:', err);
      }
      
      socketInstance.disconnect();
    };
  }, []);
  
  // Add effects to listen for message_deleted and room_deleted events
  useEffect(() => {
    if (!socket) return;
    
    const handleMessageDeleted = (data) => {
      setMessages(prev => prev.filter(msg => msg.id !== data.id));
    };
    
    const handleRoomDeleted = (data) => {
      // If the active room was deleted, set activeRoom to null
      if (activeRoom && activeRoom.id === data.id) {
        setActiveRoom(null);
      }
      
      // Remove the deleted room from the rooms list
      setRooms(prev => prev.filter(room => room.id !== data.id));
    };
    
    const handleVoiceChannelDeleted = (data) => {
      // If the active voice channel was deleted, leave it
      if (activeVoiceChannel && activeVoiceChannel.id === data.id) {
        leaveVoiceChannel();
      }
      
      // Remove the deleted voice channel from the list
      setVoiceChannels(prev => prev.filter(channel => channel.id !== data.id));
    };
    
    socket.on('message_deleted', handleMessageDeleted);
    socket.on('room_deleted', handleRoomDeleted);
    socket.on('voice_channel_deleted', handleVoiceChannelDeleted);
    
    return () => {
      socket.off('message_deleted', handleMessageDeleted);
      socket.off('room_deleted', handleRoomDeleted);
      socket.off('voice_channel_deleted', handleVoiceChannelDeleted);
    };
  }, [socket, activeRoom, activeVoiceChannel]);

  // Fetch available rooms
  useEffect(() => {
    const fetchRooms = async () => {
      try {
        const token = localStorage.getItem('auth_token');
        const response = await axios.get(`${API_CONFIG.BASE_URL}/chat/rooms`, {
          headers: { Authorization: `Bearer ${token}` }
        });
        setRooms(response.data);
        
        // If there are rooms and no active room, set the first one as active
        if (response.data.length > 0 && !activeRoom) {
          setActiveRoom(response.data[0]);
        }
      } catch (error) {
        console.error('Failed to fetch rooms:', error);
      }
    };

    fetchRooms();
  }, [activeRoom]);

  // Join room and fetch messages
  useEffect(() => {
    if (!activeRoom || !socket) return;

    // Join the room via WebSocket
    socket.emit('join_room', activeRoom.id);

    // Fetch messages for the room
    const fetchMessages = async () => {
      try {
        const token = localStorage.getItem('auth_token');
        const response = await axios.get(
          `${API_CONFIG.BASE_URL}/chat/rooms/${activeRoom.id}/messages`,
          { headers: { Authorization: `Bearer ${token}` } }
        );
        setMessages(response.data);
      } catch (error) {
        console.error('Failed to fetch messages:', error);
      }
    };

    // Fetch voice channels for the room
    const fetchVoiceChannels = async () => {
      try {
        const token = localStorage.getItem('auth_token');
        const response = await axios.get(
          `${API_CONFIG.BASE_URL}/chat/rooms/${activeRoom.id}/voice-channels`,
          { headers: { Authorization: `Bearer ${token}` } }
        );
        setVoiceChannels(response.data);
      } catch (error) {
        console.error('Failed to fetch voice channels:', error);
      }
    };

    fetchMessages();
    fetchVoiceChannels();

    // Listen for new messages
    const handleNewMessage = (message) => {
      setMessages((prev) => [...prev, message]);
    };

    socket.on('new_message', handleNewMessage);
//test
    return () => {
      // Leave the room when component unmounts or room changes
      socket.emit('leave_room', activeRoom.id);
      socket.off('new_message', handleNewMessage);
    };
  }, [activeRoom, socket]);

  // Set up voice activity detection
  useEffect(() => {
    if (!localStream || !socket || !activeVoiceChannel) return;
    
    // Create audio context and analyzer
    try {
      // Clean up any existing audio context
      if (audioContextRef.current) {
        audioContextRef.current.close();
      }
      
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      audioContextRef.current = audioContext;
      
      // Create analyzer node
      const analyser = audioContext.createAnalyser();
      analyser.fftSize = 256;
      analyser.smoothingTimeConstant = 0.8;
      analyserRef.current = analyser;
      
      // Connect the stream to the analyzer
      const source = audioContext.createMediaStreamSource(localStream);
      source.connect(analyser);
      
      // Set up the buffer for the analyzer
      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);
      
      // Function to check if user is speaking
      const checkSpeaking = () => {
        if (!analyser || !socket || !activeVoiceChannel || isMuted) return;
        
        analyser.getByteFrequencyData(dataArray);
        
        // Calculate average volume
        let sum = 0;
        for (let i = 0; i < bufferLength; i++) {
          sum += dataArray[i];
        }
        const average = sum / bufferLength;
        
        // Threshold for speaking detection
        const threshold = 20; // Adjust as needed
        
        // Check if speaking
        const isSpeaking = average > threshold;
        
        // If speaking state changed, emit event
        if (isSpeaking && !speakingUsers.has(user.id)) {
          // User started speaking
          socket.emit('voice_speaking_start', {
            channelId: activeVoiceChannel.id
          });
          
          // Update local state
          setSpeakingUsers(prev => {
            const newSet = new Set(prev);
            newSet.add(user.id);
            return newSet;
          });
          
          // Clear any existing timeout
          if (speakingTimeoutRef.current) {
            clearTimeout(speakingTimeoutRef.current);
          }
        } else if (!isSpeaking && speakingUsers.has(user.id)) {
          // Set a timeout to stop speaking status after a short delay
          // This prevents the speaking status from flickering
          if (!speakingTimeoutRef.current) {
            speakingTimeoutRef.current = setTimeout(() => {
              socket.emit('voice_speaking_stop', {
                channelId: activeVoiceChannel.id
              });
              
              // Update local state
              setSpeakingUsers(prev => {
                const newSet = new Set(prev);
                newSet.delete(user.id);
                return newSet;
              });
              
              speakingTimeoutRef.current = null;
            }, 300); // 300ms delay
          }
        }
      };
      
      // Set up interval to check speaking
      const intervalId = setInterval(checkSpeaking, 100); // Check every 100ms
      
      return () => {
        clearInterval(intervalId);
        if (speakingTimeoutRef.current) {
          clearTimeout(speakingTimeoutRef.current);
        }
        if (audioContextRef.current) {
          audioContextRef.current.close();
          audioContextRef.current = null;
        }
        analyserRef.current = null;
      };
    } catch (error) {
      console.error('Error setting up voice activity detection:', error);
    }
  }, [localStream, socket, activeVoiceChannel, isMuted, user.id, speakingUsers]);
  
  // Voice chat socket event handlers
  useEffect(() => {
    if (!socket) return;
    
    // Handle speaking events
    const handleUserSpeakingStart = (data) => {
      if (data.channelId === activeVoiceChannel?.id && data.userId !== user.id) {
        setSpeakingUsers(prev => {
          const newSet = new Set(prev);
          newSet.add(data.userId);
          return newSet;
        });
      }
    };
    
    const handleUserSpeakingStop = (data) => {
      if (data.channelId === activeVoiceChannel?.id && data.userId !== user.id) {
        setSpeakingUsers(prev => {
          const newSet = new Set(prev);
          newSet.delete(data.userId);
          return newSet;
        });
      }
    };
    
    socket.on('user_speaking_start', handleUserSpeakingStart);
    socket.on('user_speaking_stop', handleUserSpeakingStop);
    
    // Handle when a user joins a voice channel
    const handleUserJoinedVoice = (data) => {
      console.log('User joined voice:', data);
      
      // Add to participants list
      setVoiceParticipants(prev => {
        // Check if user is already in the list
        if (prev.some(p => p.user_id === data.userId)) {
          return prev;
        }
        
        // Play join sound if this is our active channel and we're not the one joining
        if (activeVoiceChannel && 
            activeVoiceChannel.id === data.channelId && 
            data.userId !== user.id &&
            joinSoundRef.current) {
          // Reset the audio to the beginning and play it
          joinSoundRef.current.currentTime = 0;
          joinSoundRef.current.play().catch(err => {
            console.error('Error playing join sound:', err);
          });
        }
        
        return [...prev, {
          user_id: data.userId,
          username: data.username,
          is_muted: data.isMuted,
          channel_id: data.channelId
        }];
      });
      
      // If this is our active voice channel and we have a local stream,
      // initiate a peer connection to the new user
      if (activeVoiceChannel && 
          activeVoiceChannel.id === data.channelId && 
          localStream && 
          localStream.active && // Check that stream is active
          data.userId !== user.id) {
        
        console.log('Creating new peer connection to user:', data.userId);
        
        // Create peer connection with optimized settings
        try {
          // Track connection start time for performance monitoring
          const connectionStartTime = performance.now();
          
          const peer = new SimplePeer({
            initiator: true,
            trickle: true, // Enable trickle ICE for faster connections
            stream: localStream,
            config: {
              iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' },
                { urls: 'stun:stun3.l.google.com:19302' },
                { urls: 'stun:stun4.l.google.com:19302' }
              ],
              iceCandidatePoolSize: 10 // Pre-gather some ICE candidates
            }
          });
            
            peer.on('signal', signal => {
              console.log('Generated signal for user:', data.userId, signal);
              console.time('signaling-' + data.userId);
              socket.emit('voice_signal', {
                channelId: activeVoiceChannel.id,
                targetUserId: data.userId,
                signal
              });
            });
            
            peer.on('stream', stream => {
              console.log('Received stream from user:', data.userId, stream);
              // Create audio element for the remote stream
              createAudioElement(data.userId, stream);
            });
            
            // Add error handling
            peer.on('error', err => {
              console.error('Peer connection error (initiator):', err);
            });
            
            // Monitor ICE connection state
            peer.on('iceStateChange', state => {
              console.log('ICE state change (initiator):', state);
            });
            
            // Monitor connection state with timing
            peer.on('connect', () => {
              console.timeEnd('signaling-' + data.userId);
              const connectionTime = performance.now() - connectionStartTime;
              console.log('Peer connection established (initiator) with user:', data.userId, 'in', connectionTime.toFixed(0), 'ms');
            });
            
            // Add to peers state
            setPeers(prev => ({
              ...prev,
              [data.userId]: peer
            }));
          } catch (err) {
            console.error('Error creating peer connection (initiator):', err);
          }
      }
    };
    
    // Handle when a user leaves a voice channel
    const handleUserLeftVoice = (data) => {
      console.log('User left voice:', data);
      
      // Remove from participants list
      setVoiceParticipants(prev => 
        prev.filter(p => !(p.user_id === data.userId && p.channel_id === data.channelId))
      );
      
      // If we have a peer connection to this user, clean it up
      if (peers[data.userId]) {
        // Use our helper function to safely destroy the peer
        safelyDestroyPeer(peers[data.userId]);
        
        // Remove the audio element
        const audioElement = document.getElementById(`remote-audio-${data.userId}`);
        if (audioElement) {
          try {
            audioElement.remove();
          } catch (err) {
            console.error('Error removing audio element:', err);
          }
        }
        
        // Remove from peers state with a small delay to allow cleanup
        setTimeout(() => {
          setPeers(prev => {
            const newPeers = { ...prev };
            delete newPeers[data.userId];
            return newPeers;
          });
        }, 200);
      }
    };
    
    // Handle voice participants list
    const handleVoiceParticipants = (data) => {
      if (data.channelId === activeVoiceChannel?.id) {
        setVoiceParticipants(data.participants);
      }
    };
    
    // Handle WebRTC signaling
    const handleVoiceSignal = (data) => {
      console.log('Received voice signal:', data);
      
      // If the signal is for us and we're in the same channel
      if (data.channelId === activeVoiceChannel?.id && data.fromUserId !== user.id) {
        
        // If we already have a peer for this user
        if (peers[data.fromUserId]) {
          console.log('Signaling existing peer for user:', data.fromUserId);
          peers[data.fromUserId].signal(data.signal);
        } else {
          // Check if we have a valid stream
          if (!localStream || !localStream.active) {
            console.error('Cannot create peer connection: localStream is not available or not active');
            return;
          }
          
          // Create a new peer with optimized settings
          console.log('Creating new non-initiator peer for user:', data.fromUserId);
          
          try {
            // Track connection start time for performance monitoring
            const connectionStartTime = performance.now();
            
            const peer = new SimplePeer({
              initiator: false,
              trickle: true, // Enable trickle ICE for faster connections
              stream: localStream,
              config: {
                iceServers: [
                  { urls: 'stun:stun.l.google.com:19302' },
                  { urls: 'stun:stun1.l.google.com:19302' },
                  { urls: 'stun:stun2.l.google.com:19302' },
                  { urls: 'stun:stun3.l.google.com:19302' },
                  { urls: 'stun:stun4.l.google.com:19302' }
                ],
                iceCandidatePoolSize: 10 // Pre-gather some ICE candidates
              }
            });
              
              peer.on('signal', signal => {
                console.log('Generated response signal for user:', data.fromUserId, signal);
                console.time('signaling-' + data.fromUserId);
                socket.emit('voice_signal', {
                  channelId: activeVoiceChannel.id,
                  targetUserId: data.fromUserId,
                  signal
                });
              });
              
              peer.on('stream', stream => {
                console.log('Received stream from user:', data.fromUserId, stream);
                // Create audio element for the remote stream
                createAudioElement(data.fromUserId, stream);
              });
              
              // Add error handling
              peer.on('error', err => {
                console.error('Peer connection error (non-initiator):', err);
              });
              
              // Monitor ICE connection state
              peer.on('iceStateChange', state => {
                console.log('ICE state change (non-initiator):', state);
              });
              
              // Monitor connection state with timing
              peer.on('connect', () => {
                console.timeEnd('signaling-' + data.fromUserId);
                const connectionTime = performance.now() - connectionStartTime;
                console.log('Peer connection established (non-initiator) with user:', data.fromUserId, 'in', connectionTime.toFixed(0), 'ms');
              });
              
              // Signal with the received data
              peer.signal(data.signal);
              
              // Add to peers state
              setPeers(prev => ({
                ...prev,
                [data.fromUserId]: peer
              }));
            } catch (err) {
              console.error('Error creating peer connection (non-initiator):', err);
            }
        }
      }
    };
    
    // Handle mute status changes
    const handleUserMuteChanged = (data) => {
      setVoiceParticipants(prev => 
        prev.map(p => 
          p.user_id === data.userId && p.channel_id === data.channelId
            ? { ...p, is_muted: data.isMuted }
            : p
        )
      );
    };
    
    socket.on('user_joined_voice', handleUserJoinedVoice);
    socket.on('user_left_voice', handleUserLeftVoice);
    socket.on('voice_participants', handleVoiceParticipants);
    socket.on('voice_signal', handleVoiceSignal);
    socket.on('user_mute_changed', handleUserMuteChanged);
    
    return () => {
      socket.off('user_joined_voice', handleUserJoinedVoice);
      socket.off('user_left_voice', handleUserLeftVoice);
      socket.off('voice_participants', handleVoiceParticipants);
      socket.off('voice_signal', handleVoiceSignal);
      socket.off('user_mute_changed', handleUserMuteChanged);
    };
  }, [socket, activeVoiceChannel, localStream, peers, user]);

  // Scroll to bottom when messages change
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  const handleMessageChange = (e) => {
    const value = e.target.value;
    if (value.length <= MAX_CHARS) {
      setNewMessage(value);
      setCharCount(value.length);
    }
  };

  const handleSendMessage = async (e) => {
    e.preventDefault();
    if (!newMessage.trim() || !activeRoom) return;

    try {
      const token = localStorage.getItem('auth_token');
      await axios.post(
        `${API_CONFIG.BASE_URL}/chat/rooms/${activeRoom.id}/messages`,
        { message: newMessage },
        { headers: { Authorization: `Bearer ${token}` } }
      );
      setNewMessage('');
      setCharCount(0);
    } catch (error) {
      console.error('Failed to send message:', error);
    }
  };

  const handleCreateRoom = async (e) => {
    e.preventDefault();
    if (!newRoomName.trim()) return;

    try {
      const token = localStorage.getItem('auth_token');
      const response = await axios.post(
        `${API_CONFIG.BASE_URL}/chat/rooms`,
        { name: newRoomName },
        { headers: { Authorization: `Bearer ${token}` } }
      );
      setRooms((prev) => [response.data, ...prev]);
      setNewRoomName('');
      setActiveRoom(response.data);
    } catch (error) {
      console.error('Failed to create room:', error);
    }
  };
  
  // Add new function to handle message deletion
  const handleDeleteMessage = async (messageId) => {
    try {
      const token = localStorage.getItem('auth_token');
      const endpoint = API_CONFIG.ENDPOINTS.CHAT_DELETE_MESSAGE.replace(':id', messageId);
      await axios.delete(
        `${API_CONFIG.BASE_URL}${endpoint}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      // The message will be removed from the UI when the socket event is received
      setActiveMenu(null); // Close the menu
    } catch (error) {
      console.error('Failed to delete message:', error);
    }
  };

  // Toggle menu function
  const toggleMenu = (messageId) => {
    setActiveMenu(activeMenu === messageId ? null : messageId);
  };

  const joinRoom = async (room) => {
    try {
      const token = localStorage.getItem('auth_token');
      await axios.post(
        `${API_CONFIG.BASE_URL}/chat/rooms/${room.id}/join`,
        {},
        { headers: { Authorization: `Bearer ${token}` } }
      );
      setActiveRoom(room);
    } catch (error) {
      console.error('Failed to join room:', error);
    }
  };
  
  // Voice chat functions
  const createVoiceChannel = async (e) => {
    e.preventDefault();
    if (!newVoiceChannelName.trim() || !activeRoom) return;
    
    try {
      const token = localStorage.getItem('auth_token');
      const response = await axios.post(
        `${API_CONFIG.BASE_URL}/chat/rooms/${activeRoom.id}/voice-channels`,
        { name: newVoiceChannelName },
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      setVoiceChannels(prev => [response.data, ...prev]);
      setNewVoiceChannelName('');
    } catch (error) {
      console.error('Failed to create voice channel:', error);
    }
  };
  
  const joinVoiceChannel = async (channel) => {
    // If already in a voice channel, leave it first
    if (activeVoiceChannel) {
      await leaveVoiceChannel();
    }
    
    try {
      // Request microphone access
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      
      // Verify we have an active stream with audio tracks
      if (!stream || !stream.active || stream.getAudioTracks().length === 0) {
        console.error('Failed to get active audio stream');
        alert('Could not access microphone. Please check your permissions.');
        return;
      }
      
      // Set initial mute state
      stream.getAudioTracks()[0].enabled = !isMuted;
      
      // Store the stream
      setLocalStream(stream);
      
      // Set the active voice channel
      setActiveVoiceChannel(channel);
      
      // Join the channel via socket
      socket.emit('join_voice', { 
        channelId: channel.id,
        isMuted
      });
      
      console.log(`Joined voice channel: ${channel.name}`);
    } catch (error) {
      console.error('Failed to join voice channel:', error);
      alert('Could not access microphone. Please check your permissions.');
    }
  };
  
  const leaveVoiceChannel = async () => {
    if (!activeVoiceChannel || !socket) return;
    
    // Notify server
    socket.emit('leave_voice', activeVoiceChannel.id);
    
    // Clean up peer connections safely using our helper function
    try {
      Object.values(peers).forEach(peer => {
        safelyDestroyPeer(peer);
      });
    } catch (err) {
      console.error('Error cleaning up peer connections:', err);
    }
    
    // Delay setting peers to empty to allow cleanup to complete
    setTimeout(() => {
      setPeers({});
    }, 300);
    
    // Remove remote audio elements
    document.querySelectorAll('[id^="remote-audio-"]').forEach(el => {
      try {
        el.remove();
      } catch (err) {
        console.error('Error removing audio element:', err);
      }
    });
    
    // Stop local stream
    if (localStream) {
      try {
        localStream.getTracks().forEach(track => track.stop());
      } catch (err) {
        console.error('Error stopping local stream tracks:', err);
      }
      setLocalStream(null);
    }
    
    // Clear active voice channel
    setActiveVoiceChannel(null);
    setVoiceParticipants([]);
    
    console.log('Left voice channel');
  };
  
  const toggleMute = () => {
    if (!localStream) return;
    
    // Toggle mute state
    const newMuteState = !isMuted;
    setIsMuted(newMuteState);
    
    // Update audio track
    localStream.getAudioTracks()[0].enabled = !newMuteState;
    
    // Notify others
    if (socket && activeVoiceChannel) {
      socket.emit('voice_mute_toggle', {
        channelId: activeVoiceChannel.id,
        isMuted: newMuteState
      });
    }
  };

  return (
    <div className="flex h-full">
      {/* Room sidebar */}
      <div className="w-1/9 max-w-[20%] min-w-[10%] bg-stone-900 border-r border-stone-700 flex flex-col">
        {/* Text channels */}
        <div className="p-2 border-b border-stone-700">
          <h3 className="text-teal-400 font-medium text-sm">Text Channels</h3>
        </div>
        <div className="flex-1 overflow-y-auto">
          {rooms.map((room) => (
            <div
              key={room.id}
              className={`text-sm p-2 cursor-pointer hover:bg-stone-700 ${
                activeRoom?.id === room.id ? 'bg-stone-800' : ''
              }`}
              onClick={() => joinRoom(room)}
            >
              <div className="text-white">{room.name}</div>
            </div>
          ))}
        </div>
        
        {/* Voice channels */}
        {activeRoom && (
          <>
            <div className="p-2 border-t border-b border-stone-700 flex justify-between items-center">
              <h3 className="text-teal-400 font-medium text-sm">Voice Channels</h3>
            </div>   
            <div className="overflow-y-auto">
              {voiceChannels.map((channel) => (
                <div
                  key={channel.id}
                  className={`text-sm p-2 cursor-pointer hover:bg-stone-700 ${
                    activeVoiceChannel?.id === channel.id ? 'bg-stone-800' : ''
                  }`}
                >
                  <div 
                    className="text-white flex items-center justify-between"
                    onClick={() => activeVoiceChannel?.id === channel.id ? leaveVoiceChannel() : joinVoiceChannel(channel)}
                  >
                    <span>{channel.name}</span>
                    {activeVoiceChannel?.id === channel.id ? (
                      <PhoneOff size={16} className="text-red-500" />
                    ) : (
                      <Phone size={16} className="text-teal-400" />
                    )}
                  </div>
                  
                  {/* Voice participants */}
                  {voiceParticipants.length > 0 && channel.id === activeVoiceChannel?.id && (
                    <div className="mt-1 pl-2 border-l border-stone-700">
                      {voiceParticipants.map(participant => (
                        <div key={participant.user_id} className="flex items-center text-xs text-stone-400 py-1">
                          {participant.is_muted ? (
                            <MicOff size={12} className="mr-1 text-red-500" />
                          ) : (
                            <Mic size={12} className={`mr-1 ${speakingUsers.has(participant.user_id) ? 'text-teal-400 animate-pulse' : 'text-green-500'}`} />
                          )}
                          <span 
                            className={`${speakingUsers.has(participant.user_id) && !participant.is_muted ? 'text-teal-400 font-medium animate-pulse' : ''}`}
                            style={{
                              textShadow: speakingUsers.has(participant.user_id) && !participant.is_muted ? '0 0 10px rgba(20, 184, 166, 0.5)' : 'none'
                            }}
                          >
                            {participant.username}
                          </span>
                          {participant.user_id === user.id && (
                            <button 
                              onClick={(e) => {
                                e.stopPropagation();
                                toggleMute();
                              }}
                              className="ml-2 text-stone-400 hover:text-teal-400"
                              title={isMuted ? "Unmute" : "Mute"}
                            >
                              {isMuted ? <MicOff size={12} /> : <Mic size={12} />}
                            </button>
                          )}
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              ))}
            </div>
          </>
        )}
      </div>

      {/* Chat area */}
      <div className="flex-1 flex flex-col">
        {activeRoom ? (
          <>
            <div className="p-2 bg-stone-900 border-b border-stone-700 font-mono text-sm">
              <h3 className="text-teal-400 font-medium">{activeRoom.name}</h3>
            </div>
            <div className="flex-1 overflow-y-auto p-4 bg-stone-900">
              {messages.map((msg) => (
                <div
                  key={msg.id}
                  className="mb-1"
                >
                  <div
                    className="hover:bg-stone-800 inline-block rounded-lg px-4 py-2 w-[100%] break-all overflow-wrap break-word hyphens-auto overflow-hidden whitespace-pre-wrap relative text-white"
                    style={{ wordBreak: 'break-word', overflowWrap: 'break-word' }}
                  >
                    <div className="text-teal-400 flex font-medium text-s mb-1">
                      {msg.username}
                      <div className="text-xs text-white opacity-75 mt-1 ml-3">
                        {(() => {
                          // Ensure UTC interpretation by appending 'Z' if not already present
                          const timestamp = msg.created_at.endsWith('Z') ? 
                            msg.created_at : 
                            msg.created_at + 'Z';
                          
                          const msgDate = new Date(timestamp);
                          
                          return msgDate.toLocaleTimeString('en-US', {
                            year: 'numeric',
                            month: '2-digit',
                            day: '2-digit',
                            hour: 'numeric',
                            minute: '2-digit',
                            timeZoneName: 'short',
                            hour12: false
                          });
                        })()}
                      </div>
                      
                      {/* Admin controls - only show if user is admin */}
                      {user?.is_admin && (
                        <div className="ml-auto">
                          <button 
                            onClick={(e) => {
                              e.stopPropagation();
                              handleDeleteMessage(msg.id);
                            }}
                            className="text-white opacity-50 hover:opacity-100 focus:outline-none"
                            title="Delete message"
                          >
                            <Trash size={16} />
                          </button>
                        </div>
                      )}
                    </div>
                    <div>{msg.message}</div>
                  </div>
                </div>
              ))}
              <div ref={messagesEndRef} />
            </div>
            <form
              onSubmit={handleSendMessage}
              className="p-2 bg-stone-900 border-t border-stone-700 flex"
            >
              <div className="flex-1 flex flex-col">
                <input
                  type="text"
                  value={newMessage}
                  onChange={handleMessageChange}
                  className="flex-1 bg-stone-800 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none focus:ring-1 focus:ring-teal-400"
                  maxLength={MAX_CHARS}
                />
              </div>
            </form>
          </>
        ) : (
          <div className="flex-1 flex items-center justify-center bg-stone-900">
            <div className="text-stone-500">
              Select a channel to start chatting
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default ChatWindow;

================
File: components/windows/EditorWindow.jsx
================
import React, { useState, useEffect } from 'react';

const EditorWindow = ({ nodeId, onCommand, windowState, updateWindowState }) => {
  // Use state from windowState or default value
  const [text, setText] = useState(windowState?.text || `function hello() {\n  console.log("Hello, World!");\n}\n\n// Call the function\nhello();`);
  const [command, setCommand] = useState('');
  
  // Sync with external state when it changes
  useEffect(() => {
    if (windowState && windowState.text !== undefined) {
      setText(windowState.text);
    }
  }, [windowState]);
  
  // Update window state when text changes
  useEffect(() => {
    if (updateWindowState) {
      updateWindowState({ text });
    }
  }, [text, updateWindowState]);
  
  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && command.trim()) {
      onCommand(command.trim());
      setCommand('');
    }
  };

  const handleTextChange = (e) => {
    setText(e.target.value);
  };

  return (
    <div className="p-4 font-mono text-sm h-full flex flex-col bg-white">
      <div className="flex-1">
        <textarea
          className="w-full h-full text-gray-800 resize-none focus:outline-none"
          value={text}
          onChange={handleTextChange}
        />
      </div>

      {/* Editor's own command input */}
      <div className="mt-2 flex items-center gap-2">
        <span className="text-gray-400">$</span>
        <input
          type="text"
          value={command}
          onChange={(e) => setCommand(e.target.value)}
          onKeyDown={handleKeyDown}
          className="flex-1 bg-gray-100 px-2 py-1 rounded text-sm focus:outline-none"
          placeholder="Type a command..."
        />
      </div>
    </div>
  );
};

export default EditorWindow;

================
File: components/windows/ExplorerWindow.css
================
/* Markdown content styling */
.markdown-content {
    color: #f0f9ff; /* Light blue-white for readability */
    line-height: 1.6;
    font-family: 'Oxygen Mono', monospace;
    padding: 1rem;
  }
  
  /* Header styles with clear size differences */
  .markdown-content h1 {
    font-size: 2.5rem;
    font-weight: 700;
    margin-top: 1.5rem;
    margin-bottom: 1rem;
    color: #2dd4bf; /* Teal accent color */
    border-bottom: 1px solid #44403c;
    padding-bottom: 0.5rem;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content h2 {
    font-size: 2rem;
    font-weight: 600;
    margin-top: 1.5rem;
    margin-bottom: 0.75rem;
    color: #2dd4bf;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content h3 {
    font-size: 1.75rem;
    font-weight: 600;
    margin-top: 1.25rem;
    margin-bottom: 0.75rem;
    color: #2dd4bf;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content h4 {
    font-size: 1.5rem;
    font-weight: 600;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    color: #2dd4bf;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content h5 {
    font-size: 1.25rem;
    font-weight: 600;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    color: #2dd4bf;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content h6 {
    font-size: 1rem;
    font-weight: 600;
    margin-top: 1rem;
    margin-bottom: 0.5rem;
    color: #2dd4bf;
    font-family: 'Oxygen Mono', monospace;
  }
  
  /* Paragraph styling */
  .markdown-content p {
    margin-top: 0.5rem;
    margin-bottom: 0.5rem;
    font-family: 'Oxygen Mono', monospace;
  }
  
  /* Make sure the code blocks stand out */
  .markdown-content pre {
    background-color: #1c1917; /* Darker background for code */
    border-radius: 0.25rem;
    padding: 1rem;
    overflow-x: auto;
    margin: 1rem 0;
    font-family: 'Oxygen Mono', monospace;
    font-size: 0.875rem;
    line-height: 1.5;
  }
  
  .markdown-content code {
    font-family: 'Oxygen Mono', monospace;
    background-color: #1c1917;
    padding: 0.2rem 0.4rem;
    border-radius: 0.25rem;
    font-size: 0.875em;
  }
  
  /* Add some spacing between sections */
  .markdown-content br + h1,
  .markdown-content br + h2,
  .markdown-content br + h3,
  .markdown-content br + h4,
  .markdown-content br + h5,
  .markdown-content br + h6 {
    margin-top: 0.5rem;
  }
  
  /* Lists */
  .markdown-content ul, .markdown-content ol {
    margin-top: 0.5rem;
    margin-bottom: 0.5rem;
    padding-left: 2rem;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content li {
    margin-top: 0.25rem;
    margin-bottom: 0.25rem;
  }
  
  /* Links */
  .markdown-content a {
    color: #14b8a6;
    text-decoration: underline;
    font-family: 'Oxygen Mono', monospace;
  }
  
  .markdown-content a:hover {
    color: #2dd4bf;
  }

================
File: components/windows/ExplorerWindow.jsx
================
import React, { useState, useEffect, useRef } from 'react';
import { FolderOpen, FileText, ChevronRight, ChevronDown, File, Coffee, Code, BookOpen, Edit, Eye, Plus, FolderPlus, X, Globe, Lock, FileEdit } from 'lucide-react';
import showdown from 'showdown';
import path from 'path-browserify';
import API_CONFIG from '../../config/api';
import { useAuth } from '../../context/AuthContext';
import './ExplorerWindow.css';

const ExplorerWindow = ({ nodeId, onCommand, transformWindow, windowState, updateWindowState, focusRef }) => {
  // Get auth context to check if user is admin
  const { user } = useAuth();
  const isAdmin = user?.is_admin || false;
  
  // Use state from windowState or initialize with defaults
  const [files, setFiles] = useState([]);
  const [publicFiles, setPublicFiles] = useState([]);
  const [currentPath, setCurrentPath] = useState(windowState?.currentPath || '/');
  const [selectedFile, setSelectedFile] = useState(windowState?.selectedFile || null);
  const [expandedFolders, setExpandedFolders] = useState(windowState?.expandedFolders || {});
  const [isLoading, setIsLoading] = useState(true);
  const [fileContent, setFileContent] = useState(windowState?.fileContent || '');
  const [errorMessage, setErrorMessage] = useState('');
  const [showPreview, setShowPreview] = useState(windowState?.showPreview || false);
  const [activeTab, setActiveTab] = useState(windowState?.activeTab || 'public'); // 'public' or 'private'
  
  // Additional state for markdown editing
  const [editMode, setEditMode] = useState(windowState?.editMode || false);
  const [saveStatus, setSaveStatus] = useState('saved'); // 'saved', 'saving', 'error'
  
  // State for file/folder creation
  const [showCreateDialog, setShowCreateDialog] = useState(false);
  const [createType, setCreateType] = useState('file'); // 'file' or 'directory'
  const [newItemName, setNewItemName] = useState('');
  const [isCreating, setIsCreating] = useState(false);
  
  // State for file/folder renaming
  const [showRenameDialog, setShowRenameDialog] = useState(false);
  const [itemToRename, setItemToRename] = useState(null);
  const [newName, setNewName] = useState('');
  const [isRenaming, setIsRenaming] = useState(false);
  
  // For auto-save functionality
  const saveTimeoutRef = useRef(null);
  const createInputRef = useRef(null);
  const renameInputRef = useRef(null);
  
  // Initialize Showdown converter for Markdown
  const converter = new showdown.Converter({
    tables: true,
    tasklists: true,
    strikethrough: true,
    emoji: true
  });

  // Function to fetch public directory contents
  const fetchPublicDirectoryContents = async (publicPath = '/') => {
    try {
      setIsLoading(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsLoading(false);
        return;
      }
      
      // Fetch public directory contents from the server
      const response = await fetch(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PUBLIC_FILES_LIST}?path=${encodeURIComponent(publicPath)}`,
        {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        }
      );
      
      if (!response.ok) {
        setErrorMessage(`Failed to load public files: ${response.statusText}`);
        setIsLoading(false);
        return;
      }
      
      const data = await response.json();
      
      // Transform the data to match our expected format
      const transformedFiles = data.items.map(item => ({
        name: item.name,
        type: item.type,
        path: item.path,
        children: item.children || [],
        isPublic: true
      }));
      
      setPublicFiles(transformedFiles);
      setCurrentPath(publicPath);
      setIsLoading(false);
    } catch (error) {
      console.error('Error fetching public directory contents:', error);
      setErrorMessage('Failed to load public files. Please try again.');
      setIsLoading(false);
    }
  };

  // Function to fetch public file content
  const fetchPublicFileContent = async (filePath) => {
    try {
      setIsLoading(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsLoading(false);
        return;
      }
      
      // Fetch public file content from the server
      const response = await fetch(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PUBLIC_FILE_CONTENT}?path=${encodeURIComponent(filePath)}`,
        {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        }
      );
      
      if (!response.ok) {
        setErrorMessage(`Failed to load file content: ${response.statusText}`);
        setIsLoading(false);
        return;
      }
      
      const data = await response.json();
      setFileContent(data.content);
      setIsLoading(false);
      setSaveStatus('saved');
    } catch (error) {
      console.error('Error fetching public file content:', error);
      setErrorMessage(`Error loading file: ${error.message}`);
      setSaveStatus('error');
      setIsLoading(false);
    }
  };

  // Function to fetch private directory contents from the server (admin only)
  const fetchDirectoryContents = async (path = '/') => {
    try {
      setIsLoading(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsLoading(false);
        return;
      }
      
      // Fetch directory contents from the server
      const response = await fetch(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILES_LIST}?path=${encodeURIComponent(path)}`,
        {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        }
      );
      
      if (!response.ok) {
        // If response is 403, it means the user doesn't have admin access
        if (response.status === 403) {
          setErrorMessage('Admin access required to view files.');
        } else {
          setErrorMessage(`Failed to load files: ${response.statusText}`);
        }
        setIsLoading(false);
        return;
      }
      
      const data = await response.json();
      
      // Transform the data to match our expected format
      const transformedFiles = data.items.map(item => ({
        name: item.name,
        type: item.type,
        path: item.path,
        children: item.children || []
      }));
      
      setFiles(transformedFiles);
      setCurrentPath(path);
      setIsLoading(false);
    } catch (error) {
      console.error('Error fetching directory contents:', error);
      setErrorMessage('Failed to load files. Please try again.');
      setIsLoading(false);
    }
  };

  // Function to fetch file content
  const fetchFileContent = async (filePath) => {
    try {
      setIsLoading(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsLoading(false);
        return;
      }
      
      // Fetch file content from the server
      const response = await fetch(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_CONTENT}?path=${encodeURIComponent(filePath)}`,
        {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        }
      );
      
      if (!response.ok) {
        // If response is 403, it means the user doesn't have admin access
        if (response.status === 403) {
          setErrorMessage('Admin access required to view file content.');
        } else {
          setErrorMessage(`Failed to load file content: ${response.statusText}`);
        }
        setIsLoading(false);
        return;
      }
      
      const data = await response.json();
      setFileContent(data.content);
      setIsLoading(false);
      setSaveStatus('saved');
    } catch (error) {
      console.error('Error fetching file content:', error);
      setErrorMessage(`Error loading file: ${error.message}`);
      setSaveStatus('error');
      setIsLoading(false);
    }
  };
  
  // Function to save file content
  const saveFileContent = async () => {
    try {
      // Check if filePath is valid
      if (!selectedFile || !selectedFile.path || selectedFile.path.trim() === '') {
        setErrorMessage('No file selected. Please select a file first.');
        setSaveStatus('error');
        return;
      }
      
      setSaveStatus('saving');
      
      const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_SAVE}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('auth_token')}`
        },
        body: JSON.stringify({
          path: selectedFile.path,
          content: fileContent
        })
      });
      
      if (!response.ok) {
        throw new Error(`Failed to save file: ${response.statusText}`);
      }
      
      setSaveStatus('saved');
      setErrorMessage('');
    } catch (error) {
      console.error('Error saving file:', error);
      setErrorMessage(`Error saving file: ${error.message}`);
      setSaveStatus('error');
    }
  };
  
  // Handle markdown content change
  const handleMarkdownChange = (e) => {
    setFileContent(e.target.value);
  };

  // Load initial directory contents
  useEffect(() => {
    // Load public files for all users
    fetchPublicDirectoryContents();
    
    // Load private files for admin users
    if (isAdmin) {
      fetchDirectoryContents();
    }
  }, [isAdmin]);

  // Auto-save functionality with debounce
  useEffect(() => {
    // Only auto-save if in edit mode, user is admin, and we have a markdown file selected
    if (editMode && isAdmin && selectedFile && selectedFile.name.endsWith('.md') && fileContent) {
      // Clear any existing timeout
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
      
      // Set status to saving
      setSaveStatus('saving');
      
      // Set a new timeout for auto-save
      saveTimeoutRef.current = setTimeout(() => {
        saveFileContent();
      }, 1000); // 1 second debounce
    }
    
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, [fileContent, editMode, isAdmin, selectedFile]);

  // Update window state when relevant state changes
  useEffect(() => {
    if (updateWindowState) {
      updateWindowState({
        currentPath,
        selectedFile,
        expandedFolders,
        fileContent,
        showPreview,
        editMode,
        saveStatus,
        activeTab
      });
    }
  }, [currentPath, selectedFile, expandedFolders, fileContent, showPreview, editMode, saveStatus, activeTab, updateWindowState]);
  
  // Focus the input field when the create or rename dialog is shown
  useEffect(() => {
    if (showCreateDialog && createInputRef.current) {
      createInputRef.current.focus();
    }
    if (showRenameDialog && renameInputRef.current) {
      renameInputRef.current.focus();
    }
  }, [showCreateDialog, showRenameDialog]);

  // Toggle folder expansion
  const toggleFolder = (folderPath) => {
    setExpandedFolders(prev => ({
      ...prev,
      [folderPath]: !prev[folderPath]
    }));
  };
  
  // Create a new file or folder
  const createNewItem = async () => {
    if (!newItemName.trim()) {
      setErrorMessage('Name cannot be empty');
      return;
    }
    
    try {
      setIsCreating(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsCreating(false);
        return;
      }
      
      // Determine if we're creating in the public folder or private folder
      const isPublicFolder = activeTab === 'public';
      
      // Construct the full path for the new item
      let newItemPath;
      if (isPublicFolder) {
        // For public folder, prefix with /public
        newItemPath = path.join('/public', currentPath, newItemName.trim()).replace(/\\/g, '/');
      } else {
        // For private folder (admin only)
        newItemPath = path.join(currentPath, newItemName.trim()).replace(/\\/g, '/');
      }
      
      // Create the new file or folder
      const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_CREATE}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          path: newItemPath,
          type: createType,
          content: createType === 'file' ? '' : undefined
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || `Failed to create ${createType}: ${response.statusText}`);
      }
      
      // Close the dialog and reset the form
      setShowCreateDialog(false);
      setNewItemName('');
      
      // Refresh the appropriate file list
      if (isPublicFolder) {
        fetchPublicDirectoryContents(currentPath);
      } else {
        fetchDirectoryContents(currentPath);
      }
      
      // If it's a directory, expand it
      if (createType === 'directory') {
        setExpandedFolders(prev => ({
          ...prev,
          [newItemPath]: true
        }));
      }
      
      setIsCreating(false);
    } catch (error) {
      console.error(`Error creating ${createType}:`, error);
      setErrorMessage(`Failed to create ${createType}: ${error.message}`);
      setIsCreating(false);
    }
  };
  
  // Open the create dialog
  const openCreateDialog = (type) => {
    setCreateType(type);
    setNewItemName('');
    setErrorMessage('');
    setShowCreateDialog(true);
  };
  
  // Close the create dialog
  const closeCreateDialog = () => {
    setShowCreateDialog(false);
    setNewItemName('');
    setErrorMessage('');
  };
  
  // Handle key press in the create dialog
  const handleCreateKeyPress = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      createNewItem();
    } else if (e.key === 'Escape') {
      closeCreateDialog();
    }
  };

  // Open the rename dialog for a file or folder
  const openRenameDialog = (item) => {
    if (!isAdmin) {
      setErrorMessage('Admin access required to rename files.');
      return;
    }
    
    setItemToRename(item);
    setNewName(item.name);
    setErrorMessage('');
    setShowRenameDialog(true);
  };
  
  // Close the rename dialog
  const closeRenameDialog = () => {
    setShowRenameDialog(false);
    setItemToRename(null);
    setNewName('');
    setErrorMessage('');
  };
  
  // Handle key press in the rename dialog
  const handleRenameKeyPress = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      renameItem();
    } else if (e.key === 'Escape') {
      closeRenameDialog();
    }
  };
  
  // Rename a file or folder
  const renameItem = async () => {
    if (!newName.trim()) {
      setErrorMessage('Name cannot be empty');
      return;
    }
    
    if (!itemToRename) {
      setErrorMessage('No item selected for renaming');
      return;
    }
    
    try {
      setIsRenaming(true);
      setErrorMessage('');
      
      // Get the authentication token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        setErrorMessage('Authentication required. Please log in.');
        setIsRenaming(false);
        return;
      }
      
      // Rename the file or folder
      const response = await fetch(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.FILE_RENAME}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({
          oldPath: itemToRename.path,
          newName: newName.trim()
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || `Failed to rename ${itemToRename.type}: ${response.statusText}`);
      }
      
      // Close the dialog and reset the form
      setShowRenameDialog(false);
      setItemToRename(null);
      setNewName('');
      
      // If the renamed item was selected, update the selected file
      if (selectedFile && selectedFile.path === itemToRename.path) {
        setSelectedFile(null);
      }
      
      // Refresh the appropriate file list
      if (itemToRename.isPublic) {
        fetchPublicDirectoryContents(currentPath);
      } else {
        fetchDirectoryContents(currentPath);
      }
      
      setIsRenaming(false);
    } catch (error) {
      console.error(`Error renaming ${itemToRename.type}:`, error);
      setErrorMessage(`Failed to rename ${itemToRename.type}: ${error.message}`);
      setIsRenaming(false);
    }
  };
  
  // Handle file selection
  const handleFileSelect = (file) => {
    setSelectedFile(file);
    
    // Reset edit mode when selecting a new file
    if (editMode) {
      setEditMode(false);
    }
    
    // If it's a markdown file, fetch its content and show preview
    if (file.name.endsWith('.md')) {
      if (file.isPublic) {
        // Fetch public file content
        fetchPublicFileContent(file.path);
      } else {
        // Fetch private file content (admin only)
        fetchFileContent(file.path);
      }
      setShowPreview(true);
    } else {
      setFileContent('');
      setShowPreview(false);
    }
  };

  // Get file icon based on file extension
  const getFileIcon = (fileName) => {
    if (fileName.endsWith('.md')) return <FileText size={16} className="mr-2" />;
    if (fileName.endsWith('.jsx') || fileName.endsWith('.js')) return <Code size={16} className="mr-2" />;
    if (fileName.endsWith('.json')) return <Coffee size={16} className="mr-2" />;
    if (fileName.endsWith('.css')) return <BookOpen size={16} className="mr-2" />;
    return <File size={16} className="mr-2" />;
  };
  
  // Render the file tree recursively
  const renderFileTree = (items) => {
    return items.map(item => {
      if (item.type === 'directory') {
        const isExpanded = expandedFolders[item.path];
        return (
          <div key={item.path} className="ml-2">
            <div 
              className={`flex items-center justify-between py-1 px-1 rounded hover:bg-stone-700 cursor-pointer group ${isExpanded ? 'text-teal-300' : 'text-teal-400'}`}
            >
              <div className="flex items-center" onClick={() => toggleFolder(item.path)}>
                {isExpanded ? <ChevronDown size={14} /> : <ChevronRight size={14} />}
                <FolderOpen size={16} className="ml-1 mr-2" />
                <span className="text-sm">{item.name}</span>
              </div>
              
              {/* Admin-only rename button */}
              {isAdmin && (
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    openRenameDialog(item);
                  }}
                  className="p-1 rounded hover:bg-stone-600 text-stone-400 hover:text-teal-300 opacity-0 group-hover:opacity-100"
                  title="Rename folder"
                >
                  <FileEdit size={14} />
                </button>
              )}
            </div>
            
            {isExpanded && item.children && (
              <div className="ml-2 border-l border-stone-700">
                {renderFileTree(item.children)}
              </div>
            )}
          </div>
        );
      } else {
        const isSelected = selectedFile && selectedFile.path === item.path;
        return (
          <div 
            key={item.path} 
            className={`flex items-center justify-between py-1 px-1 ml-4 rounded cursor-pointer hover:bg-stone-700 group ${isSelected ? 'bg-stone-700 text-teal-300' : 'text-teal-50'}`}
          >
            <div className="flex items-center" onClick={() => handleFileSelect(item)}>
              {getFileIcon(item.name)}
              <span className="text-sm">{item.name}</span>
            </div>
            
            {/* Admin-only rename button */}
            {isAdmin && (
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  openRenameDialog(item);
                }}
                className="p-1 rounded hover:bg-stone-600 text-stone-400 hover:text-teal-300 opacity-0 group-hover:opacity-100"
                title="Rename file"
              >
                <FileEdit size={14} />
              </button>
            )}
          </div>
        );
      }
    });
  };

  // Toggle edit mode
  const toggleEditMode = () => {
    if (!isAdmin) {
      setErrorMessage('Admin access required to edit files.');
      return;
    }
    
    if (!selectedFile || !selectedFile.name.endsWith('.md')) {
      setErrorMessage('Only markdown files can be edited.');
      return;
    }
    
    setEditMode(!editMode);
    // When switching to preview mode, ensure preview is shown
    if (editMode) {
      setShowPreview(true);
    }
  };

  // Handle command input
  const handleCommand = (e) => {
    if (e.key === 'Enter' && e.target.value.trim()) {
      const cmd = e.target.value.trim();
      onCommand(cmd);
      e.target.value = '';
      
      // Commands:
      // - refresh: refresh file list
      // - preview: toggle markdown preview
      // - edit: toggle edit mode (admin only)
      // - save: manually save the current file
      // - new-file: create a new file (admin only)
      // - new-folder: create a new folder (admin only)
      // - rename: rename selected file or folder (admin only)
      // - public: switch to public files tab
      // - private: switch to private files tab (admin only)
      if (cmd === 'refresh') {
        // Refresh the appropriate file list based on the active tab
        if (activeTab === 'public') {
          fetchPublicDirectoryContents(currentPath);
        } else {
          fetchDirectoryContents(currentPath);
        }
      } else if (cmd === 'preview' && selectedFile?.name.endsWith('.md')) {
        setShowPreview(!showPreview);
        if (editMode) {
          setEditMode(false); // Exit edit mode when switching to preview
        }
      } else if (cmd === 'edit' && selectedFile?.name.endsWith('.md')) {
        toggleEditMode();
      } else if (cmd === 'save' && editMode && selectedFile?.name.endsWith('.md')) {
        saveFileContent();
      } else if (cmd === 'new-file' && isAdmin) {
        openCreateDialog('file');
      } else if (cmd === 'new-folder' && isAdmin) {
        openCreateDialog('directory');
      } else if (cmd === 'rename' && isAdmin && selectedFile) {
        openRenameDialog(selectedFile);
      } else if (cmd === 'public') {
        setActiveTab('public');
      } else if (cmd === 'private' && isAdmin) {
        setActiveTab('private');
      }
    }
  };

  return (
    <div className="h-full w-full flex flex-col bg-stone-900 text-teal-400 overflow-hidden">
      <div className="flex flex-1 overflow-hidden">
        {/* File tree panel */}
        <div className="w-1/3 border-r border-stone-700 flex flex-col overflow-hidden">
          <div className="p-2 border-b border-stone-700 font-mono text-sm flex items-center justify-between">
            <div className="flex items-center">
              <span>FILES</span>
              
              {/* Tabs for switching between public and private files */}
              <div className="flex ml-4">
                <button
                  onClick={() => setActiveTab('public')}
                  className={`px-2 py-1 rounded-t text-xs flex items-center gap-1 ${
                    activeTab === 'public' 
                      ? 'bg-stone-700 text-teal-300' 
                      : 'bg-stone-800 hover:bg-stone-700'
                  }`}
                  title="Public files (readable by all users)"
                >
                  <Globe size={14} />
                  <span>Public</span>
                </button>
                
                {isAdmin && (
                  <button
                    onClick={() => setActiveTab('private')}
                    className={`px-2 py-1 rounded-t text-xs flex items-center gap-1 ml-1 ${
                      activeTab === 'private' 
                        ? 'bg-stone-700 text-teal-300' 
                        : 'bg-stone-800 hover:bg-stone-700'
                    }`}
                    title="Private files (admin only)"
                  >
                    <Lock size={14} />
                    <span>Private</span>
                  </button>
                )}
              </div>
            </div>
            
            {/* Admin-only file creation buttons */}
            {isAdmin && (
              <div className="flex gap-2">
                <button
                  onClick={() => openCreateDialog('file')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Create new file"
                >
                  <Plus size={16} />
                </button>
                <button
                  onClick={() => openCreateDialog('directory')}
                  className="p-1 rounded hover:bg-stone-700 text-teal-400"
                  title="Create new folder"
                >
                  <FolderPlus size={16} />
                </button>
              </div>
            )}
          </div>
          
          <div className="flex-1 overflow-auto">
            {isLoading && !fileContent ? (
              <div className="flex items-center justify-center h-full">
                <span className="text-teal-300">Loading...</span>
              </div>
            ) : errorMessage ? (
              <div className="p-2 text-red-400">{errorMessage}</div>
            ) : (
              <div className="p-2 font-mono">
                {activeTab === 'public' ? (
                  // Show public files to all users
                  <>
                    <div className="flex items-center py-1 px-1 text-teal-300">
                      <Globe size={16} className="mr-2" />
                      <span className="text-sm font-bold">Public Files</span>
                    </div>
                    {publicFiles.length > 0 ? (
                      renderFileTree(publicFiles)
                    ) : (
                      <div className="ml-4 text-stone-500 text-sm">No public files available</div>
                    )}
                  </>
                ) : (
                  // Show private files to admin users
                  <>
                    <div className="flex items-center py-1 px-1 text-teal-300">
                      <Lock size={16} className="mr-2" />
                      <span className="text-sm font-bold">Private Files (Admin Only)</span>
                    </div>
                    {files.length > 0 ? (
                      renderFileTree(files)
                    ) : (
                      <div className="ml-4 text-stone-500 text-sm">No private files available</div>
                    )}
                  </>
                )}
              </div>
            )}
          </div>
          
          {/* Create file/folder dialog */}
          {showCreateDialog && (
            <div className="p-2 border-t border-stone-700 bg-stone-800">
              <div className="flex items-center justify-between mb-1">
                <span className="text-sm font-bold">
                  {createType === 'file' ? 'New File' : 'New Folder'}
                </span>
                <button
                  onClick={closeCreateDialog}
                  className="p-1 rounded hover:bg-stone-700 text-stone-400"
                >
                  <X size={14} />
                </button>
              </div>
              <div className="flex gap-2">
                <input
                  ref={createInputRef}
                  type="text"
                  value={newItemName}
                  onChange={(e) => setNewItemName(e.target.value)}
                  onKeyDown={handleCreateKeyPress}
                  placeholder={createType === 'file' ? 'filename.ext' : 'folder name'}
                  className="flex-1 bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
                  disabled={isCreating}
                />
                <button
                  onClick={createNewItem}
                  disabled={isCreating || !newItemName.trim()}
                  className={`px-2 py-1 rounded text-xs ${
                    isCreating || !newItemName.trim()
                      ? 'bg-stone-700 text-stone-500 cursor-not-allowed'
                      : 'bg-teal-700 text-teal-100 hover:bg-teal-600'
                  }`}
                >
                  {isCreating ? 'Creating...' : 'Create'}
                </button>
              </div>
            </div>
          )}
          
          {/* Rename file/folder dialog */}
          {showRenameDialog && itemToRename && (
            <div className="p-2 border-t border-stone-700 bg-stone-800">
              <div className="flex items-center justify-between mb-1">
                <span className="text-sm font-bold">
                  Rename {itemToRename.type === 'directory' ? 'Folder' : 'File'}
                </span>
                <button
                  onClick={closeRenameDialog}
                  className="p-1 rounded hover:bg-stone-700 text-stone-400"
                >
                  <X size={14} />
                </button>
              </div>
              <div className="flex gap-2">
                <input
                  ref={renameInputRef}
                  type="text"
                  value={newName}
                  onChange={(e) => setNewName(e.target.value)}
                  onKeyDown={handleRenameKeyPress}
                  placeholder="New name"
                  className="flex-1 bg-stone-700 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
                  disabled={isRenaming}
                />
                <button
                  onClick={renameItem}
                  disabled={isRenaming || !newName.trim() || newName === itemToRename.name}
                  className={`px-2 py-1 rounded text-xs ${
                    isRenaming || !newName.trim() || newName === itemToRename.name
                      ? 'bg-stone-700 text-stone-500 cursor-not-allowed'
                      : 'bg-teal-700 text-teal-100 hover:bg-teal-600'
                  }`}
                >
                  {isRenaming ? 'Renaming...' : 'Rename'}
                </button>
              </div>
            </div>
          )}
          
          <div className="p-2 border-t border-stone-700 text-xs">
            {selectedFile ? selectedFile.path : currentPath}
          </div>
        </div>
        
        {/* File content panel (preview or edit) */}
        <div className="flex-1 flex flex-col overflow-hidden">
          {selectedFile ? (
            <>
              {/* Header with file name, status, and controls */}
              <div className="p-2 border-b border-stone-700 font-mono text-sm flex items-center justify-between">
                <div className="flex items-center">
                  <span className="mr-2">{selectedFile.name}</span>
                  {saveStatus === 'saving' && <span className="text-yellow-400 text-xs ml-2">Saving...</span>}
                  {saveStatus === 'saved' && <span className="text-green-400 text-xs ml-2">Saved</span>}
                  {saveStatus === 'error' && <span className="text-red-400 text-xs ml-2">Error!</span>}
                </div>
                
                {/* Only show edit/preview toggle for markdown files and admin users */}
                {selectedFile.name.endsWith('.md') && isAdmin && (
                  <div className="flex gap-2">
                    <button 
                      onClick={toggleEditMode}
                      className={`px-2 py-1 rounded text-xs flex items-center gap-1 ${editMode ? 'bg-teal-700 text-teal-100' : 'bg-stone-800 hover:bg-stone-700'}`}
                      title={editMode ? "Switch to preview mode" : "Switch to edit mode"}
                    >
                      {editMode ? <Eye size={14} /> : <Edit size={14} />}
                      {editMode ? 'Preview' : 'Edit'}
                    </button>
                    
                    {editMode && (
                      <button 
                        onClick={saveFileContent}
                        className="px-2 py-1 bg-stone-800 hover:bg-stone-700 rounded text-xs"
                        title="Save file"
                      >
                        Save
                      </button>
                    )}
                  </div>
                )}
              </div>
              
              {/* Error message */}
              {errorMessage && (
                <div className="p-2 bg-red-900 text-red-200 text-sm">
                  {errorMessage}
                </div>
              )}
              
              {/* Content area - either editor or preview */}
              {isLoading ? (
                <div className="flex-1 flex items-center justify-center">
                  <span className="text-teal-300">Loading content...</span>
                </div>
              ) : editMode && selectedFile.name.endsWith('.md') && isAdmin ? (
                // Editor mode - only for markdown files and admin users
                <div className="flex-1 p-2">
                  <textarea
                    className="w-full h-full bg-stone-800 text-teal-50 p-4 resize-none focus:outline-none font-mono"
                    value={fileContent}
                    onChange={handleMarkdownChange}
                    placeholder="# Start typing your markdown here..."
                  />
                </div>
              ) : showPreview ? (
                // Preview mode
                <div className="flex-1 overflow-auto p-4">
                  <div className="markdown-preview text-teal-50">
                    {selectedFile.name.endsWith('.md') ? (
                      <div 
                        dangerouslySetInnerHTML={{ 
                          __html: converter.makeHtml(fileContent) 
                        }} 
                        className="markdown-content"
                      />
                    ) : (
                      <pre className="font-mono text-sm whitespace-pre-wrap">
                        {fileContent}
                      </pre>
                    )}
                  </div>
                </div>
              ) : null}
            </>
          ) : (
            // No file selected
            <div className="flex items-center justify-center h-full text-stone-600">
              <div className="text-center">
                <FileText size={48} className="mx-auto mb-4" />
                <p>Select a markdown file to preview</p>
                <p className="text-xs mt-2">Use the 'preview' command to toggle preview mode</p>
                {isAdmin && <p className="text-xs mt-1">Admin users can use the 'edit' command to edit markdown files</p>}
              </div>
            </div>
          )}
        </div>
      </div>
      
      {/* Command input */}
      <div className="p-2 flex items-center gap-2 border-t border-stone-700">
        <span className="text-teal-400">$</span>
        <input
          ref={focusRef}
          type="text"
          onKeyDown={handleCommand}
          className="flex-1 bg-stone-800 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
          placeholder={isAdmin ? "Commands: refresh, preview, edit, save, new-file, new-folder, rename, public, private" : "Commands: refresh, preview, public"}
        />
      </div>
    </div>
  );
};

export default ExplorerWindow;

================
File: components/windows/index.js
================
import TerminalWindow from './TerminalWindow';
import ExplorerWindow from './ExplorerWindow';
import EditorWindow from './EditorWindow';
import withCommandHandling from '../../hocs/withCommandHandling';
import withWindowState from '../../hocs/withWindowState';
import withCommandInput from '../../hocs/withCommandInput';
import AudioWindow from './AudioWindow';
import ChatWindow from './ChatWindow';
import AdminWindow from './AdminWindow';
import { WINDOW_TYPES } from '../../utils/constants';

// Create enhanced versions of each window component by wrapping them with HOCs
// Terminal and Explorer already have command inputs, so we don't need to add them
export const EnhancedTerminalWindow = withWindowState(withCommandHandling(TerminalWindow), WINDOW_TYPES.TERMINAL);
export const EnhancedExplorerWindow = withWindowState(withCommandHandling(ExplorerWindow), WINDOW_TYPES.EXPLORER);

// For other windows, add the command input
export const EnhancedEditorWindow = withWindowState(withCommandHandling(withCommandInput(EditorWindow)), WINDOW_TYPES.EDITOR);
export const EnhancedAudioWindow = withWindowState(withCommandHandling(withCommandInput(AudioWindow)), WINDOW_TYPES.AUDIO);
export const EnhancedChatWindow = withWindowState(withCommandHandling(withCommandInput(ChatWindow)), WINDOW_TYPES.CHAT);
export const EnhancedAdminWindow = withWindowState(withCommandHandling(withCommandInput(AdminWindow)), WINDOW_TYPES.ADMIN);

// Also export the base components in case they're needed
export { TerminalWindow, ExplorerWindow, EditorWindow, ChatWindow, AdminWindow };

================
File: components/windows/TerminalWindow.jsx
================
import React, { useState, useEffect, useRef } from 'react';
import { WINDOW_TYPES } from '../../utils/windowTypes';
import { useAuth } from '../../context/AuthContext';
import { useAnnouncement } from '../../context/AnnouncementContext';

const TerminalWindow = ({ onCommand, isActive, nodeId, transformWindow, windowState, updateWindowState, focusRef }) => {
  // Get user authentication info
  const { user } = useAuth();
  // Get announcement context
  const { updateAnnouncement } = useAnnouncement();
  
  // Ref for managing scrolling
  const terminalRef = useRef(null);

  // Terminal state - use windowState if available
  const [history, setHistory] = useState(
    windowState?.history || ['SLUMNET TERMINAL - Type "help" for available commands.']
  );
  const [commandHistory, setCommandHistory] = useState(windowState?.commandHistory || []);
  const [currentInput, setCurrentInput] = useState(windowState?.currentInput || '');
  const [historyIndex, setHistoryIndex] = useState(windowState?.historyIndex || -1);

  // Auto-focus is now handled by the withWindowState HOC

  // Auto-scroll to bottom when new output is added
  useEffect(() => {
    if (terminalRef.current) {
      terminalRef.current.scrollTop = terminalRef.current.scrollHeight;
    }
  }, [history]);
  
  // Clear input when window becomes active or when transformed back to terminal
  useEffect(() => {
    // Always clear the input when the component mounts or is transformed back to terminal
    setCurrentInput('');
  }, []);
  
  // Also clear input when window becomes active
  useEffect(() => {
    if (isActive) {
      setCurrentInput('');
    }
  }, [isActive]);

  // Update window state when terminal state changes
  useEffect(() => {
    if (updateWindowState) {
      updateWindowState({
        history,
        commandHistory,
        currentInput,
        historyIndex
      });
    }
  }, [history, commandHistory, currentInput, historyIndex, updateWindowState]);

  const handleTerminalClick = () => {
    focusRef.current?.focus();
  };

  const executeCommand = async (command) => {
    setHistory(prev => [...prev, `$ ${command}`]);
    setCommandHistory(prev => [...prev, command]);
  
    const parts = command.split(' ');
    const cmd = parts[0].toLowerCase();
  
    if (Object.keys(WINDOW_TYPES).some(type => type.toLowerCase() === cmd)) {
      const requestedType = WINDOW_TYPES[cmd.toUpperCase()];
      transformWindow(nodeId, requestedType);
      return;
    }
  
  // Handle the announcement command
    if (cmd === 'announcement') {
      // Check if user is admin
      if (!user?.is_admin) {
        setHistory(prev => [...prev, 'Access denied: Admin privileges required']);
        return;
      }

      // Extract the announcement text from quotes
      const match = command.match(/"([^"]*)"|'([^']*)'|`([^`]*)`/);
      if (!match) {
        setHistory(prev => [...prev, 'Usage: announcement "Your announcement text here"']);
        return;
      }

      // Get the matched text from whichever group captured it
      const announcementText = match[1] || match[2] || match[3];
      
      setHistory(prev => [...prev, `Setting announcement: "${announcementText}"...`]);
      
      try {
        // Update the announcement via the API
        const success = await updateAnnouncement(announcementText);
        
        if (success) {
          setHistory(prev => [...prev, `Announcement set: "${announcementText}"`]);
          setHistory(prev => [...prev, 'Announcement has been broadcast to all connected users.']);
        } else {
          setHistory(prev => [...prev, 'Failed to set announcement. Please try again.']);
        }
      } catch (error) {
        console.error('Error setting announcement:', error);
        setHistory(prev => [...prev, 'Error setting announcement. Please try again.']);
      }
      return;
    }
  
    let response;
    switch (cmd) {
      case 'admin':
        // Check if user is admin
        if (user?.is_admin) {
          transformWindow(nodeId, WINDOW_TYPES.ADMIN);
          return;
        } else {
          response = 'Access denied: Admin privileges required';
        }
        break;
        
      case 'help':
        const adminCommands = user?.is_admin ? 
          '  admin        - Access admin panel\n  announcement "text" - Set a system-wide announcement\n' : 
          '';
        response = [
          'Commands:',
          '  explorer     - Transform window into file explorer',
          '  terminal     - Transform into terminal',
          adminCommands,
          '  help         - Show this help message',
          '  clear        - Clear terminal output',
          '',
          'Keyboard shortcuts:',
          '  Ctrl + Enter       - Split vertically',
          '  Ctrl + Shift + Enter - Split horizontally',
          '  Ctrl + Backspace   - Close window',
          '  Ctrl + Q   - Resize mode',
          '  Ctrl + M   - Move mode'
        ].join('\n');
        break;
  
      case 'clear':
        setHistory(['']);
        return;
  
      case 'version':
        response = 'SLUMNET Terminal v1.0.0';
        break;
  
      default:
        response = `Unknown command: ${command}`;
    }
  
    setHistory(prev => [...prev, response]);
  };

  const handleKeyDown = (e) => {
    if (e.key === 'Enter' && currentInput.trim()) {
      executeCommand(currentInput.trim());
      setCurrentInput('');
      setHistoryIndex(-1);
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      if (historyIndex < commandHistory.length - 1) {
        const newIndex = historyIndex + 1;
        setHistoryIndex(newIndex);
        setCurrentInput(commandHistory[commandHistory.length - 1 - newIndex] || '');
      }
    } else if (e.key === 'ArrowDown') {
      e.preventDefault();
      if (historyIndex > -1) {
        const newIndex = historyIndex - 1;
        setHistoryIndex(newIndex);
        setCurrentInput(newIndex === -1 ? '' : commandHistory[commandHistory.length - 1 - newIndex] || '');
      }
    }
  };

  return (
    <div 
      className="bg-stone-900 text-teal-400 font-mono text-sm h-full flex flex-col"
      onClick={handleTerminalClick}
    >
      <div ref={terminalRef} className="p-2 flex-1 overflow-auto whitespace-pre-wrap">
        {history.map((line, i) => (
          <div key={i}>{line}</div>
        ))}
      </div>

      <div className="p-2 flex items-center gap-2 border-t border-stone-700">
        <span className="mr-2">$</span>
        <input
          ref={focusRef}
          type="text"
          value={currentInput}
          onChange={(e) => setCurrentInput(e.target.value)}
          onKeyDown={handleKeyDown}
          className="flex-1 bg-stone-800 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
          autoFocus
        />
      </div>
    </div>
  );
};

export default TerminalWindow;

================
File: config/api.js
================
// API configuration
const API_CONFIG = {
  // Use environment variable with fallback
  BASE_URL: import.meta.env.VITE_API_BASE_URL || '/api',
  
  // Endpoints
  ENDPOINTS: {
    LOGIN: '/login',
    REGISTER: '/register',
    PROFILE: '/profile',
    ANNOUNCEMENT: '/announcement',
    // Chat endpoints
    CHAT_ROOMS: '/chat/rooms',
    CHAT_MESSAGES: '/chat/rooms/:id/messages',
    CHAT_JOIN: '/chat/rooms/:id/join',
    CHAT_DELETE_MESSAGE: '/chat/messages/:id',
    CHAT_DELETE_ROOM: '/chat/rooms/:id',
    // Voice chat endpoints
    VOICE_CHANNELS: '/chat/rooms/:id/voice-channels',
    VOICE_CHANNEL: '/chat/voice-channels/:id',
    VOICE_PARTICIPANTS: '/chat/voice-channels/:id/participants',
    VOICE_DELETE_CHANNEL: '/chat/voice-channels/:id',
    // Admin endpoints
    USERS: '/users',
    // Window state endpoints
    WINDOW_STATES: '/window-states',
    // Workspace endpoints
    WORKSPACES: '/workspaces',
    // File endpoints
    FILES_LIST: '/files',
    FILE_CONTENT: '/files/content',
    FILE_SAVE: '/files/content',
    FILE_CREATE: '/files/create',
    FILE_DELETE: '/files/delete',
    FILE_RENAME: '/files/rename',
    // Public file endpoints
    PUBLIC_FILES_LIST: '/public-files',
    PUBLIC_FILE_CONTENT: '/public-files/content'
  }
};

export default API_CONFIG;

================
File: context/AnnouncementContext.jsx
================
import React, { createContext, useContext, useState, useEffect } from 'react';
import axios from 'axios';
import io from 'socket.io-client';
import API_CONFIG from '../config/api';

const AnnouncementContext = createContext();

export function AnnouncementProvider({ children }) {
  const [announcement, setAnnouncement] = useState('');
  
  // Fetch initial announcement when component mounts
  useEffect(() => {
    const fetchAnnouncement = async () => {
      try {
        const response = await axios.get(
          `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.ANNOUNCEMENT}`
        );
        setAnnouncement(response.data.announcement);
      } catch (error) {
        console.error('Failed to fetch announcement:', error);
      }
    };
    
    fetchAnnouncement();
    
    // Extract the origin from the BASE_URL or use window.location.origin
    const getSocketUrl = () => {
      // If BASE_URL is a full URL (starts with http)
      if (API_CONFIG.BASE_URL.startsWith('http')) {
        try {
          const url = new URL(API_CONFIG.BASE_URL);
          console.log('Using Socket.IO URL from BASE_URL origin:', url.origin);
          return url.origin; // Just the protocol, hostname, and port
        } catch (e) {
          console.error('Invalid BASE_URL format:', e);
        }
      }
      // Otherwise use the current origin
      console.log('Using Socket.IO URL from window.location.origin:', window.location.origin);
      return window.location.origin;
    };
    
    // Improved Socket.IO connection with correct URL
    const socketUrl = getSocketUrl();
    console.log('Connecting Socket.IO to:', socketUrl);
    
    const socket = io(socketUrl, {
      reconnectionAttempts: 5,
      reconnectionDelay: 1000,
      transports: ['websocket', 'polling'],
      path: '/socket.io' // Default Socket.IO path
    });
    
    socket.on('connect', () => {
      console.log('Socket.IO connected, ID:', socket.id);
    });
    
    socket.on('connect_error', (err) => {
      console.error('Socket.IO connection error:', err);
      console.error('Connection details:', {
        url: socketUrl,
        transport: socket.io.engine.transport.name
      });
    });
    
    socket.on('announcement_update', (data) => {
      console.log('Received announcement update:', data);
      setAnnouncement(data.announcement);
      
      // Send acknowledgment back to server
      socket.emit('announcement_received', { 
        received: true, 
        announcement: data.announcement,
        timestamp: new Date().toISOString()
      });
    });
    
    return () => {
      console.log('Disconnecting Socket.IO');
      socket.off('announcement_update');
      socket.disconnect();
    };
  }, []);
  
  // Function to set a new announcement (admin only)
  const updateAnnouncement = async (text) => {
    try {
      const token = localStorage.getItem('auth_token');
      await axios.post(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.ANNOUNCEMENT}`,
        { announcement: text },
        { headers: { Authorization: `Bearer ${token}` } }
      );
      return true;
    } catch (error) {
      console.error('Failed to update announcement:', error);
      return false;
    }
  };

  return (
    <AnnouncementContext.Provider value={{ announcement, updateAnnouncement }}>
      {children}
    </AnnouncementContext.Provider>
  );
}

export function useAnnouncement() {
  return useContext(AnnouncementContext);
}

================
File: context/AuthContext.jsx
================
import React, { createContext, useContext, useState, useEffect } from 'react';
import axios from 'axios';
import API_CONFIG from '../config/api';
import { useWindowState } from './WindowStateContext';
import { useWorkspace } from './WorkspaceContext';

// Create the authentication context
const AuthContext = createContext();

// Internal context for window state access
const InternalAuthContext = createContext();

// Main Auth Provider that doesn't depend on WindowStateContext
export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Check if user is already logged in on component mount
  useEffect(() => {
    const token = localStorage.getItem('auth_token');
    if (token) {
      fetchUserProfile(token);
    } else {
      setLoading(false);
    }
  }, []);

  // Fetch user profile using the token
  const fetchUserProfile = async (token) => {
    try {
      const response = await axios.get(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.PROFILE}`, {
        headers: { Authorization: `Bearer ${token}` }
      });
      
      // If is_admin is not present in the response, default to false
      const userData = {
        ...response.data,
        is_admin: response.data.is_admin || false
      };
      
      setUser(userData);
      setError(null);
    } catch (err) {
      console.error('Failed to fetch user profile:', err);
      localStorage.removeItem('auth_token');
      setError('Session expired. Please login again.');
    } finally {
      setLoading(false);
    }
  };

  // Login function
  const login = async (username, password) => {
    setLoading(true);
    try {
      const response = await axios.post(`${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.LOGIN}`, {
        username,
        password
      });
      
      const { token } = response.data;
      localStorage.setItem('auth_token', token);
      
      await fetchUserProfile(token);
      return { success: true };
    } catch (err) {
      setLoading(false);
      const message = err.response?.data?.message || 'Login failed';
      setError(message);
      return { success: false, message };
    }
  };

  // Logout function (without window state clearing)
  const logout = () => {
    localStorage.removeItem('auth_token');
    setUser(null);
    setError(null);
  };

  // Clear any authentication errors
  const clearError = () => {
    setError(null);
  };

  // Context value
  const value = {
    user,
    loading,
    error,
    login,
    logout,
    clearError,
    isAuthenticated: !!user
  };

  return (
    <InternalAuthContext.Provider value={value}>
      {children}
    </InternalAuthContext.Provider>
  );
}

// Wrapper component that connects AuthContext with WindowStateContext
export function AuthProviderWithWindowState({ children }) {
  // Get the window state context
  const { clearWindowStates, reloadWindowStates } = useWindowState();
  
  // Get the workspace context
  const { setWorkspaces, loadWorkspaces } = useWorkspace();
  
  // Initial workspaces state
  const initialWorkspaces = [
    { id: 1, name: 'Main', root: null, activeNodeId: null, terminalStates: {} },
    { id: 2, name: 'Code', root: null, activeNodeId: null, terminalStates: {} },
    { id: 3, name: 'Terminal', root: null, activeNodeId: null, terminalStates: {} },
    { id: 4, name: 'Preview', root: null, activeNodeId: null, terminalStates: {} }
  ];
  
  // Get the internal auth context
  const auth = useContext(InternalAuthContext);
  
  // Create a new logout function that also clears window states and workspaces
  const logoutWithClear = () => {
    auth.logout();
    clearWindowStates();
    
    // Reset workspaces to initial state
    setWorkspaces(initialWorkspaces);
  };
  
  // Create a new login function that also reloads window states and workspaces
  const loginWithReload = async (username, password) => {
    const result = await auth.login(username, password);
    
    if (result.success) {
      // Reload window states and workspaces after successful login
      console.log('Login successful, reloading window states and workspaces');
      await Promise.all([
        reloadWindowStates(),
        loadWorkspaces()
      ]);
    }
    
    return result;
  };
  
  // Create a new context value with the enhanced functions
  const enhancedValue = {
    ...auth,
    logout: logoutWithClear,
    login: loginWithReload
  };
  
  return (
    <AuthContext.Provider value={enhancedValue}>
      {children}
    </AuthContext.Provider>
  );
}

// Custom hook to use the auth context
export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProviderWithWindowState');
  }
  return context;
}

================
File: context/WindowStateContext.jsx
================
import React, { createContext, useContext, useState, useEffect, useCallback, useMemo, useRef } from 'react';
import axios from 'axios';
import API_CONFIG from '../config/api';

// Create context
const WindowStateContext = createContext();

// Initial state with different content types
const initialState = {
  windowStates: {}
};

// Context provider component
export function WindowStateProvider({ children }) {
  // Use a ref to store the state to avoid re-renders
  const stateRef = useRef(initialState);
  
  // Use useState just to trigger re-renders when needed
  const [, forceUpdate] = useState({});
  
  // Add a ref to track if we should update API
  const isInitialMount = useRef(true);
  const saveTimeoutRef = useRef(null);

  // Load initial state from API once on mount
  useEffect(() => {
    const fetchWindowStates = async () => {
      try {
        const token = localStorage.getItem('auth_token');
        if (!token) {
          isInitialMount.current = false;
          return; // No token, use default empty state
        }
        
        const response = await axios.get(
          `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.WINDOW_STATES}`, 
          { headers: { Authorization: `Bearer ${token}` } }
        );
        
        if (response.data.windowStates) {
          // Update the state ref directly
          stateRef.current = {
            windowStates: response.data.windowStates
          };
          // Force a re-render
          forceUpdate({});
        }
        
        // Mark initial load as complete
        isInitialMount.current = false;
      } catch (error) {
        console.error('Failed to load window states from API:', error);
        isInitialMount.current = false;
      }
    };
    
    fetchWindowStates();
  }, []); // Empty dependency array means this runs once on mount

  // Save to API with debounce
  const saveToAPI = useCallback(() => {
    // Skip saving on initial load
    if (isInitialMount.current) {
      return;
    }
    
    // Clear any existing timeout
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
    }
    
    // Set a new timeout to save the state after a delay
    saveTimeoutRef.current = setTimeout(async () => {
      try {
        const token = localStorage.getItem('auth_token');
        if (!token) return; // No token, don't save
        
        await axios.post(
          `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.WINDOW_STATES}`, 
          { windowStates: stateRef.current.windowStates },
          { headers: { Authorization: `Bearer ${token}` } }
        );
      } catch (error) {
        console.error('Failed to save window states to API:', error);
      }
    }, 500); // 500ms debounce
  }, []);

  // Clear window states (used during logout)
  const clearWindowStates = useCallback(() => {
    stateRef.current = initialState;
    forceUpdate({});
  }, []);

  // Reload window states from API (used after login)
  const reloadWindowStates = useCallback(async () => {
    try {
      const token = localStorage.getItem('auth_token');
      if (!token) {
        return; // No token, use default empty state
      }
      
      const response = await axios.get(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.WINDOW_STATES}`, 
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      if (response.data.windowStates) {
        // Update the state ref directly
        stateRef.current = {
          windowStates: response.data.windowStates
        };
        // Force a re-render
        forceUpdate({});
        console.log('Window states reloaded after login');
      }
    } catch (error) {
      console.error('Failed to reload window states from API:', error);
    }
  }, []);

  // Action creators
  const setWindowState = useCallback((windowId, windowType, content) => {
    // Update the state ref directly
    stateRef.current = {
      ...stateRef.current,
      windowStates: {
        ...stateRef.current.windowStates,
        [windowId]: {
          type: windowType,
          content
        }
      }
    };
    
    // Save to API
    saveToAPI();
    
    // Force a re-render
    forceUpdate({});
  }, [saveToAPI]);

  const removeWindowState = useCallback((windowId) => {
    // Create a new state object
    const newState = {
      ...stateRef.current,
      windowStates: { ...stateRef.current.windowStates }
    };
    
    // Delete the window state
    delete newState.windowStates[windowId];
    
    // Update the state ref
    stateRef.current = newState;
    
    // Save to API
    saveToAPI();
    
    // Force a re-render
    forceUpdate({});
  }, [saveToAPI]);

  const getWindowState = useCallback((windowId) => {
    return stateRef.current.windowStates[windowId] || null;
  }, []);

  // Create a stable context value
  const contextValue = useMemo(() => ({
    windowStates: stateRef.current.windowStates,
    setWindowState,
    removeWindowState,
    getWindowState,
    clearWindowStates,
    reloadWindowStates
  }), [setWindowState, removeWindowState, getWindowState, clearWindowStates, reloadWindowStates]);

  return (
    <WindowStateContext.Provider value={contextValue}>
      {children}
    </WindowStateContext.Provider>
  );
}

// Custom hook to use the window state context
export function useWindowState() {
  const context = useContext(WindowStateContext);
  if (!context) {
    throw new Error('useWindowState must be used within a WindowStateProvider');
  }
  return context;
}

================
File: context/WorkspaceContext.jsx
================
import React, { createContext, useContext, useState, useEffect, useCallback, useMemo } from 'react';
import axios from 'axios';
import API_CONFIG from '../config/api';

// Create context
const WorkspaceContext = createContext();

// Initial workspaces
const initialWorkspaces = [
  { id: 1, name: 'Main', root: null, activeNodeId: null, terminalStates: {} },
  { id: 2, name: 'Code', root: null, activeNodeId: null, terminalStates: {} },
  { id: 3, name: 'Terminal', root: null, activeNodeId: null, terminalStates: {} },
  { id: 4, name: 'Preview', root: null, activeNodeId: null, terminalStates: {} }
];

/**
 * WorkspaceProvider component for managing workspace state
 * This handles the persistence of window layouts across page refreshes
 */
export function WorkspaceProvider({ children }) {
  const [workspaces, setWorkspaces] = useState(initialWorkspaces);
  const [currentWorkspaceIndex, setCurrentWorkspaceIndex] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  
  // Function to load workspaces from server
  const loadWorkspaces = useCallback(async () => {
    try {
      setIsLoading(true);
      
      // Get auth token
      const token = localStorage.getItem('auth_token');
      if (!token) {
        console.log('No auth token found, using initial workspaces');
        setIsLoading(false);
        return;
      }
      
      // Fetch workspaces from server
      const response = await axios.get(
        `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.WORKSPACES}`,
        { headers: { Authorization: `Bearer ${token}` } }
      );
      
      if (response.data && response.data.workspaces) {
        console.log('Loaded workspaces from server:', response.data.workspaces);
        setWorkspaces(response.data.workspaces);
      } else {
        console.log('No saved workspaces found, using initial workspaces');
      }
    } catch (error) {
      console.error('Failed to load workspaces from server:', error);
    } finally {
      setIsLoading(false);
    }
  }, []);
  
  // Load workspaces from server API on mount
  useEffect(() => {
    loadWorkspaces();
  }, [loadWorkspaces]);
  
  // Save workspaces to server API whenever they change
  useEffect(() => {
    if (isLoading) return; // Skip saving during initial load
    
    const saveWorkspaces = async () => {
      try {
        // Get auth token
        const token = localStorage.getItem('auth_token');
        if (!token) return; // Don't save if not authenticated
        
        // Ensure we're only saving the array of workspaces
        // Create a clean copy without any non-array properties
        const workspacesToSave = [...workspaces].map(workspace => ({
          id: workspace.id,
          name: workspace.name,
          root: workspace.root,
          activeNodeId: workspace.activeNodeId,
          terminalStates: workspace.terminalStates || {}
        }));
        
        console.log('Saving workspaces to server:', workspacesToSave);
        
        // Save workspaces to server
        await axios.post(
          `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.WORKSPACES}`,
          { workspaces: workspacesToSave },
          { headers: { Authorization: `Bearer ${token}` } }
        );
      } catch (error) {
        console.error('Failed to save workspaces to server:', error);
      }
    };
    
    const timeoutId = setTimeout(saveWorkspaces, 500); // Debounce
    return () => clearTimeout(timeoutId);
  }, [workspaces, isLoading]);
  
  // Update a specific workspace
  const updateWorkspace = useCallback((index, updater) => {
    setWorkspaces(prev => {
      const updated = [...prev];
      if (typeof updater === 'function') {
        updated[index] = {
          ...updated[index],
          ...updater(updated[index])
        };
      } else {
        updated[index] = {
          ...updated[index],
          ...updater
        };
      }
      return updated;
    });
  }, []);
  
  // Switch to a different workspace
  const switchWorkspace = useCallback((target) => {
    if (typeof target === 'number' && target >= 0 && target < workspaces.length) {
      setCurrentWorkspaceIndex(target);
    } else if (target === 'right' || target === 'left') {
      setCurrentWorkspaceIndex(prev => {
        const newIndex = target === 'right' 
          ? (prev + 1) % workspaces.length 
          : prev - 1 < 0 ? workspaces.length - 1 : prev - 1;
        return newIndex;
      });
    }
  }, [workspaces.length]);
  
  // Context value
  const value = useMemo(() => ({
    workspaces,
    setWorkspaces,
    currentWorkspaceIndex,
    currentWorkspace: workspaces[currentWorkspaceIndex],
    updateWorkspace,
    switchWorkspace,
    isLoading,
    loadWorkspaces
  }), [workspaces, setWorkspaces, currentWorkspaceIndex, updateWorkspace, switchWorkspace, isLoading, loadWorkspaces]);
  
  return (
    <WorkspaceContext.Provider value={value}>
      {children}
    </WorkspaceContext.Provider>
  );
}

// Custom hook to use the workspace context
export function useWorkspace() {
  const context = useContext(WorkspaceContext);
  if (!context) {
    throw new Error('useWorkspace must be used within a WorkspaceProvider');
  }
  return context;
}

================
File: db/db-config.js
================
/**
 * IndexedDB configuration for the window manager
 */

const DB_NAME = 'WindowManagerDB';
const DB_VERSION = 1;
const STORES = {
  WORKSPACES: 'workspaces',
  WINDOW_STATES: 'windowStates'
};

export { DB_NAME, DB_VERSION, STORES };

================
File: db/db-operations.js
================
/**
 * Basic CRUD operations for IndexedDB
 */
import { getDB } from './db';

/**
 * Save data to a store
 * @param {string} storeName - The name of the object store
 * @param {Object} data - The data to save
 * @returns {Promise<any>} A promise that resolves to the result of the operation
 */
export const saveData = async (storeName, data) => {
  const db = await getDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readwrite');
    const store = transaction.objectStore(storeName);
    const request = store.put(data);
    
    request.onerror = (event) => reject(event.target.error);
    request.onsuccess = (event) => resolve(event.target.result);
    
    // Close the database when the transaction is complete
    transaction.oncomplete = () => db.close();
  });
};

/**
 * Get data from a store
 * @param {string} storeName - The name of the object store
 * @param {string|number} id - The ID of the data to retrieve
 * @returns {Promise<any>} A promise that resolves to the retrieved data
 */
export const getData = async (storeName, id) => {
  const db = await getDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readonly');
    const store = transaction.objectStore(storeName);
    const request = store.get(id);
    
    request.onerror = (event) => reject(event.target.error);
    request.onsuccess = (event) => resolve(request.result);
    
    // Close the database when the transaction is complete
    transaction.oncomplete = () => db.close();
  });
};

/**
 * Delete data from a store
 * @param {string} storeName - The name of the object store
 * @param {string|number} id - The ID of the data to delete
 * @returns {Promise<void>} A promise that resolves when the data is deleted
 */
export const deleteData = async (storeName, id) => {
  const db = await getDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readwrite');
    const store = transaction.objectStore(storeName);
    const request = store.delete(id);
    
    request.onerror = (event) => reject(event.target.error);
    request.onsuccess = (event) => resolve();
    
    // Close the database when the transaction is complete
    transaction.oncomplete = () => db.close();
  });
};

/**
 * Get all data from a store
 * @param {string} storeName - The name of the object store
 * @returns {Promise<Array>} A promise that resolves to an array of all data in the store
 */
export const getAllData = async (storeName) => {
  const db = await getDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readonly');
    const store = transaction.objectStore(storeName);
    const request = store.getAll();
    
    request.onerror = (event) => reject(event.target.error);
    request.onsuccess = (event) => resolve(request.result);
    
    // Close the database when the transaction is complete
    transaction.oncomplete = () => db.close();
  });
};

/**
 * Clear all data from a store
 * @param {string} storeName - The name of the object store
 * @returns {Promise<void>} A promise that resolves when the store is cleared
 */
export const clearStore = async (storeName) => {
  const db = await getDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction(storeName, 'readwrite');
    const store = transaction.objectStore(storeName);
    const request = store.clear();
    
    request.onerror = (event) => reject(event.target.error);
    request.onsuccess = (event) => resolve();
    
    // Close the database when the transaction is complete
    transaction.oncomplete = () => db.close();
  });
};

================
File: db/db.js
================
/**
 * IndexedDB initialization and core functionality
 */
import { DB_NAME, DB_VERSION, STORES } from './db-config';

/**
 * Initialize the IndexedDB database
 * @returns {Promise<IDBDatabase>} A promise that resolves to the database instance
 */
export const initDB = () => {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);
    
    request.onerror = (event) => {
      console.error('IndexedDB error:', event.target.error);
      reject('Error opening IndexedDB');
    };
    
    request.onsuccess = (event) => {
      const db = event.target.result;
      console.log('IndexedDB opened successfully');
      resolve(db);
    };
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      
      // Create object stores if they don't exist
      if (!db.objectStoreNames.contains(STORES.WORKSPACES)) {
        db.createObjectStore(STORES.WORKSPACES, { keyPath: 'id' });
        console.log(`Created ${STORES.WORKSPACES} object store`);
      }
      
      if (!db.objectStoreNames.contains(STORES.WINDOW_STATES)) {
        db.createObjectStore(STORES.WINDOW_STATES, { keyPath: 'id' });
        console.log(`Created ${STORES.WINDOW_STATES} object store`);
      }
    };
  });
};

/**
 * Get a database connection
 * @returns {Promise<IDBDatabase>} A promise that resolves to the database instance
 */
export const getDB = () => {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME);
    request.onerror = (event) => reject(event.target.error);
    request.onsuccess = (event) => resolve(event.target.result);
  });
};

================
File: hocs/withCommandHandling.jsx
================
import React from 'react';
import { WINDOW_TYPES } from '../utils/windowTypes';

/**
 * Higher-Order Component that adds command handling capabilities to window components.
 * This HOC provides a standardized way to handle commands across different window types,
 * particularly focusing on window transformation commands.
 *
 * @param {React.Component} WrappedComponent - The window component to enhance with command handling
 * @returns {React.Component} - A new component with command handling capabilities
 */
const withCommandHandling = (WrappedComponent) => {
  // Return a new component that includes the command handling functionality
  return function WithCommandHandling({ 
    transformWindow, // Function to change window type
    nodeId,         // Unique identifier for the window
    ...props        // All other props passed to the window
  }) {
    /**
     * Handles commands entered in the window.
     * Currently supports window transformation commands (e.g., 'terminal', 'editor', etc.)
     * Can be extended to handle other command types in the future.
     *
     * @param {string} command - The command string to process
     * @returns {boolean} - Whether the command was handled
     */
    const handleCommand = (command) => {
      // Convert command to lowercase for case-insensitive comparison
      const cmd = command.toLowerCase();
      
      // Check if the command matches any window type
      // This allows commands like 'terminal', 'editor', 'explorer', 'preview'
      const isWindowTypeCommand = Object.keys(WINDOW_TYPES).some(
        type => type.toLowerCase() === cmd
      );

      if (isWindowTypeCommand) {
        // Get the actual window type constant from our types enum
        const requestedType = WINDOW_TYPES[cmd.toUpperCase()];
        
        // Log the transformation request for debugging
        console.log(`Transforming window ${nodeId} to ${requestedType}`);
        
        // Execute the transformation
        transformWindow(nodeId, requestedType);
        
        // Return true to indicate the command was handled
        return true;
      }
      
      // Return false if the command wasn't handled by this HOC
      // This allows the wrapped component to handle other commands if needed
      return false;
    };
    
    // Render the wrapped component with both the original props
    // and our new command handler
    return (
      <WrappedComponent 
        {...props} 
        transformWindow={transformWindow}
        nodeId={nodeId}
        onCommand={handleCommand}
      />
    );
  };
};

export default withCommandHandling;

================
File: hocs/withCommandInput.jsx
================
import React, { useState, useRef } from 'react';

/**
 * Higher-Order Component that adds a command input field to any window component.
 * This HOC provides a standardized way to input commands across different window types.
 * The command input is added at the bottom of the window, after any existing content.
 *
 * @param {React.Component} WrappedComponent - The window component to enhance with a command input
 * @returns {React.Component} - A new component with a command input field
 */
const withCommandInput = (WrappedComponent) => {
  return function WithCommandInput({
    onCommand,
    focusRef,
    ...props
  }) {
    const [command, setCommand] = useState('');
    const commandInputRef = useRef(null);

    // Use the provided focusRef for the command input
    const combinedRef = (el) => {
      commandInputRef.current = el;
      if (focusRef) {
        focusRef.current = el;
      }
    };

    const handleKeyDown = (e) => {
      if (e.key === 'Enter' && command.trim()) {
        onCommand(command.trim());
        setCommand('');
      }
    };

    return (
      <div className="h-full flex flex-col">
        {/* Original component takes most of the space */}
        <div className="flex-1 overflow-auto">
          <WrappedComponent
            {...props}
            onCommand={onCommand}
          />
        </div>
        
        {/* Command input - always at the bottom */}
        <div className="p-2 flex items-center gap-2 border-t border-stone-700 bg-stone-900">
          <span className="text-teal-400 mr-2">$</span>
          <input
            ref={combinedRef}
            type="text"
            value={command}
            onChange={(e) => setCommand(e.target.value)}
            onKeyDown={handleKeyDown}
            className="flex-1 bg-stone-800 text-teal-400 px-2 py-1 rounded font-mono text-sm focus:outline-none"
          />
        </div>
      </div>
    );
  };
};

export default withCommandInput;

================
File: hocs/withWindowState.jsx
================
import React, { useCallback, useMemo, useRef, useEffect } from 'react';
import { useWindowState } from '../context/WindowStateContext';

/**
 * Higher-Order Component that adds state management capabilities to window components.
 * This HOC provides a standardized way to manage window state across different window types.
 *
 * @param {React.Component} WrappedComponent - The window component to enhance with state management
 * @param {string} windowType - The type of window from WINDOW_TYPES
 * @returns {React.Component} - A new component with state management capabilities
 */
const withWindowState = (WrappedComponent, windowType) => {
  return function WithWindowState({ 
    nodeId,
    isActive,
    ...props
  }) {
    // Create a ref for auto-focusing input elements
    const focusRef = useRef(null);
    
    // Auto-focus when window becomes active
    useEffect(() => {
      if (isActive && focusRef.current) {
        focusRef.current.focus();
      }
    }, [isActive]);
    // Access the window state context
    const { getWindowState, setWindowState } = useWindowState();
    
    // Get the current state or use an empty object if none exists
    // Use useMemo to avoid recreating the object on every render
    const currentState = useMemo(() => {
      return getWindowState(nodeId)?.content || {};
    }, [getWindowState, nodeId]);
    
    // Create an updater function for the component to use
    // Use useCallback to avoid recreating the function on every render
    const updateWindowState = useCallback((updates) => {
      // Get the latest state to ensure we're working with current data
      const latestState = getWindowState(nodeId)?.content || {};
      
      // Allow both object and function updaters
      const newContent = typeof updates === 'function'
        ? updates(latestState)
        : { ...latestState, ...updates };
        
      setWindowState(nodeId, windowType, newContent);
    }, [getWindowState, setWindowState, nodeId, windowType]);
    
    return (
      <WrappedComponent
        {...props}
        nodeId={nodeId}
        windowState={currentState}
        updateWindowState={updateWindowState}
        isActive={isActive}
        focusRef={focusRef}
      />
    );
  };
};

export default withWindowState;

================
File: hooks/swapWindows.js
================
// Function to swap two windows in the tree
const swapWindows = useCallback((sourceId, targetId) => {
  if (!sourceId || !targetId || sourceId === targetId) return;

  console.log('Swapping windows:', sourceId, targetId);

  updateWorkspace(workspace => {
    const newRoot = JSON.parse(JSON.stringify(workspace.root));
    
    // Find the nodes to swap
    const sourceNode = findNodeById(newRoot, sourceId);
    const targetNode = findNodeById(newRoot, targetId);
    
    if (!sourceNode || !targetNode) {
      console.log('Could not find one or both nodes to swap');
      return workspace;
    }
    
    // Swap the window types and states
    const tempWindowType = sourceNode.windowType;
    const tempState = sourceNode.state;
    
    sourceNode.windowType = targetNode.windowType;
    sourceNode.state = targetNode.state;
    
    targetNode.windowType = tempWindowType;
    targetNode.state = tempState;
    
    return { ...workspace, root: newRoot };
  });
  
  // Exit move mode after swapping
  setIsMoveMode(false);
  setMoveSourceWindowId(null);
}, [updateWorkspace]);

// Add direct keyboard event listener for move mode
useEffect(() => {
  const handleMoveKeyDown = (e) => {
    // Handle move mode toggle
    if (e.ctrlKey && e.key === 'm') {
      e.preventDefault();
      e.stopPropagation(); // Stop event propagation to prevent multiple handlers
      console.log('Move mode toggle pressed directly in useWindowManager');
      console.log('Current isMoveMode:', isMoveMode);
      
      // Toggle move mode
      setIsMoveMode(!isMoveMode);
      
      // Reset source window when toggling off
      if (isMoveMode) {
        setMoveSourceWindowId(null);
      }
    }
    
    // Handle move mode Enter key
    if (isMoveMode && e.key === 'Enter') {
      e.preventDefault();
      e.stopPropagation();
      console.log('Enter key pressed in move mode');
      
      if (!moveSourceWindowId) {
        // First window selection
        console.log('Selected first window for move:', activeNodeId);
        setMoveSourceWindowId(activeNodeId);
      } else {
        // Second window selection - perform the swap
        console.log('Selected second window for move:', activeNodeId);
        swapWindows(moveSourceWindowId, activeNodeId);
      }
    }
  };
  
  // Add the event listener with capture: true to ensure it runs before other listeners
  window.addEventListener('keydown', handleMoveKeyDown, { capture: true });
  return () => window.removeEventListener('keydown', handleMoveKeyDown, { capture: true });
}, [isMoveMode, moveSourceWindowId, activeNodeId, setIsMoveMode, setMoveSourceWindowId, swapWindows]);

// Debug checks for modes
useEffect(() => {
  console.log('Resize mode:', isResizeMode);
}, [isResizeMode]);

useEffect(() => {
  console.log('Move mode:', isMoveMode);
  if (!isMoveMode) {
    setMoveSourceWindowId(null);
  }
}, [isMoveMode]);

// Function to update terminal state
const updateTerminalState = useCallback((terminalId, newState) => {
  updateWorkspace(workspace => ({
    ...workspace,
    terminalStates: {
      ...workspace.terminalStates,
      [terminalId]: newState
    }
  }));
}, [updateWorkspace]);

return {
  rootNode,
  activeNodeId,
  setActiveNodeId,
  terminalStates,
  updateTerminalState,
  createNewWindow,
  splitWindow,
  closeWindow,
  transformWindow,
  handleCommand,
  navigateToWindow,
  hasActiveWindow: Boolean(activeNodeId),
  hasRootNode: Boolean(rootNode),
  currentWorkspaceIndex,
  workspaceCount: 4,
  switchWorkspace,
  isResizeMode,
  setIsResizeMode,
  resizeActiveWindow,
  isMoveMode,
  setIsMoveMode,
  moveSourceWindowId,
  setMoveSourceWindowId,
  swapWindows
};

================
File: hooks/useForceUpdate.js
================
import { useState } from 'react';

export function useForceUpdate() {
    const [state, setState] = useState(0);
    return () => setState((state) => state + 1);
  }

================
File: hooks/useKeyboardShortcuts.js
================
import { useEffect } from 'react';
import { WINDOW_TYPES } from '../utils/windowTypes';

/**
 * A custom hook that manages keyboard shortcuts for window operations.
 * This hook centralizes all keyboard-related logic for the window manager.
 * 
 * @param {Object} handlers - Object containing callback functions for various window operations
 * @param {Function} handlers.onSplitVertical - Handler for vertical split command
 * @param {Function} handlers.onSplitHorizontal - Handler for horizontal split command
 * @param {Function} handlers.onClose - Handler for window close command
 * @param {Function} handlers.createNewWindow - Handler for creating new windows
 * @param {boolean} hasActiveWindow - Whether there is currently an active window
 * @param {boolean} hasRootNode - Whether there is a root node in the tree
 */
export const useKeyboardShortcuts = ({
  onSplitVertical,
  onSplitHorizontal,
  onClose,
  createNewWindow,
  hasActiveWindow,
  hasRootNode,
  isResizeMode = false,
  setIsResizeMode = () => console.warn('setIsResizeMode not provided'),
  resizeActiveWindow = () => console.warn('resizeActiveWindow not provided'),
  isMoveMode = false,
  setIsMoveMode = () => console.warn('setIsMoveMode not provided'),
  moveSourceWindowId = null,
  setMoveSourceWindowId = () => console.warn('setMoveSourceWindowId not provided'),
  swapWindows = () => console.warn('swapWindows not provided'),
  activeNodeId = null
}) => {
  // Log the props for debugging
  console.log('useKeyboardShortcuts props:', {
    isResizeMode,
    isMoveMode,
    moveSourceWindowId,
    activeNodeId,
    hasSetIsResizeMode: typeof setIsResizeMode === 'function',
    hasSetIsMoveMode: typeof setIsMoveMode === 'function',
    hasSetMoveSourceWindowId: typeof setMoveSourceWindowId === 'function',
    hasSwapWindows: typeof swapWindows === 'function'
  });
  useEffect(() => {
    const handleKeyDown = (e) => {
      // Handle resize mode toggle
      if (e.ctrlKey && e.key === 'q') {
        e.preventDefault();
        setIsResizeMode(!isResizeMode);
        // Exit move mode if it's active
        if (isMoveMode) {
          setIsMoveMode(false);
          setMoveSourceWindowId(null);
        }
        return;
      }

      // Handle move mode toggle
      if (e.ctrlKey && e.key === 'm') {
        e.preventDefault();
        e.stopPropagation(); // Stop event propagation to prevent multiple handlers
        console.log('Move mode toggle pressed in useKeyboardShortcuts');
        console.log('setIsMoveMode type:', typeof setIsMoveMode);
        console.log('Current isMoveMode:', isMoveMode);
        console.log('Component ID:', Math.random()); // Add a random ID to identify which instance is handling the event
        
        // Check if setIsMoveMode is a function before calling it
        if (typeof setIsMoveMode === 'function') {
          // Toggle move mode with a direct call to ensure it works
          const newMoveMode = !isMoveMode;
          console.log('Setting move mode to:', newMoveMode);
          setIsMoveMode(newMoveMode);
          
          // Reset source window when toggling off
          if (isMoveMode && typeof setMoveSourceWindowId === 'function') {
            setMoveSourceWindowId(null);
          }
          
          // Exit resize mode if it's active
          if (isResizeMode && typeof setIsResizeMode === 'function') {
            setIsResizeMode(false);
          }
        } else {
          console.error('setIsMoveMode is not a function');
        }
        return;
      }

      // Handle move mode Enter key
      if (isMoveMode && e.key === 'Enter') {
        e.preventDefault();
        console.log('Enter key pressed in move mode');
        
        if (!moveSourceWindowId) {
          // First window selection
          console.log('Selected first window for move:', activeNodeId);
          if (typeof setMoveSourceWindowId === 'function') {
            setMoveSourceWindowId(activeNodeId);
          } else {
            console.error('setMoveSourceWindowId is not a function');
          }
        } else {
          // Second window selection - perform the swap
          console.log('Selected second window for move:', activeNodeId);
          if (typeof swapWindows === 'function') {
            swapWindows(moveSourceWindowId, activeNodeId);
          } else {
            console.error('swapWindows is not a function');
          }
        }
        return;
      }

      // Handle resize mode arrow keys
      if (isResizeMode && !e.ctrlKey) {
        switch (e.key) {
          case 'ArrowLeft':
            e.preventDefault();
            resizeActiveWindow('left');
            break;
          case 'ArrowRight':
            e.preventDefault();
            resizeActiveWindow('right');
            break;
          case 'ArrowUp':
            e.preventDefault();
            resizeActiveWindow('up');
            break;
          case 'ArrowDown':
            e.preventDefault();
            resizeActiveWindow('down');
            break;
        }
        return;
      }

      // Handle other keyboard shortcuts...
      if (e.ctrlKey) {
        if (e.key === 'Enter') {
          e.preventDefault();
          if (e.shiftKey) {
            hasActiveWindow ? onSplitVertical() : createNewWindow();
          } else {
            hasActiveWindow ? onSplitHorizontal() : createNewWindow();
          }
        } else if ((e.key === 'Backspace' || e.key === 'Delete') && hasActiveWindow && hasRootNode) {
          e.preventDefault();
          onClose();
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [
    onSplitVertical,
    onSplitHorizontal,
    onClose,
    createNewWindow,
    hasActiveWindow,
    hasRootNode,
    isResizeMode,
    setIsResizeMode,
    resizeActiveWindow,
    isMoveMode,
    setIsMoveMode,
    moveSourceWindowId,
    setMoveSourceWindowId,
    swapWindows,
    activeNodeId
  ]);
};

================
File: hooks/useWindowManager.js
================
import { useState, useCallback, useEffect, useRef } from 'react';
import { Node } from '../models/Node';
import { WINDOW_TYPES } from '../utils/windowTypes';
import { 
  splitNodeById, 
  removeNodeById, 
  findNodeById, 
  findAllWindowIds,
  updateSplitRatio,
} from '../utils/treeUtils';
import { getWindowBounds } from '../utils/windowUtils';
import { useWindowState } from '../context/WindowStateContext';
import { useWorkspace } from '../context/WorkspaceContext';
import { 
  MIN_WINDOW_WIDTH_PX, 
  MIN_WINDOW_HEIGHT_PX 
} from '../utils/windowSizeConstants';

export const useWindowManager = ({ defaultLayout = null, onFlashBorder = null } = {}) => {
  // Use workspace context instead of internal state
  const { 
    workspaces,
    currentWorkspaceIndex,
    currentWorkspace,
    updateWorkspace,
    switchWorkspace
  } = useWorkspace();
  
  // Get current workspace data
  const rootNode = currentWorkspace.root;
  const activeNodeId = currentWorkspace.activeNodeId;
  const terminalStates = currentWorkspace.terminalStates;
  
  const [isResizeMode, setIsResizeMode] = useState(false);
  const [isMoveMode, setIsMoveMode] = useState(false);
  const [moveSourceWindowId, setMoveSourceWindowId] = useState(null);

  // Create setActiveNodeId function that updates the workspace
  const setActiveNodeId = useCallback((nodeId) => {
    updateWorkspace(currentWorkspaceIndex, workspace => ({
      ...workspace,
      activeNodeId: nodeId
    }));
  }, [updateWorkspace, currentWorkspaceIndex]);

  useEffect(() => {
    const handleWorkspaceKeys = (e) => {
      if (e.ctrlKey && e.altKey) {
        switch (e.key) {
          case 'ArrowRight':
            e.preventDefault();
            switchWorkspace('right');
            break;
          case 'ArrowLeft':
            e.preventDefault();
            switchWorkspace('left');
            break;
          // Removed 'n' key handler for creating new workspaces
        }
      }
    };

    window.addEventListener('keydown', handleWorkspaceKeys);
    return () => window.removeEventListener('keydown', handleWorkspaceKeys);
  }, [switchWorkspace]);

  // Window navigation functions
  const navigateToWindow = useCallback((direction) => {
    if (!activeNodeId || !rootNode) return;
  
    const allWindows = getWindowBounds(rootNode);
    const activeWindow = allWindows.find(w => w.id === activeNodeId);
    if (!activeWindow) return;
  
    // Filter out the active window
    const otherWindows = allWindows.filter(w => w.id !== activeNodeId);
    
    // If no other windows, nothing to navigate to
    if (otherWindows.length === 0) return;
    
    // Calculate the active window's center
    const activeBounds = activeWindow.bounds;
    
    // Helper function to calculate overlap percentage between windows
    const calculateOverlap = (window1, window2, isHorizontal) => {
      if (isHorizontal) {
        // Calculate horizontal overlap
        const overlapStart = Math.max(window1.left, window2.left);
        const overlapEnd = Math.min(window1.right, window2.right);
        if (overlapEnd <= overlapStart) return 0; // No overlap
        
        const overlapWidth = overlapEnd - overlapStart;
        const window1Width = window1.right - window1.left;
        
        return overlapWidth / window1Width;
      } else {
        // Calculate vertical overlap
        const overlapStart = Math.max(window1.top, window2.top);
        const overlapEnd = Math.min(window1.bottom, window2.bottom);
        if (overlapEnd <= overlapStart) return 0; // No overlap
        
        const overlapHeight = overlapEnd - overlapStart;
        const window1Height = window1.bottom - window1.top;
        
        return overlapHeight / window1Height;
      }
    };
    
    // Find windows in the specified direction with a more relaxed approach
    let candidateWindows = [];
    const tolerance = 0.1; // 10% tolerance for adjacency
    
    switch (direction) {
      case 'up':
        // Windows that are above the active window
        candidateWindows = otherWindows.filter(w => {
          const bounds = w.bounds;
          // Window must be above the active window
          if (bounds.bottom > activeBounds.top) return false;
          
          // Calculate horizontal overlap
          const overlap = calculateOverlap(activeBounds, bounds, true);
          return overlap > 0; // Any overlap makes it a candidate
        });
        break;
        
      case 'down':
        // Windows that are below the active window
        candidateWindows = otherWindows.filter(w => {
          const bounds = w.bounds;
          // Window must be below the active window
          if (bounds.top < activeBounds.bottom) return false;
          
          // Calculate horizontal overlap
          const overlap = calculateOverlap(activeBounds, bounds, true);
          return overlap > 0; // Any overlap makes it a candidate
        });
        break;
        
      case 'left':
        // Windows that are to the left of the active window
        candidateWindows = otherWindows.filter(w => {
          const bounds = w.bounds;
          // Window must be to the left of the active window
          if (bounds.right > activeBounds.left) return false;
          
          // Calculate vertical overlap
          const overlap = calculateOverlap(activeBounds, bounds, false);
          return overlap > 0; // Any overlap makes it a candidate
        });
        break;
        
      case 'right':
        // Windows that are to the right of the active window
        candidateWindows = otherWindows.filter(w => {
          const bounds = w.bounds;
          // Window must be to the right of the active window
          if (bounds.left < activeBounds.right) return false;
          
          // Calculate vertical overlap
          const overlap = calculateOverlap(activeBounds, bounds, false);
          return overlap > 0; // Any overlap makes it a candidate
        });
        break;
    }
    
    // If no candidates found, return
    if (candidateWindows.length === 0) return;
    
    // Calculate scores for each candidate window based on:
    // 1. Overlap percentage (higher is better)
    // 2. Distance from active window (lower is better)
    const scoredWindows = candidateWindows.map(window => {
      const bounds = window.bounds;
      let overlapScore = 0;
      let distanceScore = 0;
      
      switch (direction) {
        case 'up':
          overlapScore = calculateOverlap(activeBounds, bounds, true);
          distanceScore = activeBounds.top - bounds.bottom;
          break;
          
        case 'down':
          overlapScore = calculateOverlap(activeBounds, bounds, true);
          distanceScore = bounds.top - activeBounds.bottom;
          break;
          
        case 'left':
          overlapScore = calculateOverlap(activeBounds, bounds, false);
          distanceScore = activeBounds.left - bounds.right;
          break;
          
        case 'right':
          overlapScore = calculateOverlap(activeBounds, bounds, false);
          distanceScore = bounds.left - activeBounds.right;
          break;
      }
      
      // Normalize distance score (closer is better)
      const normalizedDistanceScore = 1 / (1 + distanceScore);
      
      // Calculate final score with higher weight on overlap
      const finalScore = (overlapScore * 0.7) + (normalizedDistanceScore * 0.3);
      
      return {
        window,
        overlapScore,
        distanceScore,
        finalScore
      };
    });
    
    // Sort by final score (higher is better)
    scoredWindows.sort((a, b) => b.finalScore - a.finalScore);
    
    // Select the window with the highest score
    const nextWindow = scoredWindows[0].window;
    
    if (nextWindow) {
      setActiveNodeId(nextWindow.id);
    }
  }, [activeNodeId, rootNode, setActiveNodeId]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (!e.ctrlKey) return;
  
      switch (e.key) {
        case 'ArrowLeft':
          e.preventDefault();
          navigateToWindow('left');
          break;
        case 'ArrowRight':
          e.preventDefault();
          navigateToWindow('right');
          break;
        case 'ArrowUp':
          e.preventDefault();
          navigateToWindow('up');
          break;
        case 'ArrowDown':
          e.preventDefault();
          navigateToWindow('down');
          break;
      }
    };
  
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [navigateToWindow]);

  // Get window state management functions
  const { getWindowState, setWindowState, removeWindowState } = useWindowState();

  // Helper function to convert percentage-based bounds to pixel dimensions
  const calculatePixelDimensions = useCallback((bounds) => {
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;
    
    const pixelDimensions = {
      width: (bounds.width / 100) * windowWidth,
      height: (bounds.height / 100) * windowHeight
    };
    
    console.log('Window dimensions (percentage):', bounds);
    console.log('Window dimensions (pixels):', pixelDimensions);
    console.log('Minimum required:', MIN_WINDOW_WIDTH_PX, 'x', MIN_WINDOW_HEIGHT_PX);
    console.log('Is too small:', 
      pixelDimensions.width < MIN_WINDOW_WIDTH_PX || 
      pixelDimensions.height < MIN_WINDOW_HEIGHT_PX
    );
    
    return pixelDimensions;
  }, []);

  // Helper function to check if a resize operation would result in windows that are too small
  const wouldViolateMinSize = useCallback((root, direction, affectedSplits, resizeStep) => {
    console.log('Checking if resize would violate minimum size...');
    console.log('Direction:', direction);
    console.log('Affected splits:', affectedSplits.length);
    console.log('Browser window size:', window.innerWidth, 'x', window.innerHeight);
    
    // Create a deep copy of the root to simulate the resize
    const simulatedRoot = JSON.parse(JSON.stringify(root));
    
    // Apply the resize to the simulated root
    affectedSplits.forEach(({ node: originalNode, targetInFirst, isRightSide, isBottomSide }) => {
      // Find the corresponding node in the simulated root
      const simulatedNode = findNodeById(simulatedRoot, originalNode.id);
      if (!simulatedNode) return;
      
      console.log('Simulating resize on node:', simulatedNode.id);
      console.log('Original split ratio:', simulatedNode.splitRatio);
      
      // Determine effective direction
      let effectiveDirection = direction;
      if (isRightSide && (direction === 'left' || direction === 'right')) {
        effectiveDirection = direction === 'left' ? 'right' : 'left';
      }
      if (isBottomSide && (direction === 'up' || direction === 'down')) {
        effectiveDirection = direction === 'up' ? 'down' : 'up';
      }
      
      console.log('Effective direction:', effectiveDirection);
      
      // Apply the resize
      switch (effectiveDirection) {
        case 'left': // Shrink width
          if (targetInFirst) {
            simulatedNode.splitRatio = Math.max(0.1, simulatedNode.splitRatio - resizeStep);
          } else {
            simulatedNode.splitRatio = Math.min(0.9, simulatedNode.splitRatio + resizeStep);
          }
          break;
          
        case 'right': // Grow width
          if (targetInFirst) {
            simulatedNode.splitRatio = Math.min(0.9, simulatedNode.splitRatio + resizeStep);
          } else {
            simulatedNode.splitRatio = Math.max(0.1, simulatedNode.splitRatio - resizeStep);
          }
          break;
          
        case 'up': // Shrink height
          if (targetInFirst) {
            simulatedNode.splitRatio = Math.max(0.1, simulatedNode.splitRatio - resizeStep);
          } else {
            simulatedNode.splitRatio = Math.min(0.9, simulatedNode.splitRatio + resizeStep);
          }
          break;
          
        case 'down': // Grow height
          if (targetInFirst) {
            simulatedNode.splitRatio = Math.min(0.9, simulatedNode.splitRatio + resizeStep);
          } else {
            simulatedNode.splitRatio = Math.max(0.1, simulatedNode.splitRatio - resizeStep);
          }
          break;
      }
      
      console.log('New split ratio:', simulatedNode.splitRatio);
    });
    
    // Calculate the bounds of all windows after the simulated resize
    const simulatedWindows = getWindowBounds(simulatedRoot);
    console.log('Number of windows to check:', simulatedWindows.length);
    
    // Check if any window would be smaller than the minimum size
    const tooSmallWindows = simulatedWindows.filter(window => {
      const pixelDimensions = calculatePixelDimensions(window.bounds);
      return pixelDimensions.width < MIN_WINDOW_WIDTH_PX || 
             pixelDimensions.height < MIN_WINDOW_HEIGHT_PX;
    });
    
    const wouldViolate = tooSmallWindows.length > 0;
    console.log('Windows that would be too small:', tooSmallWindows.length);
    console.log('Would violate minimum size:', wouldViolate);
    
    return wouldViolate;
  }, [calculatePixelDimensions]);

  // Define splitWindow before createNewWindow since createNewWindow depends on it
  const splitWindow = useCallback((nodeId, direction, newWindow = null) => {
    // Create a new terminal window if one wasn't provided
    if (!newWindow) {
      newWindow = Node.createWindow(Date.now(), WINDOW_TYPES.TERMINAL);
      
      // Initialize terminal state with default content
      const initialContent = {
        history: ['Welcome to the Terminal! Type "help" for available commands.'],
        commandHistory: []
      };
      
      // Set the initial window state for the terminal
      setWindowState(newWindow.id, WINDOW_TYPES.TERMINAL, initialContent);
      
      // Also update the workspace terminal states
      updateWorkspace(currentWorkspaceIndex, workspace => ({
        ...workspace,
        terminalStates: {
          ...workspace.terminalStates,
          [newWindow.id]: {
            history: initialContent.history,
            commandHistory: initialContent.commandHistory
          }
        }
      }));
    }
    
    // Check if splitting would result in windows that are too small
    const simulatedRoot = JSON.parse(JSON.stringify(rootNode));
    const simulatedSplitRoot = splitNodeById(simulatedRoot, nodeId, direction, JSON.parse(JSON.stringify(newWindow)));
    
    // Calculate the bounds of all windows after the simulated split
    const simulatedWindows = getWindowBounds(simulatedSplitRoot);
    console.log('Simulating split - number of windows:', simulatedWindows.length);
    
    // Check if any window would be smaller than the minimum size
    const tooSmallWindows = simulatedWindows.filter(window => {
      const pixelDimensions = calculatePixelDimensions(window.bounds);
      return pixelDimensions.width < MIN_WINDOW_WIDTH_PX || 
             pixelDimensions.height < MIN_WINDOW_HEIGHT_PX;
    });
    
    const wouldViolate = tooSmallWindows.length > 0;
    console.log('Split would create windows that are too small:', wouldViolate);
    
    if (wouldViolate) {
      console.log('Split blocked: would result in windows smaller than minimum size');
      // Flash the window being split to indicate we've hit the minimum size
      if (onFlashBorder && nodeId) {
        onFlashBorder(nodeId);
      }
      return;
    }
  
  updateWorkspace(currentWorkspaceIndex, workspace => ({
    ...workspace,
    root: splitNodeById(workspace.root, nodeId, direction, newWindow)
  }));
  }, [updateWorkspace, getWindowState, setWindowState, rootNode, calculatePixelDimensions, currentWorkspaceIndex]);

  const createNewWindow = useCallback((windowType) => {
    const newNode = Node.createWindow(Date.now(), windowType || WINDOW_TYPES.TERMINAL);
    
    // Initialize window state based on window type
    const initialContent = {};
    
    if (windowType === WINDOW_TYPES.TERMINAL) {
      // Initialize terminal state
      initialContent.history = ['Welcome to the Terminal! Type "help" for available commands.'];
      initialContent.commandHistory = [];
      
      updateWorkspace(currentWorkspaceIndex, workspace => ({
        ...workspace,
        terminalStates: {
          ...workspace.terminalStates,
          [newNode.id]: {
            history: initialContent.history,
            commandHistory: initialContent.commandHistory
          }
        }
      }));
    } else if (windowType === WINDOW_TYPES.EDITOR) {
      // Initialize editor state with default content
      initialContent.text = `function hello() {\n  console.log("Hello, World!");\n}\n\n// Call the function\nhello();`;
    } else if (windowType === WINDOW_TYPES.EXPLORER) {
      // Initialize explorer state
      initialContent.currentPath = '/';
      initialContent.selectedItem = null;
    }
    
    // Set the initial window state
    setWindowState(newNode.id, newNode.windowType, initialContent);
    
    if (!rootNode) {
      // First window, always allowed
      updateWorkspace(currentWorkspaceIndex, {
        root: newNode,
        activeNodeId: newNode.id
      });
      return;
    }
    
    if (!activeNodeId) {
      // No active window, but we have a root - this is unusual
      // Let's check if we can add a window without violating minimum size
      const simulatedRoot = JSON.parse(JSON.stringify(rootNode));
      const simulatedWindows = getWindowBounds(simulatedRoot);
      
      // Check if existing windows are already too small
      const tooSmallWindows = simulatedWindows.filter(window => {
        const pixelDimensions = calculatePixelDimensions(window.bounds);
        return pixelDimensions.width < MIN_WINDOW_WIDTH_PX || 
               pixelDimensions.height < MIN_WINDOW_HEIGHT_PX;
      });
      
      if (tooSmallWindows.length > 0) {
        console.log('Cannot create new window: existing windows are already too small');
        // Flash the window that would be affected
        if (onFlashBorder && rootNode) {
          // If there's no active window but there's a root node, flash the root node
          const nodeToFlash = rootNode.type === 'window' ? rootNode.id : null;
          if (nodeToFlash) {
            onFlashBorder(nodeToFlash);
          }
        }
        return;
      }
      
      updateWorkspace(currentWorkspaceIndex, {
        root: newNode,
        activeNodeId: newNode.id
      });
      return;
    }
    
    // Use splitWindow which already has minimum size checks
    splitWindow(activeNodeId, 'vertical', newNode);
    setActiveNodeId(newNode.id);
  }, [rootNode, activeNodeId, updateWorkspace, setActiveNodeId, setWindowState, calculatePixelDimensions, splitWindow, currentWorkspaceIndex]);

  const closeWindow = useCallback((nodeId) => {
    // Clean up window state when closing a window
    removeWindowState(nodeId);
    
    if (rootNode.type === 'window' && rootNode.id === nodeId) {
      updateWorkspace(currentWorkspaceIndex, {
        root: null,
        activeNodeId: null
      });
      return;
    }

    const newRoot = JSON.parse(JSON.stringify(rootNode));
    const result = removeNodeById(newRoot, nodeId);
    
    if (activeNodeId === nodeId && result) {
      const nextWindowId = findAllWindowIds(result)[0] || null;
      updateWorkspace(currentWorkspaceIndex, {
        root: result,
        activeNodeId: nextWindowId
      });
    } else {
      updateWorkspace(currentWorkspaceIndex, {
        root: result
      });
    }
  }, [rootNode, activeNodeId, updateWorkspace, removeWindowState, currentWorkspaceIndex]);

  const transformWindow = useCallback((nodeId, newType) => {
    const newRoot = JSON.parse(JSON.stringify(rootNode));
    
    // Get the current window state before transformation
    const currentWindowState = getWindowState(nodeId);
    
    const updateNodeInTree = (node) => {
      if (!node) return null;
      
      if (node.type === 'window' && node.id === nodeId) {
        // Update the window type
        node.windowType = newType;
        
        // Update the window state with the new type but preserve content
        if (currentWindowState) {
          // If transforming to a terminal window, clear the currentInput field
          if (newType === WINDOW_TYPES.TERMINAL) {
            const updatedContent = { 
              ...currentWindowState.content,
              currentInput: '' // Clear the input field
            };
            setWindowState(nodeId, newType, updatedContent);
          } else {
            setWindowState(nodeId, newType, currentWindowState.content);
          }
        }
        
        return true;
      }
      
      if (node.type === 'split') {
        return updateNodeInTree(node.first) || updateNodeInTree(node.second);
      }
      
      return false;
    };
    
    const updated = updateNodeInTree(newRoot);
    if (updated) {
      updateWorkspace(currentWorkspaceIndex, {
        root: newRoot
      });
    }
  }, [rootNode, updateWorkspace, getWindowState, setWindowState, currentWorkspaceIndex]);

  const handleCommand = useCallback((command) => {
    const parts = command.split(' ');
    const cmd = parts[0].toLowerCase();

    switch (cmd) {
      case 'split':
        if (activeNodeId) {
          const direction = parts[1] === 'vertical' ? 'vertical' : 'horizontal';
          splitWindow(activeNodeId, direction);
        }
        break;
      case 'close':
        if (activeNodeId) {
          closeWindow(activeNodeId);
        }
        break;
    }
  }, [activeNodeId, splitWindow, closeWindow, currentWorkspaceIndex]);

  const resizeActiveWindow = useCallback((direction) => {
    if (!activeNodeId || !rootNode || !isResizeMode) return;
  
    updateWorkspace(currentWorkspaceIndex, workspace => {
      const newRoot = JSON.parse(JSON.stringify(workspace.root));
      
      // Helper function to find all affected splits and determine if window is in second child
      const findAffectedSplits = (node, targetId) => {
        if (!node) return [];
        
        const splits = [];
        if (node.type === 'split') {
          const targetInFirst = findNodeById(node.first, targetId);
          const targetInSecond = findNodeById(node.second, targetId);
          
          if (targetInFirst || targetInSecond) {
            // Add this split if it matches our resize direction
            if ((direction === 'left' || direction === 'right') && node.direction === 'horizontal') {
              splits.push({ 
                node, 
                targetInFirst: !!targetInFirst,
                // If this is a horizontal split and window is in second child, it's on the right side
                isRightSide: !!targetInSecond && node.direction === 'horizontal'
              });
            }
            if ((direction === 'up' || direction === 'down') && node.direction === 'vertical') {
              splits.push({ 
                node, 
                targetInFirst: !!targetInFirst,
                isRightSide: !!targetInSecond && node.direction === 'horizontal',
                isBottomSide: !!targetInSecond && node.direction === 'vertical'
              });
            }
          }
          
          splits.push(...findAffectedSplits(node.first, targetId));
          splits.push(...findAffectedSplits(node.second, targetId));
        }
        
        return splits;
      };
  
      const affectedSplits = findAffectedSplits(newRoot, activeNodeId);
      const resizeStep = 0.05;
      
      // We no longer block resize operations based on minimum size
      // Just log that windows will be below minimum size
      const willViolateMinSize = wouldViolateMinSize(newRoot, direction, affectedSplits, resizeStep);
      if (willViolateMinSize) {
        console.log('Windows will be below minimum size, but resize is allowed');
      }
  
      // Apply resize to all affected splits
      affectedSplits.forEach(({ node, targetInFirst, isRightSide, isBottomSide }) => {
        // Determine if we need to invert the direction based on window position
        let effectiveDirection = direction;
        if (isRightSide && (direction === 'left' || direction === 'right')) {
          effectiveDirection = direction === 'left' ? 'right' : 'left';
        }
        if (isBottomSide && (direction === 'up' || direction === 'down')) {
          effectiveDirection = direction === 'up' ? 'down' : 'up';
        }
        
        switch (effectiveDirection) {
          case 'left': // Shrink width
            if (targetInFirst) {
              node.splitRatio = Math.max(0.1, node.splitRatio - resizeStep);
            } else {
              node.splitRatio = Math.min(0.9, node.splitRatio + resizeStep);
            }
            break;
            
          case 'right': // Grow width
            if (targetInFirst) {
              node.splitRatio = Math.min(0.9, node.splitRatio + resizeStep);
            } else {
              node.splitRatio = Math.max(0.1, node.splitRatio - resizeStep);
            }
            break;
            
          case 'up': // Shrink height
            if (targetInFirst) {
              node.splitRatio = Math.max(0.1, node.splitRatio - resizeStep);
            } else {
              node.splitRatio = Math.min(0.9, node.splitRatio + resizeStep);
            }
            break;
            
          case 'down': // Grow height
            if (targetInFirst) {
              node.splitRatio = Math.min(0.9, node.splitRatio + resizeStep);
            } else {
              node.splitRatio = Math.max(0.1, node.splitRatio - resizeStep);
            }
            break;
        }
      });
  
      return { ...workspace, root: newRoot };
    });
  }, [activeNodeId, rootNode, isResizeMode, updateWorkspace, wouldViolateMinSize, currentWorkspaceIndex]);
  
  // Function to swap two windows in the tree
  const swapWindows = useCallback((sourceId, targetId) => {
    if (!sourceId || !targetId || sourceId === targetId) return;

    console.log('Swapping windows:', sourceId, targetId);

    updateWorkspace(currentWorkspaceIndex, workspace => {
      const newRoot = JSON.parse(JSON.stringify(workspace.root));
      
      // Find the nodes to swap
      const sourceNode = findNodeById(newRoot, sourceId);
      const targetNode = findNodeById(newRoot, targetId);
      
      if (!sourceNode || !targetNode) {
        console.log('Could not find one or both nodes to swap');
        return workspace;
      }
      
      // Swap the window types and states
      const tempWindowType = sourceNode.windowType;
      const tempState = sourceNode.state;
      
      sourceNode.windowType = targetNode.windowType;
      sourceNode.state = targetNode.state;
      
      targetNode.windowType = tempWindowType;
      targetNode.state = tempState;
      
      return { ...workspace, root: newRoot };
    });
    
    // Exit move mode after swapping
    setIsMoveMode(false);
    setMoveSourceWindowId(null);
  }, [updateWorkspace, currentWorkspaceIndex]);

  // Add direct keyboard event listener for move mode
  useEffect(() => {
    const handleMoveKeyDown = (e) => {
      // Handle move mode toggle
      if (e.ctrlKey && e.key === 'm') {
        e.preventDefault();
        e.stopPropagation(); // Stop event propagation to prevent multiple handlers
        console.log('Move mode toggle pressed directly in useWindowManager');
        console.log('Current isMoveMode:', isMoveMode);
        
        // Toggle move mode
        setIsMoveMode(!isMoveMode);
        
        // Reset source window when toggling off
        if (isMoveMode) {
          setMoveSourceWindowId(null);
        }
      }
      
      // Handle move mode Enter key
      if (isMoveMode && e.key === 'Enter') {
        e.preventDefault();
        e.stopPropagation();
        console.log('Enter key pressed in move mode');
        
        if (!moveSourceWindowId) {
          // First window selection
          console.log('Selected first window for move:', activeNodeId);
          setMoveSourceWindowId(activeNodeId);
        } else {
          // Second window selection - perform the swap
          console.log('Selected second window for move:', activeNodeId);
          swapWindows(moveSourceWindowId, activeNodeId);
        }
      }
    };
    
    // Add the event listener with capture: true to ensure it runs before other listeners
    window.addEventListener('keydown', handleMoveKeyDown, { capture: true });
    return () => window.removeEventListener('keydown', handleMoveKeyDown, { capture: true });
  }, [isMoveMode, moveSourceWindowId, activeNodeId, setIsMoveMode, setMoveSourceWindowId, swapWindows]);

  // Debug checks for modes
  useEffect(() => {
    console.log('Resize mode:', isResizeMode);
  }, [isResizeMode]);

  useEffect(() => {
    console.log('Move mode:', isMoveMode);
    if (!isMoveMode) {
      setMoveSourceWindowId(null);
    }
  }, [isMoveMode]);

  // Function to update terminal state
  const updateTerminalState = useCallback((terminalId, newState) => {
    updateWorkspace(currentWorkspaceIndex, workspace => ({
      ...workspace,
      terminalStates: {
        ...workspace.terminalStates,
        [terminalId]: newState
      }
    }));
  }, [updateWorkspace, currentWorkspaceIndex]);

  return {
    rootNode,
    activeNodeId,
    setActiveNodeId,
    terminalStates,
    updateTerminalState,
    createNewWindow,
    splitWindow,
    closeWindow,
    transformWindow,
    handleCommand,
    navigateToWindow,
    hasActiveWindow: Boolean(activeNodeId),
    hasRootNode: Boolean(rootNode),
    currentWorkspaceIndex,
    workspaceCount: 4,
    switchWorkspace,
    isResizeMode,
    setIsResizeMode,
    resizeActiveWindow,
    isMoveMode,
    setIsMoveMode,
    moveSourceWindowId,
    setMoveSourceWindowId,
    swapWindows
  };
};

================
File: hooks/useWindowManagerCompletion.js
================
// Function to swap two windows in the tree
  const swapWindows = useCallback((sourceId, targetId) => {
    if (!sourceId || !targetId || sourceId === targetId) return;

    console.log('Swapping windows:', sourceId, targetId);

    updateWorkspace(workspace => {
      const newRoot = JSON.parse(JSON.stringify(workspace.root));
      
      // Find the nodes to swap
      const sourceNode = findNodeById(newRoot, sourceId);
      const targetNode = findNodeById(newRoot, targetId);
      
      if (!sourceNode || !targetNode) {
        console.log('Could not find one or both nodes to swap');
        return workspace;
      }
      
      // Swap the window types and states
      const tempWindowType = sourceNode.windowType;
      const tempState = sourceNode.state;
      
      sourceNode.windowType = targetNode.windowType;
      sourceNode.state = targetNode.state;
      
      targetNode.windowType = tempWindowType;
      targetNode.state = tempState;
      
      return { ...workspace, root: newRoot };
    });
    
    // Exit move mode after swapping
    setIsMoveMode(false);
    setMoveSourceWindowId(null);
  }, [updateWorkspace]);

  // Add direct keyboard event listener for move mode
  useEffect(() => {
    const handleMoveKeyDown = (e) => {
      // Handle move mode toggle
      if (e.ctrlKey && e.key === 'm') {
        e.preventDefault();
        e.stopPropagation(); // Stop event propagation to prevent multiple handlers
        console.log('Move mode toggle pressed directly in useWindowManager');
        console.log('Current isMoveMode:', isMoveMode);
        
        // Toggle move mode
        setIsMoveMode(!isMoveMode);
        
        // Reset source window when toggling off
        if (isMoveMode) {
          setMoveSourceWindowId(null);
        }
      }
      
      // Handle move mode Enter key
      if (isMoveMode && e.key === 'Enter') {
        e.preventDefault();
        e.stopPropagation();
        console.log('Enter key pressed in move mode');
        
        if (!moveSourceWindowId) {
          // First window selection
          console.log('Selected first window for move:', activeNodeId);
          setMoveSourceWindowId(activeNodeId);
        } else {
          // Second window selection - perform the swap
          console.log('Selected second window for move:', activeNodeId);
          swapWindows(moveSourceWindowId, activeNodeId);
        }
      }
    };
    
    // Add the event listener with capture: true to ensure it runs before other listeners
    window.addEventListener('keydown', handleMoveKeyDown, { capture: true });
    return () => window.removeEventListener('keydown', handleMoveKeyDown, { capture: true });
  }, [isMoveMode, moveSourceWindowId, activeNodeId, setIsMoveMode, setMoveSourceWindowId, swapWindows]);

  // Debug checks for modes
  useEffect(() => {
    console.log('Resize mode:', isResizeMode);
  }, [isResizeMode]);

  useEffect(() => {
    console.log('Move mode:', isMoveMode);
    if (!isMoveMode) {
      setMoveSourceWindowId(null);
    }
  }, [isMoveMode]);

  // Function to update terminal state
  const updateTerminalState = useCallback((terminalId, newState) => {
    updateWorkspace(workspace => ({
      ...workspace,
      terminalStates: {
        ...workspace.terminalStates,
        [terminalId]: newState
      }
    }));
  }, [updateWorkspace]);

  return {
    rootNode,
    activeNodeId,
    setActiveNodeId,
    terminalStates,
    updateTerminalState,
    createNewWindow,
    splitWindow,
    closeWindow,
    transformWindow,
    handleCommand,
    navigateToWindow,
    hasActiveWindow: Boolean(activeNodeId),
    hasRootNode: Boolean(rootNode),
    currentWorkspaceIndex,
    workspaceCount: 4,
    switchWorkspace,
    isResizeMode,
    setIsResizeMode,
    resizeActiveWindow,
    isMoveMode,
    setIsMoveMode,
    moveSourceWindowId,
    setMoveSourceWindowId,
    swapWindows
  };
};

================
File: index.html
================
// index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oxygen+Mono&display=swap" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Window Manager</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

================
File: main.jsx
================
// Import polyfill for simple-peer library
import './utils/globalPolyfill.js'

import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import './styles.css'
import './App.css'
import { WindowStateProvider } from './context/WindowStateContext'
import { WorkspaceProvider } from './context/WorkspaceContext'
import { AuthProvider, AuthProviderWithWindowState } from './context/AuthContext'
import { AnnouncementProvider } from './context/AnnouncementContext'

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <AuthProvider>
      <WindowStateProvider>
        <WorkspaceProvider>
          <AuthProviderWithWindowState>
            <AnnouncementProvider>
              <App />
            </AnnouncementProvider>
          </AuthProviderWithWindowState>
        </WorkspaceProvider>
      </WindowStateProvider>
    </AuthProvider>
  </React.StrictMode>,
)

================
File: models/Node.js
================
/**
 * Node class representing a window or split in the window management system.
 * Forms the foundation of our tree-based window layout structure.
 */
export class Node {
  constructor(id, type) {
    this.id = id;
    this.type = type;
    this.windowType = null;
    this.direction = null;
    this.first = null;
    this.second = null;
    this.splitRatio = 0.5;
    this.minimumSize = 20;
    this.state = null;
  }

  static createWindow(id, windowType, state = null) {
    const node = new Node(id, 'window');
    node.windowType = windowType;
    node.state = state;
    return node;
  }

  static createSplit(direction, first, second, ratio = 0.5) {
    const node = new Node(Date.now(), 'split');
    node.direction = direction;
    node.first = first;
    node.second = second;
    node.splitRatio = ratio;
    return node;
  }
}

================
File: services/indexedDBService.js
================
/**
 * IndexedDB service for the window manager
 * Provides specific functions for working with workspaces and window states
 */
import { initDB } from '../db/db';
import { saveData, getData, getAllData, deleteData, clearStore } from '../db/db-operations';
import { STORES } from '../db/db-config';

// Initialize the database when the service is first imported
let dbInitialized = false;
const ensureDBInitialized = async () => {
  if (!dbInitialized) {
    await initDB();
    dbInitialized = true;
  }
};

/**
 * Save a workspace to IndexedDB
 * @param {Object} workspace - The workspace to save
 * @returns {Promise<any>} A promise that resolves to the result of the operation
 */
export const saveWorkspace = async (workspace) => {
  await ensureDBInitialized();
  return saveData(STORES.WORKSPACES, workspace);
};

/**
 * Get a workspace from IndexedDB
 * @param {string|number} id - The ID of the workspace to retrieve
 * @returns {Promise<Object>} A promise that resolves to the workspace
 */
export const getWorkspace = async (id) => {
  await ensureDBInitialized();
  return getData(STORES.WORKSPACES, id);
};

/**
 * Get all workspaces from IndexedDB
 * @returns {Promise<Array>} A promise that resolves to an array of all workspaces
 */
export const getAllWorkspaces = async () => {
  await ensureDBInitialized();
  return getAllData(STORES.WORKSPACES);
};

/**
 * Delete a workspace from IndexedDB
 * @param {string|number} id - The ID of the workspace to delete
 * @returns {Promise<void>} A promise that resolves when the workspace is deleted
 */
export const deleteWorkspace = async (id) => {
  await ensureDBInitialized();
  return deleteData(STORES.WORKSPACES, id);
};

/**
 * Save a window state to IndexedDB
 * @param {Object} windowState - The window state to save
 * @returns {Promise<any>} A promise that resolves to the result of the operation
 */
export const saveWindowState = async (windowState) => {
  await ensureDBInitialized();
  return saveData(STORES.WINDOW_STATES, windowState);
};

/**
 * Get a window state from IndexedDB
 * @param {string|number} id - The ID of the window state to retrieve
 * @returns {Promise<Object>} A promise that resolves to the window state
 */
export const getWindowState = async (id) => {
  await ensureDBInitialized();
  return getData(STORES.WINDOW_STATES, id);
};

/**
 * Get all window states from IndexedDB
 * @returns {Promise<Array>} A promise that resolves to an array of all window states
 */
export const getAllWindowStates = async () => {
  await ensureDBInitialized();
  return getAllData(STORES.WINDOW_STATES);
};

/**
 * Delete a window state from IndexedDB
 * @param {string|number} id - The ID of the window state to delete
 * @returns {Promise<void>} A promise that resolves when the window state is deleted
 */
export const deleteWindowState = async (id) => {
  await ensureDBInitialized();
  return deleteData(STORES.WINDOW_STATES, id);
};

/**
 * Save all workspaces at once (for bulk operations)
 * @param {Array} workspaces - The workspaces to save
 * @returns {Promise<void>} A promise that resolves when all workspaces are saved
 */
export const saveAllWorkspaces = async (workspaces) => {
  await ensureDBInitialized();
  
  // Clear existing workspaces
  await clearStore(STORES.WORKSPACES);
  
  // Save each workspace
  for (const workspace of workspaces) {
    await saveWorkspace(workspace);
  }
};

/**
 * Save all window states at once (for bulk operations)
 * @param {Array} windowStates - The window states to save
 * @returns {Promise<void>} A promise that resolves when all window states are saved
 */
export const saveAllWindowStates = async (windowStates) => {
  await ensureDBInitialized();
  
  // Clear existing window states
  await clearStore(STORES.WINDOW_STATES);
  
  // Save each window state
  for (const state of windowStates) {
    await saveWindowState(state);
  }
};

================
File: styles.css
================
@import "tailwindcss";

@tailwind base;

@layer base {
  html {
    font-family: 'Oxygen Mono', monospace;
  }
}
@tailwind components;
@tailwind utilities;

html, body, #root {
  width: 100%;
  height: 100vh;
  margin: 0;
  padding: 0;
  overflow: hidden;
}

/* Custom scrollbar styling to match the application theme */
::-webkit-scrollbar {
  width: 8px;  /* for vertical scrollbars */
  height: 8px; /* for horizontal scrollbars */
}

::-webkit-scrollbar-track {
  background: #292524; /* stone-800 */
}

::-webkit-scrollbar-thumb {
  background: #44403c; /* stone-700 */
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #14b8a6; /* teal-500 */
}

/* Firefox scrollbar styling */
* {
  scrollbar-width: thin;
  scrollbar-color: #44403c #292524; /* thumb and track color */
}

.window-container {
  position: absolute;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.window-content {
  flex: 1;
  overflow: auto;
}

.resize-handle {
  position: absolute;
  z-index: 10;
  background-color: transparent;
  transition: background-color 0.2s;
}

.resize-handle:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

.resize-handle.horizontal {
  cursor: col-resize;
  width: 4px;
  height: 100%;
}

.resize-handle.vertical {
  cursor: row-resize;
  width: 100%;
  height: 4px;
}

/* Announcement carousel animation - simple and consistent */
@keyframes scroll-text {
  0% { transform: translateX(100%); }
  100% { transform: translateX(-100%); }
}

/* Container for announcement text */
.announcement-container {
  position: relative;
  overflow: hidden;
  width: 100%;
}

/* Wrapper for scrolling text with padding */
.announcement-text {
  display: inline-block;
  padding-right: 50px; /* Add space between end and beginning when looping */
  white-space: nowrap;
}

================
File: styles/main.css
================
/* This imports all of Tailwind's utility classes */
@import "tailwindcss";

/* You can add any custom CSS below this line */

================
File: utils/constants.js
================
// src/utils/constants.js
export const WINDOW_TYPES = {
    EXPLORER: 'explorer',
    EDITOR: 'editor',
    TERMINAL: 'terminal',
    AUDIO: 'audio',
    CHAT: 'chat',  // Add chat window type
    ADMIN: 'admin' // Add admin window type
  };

================
File: utils/globalPolyfill.js
================
// Import the actual process module
import process from 'process';

// Ensure global is defined as window
window.global = window;

// Use the actual process module instead of our basic polyfill
window.process = process;

// Ensure browser property is set (SimplePeer checks this)
window.process.browser = true;

================
File: utils/treeUtils.js
================
import { Node } from '../models/Node';

/**
 * Splits a window by ID, ensuring only the target window is affected
 * @param {Node} node - Current node in the tree
 * @param {string} targetId - ID of the window to split
 * @param {string} direction - Split direction ('vertical' or 'horizontal')
 * @param {Node} newWindow - New window to insert
 * @returns {Node} Updated tree structure
 */
export const findFirstWindowId = (node) => {
  if (!node) return null;
  if (node.type === 'window') return node.id;
  return findFirstWindowId(node.first) || findFirstWindowId(node.second);
};

/**
 * Creates a new split by ID, inserting a new window at the specified location
 */
export const splitNodeById = (node, targetId, direction, newWindow) => {
    if (!node) return null;
  
    // If this is the node we want to split
    if (node.id === targetId && node.type === 'window') {
      // Create a new split with the current window and new window
      return Node.createSplit(direction, node, newWindow);
    }
  
    // If this is a split node, recursively check its children
    if (node.type === 'split') {
      // Check if target is in first child
      if (findNodeById(node.first, targetId)) {
        return {
          ...node,
          first: splitNodeById(node.first, targetId, direction, newWindow)
        };
      }
      
      // Check if target is in second child
      if (findNodeById(node.second, targetId)) {
        return {
          ...node,
          second: splitNodeById(node.second, targetId, direction, newWindow)
        };
      }
    }
  
    // If we haven't found the target node, return the original node unchanged
    return node;
  };

export const removeNodeById = (node, targetId) => {
  if (!node) return null;

  if (node.type === 'split') {
    // Only remove if the child is a window node with matching ID
    if (node.first.type === 'window' && node.first.id === targetId) {
      return node.second;
    }
    if (node.second.type === 'window' && node.second.id === targetId) {
      return node.first;
    }

    const firstResult = removeNodeById(node.first, targetId);
    if (firstResult !== node.first) {
      node.first = firstResult;
      return node;
    }

    const secondResult = removeNodeById(node.second, targetId);
    if (secondResult !== node.second) {
      node.second = secondResult;
      return node;
    }
  }

  return node;
};

export const findNodeById = (node, targetId) => {
  if (!node) return null;
  
  if (node.id === targetId && node.type === 'window') return node;
  
  if (node.type === 'split') {
    const firstResult = findNodeById(node.first, targetId);
    if (firstResult) return firstResult;
    
    const secondResult = findNodeById(node.second, targetId);
    if (secondResult) return secondResult;
  }
  
  return null;
};

export const findAllWindowIds = (node) => {
  if (!node) return [];
  if (node.type === 'window') return [node.id];
  return [...findAllWindowIds(node.first), ...findAllWindowIds(node.second)];
};

export const updateSplitRatio = (node, splitId, newRatio) => {
  if (!node) return;

  if (node.type === 'split' && node.id === splitId) {
    node.splitRatio = Math.max(0.2, Math.min(0.8, newRatio));
    return;
  }

  if (node.type === 'split') {
    updateSplitRatio(node.first, splitId, newRatio);
    updateSplitRatio(node.second, splitId, newRatio);
  }
};

================
File: utils/windowSizeConstants.js
================
/**
 * Constants for window size constraints
 * These values define the minimum sizes for windows to ensure they remain usable
 */

// Minimum window dimensions in percentage of screen size
export const MIN_WINDOW_WIDTH_PERCENT = 30; // 30% of screen width
export const MIN_WINDOW_HEIGHT_PERCENT = 30; // 30% of screen height

// Minimum window dimensions in pixels (used for absolute size checks)
export const MIN_WINDOW_WIDTH_PX = 300; // 300px minimum width
export const MIN_WINDOW_HEIGHT_PX = 200; // 200px minimum height

// Maximum number of windows total (regardless of arrangement)
export const MAX_HORIZONTAL_WINDOWS = 4; // Maximum windows total
export const MAX_VERTICAL_WINDOWS = 4;   // Maximum windows total

================
File: utils/windowTypes.js
================
// src/utils/windowTypes.js
import { FolderOpen, Code, Terminal as TerminalIcon, Eye, MessageSquare, Shield } from 'lucide-react';
import { WINDOW_TYPES } from './constants';

// Import individually to avoid circular dependency
import { 
  EnhancedTerminalWindow,
  EnhancedEditorWindow,
  EnhancedExplorerWindow,
  EnhancedAudioWindow,
  EnhancedChatWindow,
  EnhancedAdminWindow
} from '../components/windows';

export { WINDOW_TYPES };

export const WINDOW_CONTENT = {
  [WINDOW_TYPES.EXPLORER]: {
    title: 'File Explorer',
    icon: FolderOpen,
    component: EnhancedExplorerWindow
  },
  [WINDOW_TYPES.EDITOR]: {
    title: 'Code Editor',
    icon: Code,
    component: EnhancedEditorWindow
  },
  [WINDOW_TYPES.TERMINAL]: {
    title: 'Terminal',
    icon: TerminalIcon,
    component: EnhancedTerminalWindow
  },
  [WINDOW_TYPES.AUDIO]: {
    title: 'Audio Player',
    icon: Eye,
    component: EnhancedAudioWindow
  },
  [WINDOW_TYPES.CHAT]: {
    title: 'Chat',
    icon: MessageSquare,
    component: EnhancedChatWindow
  },
  [WINDOW_TYPES.ADMIN]: {
    title: 'Admin Panel',
    icon: Shield,
    component: EnhancedAdminWindow
  }
};

================
File: utils/windowUtils.js
================
/**
 * Contains utility functions for window-specific calculations and operations.
 * These functions focus on spatial relationships and window bounds rather than
 * tree structure manipulation.
 */

/**
 * Calculates the bounds of windows in the tree. Each window gets its position
 * and size as percentages of the available space.
 * 
 * @param {Node} node - The node to calculate bounds for
 * @param {Object} available - The available space in percentages
 * @returns {Array} Array of objects containing window IDs and their bounds
 */
export const getWindowBounds = (node, available = { x: 0, y: 0, width: 100, height: 100 }) => {
    if (node.type === 'window') {
      return [{
        id: node.id,
        bounds: {
          left: available.x,
          top: available.y,
          right: available.x + available.width,
          bottom: available.y + available.height,
          width: available.width,
          height: available.height,
          centerX: available.x + (available.width / 2),
          centerY: available.y + (available.height / 2)
        }
      }];
    }
  
    // For split nodes, recursively get bounds of children
    const bounds = [];
    
    if (node.direction === 'horizontal') {
      const firstHalf = {
        x: available.x,
        y: available.y,
        width: available.width * node.splitRatio,
        height: available.height
      };
      const secondHalf = {
        x: available.x + (available.width * node.splitRatio),
        y: available.y,
        width: available.width * (1 - node.splitRatio),
        height: available.height
      };
      bounds.push(...getWindowBounds(node.first, firstHalf));
      bounds.push(...getWindowBounds(node.second, secondHalf));
    } else {
      const firstHalf = {
        x: available.x,
        y: available.y,
        width: available.width,
        height: available.height * node.splitRatio
      };
      const secondHalf = {
        x: available.x,
        y: available.y + (available.height * node.splitRatio),
        width: available.width,
        height: available.height * (1 - node.splitRatio)
      };
      bounds.push(...getWindowBounds(node.first, firstHalf));
      bounds.push(...getWindowBounds(node.second, secondHalf));
    }
  
    return bounds;
  };
  
  /**
   * Determines if two windows are adjacent in a specific direction.
   * Uses a small tolerance value to account for floating-point calculations.
   * 
   * @param {Object} window1 - First window with bounds
   * @param {Object} window2 - Second window with bounds
   * @param {string} direction - Direction to check ('left', 'right', 'up', 'down')
   * @returns {boolean} Whether the windows are adjacent
   */
  export const areWindowsAdjacent = (window1, window2, direction) => {
    const tolerance = 0.01; // 1% tolerance for floating point comparisons
    
    switch (direction) {
      case 'left':
        return Math.abs(window1.bounds.left - window2.bounds.right) < tolerance &&
               !(window1.bounds.bottom < window2.bounds.top || window1.bounds.top > window2.bounds.bottom);
      case 'right':
        return Math.abs(window1.bounds.right - window2.bounds.left) < tolerance &&
               !(window1.bounds.bottom < window2.bounds.top || window1.bounds.top > window2.bounds.bottom);
      case 'up':
        return Math.abs(window1.bounds.top - window2.bounds.bottom) < tolerance &&
               !(window1.bounds.right < window2.bounds.left || window1.bounds.left > window2.bounds.right);
      case 'down':
        return Math.abs(window1.bounds.bottom - window2.bounds.top) < tolerance &&
               !(window1.bounds.right < window2.bounds.left || window1.bounds.left > window2.bounds.right);
      default:
        return false;
    }
  };
  
  /**
   * Finds the next window in a specified direction from the active window.
   * 
   * @param {Node} rootNode - The root node of the window tree
   * @param {string} activeNodeId - ID of the currently active window
   * @param {string} direction - Direction to look for the next window
   * @returns {string|null} ID of the next window, or null if none found
   */
  export const findNextWindow = (rootNode, activeNodeId, direction) => {
    const allWindows = getWindowBounds(rootNode);
    const activeWindow = allWindows.find(w => w.id === activeNodeId);
    if (!activeWindow) return null;
  
    const adjacentWindows = allWindows.filter(w => 
      w.id !== activeNodeId && areWindowsAdjacent(activeWindow, w, direction)
    );
  
    if (adjacentWindows.length === 0) return null;
  
    // Sort adjacent windows based on position and direction
    let nextWindow;
    switch (direction) {
      case 'left':
        nextWindow = adjacentWindows.sort((a, b) => 
          a.bounds.centerX !== b.bounds.centerX
            ? b.bounds.centerX - a.bounds.centerX
            : a.bounds.centerY - b.bounds.centerY
        )[0];
        break;
      case 'right':
        nextWindow = adjacentWindows.sort((a, b) => 
          a.bounds.centerX !== b.bounds.centerX
            ? a.bounds.centerX - b.bounds.centerX
            : a.bounds.centerY - b.bounds.centerY
        )[0];
        break;
      case 'up':
        nextWindow = adjacentWindows.sort((a, b) => 
          a.bounds.centerY !== b.bounds.centerY
            ? b.bounds.centerY - a.bounds.centerY
            : a.bounds.centerX - b.bounds.centerX
        )[0];
        break;
      case 'down':
        nextWindow = adjacentWindows.sort((a, b) => 
          a.bounds.centerY !== b.bounds.centerY
            ? a.bounds.centerY - b.bounds.centerY
            : a.bounds.centerX - b.bounds.centerX
        )[0];
        break;
    }
  
    return nextWindow?.id || null;
  };



================================================================
End of Codebase
================================================================

================
File: src/services/indexedDBService.js
================
/**
 * IndexedDB service for the window manager
 * Provides specific functions for working with workspaces and window states
 */
import { initDB } from '../db/db';
import { saveData, getData, getAllData, deleteData, clearStore } from '../db/db-operations';
import { STORES } from '../db/db-config';

// Initialize the database when the service is first imported
let dbInitialized = false;
const ensureDBInitialized = async () => {
  if (!dbInitialized) {
    await initDB();
    dbInitialized = true;
  }
};

/**
 * Save a workspace to IndexedDB
 * @param {Object} workspace - The workspace to save
 * @returns {Promise<any>} A promise that resolves to the result of the operation
 */
export const saveWorkspace = async (workspace) => {
  await ensureDBInitialized();
  return saveData(STORES.WORKSPACES, workspace);
};

/**
 * Get a workspace from IndexedDB
 * @param {string|number} id - The ID of the workspace to retrieve
 * @returns {Promise<Object>} A promise that resolves to the workspace
 */
export const getWorkspace = async (id) => {
  await ensureDBInitialized();
  return getData(STORES.WORKSPACES, id);
};

/**
 * Get all workspaces from IndexedDB
 * @returns {Promise<Array>} A promise that resolves to an array of all workspaces
 */
export const getAllWorkspaces = async () => {
  await ensureDBInitialized();
  return getAllData(STORES.WORKSPACES);
};

/**
 * Delete a workspace from IndexedDB
 * @param {string|number} id - The ID of the workspace to delete
 * @returns {Promise<void>} A promise that resolves when the workspace is deleted
 */
export const deleteWorkspace = async (id) => {
  await ensureDBInitialized();
  return deleteData(STORES.WORKSPACES, id);
};

/**
 * Save a window state to IndexedDB
 * @param {Object} windowState - The window state to save
 * @returns {Promise<any>} A promise that resolves to the result of the operation
 */
export const saveWindowState = async (windowState) => {
  await ensureDBInitialized();
  return saveData(STORES.WINDOW_STATES, windowState);
};

/**
 * Get a window state from IndexedDB
 * @param {string|number} id - The ID of the window state to retrieve
 * @returns {Promise<Object>} A promise that resolves to the window state
 */
export const getWindowState = async (id) => {
  await ensureDBInitialized();
  return getData(STORES.WINDOW_STATES, id);
};

/**
 * Get all window states from IndexedDB
 * @returns {Promise<Array>} A promise that resolves to an array of all window states
 */
export const getAllWindowStates = async () => {
  await ensureDBInitialized();
  return getAllData(STORES.WINDOW_STATES);
};

/**
 * Delete a window state from IndexedDB
 * @param {string|number} id - The ID of the window state to delete
 * @returns {Promise<void>} A promise that resolves when the window state is deleted
 */
export const deleteWindowState = async (id) => {
  await ensureDBInitialized();
  return deleteData(STORES.WINDOW_STATES, id);
};

/**
 * Save all workspaces at once (for bulk operations)
 * @param {Array} workspaces - The workspaces to save
 * @returns {Promise<void>} A promise that resolves when all workspaces are saved
 */
export const saveAllWorkspaces = async (workspaces) => {
  await ensureDBInitialized();
  
  // Clear existing workspaces
  await clearStore(STORES.WORKSPACES);
  
  // Save each workspace
  for (const workspace of workspaces) {
    await saveWorkspace(workspace);
  }
};

/**
 * Save all window states at once (for bulk operations)
 * @param {Array} windowStates - The window states to save
 * @returns {Promise<void>} A promise that resolves when all window states are saved
 */
export const saveAllWindowStates = async (windowStates) => {
  await ensureDBInitialized();
  
  // Clear existing window states
  await clearStore(STORES.WINDOW_STATES);
  
  // Save each window state
  for (const state of windowStates) {
    await saveWindowState(state);
  }
};

// ========== Terminal State Functions ==========

/**
 * Save a terminal state to IndexedDB
 * @param {Object} terminalState - The terminal state to save
 * @returns {Promise<any>} A promise that resolves to the result of the operation
 */
export const saveTerminalState = async (terminalState) => {
  await ensureDBInitialized();
  return saveData(STORES.TERMINAL_STATES, terminalState);
};

/**
 * Get a terminal state from IndexedDB
 * @param {string|number} id - The ID of the terminal state to retrieve
 * @returns {Promise<Object>} A promise that resolves to the terminal state
 */
export const getTerminalState = async (id) => {
  await ensureDBInitialized();
  return getData(STORES.TERMINAL_STATES, id);
};

/**
 * Get all terminal states from IndexedDB
 * @returns {Promise<Array>} A promise that resolves to an array of all terminal states
 */
export const getAllTerminalStates = async () => {
  await ensureDBInitialized();
  return getAllData(STORES.TERMINAL_STATES);
};

/**
 * Delete a terminal state from IndexedDB
 * @param {string|number} id - The ID of the terminal state to delete
 * @returns {Promise<void>} A promise that resolves when the terminal state is deleted
 */
export const deleteTerminalState = async (id) => {
  await ensureDBInitialized();
  return deleteData(STORES.TERMINAL_STATES, id);
};

// ========== Chat State Functions ==========

/**
 * Save a chat state to IndexedDB
 * @param {Object} chatState - The chat state to save
 * @returns {Promise<any>} A promise that resolves to the result of the operation
 */
export const saveChatState = async (chatState) => {
  await ensureDBInitialized();
  return saveData(STORES.CHAT_STATES, chatState);
};

/**
 * Get a chat state from IndexedDB
 * @param {string|number} id - The ID of the chat state to retrieve
 * @returns {Promise<Object>} A promise that resolves to the chat state
 */
export const getChatState = async (id) => {
  await ensureDBInitialized();
  return getData(STORES.CHAT_STATES, id);
};

/**
 * Get all chat states from IndexedDB
 * @returns {Promise<Array>} A promise that resolves to an array of all chat states
 */
export const getAllChatStates = async () => {
  await ensureDBInitialized();
  return getAllData(STORES.CHAT_STATES);
};

/**
 * Delete a chat state from IndexedDB
 * @param {string|number} id - The ID of the chat state to delete
 * @returns {Promise<void>} A promise that resolves when the chat state is deleted
 */
export const deleteChatState = async (id) => {
  await ensureDBInitialized();
  return deleteData(STORES.CHAT_STATES, id);
};

// ========== Explorer State Functions ==========

/**
 * Save an explorer state to IndexedDB
 * @param {Object} explorerState - The explorer state to save
 * @returns {Promise<any>} A promise that resolves to the result of the operation
 */
export const saveExplorerState = async (explorerState) => {
  await ensureDBInitialized();
  return saveData(STORES.EXPLORER_STATES, explorerState);
};

/**
 * Get an explorer state from IndexedDB
 * @param {string|number} id - The ID of the explorer state to retrieve
 * @returns {Promise<Object>} A promise that resolves to the explorer state
 */
export const getExplorerState = async (id) => {
  await ensureDBInitialized();
  return getData(STORES.EXPLORER_STATES, id);
};

/**
 * Get all explorer states from IndexedDB
 * @returns {Promise<Array>} A promise that resolves to an array of all explorer states
 */
export const getAllExplorerStates = async () => {
  await ensureDBInitialized();
  return getAllData(STORES.EXPLORER_STATES);
};

/**
 * Delete an explorer state from IndexedDB
 * @param {string|number} id - The ID of the explorer state to delete
 * @returns {Promise<void>} A promise that resolves when the explorer state is deleted
 */
export const deleteExplorerState = async (id) => {
  await ensureDBInitialized();
  return deleteData(STORES.EXPLORER_STATES, id);
};

// ========== Canvas State Functions ==========

/**
 * Save a canvas state to IndexedDB
 * @param {Object} canvasState - The canvas state to save
 * @returns {Promise<any>} A promise that resolves to the result of the operation
 */
export const saveCanvasState = async (canvasState) => {
  await ensureDBInitialized();
  return saveData(STORES.CANVAS_STATES, canvasState);
};

/**
 * Get a canvas state from IndexedDB
 * @param {string|number} id - The ID of the canvas state to retrieve
 * @returns {Promise<Object>} A promise that resolves to the canvas state
 */
export const getCanvasState = async (id) => {
  await ensureDBInitialized();
  return getData(STORES.CANVAS_STATES, id);
};

/**
 * Get all canvas states from IndexedDB
 * @returns {Promise<Array>} A promise that resolves to an array of all canvas states
 */
export const getAllCanvasStates = async () => {
  await ensureDBInitialized();
  return getAllData(STORES.CANVAS_STATES);
};

/**
 * Delete a canvas state from IndexedDB
 * @param {string|number} id - The ID of the canvas state to delete
 * @returns {Promise<void>} A promise that resolves when the canvas state is deleted
 */
export const deleteCanvasState = async (id) => {
  await ensureDBInitialized();
  return deleteData(STORES.CANVAS_STATES, id);
};

// ========== Active Window Functions ==========

/**
 * Save an active window reference to IndexedDB
 * @param {Object} activeWindow - The active window reference to save
 * @returns {Promise<any>} A promise that resolves to the result of the operation
 */
export const saveActiveWindow = async (activeWindow) => {
  await ensureDBInitialized();
  return saveData(STORES.ACTIVE_WINDOWS, activeWindow);
};

/**
 * Get an active window reference from IndexedDB
 * @param {string|number} id - The ID of the active window reference to retrieve
 * @returns {Promise<Object>} A promise that resolves to the active window reference
 */
export const getActiveWindow = async (id) => {
  await ensureDBInitialized();
  return getData(STORES.ACTIVE_WINDOWS, id);
};

/**
 * Get all active window references from IndexedDB
 * @returns {Promise<Array>} A promise that resolves to an array of all active window references
 */
export const getAllActiveWindows = async () => {
  await ensureDBInitialized();
  return getAllData(STORES.ACTIVE_WINDOWS);
};

/**
 * Delete an active window reference from IndexedDB
 * @param {string|number} id - The ID of the active window reference to delete
 * @returns {Promise<void>} A promise that resolves when the active window reference is deleted
 */
export const deleteActiveWindow = async (id) => {
  await ensureDBInitialized();
  return deleteData(STORES.ACTIVE_WINDOWS, id);
};

================
File: src/styles.css
================
@import "tailwindcss";

@tailwind base;

@layer base {
  html {
    font-family: 'Oxygen Mono', monospace;
  }
}
@tailwind components;
@tailwind utilities;

html, body, #root {
  width: 100%;
  height: 100vh;
  margin: 0;
  padding: 0;
  overflow: hidden;
}

/* Custom scrollbar styling to match the application theme */
::-webkit-scrollbar {
  width: 8px;  /* for vertical scrollbars */
  height: 8px; /* for horizontal scrollbars */
}

::-webkit-scrollbar-track {
  background: #292524; /* stone-800 */
}

::-webkit-scrollbar-thumb {
  background: #44403c; /* stone-700 */
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #14b8a6; /* teal-500 */
}

/* Firefox scrollbar styling */
* {
  scrollbar-width: thin;
  scrollbar-color: #44403c #292524; /* thumb and track color */
}

.window-container {
  position: absolute;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.window-content {
  flex: 1;
  overflow: auto;
}

.resize-handle {
  position: absolute;
  z-index: 10;
  background-color: transparent;
  transition: background-color 0.2s;
}

.resize-handle:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

.resize-handle.horizontal {
  cursor: col-resize;
  width: 4px;
  height: 100%;
}

.resize-handle.vertical {
  cursor: row-resize;
  width: 100%;
  height: 4px;
}

/* Announcement carousel animation - simple and consistent */
@keyframes scroll-text {
  0% { transform: translateX(100%); }
  100% { transform: translateX(-100%); }
}

/* Container for announcement text */
.announcement-container {
  position: relative;
  overflow: hidden;
  width: 100%;
}

/* Wrapper for scrolling text with padding */
.announcement-text {
  display: inline-block;
  padding-right: 50px; /* Add space between end and beginning when looping */
  white-space: nowrap;
}

================
File: src/styles/main.css
================
/* This imports all of Tailwind's utility classes */
@import "tailwindcss";

/* You can add any custom CSS below this line */

================
File: src/utils/cacheManager.js
================
/**
 * Cache Manager Utility
 * 
 * This utility helps manage browser caching, especially to prevent issues
 * after application updates where users might see a white screen until 
 * they manually clear their cache.
 */

// Generate a unique version identifier based on build timestamp
// This should change with each new build/deployment
const APP_VERSION = Date.now().toString();
const VERSION_KEY = 'app_version';

/**
 * Checks the stored application version against the current version
 * and invalidates cache if there's a version mismatch.
 * 
 * @returns {boolean} True if the cache was cleared (version changed), false otherwise
 */
export const checkAndUpdateVersion = () => {
  try {
    // Get stored version from localStorage
    const storedVersion = localStorage.getItem(VERSION_KEY);
    
    // If no stored version or versions don't match, we have a new deployment
    if (!storedVersion || storedVersion !== APP_VERSION) {
      console.log('Application updated! Clearing cache...');
      
      // Store the new version
      localStorage.setItem(VERSION_KEY, APP_VERSION);
      
      // If service workers are supported, unregister them to clear cache
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.getRegistrations().then(registrations => {
          registrations.forEach(registration => {
            registration.unregister();
            console.log('ServiceWorker unregistered');
          });
        });
      }
      
      // Clear browser caches if supported
      if ('caches' in window) {
        caches.keys().then(cacheNames => {
          cacheNames.forEach(cacheName => {
            caches.delete(cacheName);
            console.log(`Cache ${cacheName} deleted`);
          });
        });
      }
      
      // If there was a version mismatch and we cleared caches, return true
      return true;
    }
    
    // No version change detected
    return false;
  } catch (error) {
    // If we encounter errors during cache management, log them but don't break the app
    console.error('Error managing cache:', error);
    return false;
  }
};

/**
 * Forces a page reload to ensure clean state
 * This is useful after clearing caches to ensure all new assets are loaded
 */
export const forceReload = () => {
  window.location.reload(true);
};

export default {
  checkAndUpdateVersion,
  forceReload
};

================
File: src/utils/canvasNodeTypes.js
================
import React, { memo } from 'react';

// Text Node component
const TextNode = memo(({ data }) => {
  return (
    <div className="p-3 bg-stone-800 rounded-md border border-teal-600 text-stone-200 shadow-lg">
      <div className="text-sm whitespace-pre-wrap break-words">{data.text}</div>
    </div>
  );
});

// Group Node component
const GroupNode = memo(({ data }) => {
  return (
    <div 
      className="p-3 rounded-md border border-dashed shadow-inner"
      style={{ 
        borderColor: `rgba(${data.color || '20, 184, 166'}, 0.7)`,
        backgroundColor: `rgba(${data.color || '20, 184, 166'}, 0.1)`
      }}
    >
      <div 
        className="font-medium text-sm mb-1"
        style={{ color: `rgba(${data.color || '20, 184, 166'}, 1)` }}
      >
        {data.label || 'Group'}
      </div>
    </div>
  );
});

// Export a memoized object of node types to avoid recreation on each render
const nodeTypes = {
  text: TextNode,
  group: GroupNode
};

export default nodeTypes;

================
File: src/utils/commandAliases.js
================
// src/utils/commandAliases.js

/**
 * Command aliases mapping
 * Maps short commands to their full versions to provide shortcuts
 * for common terminal commands
 */
export const COMMAND_ALIASES = {
  // Window type aliases
  'ex': 'explorer',
  'ed': 'editor',
  'term': 'terminal',
  'aud': 'audio',
  'ch': 'chat',
  'adm': 'admin',
  'can': 'canvas',
  
  // Other command aliases
  'cl': 'clear',
  'h': 'help',
  'v': 'version',
  'ann': 'announcement',
  'r': 'roll',
  'd': 'roll',
  'dbg': 'debug',
  
  // Party command aliases (new style)
  'p': 'party',
  'pc': 'party create',
  'pj': 'party join',
  'pl': 'party leave',
  'pls': 'party list',
  'pi': 'party info',
  
  // Legacy party command aliases (for backwards compatibility)
  'cp': 'create-party',
  'jp': 'join-party',
  'lp': 'leave-party'
};

================
File: src/utils/constants.js
================
// src/utils/constants.js
export const WINDOW_TYPES = {
    EXPLORER: 'explorer',
    EDITOR: 'editor',
    TERMINAL: 'terminal',
    AUDIO: 'audio',
    CHAT: 'chat',  // Add chat window type
    ADMIN: 'admin', // Add admin window type
    CANVAS: 'canvas', // Add canvas window type
    DICE: 'dice', // Add dice window type
    MAP_EDITOR: 'map_editor' // Add map editor window type
  };

================
File: src/utils/debugLogger.js
================
/**
 * Debug Logger Utility
 * Provides functionality to enable/disable console logging
 * for debugging purposes in the application.
 */

// Store original console methods
const originalConsole = {
  log: console.log,
  warn: console.warn,
  error: console.error,
  info: console.info,
  debug: console.debug
};

// Track debug state
let debugEnabled = false;

const DebugLogger = {
  /**
   * Toggle debug mode on or off
   * @param {boolean} [force] - Optional parameter to force a specific state
   * @returns {boolean} Current debug state after toggling
   */
  toggleDebug: (force) => {
    if (typeof force === 'boolean') {
      debugEnabled = force;
    } else {
      debugEnabled = !debugEnabled;
    }

    if (debugEnabled) {
      // Restore original console methods
      console.log = originalConsole.log;
      console.warn = originalConsole.warn;
      console.error = originalConsole.error;
      console.info = originalConsole.info;
      console.debug = originalConsole.debug;
      console.log('Debug mode enabled');
    } else {
      // Replace console methods with empty functions
      console.log = function() {};
      console.warn = function() {};
      console.info = function() {};
      console.debug = function() {};
      // Keep error logging enabled for critical errors
      // console.error = function() {};
    }

    return debugEnabled;
  },

  /**
   * Get current debug state
   * @returns {boolean} Current debug state
   */
  isDebugEnabled: () => {
    return debugEnabled;
  },

  /**
   * Initialize the debug logger (disables logging by default)
   */
  init: () => {
    // By default, disable logging when app starts
    if (!debugEnabled) {
      DebugLogger.toggleDebug(false);
    }
  }
};

export default DebugLogger;

================
File: src/utils/diceUtils.js
================
/**
 * Utility functions for dice rolling
 */

/**
 * Roll dice based on a dice expression
 * @param {number} diceType - The type of dice (e.g., 6, 20, 100)
 * @param {number} numDice - Number of dice to roll
 * @param {number} modifier - Modifier to add to the total
 * @returns {Object} Object containing results and total
 */
export const rollDice = (diceType, numDice, modifier = 0) => {
  const results = [];
  let total = 0;
  
  // Roll each die
  for (let i = 0; i < numDice; i++) {
    const result = Math.floor(Math.random() * diceType) + 1;
    results.push(result);
    total += result;
  }
  
  // Add modifier to total
  total += modifier;
  
  return {
    diceType,
    numDice,
    modifier,
    results,
    total,
    timestamp: new Date().toISOString(),
  };
};

/**
 * Parse a dice roll expression (e.g., "2d6+3")
 * @param {string} expression - The dice expression to parse
 * @returns {Object|null} Parsed dice roll parameters or null if invalid
 */
export const parseDiceExpression = (expression) => {
  // Basic regex to match dice roll syntax like "2d6+3"
  const diceRegex = /^(\d+)d(\d+)([+-]\d+)?$/i;
  const match = expression.match(diceRegex);
  
  if (!match) {
    return null;
  }
  
  return {
    numDice: parseInt(match[1], 10),
    diceType: parseInt(match[2], 10),
    modifier: match[3] ? parseInt(match[3], 10) : 0
  };
};

/**
 * Format the results of a dice roll for display
 * @param {Object} rollResult - The result of a dice roll
 * @returns {string} Formatted string for display
 */
export const formatRollResult = (rollResult) => {
  const { diceType, numDice, modifier, results, total } = rollResult;
  
  let output = [];
  
  // Format the expression
  let expression = `${numDice}d${diceType}`;
  if (modifier > 0) {
    expression += `+${modifier}`;
  } else if (modifier < 0) {
    expression += `${modifier}`;
  }
  
  output.push(`Roll: ${expression}`);
  
  // Format the individual results
  if (results.length > 1) {
    output.push(`Results: [${results.join(', ')}]`);
  } else {
    output.push(`Result: ${results[0]}`);
  }
  
  // Format the total with modifier calculation if needed
  if (modifier !== 0) {
    let calculation = `${results.reduce((a, b) => a + b, 0)}`;
    if (modifier > 0) {
      calculation += ` + ${modifier}`;
    } else if (modifier < 0) {
      calculation += ` - ${Math.abs(modifier)}`;
    }
    output.push(`Total: ${calculation} = ${total}`);
  } else {
    output.push(`Total: ${total}`);
  }
  
  return output.join('\n');
};

/**
 * Validate if a dice type is valid
 * @param {number} diceType - The dice type to validate
 * @returns {boolean} Whether the dice type is valid
 */
export const isValidDiceType = (diceType) => {
  // Allow any dice from d2 to d100
  return diceType >= 2 && diceType <= 100;
};

================
File: src/utils/globalPolyfill.js
================
// Import the actual process module
import process from 'process';

// Ensure global is defined as window
window.global = window;

// Use the actual process module instead of our basic polyfill
window.process = process;

// Ensure browser property is set (SimplePeer checks this)
window.process.browser = true;

================
File: src/utils/terminal/command-system-documentation.md
================
# SLUMNET Terminal Command System Documentation

## Overview

The SLUMNET Terminal Command System is a modular, extensible framework for handling terminal commands in a structured way. Inspired by bash and modern CLI parsers, it provides a robust foundation for command processing with features like argument validation, command aliases, quoted text extraction, and categorized help output.

```
                Command Input
                     
                     

           Tokenization               Handles quotes, whitespace, etc.

                     
                     

        Command Resolution            Registry lookup, alias handling

                     
                     

        Argument Processing           Validation, defaults

                     
                     

         Command Execution            Context injection, error handling

                     
                     
              Command Output
```

## Core Components

### Command Base Class (`Command.js`)

The foundation of the command system is the `Command` class, which provides a consistent interface for all commands. Each command extends this base class and implements the `execute` method.

```javascript
class Command {
  constructor() {
    this.name = '';            // Primary command name
    this.aliases = [];         // Alternative names
    this.description = '';     // Help text
    this.usage = '';           // Usage example
    this.category = 'General'; // Category for grouping in help
    this.args = [];            // Argument definitions
  }

  async execute(args, context) {
    // Command implementation
  }
}
```

### Command Registry (`registry.js`)

The registry is a central store for all commands, providing methods to register, find, and list commands.

Key responsibilities:
- Register new commands
- Look up commands by name or alias
- Provide lists of all registered commands or by category

### Parser (`parser.js` and `tokenizer.js`)

The parser consists of two main components:

1. **Tokenizer**: Converts input strings into tokens, handling quoted text and whitespace
2. **Parser**: Processes tokens into commands and arguments

Additional utilities:
- `extractQuotedText`: Extracts text enclosed in quotes (", ', or `)

### Command Executor (`executor.js`)

The executor is responsible for:
- Finding the appropriate command in the registry
- Validating command arguments
- Providing execution context
- Executing the command and handling errors

### Command Loader (`commandLoader.js`)

The loader imports all command classes and registers them with the registry during initialization.

## Command Structure

### Metadata

Each command provides metadata that describes its purpose and usage:

- `name`: The primary command identifier
- `aliases`: Alternative names for the command
- `description`: A brief description for help text
- `usage`: Usage example for help text 
- `category`: Grouping category for organized help output

### Arguments

Commands define their expected arguments with metadata:

```javascript
this.args = [
  {
    name: 'argName',
    description: 'Description of the argument',
    required: true|false
  }
];
```

This metadata is used for:
- Validating input
- Generating help text
- Providing context-aware error messages

### Execution Context

Commands receive a rich execution context with access to application state and functionality:

- User information (`user`)
- Window management (`nodeId`, `transformWindow`)
- Party system (`currentParty`, `createParty`, etc.)
- Utility functions (`debugLogger`, etc.)
- Original command text (`original`)

This context injection pattern allows commands to access needed functionality without tight coupling to implementation details.

## Categories of Commands

Commands are organized by category for better organization and discoverability:

1. **Core Commands**: Basic functionality like help, clear, version
   - `HelpCommand`: Display available commands
   - `ClearCommand`: Clear terminal output
   - `VersionCommand`: Show terminal version
   - `RollCommand`: Roll dice with specified parameters

2. **Window Commands**: Transform the current window
   - `WindowCommand`: Base class for window transformations
   - `TerminalCommand`: Transform to terminal
   - `ExplorerCommand`: Transform to file explorer
   - `ChatCommand`: Transform to chat window

3. **Admin Commands**: Administrative functionality
   - `AdminCommand`: Access admin panel
   - `DebugCommand`: Toggle debug mode
   - `AnnouncementCommand`: Set system-wide announcements

4. **Party Commands**: Manage D&D parties
   - `PartyCommand`: Main command with subcommands
     - create, join, leave, list, info, delete
   - Legacy party commands for backward compatibility

## Special Features

### Subcommand System

For complex commands with multiple operations, the system supports subcommands:

```javascript
// In PartyCommand
this.subcommands = {
  create: this.createParty,
  join: this.joinParty,
  // other subcommands...
};

async execute(args, context) {
  const subcommand = args[0]?.toLowerCase() || 'default';
  return this.subcommands[subcommand].call(this, args.slice(1), context);
}
```

### Legacy Command Support

The system provides backward compatibility for existing commands through redirection:

```javascript
// Legacy command example
async execute(args, context) {
  return context.executeCommand(`party join ${args.join(' ')}`);
}
```

### Admin-Only Command Restriction

Commands can implement access control:

```javascript
async execute(args, context) {
  if (!context.user?.is_admin) {
    return 'Access denied: Admin privileges required';
  }
  // Command implementation for admins...
}
```

## Creating New Commands

### Step 1: Create a Command Class

Start by creating a new file in the appropriate directory:
- `src/utils/terminal/commands/core/` - Basic commands
- `src/utils/terminal/commands/window/` - Window manipulation
- `src/utils/terminal/commands/admin/` - Admin functionality
- `src/utils/terminal/commands/party/` - Party-related commands
- Or create a new category directory

Example command class template:

```javascript
import { Command } from '../../Command.js';

export class ExampleCommand extends Command {
  constructor() {
    super();
    this.name = 'example';
    this.aliases = ['ex'];
    this.description = 'Example command description';
    this.usage = 'example [arg1] [arg2]';
    this.category = 'Custom';
    this.args = [
      {
        name: 'arg1',
        description: 'First argument',
        required: false
      }
    ];
  }

  async execute(args, context) {
    // Command implementation
    return `Executed example command with args: ${args.join(', ')}`;
  }
}
```

### Step 2: Register the Command

Import and register your command in `commandLoader.js`:

```javascript
import { ExampleCommand } from './commands/custom/ExampleCommand.js';

// In registerCommands function
const commands = [
  // existing commands...
  new ExampleCommand(),
];
```

### Step 3: Add Context Requirements

If your command needs access to specific functionality or state, ensure it's provided in the context object in `TerminalWindow.jsx`:

```javascript
// In TerminalWindow.jsx, processCommand function
const context = {
  // existing context...
  customFeature: customFeatureValue
};
```

## Command Context Reference

The following context properties are available to commands:

| Property | Type | Description |
|----------|------|-------------|
| `original` | string | Original command text |
| `user` | object | Current user information |
| `nodeId` | string | Current window node ID |
| `transformWindow` | function | Function to transform window type |
| `updateAnnouncement` | function | Function to set system announcements |
| `parties` | array | Available parties |
| `currentParty` | object | Current party information |
| `joinParty` | function | Function to join a party |
| `leaveParty` | function | Function to leave current party |
| `createParty` | function | Function to create new party |
| `refreshParty` | function | Function to refresh party data |
| `refreshParties` | function | Function to refresh all parties |
| `deleteParty` | function | Function to delete a party |
| `parseDiceExpression` | function | Function to parse dice notation |
| `rollDice` | function | Function to roll dice |
| `formatRollResult` | function | Function to format dice results |
| `isValidDiceType` | function | Function to validate dice type |
| `debugLogger` | object | Debug logging utilities |
| `clearTerminal` | function | Function to clear terminal output |
| `executeCommand` | function | Function to execute another command |

## Examples

### Simple Command

```javascript
import { Command } from '../../Command.js';

export class HelloCommand extends Command {
  constructor() {
    super();
    this.name = 'hello';
    this.aliases = ['hi'];
    this.description = 'Say hello to a user';
    this.usage = 'hello [username]';
    this.category = 'Greeting';
    this.args = [
      {
        name: 'username',
        description: 'Name to greet',
        required: false
      }
    ];
  }

  async execute(args, context) {
    const name = args[0] || context.user?.username || 'World';
    return `Hello, ${name}!`;
  }
}
```

### Command with Subcommands

```javascript
import { Command } from '../../Command.js';

export class TestCommand extends Command {
  constructor() {
    super();
    this.name = 'test';
    this.aliases = ['t'];
    this.description = 'Test various functions';
    this.usage = 'test <subcommand>';
    this.category = 'Utilities';
    this.args = [
      {
        name: 'subcommand',
        description: 'Subcommand to execute',
        required: true
      }
    ];
    
    this.subcommands = {
      echo: this.echoText,
      random: this.randomNumber
    };
  }

  async execute(args, context) {
    const subcommand = args[0]?.toLowerCase();
    
    if (!subcommand || !this.subcommands[subcommand]) {
      return `Unknown subcommand. Available: ${Object.keys(this.subcommands).join(', ')}`;
    }
    
    return this.subcommands[subcommand].call(this, args.slice(1), context);
  }
  
  async echoText(args, context) {
    return args.join(' ') || 'No text provided to echo';
  }
  
  async randomNumber(args, context) {
    const max = parseInt(args[0]) || 100;
    return `Random number: ${Math.floor(Math.random() * max)}`;
  }
}
```

## Best Practices

1. **Categorize Commands**
   - Place commands in appropriate category directories
   - Set descriptive category name in command metadata

2. **Provide Helpful Documentation**
   - Set clear description and usage examples
   - Include argument documentation

3. **Use Context Appropriately**
   - Validate context properties before use
   - Report clear errors when required context is missing

4. **Implement Access Control**
   - Check user permissions at the beginning of execution
   - Return clear access denied messages

5. **Handle Errors Gracefully**
   - Use try/catch to handle unexpected errors
   - Return user-friendly error messages

## Troubleshooting

### Command Not Found

If your command isn't being recognized:

1. Ensure it's properly imported and registered in `commandLoader.js`
2. Check that the class name matches the export name
3. Verify the command name and aliases don't conflict with existing commands

### Context Missing

If context properties are undefined:

1. Check that the property is being provided in the `processCommand` function in `TerminalWindow.jsx`
2. Add proper validation in your command to check context properties
3. Return clear error messages when required context is missing

### Command Execution Fails

If a command fails during execution:

1. Check browser console for JavaScript errors
2. Ensure all async operations have proper error handling
3. Verify that functions being called from context exist and work as expected

================
File: src/utils/terminal/Command.js
================
/**
 * Base Command class that all terminal commands will extend
 * Provides a consistent interface for command execution and metadata
 */
export class Command {
  constructor() {
    this.name = ''; // Primary command name
    this.aliases = []; // Command aliases
    this.description = ''; // Command description
    this.usage = ''; // Usage example
    this.args = []; // Argument definitions
  }

  /**
   * Execute the command with the given arguments and context
   * @param {Array} args - Parsed arguments array
   * @param {Object} context - Terminal context (user, state, etc.)
   * @returns {Promise<string|Array<string>>} - Command output
   */
  async execute(args, context) {
    throw new Error('Command implementation missing');
  }

  /**
   * Generate help text for this command
   * @returns {string} - Formatted help text
   */
  generateHelp() {
    let help = `${this.name} - ${this.description}\n`;
    help += `Usage: ${this.usage}\n`;
    
    if (this.aliases.length > 0) {
      help += `Aliases: ${this.aliases.join(', ')}\n`;
    }
    
    if (this.args.length > 0) {
      help += 'Arguments:\n';
      this.args.forEach(arg => {
        help += `  ${arg.name} - ${arg.description}${arg.required ? ' (required)' : ' (optional)'}\n`;
      });
    }
    
    return help;
  }

  /**
   * Check if a given name matches this command's name or aliases
   * @param {string} name - Command name to check
   * @returns {boolean} - True if name matches command name or aliases
   */
  matches(name) {
    return this.name === name || this.aliases.includes(name);
  }
}

================
File: src/utils/terminal/commandLoader.js
================
/**
 * Command Loader
 * Loads and registers all terminal commands
 */
import { registry } from './registry.js';

// Import core commands
import { HelpCommand } from './commands/core/HelpCommand.js';
import { ClearCommand } from './commands/core/ClearCommand.js';
import { VersionCommand } from './commands/core/VersionCommand.js';
import { RollCommand } from './commands/vtt/RollCommand.js';

// Import window commands
import { WindowCommand } from './commands/window/WindowCommand.js';
import { TerminalCommand } from './commands/window/TerminalCommand.js';
import { ExplorerCommand } from './commands/window/ExplorerCommand.js';
import { ChatCommand } from './commands/window/ChatCommand.js';

// Import admin commands
import { AdminCommand } from './commands/admin/AdminCommand.js';
import { DebugCommand } from './commands/admin/DebugCommand.js';
import { AnnouncementCommand } from './commands/admin/AnnouncementCommand.js';

// Import party commands
import { PartyCommand } from './commands/vtt/PartyCommand.js';
import { 
  CreatePartyCommand,
  JoinPartyCommand,
  LeavePartyCommand,
  PartiesCommand
} from './commands/vtt/LegacyPartyCommands.js';

/**
 * Register all terminal commands with the registry
 * Call this function to initialize the terminal command system
 */
export function registerCommands() {
  const commands = [
    // Core commands
    new HelpCommand(),
    new ClearCommand(),
    new VersionCommand(),
    new RollCommand(),
    
    // Window commands
    new WindowCommand(),
    new TerminalCommand(),
    new ExplorerCommand(),
    new ChatCommand(),
    
    // Admin commands
    new AdminCommand(),
    new DebugCommand(),
    new AnnouncementCommand(),
    
    // Party commands
    new PartyCommand(),
    
    // Legacy party commands
    // new CreatePartyCommand(),
    // new JoinPartyCommand(),
    // new LeavePartyCommand(),
    // new PartiesCommand(),
    
    // Additional commands will be added here as they are implemented
  ];
  
  registry.registerAll(commands);
  
  console.log(`Registered ${commands.length} terminal commands`);
  return commands.length;
}

/**
 * Check if a specific command exists in the registry
 * 
 * @param {string} commandName - Name of the command to check
 * @returns {boolean} - True if the command exists
 */
export function hasCommand(commandName) {
  return registry.findCommand(commandName) !== null;
}

/**
 * Get all registered commands
 * 
 * @returns {Array} - Array of all command instances
 */
export function getAllCommands() {
  return registry.getAllCommands();
}

================
File: src/utils/terminal/commands/admin/AdminCommand.js
================
/**
 * Admin Command
 * Transform window to Admin panel (admin only)
 */
import { Command } from '../../Command.js';
import { WINDOW_TYPES } from '../../../windowTypes.js';

export class AdminCommand extends Command {
  constructor() {
    super();
    this.name = 'admin';
    this.aliases = ['adm'];
    this.description = 'Access admin panel (admin only)';
    this.usage = 'admin';
    this.category = 'Admin';
    this.args = [];
  }

  async execute(args, context) {
    // Check if user is admin
    if (!context.user?.is_admin) {
      return 'Access denied: Admin privileges required';
    }

    // Check if the transform function is provided in the context
    if (!context || typeof context.transformWindow !== 'function') {
      return 'Cannot transform window: Missing transform function in context';
    }
    
    // Check if the node ID is provided in the context
    if (!context.nodeId) {
      return 'Cannot transform window: Missing node ID in context';
    }
    
    // Transform the window
    context.transformWindow(context.nodeId, WINDOW_TYPES.ADMIN);
    
    // This will be displayed only momentarily before the window transforms
    return 'Transforming to admin panel...';
  }
}

================
File: src/utils/terminal/commands/admin/AnnouncementCommand.js
================
/**
 * Announcement Command
 * Sets a system-wide announcement (admin only)
 */
import { Command } from '../../Command.js';
import { extractQuotedText } from '../../parser/parser.js';

export class AnnouncementCommand extends Command {
  constructor() {
    super();
    this.name = 'announcement';
    this.aliases = ['ann'];
    this.description = 'Set a system-wide announcement (admin only)';
    this.usage = 'announcement "Your announcement text here"';
    this.category = 'Admin';
    this.args = [
      {
        name: 'text',
        description: 'The announcement text (must be in quotes)',
        required: true
      }
    ];
  }

  async execute(args, context) {
    // Check if user is admin
    if (!context.user?.is_admin) {
      return 'Access denied: Admin privileges required';
    }

    // Check if updateAnnouncement function is available
    if (!context || typeof context.updateAnnouncement !== 'function') {
      return 'Cannot set announcement: Missing updateAnnouncement function in context';
    }
    
    // Extract the quoted text from the original command
    const extractedText = extractQuotedText(context.original || args.join(' '));
    
    if (!extractedText) {
      return 'Usage: announcement "Your announcement text here" (text must be in quotes)';
    }
    
    const announcementText = extractedText.quoted;
    
    // Display setting message
    const settingMessage = `Setting announcement: "${announcementText}"...`;
    
    try {
      // Update the announcement via the context function
      const success = await context.updateAnnouncement(announcementText);
      
      if (success) {
        return [
          settingMessage,
          `Announcement set: "${announcementText}"`,
          'Announcement has been broadcast to all connected users.'
        ].join('\n');
      } else {
        return [
          settingMessage,
          'Failed to set announcement. Please try again.'
        ].join('\n');
      }
    } catch (error) {
      console.error('Error setting announcement:', error);
      return [
        settingMessage,
        'Error setting announcement. Please try again.'
      ].join('\n');
    }
  }
}

================
File: src/utils/terminal/commands/admin/DebugCommand.js
================
/**
 * Debug Command
 * Toggles debug mode (admin only)
 */
import { Command } from '../../Command.js';

export class DebugCommand extends Command {
  constructor() {
    super();
    this.name = 'debug';
    this.aliases = ['dbg'];
    this.description = 'Toggle debug mode - (admin only)';
    this.usage = 'debug';
    this.category = 'Admin';
    this.args = [];
  }

  async execute(args, context) {
    // Check if user is admin
    if (!context.user?.is_admin) {
      return 'Access denied: Admin privileges required';
    }

    // Check if DebugLogger is available
    if (!context || !context.debugLogger) {
      return 'Cannot toggle debug mode: Missing debug logger in context';
    }
    
    // Toggle debug mode
    const debugEnabled = context.debugLogger.toggleDebug();
    
    // Return appropriate message
    return debugEnabled 
      ? 'Debug mode enabled. Console logs are now visible.' 
      : 'Debug mode disabled. Console logs are now hidden.';
  }
}

================
File: src/utils/terminal/commands/core/ClearCommand.js
================
/**
 * Clear Command
 * Clears the terminal output
 */
import { Command } from '../../Command.js';

export class ClearCommand extends Command {
  constructor() {
    super();
    this.name = 'clear';
    this.aliases = ['cl'];
    this.description = 'Clear terminal output';
    this.usage = 'clear';
    this.category = 'Core';
    this.args = [];
  }

  async execute(args, context) {
    // Return an empty string which the terminal component will interpret as clearing the terminal
    // The terminal component will replace the history array with an empty array
    return '__CLEAR_TERMINAL__'; // Special flag that will be processed by the terminal
  }
}

================
File: src/utils/terminal/commands/core/HelpCommand.js
================
/**
 * Help Command
 * Provides help information for available commands
 */
import { Command } from '../../Command.js';
import { generateHelp } from '../../executor.js';

export class HelpCommand extends Command {
  constructor() {
    super();
    this.name = 'help';
    this.aliases = ['h'];
    this.description = 'Show help for available commands';
    this.usage = 'help [command]';
    this.category = 'Core';
    this.args = [
      {
        name: 'command',
        description: 'Command name to get help for',
        required: false
      }
    ];
  }

  async execute(args, context) {
    // If a specific command is requested, show help for that command
    if (args && args.length > 0) {
      return generateHelp(args[0]);
    }
    
    // Otherwise, show general help
    return generateHelp();
  }
}

================
File: src/utils/terminal/commands/core/VersionCommand.js
================
/**
 * Version Command
 * Displays the terminal version information
 */
import { Command } from '../../Command.js';

export class VersionCommand extends Command {
  constructor() {
    super();
    this.name = 'version';
    this.aliases = ['v'];
    this.description = 'Show terminal version information';
    this.usage = 'version';
    this.category = 'Core';
    this.args = [];
  }

  async execute(args, context) {
    return 'SLUMNET Terminal v1.0.0';
  }
}

================
File: src/utils/terminal/commands/vtt/LegacyPartyCommands.js
================
/**
 * Legacy Party Commands
 * Provides backward compatibility for old party command syntax
 */
import { Command } from '../../Command.js';

// Base class for legacy party commands
class LegacyPartyCommand extends Command {
  constructor(options) {
    super();
    Object.assign(this, options);
    this.category = 'Legacy';
  }

  // Redirect to the main party command
  async execute(args, context) {
    // Check if executeCommand is available in context
    if (!context || typeof context.executeCommand !== 'function') {
      return `Cannot execute ${this.name}: Missing executeCommand function in context`;
    }
    
    // Build the redirected command
    const redirectCommand = `party ${this.redirectSubcommand} ${args.join(' ')}`;
    
    // Execute the redirected command
    return context.executeCommand(redirectCommand);
  }
}

// Create Party Command (legacy)
export class CreatePartyCommand extends LegacyPartyCommand {
  constructor() {
    super({
      name: 'create-party',
      aliases: ['cp'],
      description: 'Create a new party (admin only) [Legacy Command]',
      usage: 'create-party "Party Name"',
      redirectSubcommand: 'create',
      args: [
        {
          name: 'party_name',
          description: 'Name of the party to create',
          required: true
        }
      ]
    });
  }
}

// Join Party Command (legacy)
export class JoinPartyCommand extends LegacyPartyCommand {
  constructor() {
    super({
      name: 'join-party',
      aliases: ['jp'],
      description: 'Join an existing party [Legacy Command]',
      usage: 'join-party <party_id or party_name>',
      redirectSubcommand: 'join',
      args: [
        {
          name: 'party_identifier',
          description: 'ID or name of the party to join',
          required: true
        }
      ]
    });
  }
}

// Leave Party Command (legacy)
export class LeavePartyCommand extends LegacyPartyCommand {
  constructor() {
    super({
      name: 'leave-party',
      aliases: ['lp'],
      description: 'Leave your current party [Legacy Command]',
      usage: 'leave-party',
      redirectSubcommand: 'leave',
      args: []
    });
  }
}

// Parties Command (legacy)
export class PartiesCommand extends LegacyPartyCommand {
  constructor() {
    super({
      name: 'parties',
      aliases: [],
      description: 'Show party information or list parties [Legacy Command]',
      usage: 'parties [list]',
      redirectSubcommand: '', // Will be determined in execute
      args: [
        {
          name: 'subcommand',
          description: 'Optional "list" to show all parties',
          required: false
        }
      ]
    });
  }
  
  // Override execute to handle the list subcommand
  async execute(args, context) {
    if (!context || typeof context.executeCommand !== 'function') {
      return `Cannot execute ${this.name}: Missing executeCommand function in context`;
    }
    
    // If first arg is "list", redirect to party list, otherwise to party info
    const redirectSubcommand = args.length > 0 && args[0].toLowerCase() === 'list' 
      ? 'list' 
      : '';
      
    // Build the redirected command
    const redirectCommand = `party ${redirectSubcommand}`;
    
    // Execute the redirected command
    return context.executeCommand(redirectCommand);
  }
}

================
File: src/utils/terminal/commands/vtt/PartyCommand.js
================
/**
 * Party Command
 * Manages D&D party functionality with subcommands
 */
import { Command } from '../../Command.js';
import { extractQuotedText } from '../../parser/parser.js';

export class PartyCommand extends Command {
  constructor() {
    super();
    this.name = 'party';
    this.aliases = ['p'];
    this.description = 'Party system commands';
    this.usage = 'party [subcommand] [arguments]';
    this.category = 'VTT';
    this.args = [
      {
        name: 'subcommand',
        description: 'Subcommand to execute (create, join, leave, list, info, delete)',
        required: false
      }
    ];
    
    // Available subcommands
    this.subcommands = {
      create: this.createParty,
      join: this.joinParty,
      leave: this.leaveParty,
      list: this.listParties,
      info: this.partyInfo,
      delete: this.deleteParty
    };
  }

  async execute(args, context) {
    // If no subcommand is provided, default to 'info'
    const subcommand = args[0]?.toLowerCase() || 'info';
    
    // Check if the subcommand exists
    if (!Object.keys(this.subcommands).includes(subcommand)) {
      return 'Unknown party subcommand. Available subcommands: create, join, leave, list, info, delete';
    }
    
    // Execute the appropriate subcommand
    return this.subcommands[subcommand].call(this, args.slice(1), context);
  }

  /* Subcommand handlers */

  async createParty(args, context) {
    // Check if user is admin
    if (!context.user?.is_admin) {
      return 'Access denied: Admin privileges required';
    }
    
    // Check party context availability
    if (!context.createParty) {
      return 'Cannot create party: Missing party context';
    }
    
    // Extract party name from quotes or just take the remaining arguments
    let partyName;
    const extractedText = extractQuotedText(args.join(' '));
    
    if (extractedText) {
      partyName = extractedText.quoted;
    } else {
      partyName = args.join(' ');
    }
    
    if (!partyName) {
      return 'Usage: party create "Party Name"';
    }
    
    const creatingMessage = `Creating party "${partyName}"...`;
    
    try {
      const result = await context.createParty(partyName);
      return `${creatingMessage}\nParty "${partyName}" created successfully with ID ${result.id}`;
    } catch (error) {
      if (error.response?.status === 400) {
        return `${creatingMessage}\nError: ${error.response.data.message}`;
      } else {
        console.error('Error creating party:', error);
        return `${creatingMessage}\nError creating party. Please try again.`;
      }
    }
  }

  async joinParty(args, context) {
    // Check party context availability
    if (!context.joinParty || !context.parties) {
      return 'Cannot join party: Missing party context';
    }
    
    if (args.length === 0) {
      return 'Usage: party join <party_id or party_name>';
    }
    
    const partyIdentifier = args.join(' ');
    const joiningMessage = `Joining party "${partyIdentifier}"...`;
    
    try {
      // Try to get the party by ID first
      let partyId = parseInt(partyIdentifier);
      
      if (isNaN(partyId)) {
        // If it's not a number, assume it's a name
        // Find the party by name
        const party = context.parties.find(p => 
          p.name.toLowerCase() === partyIdentifier.toLowerCase()
        );
        
        if (!party) {
          return `${joiningMessage}\nParty "${partyIdentifier}" not found`;
        }
        
        partyId = party.id;
      }
      
      // Try to join the party
      const joinResponse = await context.joinParty(partyId);
      
      if (joinResponse.message?.includes('Already a member')) {
        return `${joiningMessage}\nYou are already a member of this party`;
      } else {
        return `${joiningMessage}\nJoined party "${joinResponse.party.name}" successfully`;
      }
    } catch (error) {
      console.error('Error joining party:', error);
      if (error.response?.status === 404) {
        return `${joiningMessage}\nParty not found`;
      } else {
        return `${joiningMessage}\nError joining party. Please try again.`;
      }
    }
  }

  async leaveParty(args, context) {
    // Check party context availability
    if (!context.leaveParty || !context.currentParty) {
      return 'Cannot leave party: Missing party context';
    }
    
    const leavingMessage = 'Leaving current party...';
    
    try {
      if (!context.currentParty) {
        return `${leavingMessage}\nYou are not currently in a party`;
      }
      
      // Leave the party
      await context.leaveParty();
      return `${leavingMessage}\nLeft party "${context.currentParty.name}" successfully`;
    } catch (error) {
      console.error('Error leaving party:', error);
      return `${leavingMessage}\nError leaving party. Please try again.`;
    }
  }

  async listParties(args, context) {
    // Check party context availability
    if (!context.refreshParties || !context.parties) {
      return 'Cannot list parties: Missing party context';
    }
    
    const fetchingMessage = 'Fetching parties...';
    
    try {
      await context.refreshParties();
      if (context.parties.length === 0) {
        return `${fetchingMessage}\nNo parties available`;
      } else {
        return [
          fetchingMessage,
          'Available parties:',
          ...context.parties.map(party => 
            `ID: ${party.id} | Name: ${party.name} | Members: ${party.member_count} | Created by: ${party.creator_name}`
          )
        ].join('\n');
      }
    } catch (error) {
      console.error('Error fetching parties:', error);
      return `${fetchingMessage}\nError fetching parties. Please try again.`;
    }
  }

  async partyInfo(args, context) {
    // Check party context availability
    if (!context.refreshParty || !context.currentParty) {
      return 'Cannot show party info: Missing party context';
    }
    
    const fetchingMessage = 'Fetching current party...';
    
    try {
      await context.refreshParty();
      
      if (!context.currentParty) {
        return `${fetchingMessage}\nYou are not currently in a party. Use "party list" to see available parties or "party join <id>" to join one.`;
      } else {
        return [
          fetchingMessage,
          `Current party: ${context.currentParty.name} (ID: ${context.currentParty.id})`,
          `Created by: ${context.currentParty.creator_name}`,
          `Created at: ${new Date(context.currentParty.created_at).toLocaleString()}`,
          `Members (${context.currentParty.members?.length || 0}):`,
          ...(context.currentParty.members || []).map(member => 
            `- ${member.username}${member.is_admin ? ' (Admin)' : ''}${member.id === context.currentParty.creator_id ? ' (Creator)' : ''}`
          )
        ].join('\n');
      }
    } catch (error) {
      console.error('Error fetching current party:', error);
      return `${fetchingMessage}\nError fetching current party. Please try again.`;
    }
  }

  async deleteParty(args, context) {
    // Check if user is admin
    if (!context.user?.is_admin) {
      return 'Access denied: Admin privileges required';
    }
    
    // Check party context availability
    if (!context.deleteParty) {
      return 'Cannot delete party: Missing party context';
    }
    
    if (args.length === 0) {
      return 'Usage: party delete <party_id>';
    }
    
    const partyIdToDelete = parseInt(args[0]);
    if (isNaN(partyIdToDelete)) {
      return 'Invalid party ID. Please provide a valid numeric ID.';
    }
    
    const deletingMessage = `Deleting party with ID ${partyIdToDelete}...`;
    
    try {
      const result = await context.deleteParty(partyIdToDelete);
      if (result.success) {
        return `${deletingMessage}\nParty with ID ${partyIdToDelete} has been deleted successfully.`;
      } else {
        return `${deletingMessage}\nFailed to delete party: ${result.message || 'Unknown error'}`;
      }
    } catch (error) {
      console.error('Error deleting party:', error);
      return `${deletingMessage}\nError deleting party. Please try again.`;
    }
  }
}

================
File: src/utils/terminal/commands/vtt/RollCommand.js
================
/**
 * Roll Command
 * Rolls dice with specified parameters
 */
import { Command } from '../../Command.js';

export class RollCommand extends Command {
  constructor() {
    super();
    this.name = 'roll';
    this.aliases = ['r', 'd'];
    this.description = 'Roll dice (e.g., roll 2d6+3)';
    this.usage = 'roll <dice expression>';
    this.category = 'VTT';
    this.args = [
      {
        name: 'expression',
        description: 'Dice expression (e.g., 2d6+3)',
        required: true
      }
    ];
  }

  async execute(args, context) {
    // Check if the dice utilities are available
    if (!context.parseDiceExpression || !context.rollDice || !context.formatRollResult || !context.isValidDiceType) {
      return 'Cannot roll dice: Missing dice utilities in context';
    }
    
    // Get the dice expression
    const diceExpression = args.join('').trim();
    
    if (!diceExpression) {
      return 'Usage: roll <dice expression> (e.g., roll 2d6+3)';
    }
    
    // Parse the dice expression
    const parsedDice = context.parseDiceExpression(diceExpression);
    
    if (!parsedDice) {
      return 'Invalid dice expression. Use format: NdS+M (e.g., 2d6+3)';
    }
    
    const { numDice, diceType, modifier } = parsedDice;
    
    // Validate dice type
    if (!context.isValidDiceType(diceType)) {
      return 'Invalid dice type. Please use dice with 2-100 sides (e.g., d2, d6, d20, d37, d100)';
    }
    
    // Validate number of dice
    if (numDice < 1 || numDice > 20) {
      return 'Please use between 1 and 20 dice';
    }
    
    // Roll the dice
    const result = context.rollDice(diceType, numDice, modifier);
    
    // Format the results with a special marker to display the d20 GIF
    return {
      type: 'dice-roll',
      content: context.formatRollResult(result)
    };
  }
}

================
File: src/utils/terminal/commands/window/ChatCommand.js
================
/**
 * Chat Command
 * Transform window to Chat type
 */
import { Command } from '../../Command.js';
import { WINDOW_TYPES } from '../../../windowTypes.js';

export class ChatCommand extends Command {
  constructor() {
    super();
    this.name = 'chat';
    this.aliases = ['ch'];
    this.description = 'Transform window into chat window';
    this.usage = 'chat';
    this.category = 'Window';
    this.args = [];
  }

  async execute(args, context) {
    // Check if the transform function is provided in the context
    if (!context || typeof context.transformWindow !== 'function') {
      return 'Cannot transform window: Missing transform function in context';
    }
    
    // Check if the node ID is provided in the context
    if (!context.nodeId) {
      return 'Cannot transform window: Missing node ID in context';
    }
    
    // Transform the window
    context.transformWindow(context.nodeId, WINDOW_TYPES.CHAT);
    
    // This will be displayed only momentarily before the window transforms
    return 'Transforming to chat window...';
  }
}

================
File: src/utils/terminal/commands/window/ExplorerCommand.js
================
/**
 * Explorer Command
 * Transform window to Explorer type
 */
import { Command } from '../../Command.js';
import { WINDOW_TYPES } from '../../../windowTypes.js';

export class ExplorerCommand extends Command {
  constructor() {
    super();
    this.name = 'explorer';
    this.aliases = ['ex'];
    this.description = 'Transform window into file explorer';
    this.usage = 'explorer';
    this.category = 'Window';
    this.args = [];
  }

  async execute(args, context) {
    // Check if the transform function is provided in the context
    if (!context || typeof context.transformWindow !== 'function') {
      return 'Cannot transform window: Missing transform function in context';
    }
    
    // Check if the node ID is provided in the context
    if (!context.nodeId) {
      return 'Cannot transform window: Missing node ID in context';
    }
    
    // Transform the window
    context.transformWindow(context.nodeId, WINDOW_TYPES.EXPLORER);
    
    // This will be displayed only momentarily before the window transforms
    return 'Transforming to explorer window...';
  }
}

================
File: src/utils/terminal/commands/window/TerminalCommand.js
================
/**
 * Terminal Command
 * Transform window to Terminal type
 */
import { Command } from '../../Command.js';
import { WINDOW_TYPES } from '../../../windowTypes.js';

export class TerminalCommand extends Command {
  constructor() {
    super();
    this.name = 'terminal';
    this.aliases = ['term'];
    this.description = 'Transform window into terminal';
    this.usage = 'terminal';
    this.category = 'Window';
    this.args = [];
  }

  async execute(args, context) {
    // Check if the transform function is provided in the context
    if (!context || typeof context.transformWindow !== 'function') {
      return 'Cannot transform window: Missing transform function in context';
    }
    
    // Check if the node ID is provided in the context
    if (!context.nodeId) {
      return 'Cannot transform window: Missing node ID in context';
    }
    
    // Transform the window
    context.transformWindow(context.nodeId, WINDOW_TYPES.TERMINAL);
    
    // This will be displayed only momentarily before the window transforms
    return 'Transforming to terminal window...';
  }
}

================
File: src/utils/terminal/commands/window/WindowCommand.js
================
/**
 * Window Command
 * Handles transforming the current window to a different window type
 */
import { Command } from '../../Command.js';
import { WINDOW_TYPES } from '../../../windowTypes.js';

export class WindowCommand extends Command {
  constructor() {
    super();
    this.name = 'window';
    this.aliases = ['win'];
    this.description = 'Transform window to a specified window type';
    this.usage = 'window <type>';
    this.category = 'Window';
    this.args = [
      {
        name: 'type',
        description: 'Window type to transform to',
        required: true
      }
    ];
    
    // Valid window types that can be used with this command
    this.validTypes = Object.values(WINDOW_TYPES);
  }

  async execute(args, context) {
    if (!args || args.length === 0) {
      return this.listWindowTypes();
    }
    
    const requestedType = args[0].toUpperCase();
    
    // Check if the requested type is a valid window type
    if (!WINDOW_TYPES[requestedType] && !Object.values(WINDOW_TYPES).includes(requestedType)) {
      return `Unknown window type: ${args[0]}. Use one of: ${Object.keys(WINDOW_TYPES).map(t => t.toLowerCase()).join(', ')}`;
    }
    
    // Get the normalized window type
    const windowType = WINDOW_TYPES[requestedType] || requestedType;
    
    // Check if the transform function is provided in the context
    if (!context || typeof context.transformWindow !== 'function') {
      return 'Cannot transform window: Missing transform function in context';
    }
    
    // Check if the node ID is provided in the context
    if (!context.nodeId) {
      return 'Cannot transform window: Missing node ID in context';
    }
    
    // Transform the window
    context.transformWindow(context.nodeId, windowType);
    
    // This will be displayed only momentarily before the window transforms
    return `Transforming to ${windowType.toLowerCase()} window...`;
  }
  
  // Generate a list of available window types
  listWindowTypes() {
    return [
      'Available window types:',
      ...Object.keys(WINDOW_TYPES).map(type => `  ${type.toLowerCase()}`),
      '',
      'Usage: window <type>'
    ].join('\n');
  }
}

================
File: src/utils/terminal/executor.js
================
/**
 * Command Executor
 * Handles execution of parsed terminal commands
 */
import { registry } from './registry.js';
import { parse, validateArgs } from './parser/parser.js';

/**
 * Executes a command string with the provided terminal context
 * 
 * @param {string} commandString - Raw command string to execute
 * @param {Object} context - Terminal execution context
 * @returns {Promise<string|Array<string>>} - Command execution result
 */
export async function executeCommand(commandString, context) {
  if (!commandString || typeof commandString !== 'string') {
    return 'No command specified';
  }
  
  try {
    // Parse the command string
    const parsedCommand = parse(commandString);
    
    // Handle parsing errors
    if (parsedCommand.error) {
      return `Command parsing error: ${parsedCommand.error}`;
    }
    
    // Empty command
    if (!parsedCommand.command) {
      return '';
    }
    
    // Find the command in the registry
    const command = registry.findCommand(parsedCommand.command);
    
    // Command not found
    if (!command) {
      return `Unknown command: ${parsedCommand.command}`;
    }
    
    // Validate command arguments
    const validation = validateArgs(parsedCommand.args, command.args);
    if (!validation.valid) {
      return validation.error || `Invalid arguments for ${command.name}`;
    }
    
    // Execute the command
    const result = await command.execute(parsedCommand.args, context);
    return result;
  } catch (error) {
    console.error('Command execution error:', error);
    return `Error executing command: ${error.message}`;
  }
}

/**
 * Generate help text for all available commands or a specific command
 * 
 * @param {string} commandName - Optional command name to get help for
 * @returns {string} - Formatted help text
 */
export function generateHelp(commandName) {
  if (commandName) {
    const command = registry.findCommand(commandName);
    if (command) {
      return command.generateHelp();
    }
    return `Help not available: Unknown command "${commandName}"`;
  }
  
  // Generate help for all commands
  const allCommands = registry.getAllCommands();
  let helpText = 'Available commands:\n';
  
  // Group commands by category for better organization
  const categories = {};
  
  allCommands.forEach(cmd => {
    const category = cmd.category || 'General';
    if (!categories[category]) {
      categories[category] = [];
    }
    categories[category].push(cmd);
  });
  
  // Build the help text by category
  Object.keys(categories).sort().forEach(category => {
    helpText += `\n${category}:\n`;
    categories[category].sort((a, b) => a.name.localeCompare(b.name)).forEach(cmd => {
      helpText += `  ${cmd.name.padEnd(12)} - ${cmd.description}\n`;
    });
  });
  
  helpText += '\nType "help <command>" for more information on a specific command.';
  return helpText;
}

================
File: src/utils/terminal/parser/parser.js
================
/**
 * Terminal command parser
 * Parses and processes command input through multiple stages
 */
import { tokenize, parseCommand } from './tokenizer.js';

/**
 * Represents a parsed command with structured information
 */
export class ParsedCommand {
  constructor(input) {
    this.original = input || '';
    this.tokens = [];
    this.command = '';
    this.args = [];
    this.error = null;
  }
}

/**
 * Parse a command string into a structured ParsedCommand object
 * 
 * @param {string} input - Raw command input string
 * @returns {ParsedCommand} - Parsed command object
 */
export function parse(input) {
  const result = new ParsedCommand(input);
  
  try {
    // Stage 1: Tokenize the input
    result.tokens = tokenize(input);
    
    // Stage 2: Structure the tokens into command and args
    const parsed = parseCommand(result.tokens);
    result.command = parsed.command;
    result.args = parsed.args;
    
    // Stage 3: Variable expansion (if needed in the future)
    // This could expand environment variables, etc.
    // Currently a placeholder for future expansion
    
    // Stage 4: Path expansion (if needed in the future)
    // This could handle glob patterns or ~ expansion
    // Currently a placeholder for future expansion
  } catch (error) {
    result.error = error.message;
  }
  
  return result;
}

/**
 * Validates a command's arguments against its requirements
 * 
 * @param {Array} args - The command arguments
 * @param {Array} argDefs - The command's argument definitions
 * @returns {Object} - Validation result { valid, error }
 */
export function validateArgs(args, argDefs) {
  if (!argDefs || !argDefs.length) {
    return { valid: true };
  }
  
  // Check for required arguments
  const requiredArgs = argDefs.filter(arg => arg.required);
  
  if (args.length < requiredArgs.length) {
    const missingArgs = requiredArgs
      .slice(args.length)
      .map(arg => arg.name)
      .join(', ');
      
    return {
      valid: false,
      error: `Missing required argument(s): ${missingArgs}`
    };
  }
  
  // More advanced validation could be added here
  // such as type checking or value validation
  
  return { valid: true };
}

/**
 * Process quoted arguments in a special way (extract from quotes)
 * This is useful for commands that expect quoted text like announcement
 * 
 * @param {string} input - Original command input
 * @returns {Object|null} - Extracted quoted content or null if no quotes found
 */
export function extractQuotedText(input) {
  if (!input) return null;
  
  // Match text in quotes (single, double, or backticks)
  const match = input.match(/"([^"]*)"|'([^']*)'|`([^`]*)`/);
  if (!match) return null;
  
  // Return the matched quoted text (from whichever quote type was found)
  return {
    quoted: match[1] || match[2] || match[3],
    fullMatch: match[0]
  };
}

================
File: src/utils/terminal/parser/tokenizer.js
================
/**
 * Tokenizer for terminal command input
 * Breaks input into tokens while respecting quoted strings
 */

/**
 * Tokenize a command string into an array of tokens
 * Supports quotes (single, double, and backticks) for grouping arguments
 * 
 * @param {string} input - Raw command input string
 * @returns {Array<string>} - Array of tokens
 */
export function tokenize(input) {
  if (!input || typeof input !== 'string') {
    return [];
  }

  const tokens = [];
  let currentToken = '';
  let inQuote = false;
  let quoteChar = '';
  
  // Iterate through each character in the input
  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    const nextChar = input[i + 1];
    
    // Handle quotes (single, double, or backtick)
    if ((char === '"' || char === "'" || char === '`') && 
        (!inQuote || char === quoteChar)) {
      if (inQuote) {
        // End of quoted string
        inQuote = false;
        
        // Add the complete token to our tokens list
        if (currentToken) {
          tokens.push(currentToken);
          currentToken = '';
        }
      } else {
        // Start of quoted string
        inQuote = true;
        quoteChar = char;
        
        // If we have accumulated a token before this quote, add it
        if (currentToken) {
          tokens.push(currentToken);
          currentToken = '';
        }
      }
    }
    // Handle spaces (token separators) when not in a quoted string
    else if (char === ' ' && !inQuote) {
      // Space outside quotes marks the end of a token
      if (currentToken) {
        tokens.push(currentToken);
        currentToken = '';
      }
    }
    // Handle escaped characters
    else if (char === '\\' && (nextChar === '"' || nextChar === "'" || nextChar === '`' || nextChar === '\\')) {
      // Skip the backslash and add the escaped character
      currentToken += nextChar;
      i++; // Skip the next character since we've already processed it
    }
    // Any other character gets added to the current token
    else {
      currentToken += char;
    }
  }
  
  // Add the last token if there is one
  if (currentToken) {
    tokens.push(currentToken);
  }
  
  return tokens;
}

/**
 * Parse a tokenized command into a structured command object
 * 
 * @param {Array<string>} tokens - Tokenized command array
 * @returns {Object} - Structured command object { command, args }
 */
export function parseCommand(tokens) {
  if (!tokens || !tokens.length) {
    return { command: '', args: [] };
  }
  
  // First token is the command, rest are args
  const command = tokens[0].toLowerCase();
  const args = tokens.slice(1);
  
  return { command, args };
}

================
File: src/utils/terminal/registry.js
================
/**
 * Command Registry
 * Manages the registration and lookup of terminal commands
 */
import { COMMAND_ALIASES } from '../commandAliases.js';

/**
 * Registry of all available terminal commands
 */
class CommandRegistry {
  constructor() {
    this.commands = new Map();
    this.aliases = new Map();
  }

  /**
   * Register a command with the registry
   * @param {Command} commandInstance - Instance of a Command class
   */
  register(commandInstance) {
    if (!commandInstance || !commandInstance.name) {
      console.error('Cannot register command: Invalid command instance');
      return;
    }

    // Register the main command name
    this.commands.set(commandInstance.name.toLowerCase(), commandInstance);
    
    // Register command aliases
    if (commandInstance.aliases && Array.isArray(commandInstance.aliases)) {
      commandInstance.aliases.forEach(alias => {
        this.aliases.set(alias.toLowerCase(), commandInstance.name.toLowerCase());
      });
    }
  }

  /**
   * Register multiple commands with the registry
   * @param {Array<Command>} commandInstances - Array of Command instances
   */
  registerAll(commandInstances) {
    if (!Array.isArray(commandInstances)) {
      console.error('Cannot register commands: Expected an array of commands');
      return;
    }

    commandInstances.forEach(command => this.register(command));
  }

  /**
   * Find a command by name or alias
   * @param {string} name - Command name or alias
   * @returns {Command|null} - Command instance or null if not found
   */
  findCommand(name) {
    if (!name) return null;
    
    const normalizedName = name.toLowerCase();
    
    // Check if it's a direct command name
    if (this.commands.has(normalizedName)) {
      return this.commands.get(normalizedName);
    }
    
    // Check if it's an alias
    if (this.aliases.has(normalizedName)) {
      const commandName = this.aliases.get(normalizedName);
      return this.commands.get(commandName);
    }
    
    // Check if it's in the legacy COMMAND_ALIASES from commandAliases.js
    if (COMMAND_ALIASES[normalizedName]) {
      const aliasTarget = COMMAND_ALIASES[normalizedName].toLowerCase();
      
      // The alias might point to another command or another alias
      return this.findCommand(aliasTarget);
    }
    
    return null;
  }

  /**
   * Get all registered commands
   * @returns {Array<Command>} - Array of all command instances
   */
  getAllCommands() {
    return Array.from(this.commands.values());
  }
}

// Create and export a singleton instance
export const registry = new CommandRegistry();

// Export the class for testing or specialized use cases
export default CommandRegistry;

================
File: src/utils/treeUtils.js
================
import { Node } from '../models/Node';

/**
 * Splits a window by ID, ensuring only the target window is affected
 * @param {Node} node - Current node in the tree
 * @param {string} targetId - ID of the window to split
 * @param {string} direction - Split direction ('vertical' or 'horizontal')
 * @param {Node} newWindow - New window to insert
 * @returns {Node} Updated tree structure
 */
export const findFirstWindowId = (node) => {
  if (!node) return null;
  if (node.type === 'window') return node.id;
  return findFirstWindowId(node.first) || findFirstWindowId(node.second);
};

/**
 * Creates a new split by ID, inserting a new window at the specified location
 */
export const splitNodeById = (node, targetId, direction, newWindow) => {
    if (!node) return null;
  
    // If this is the node we want to split
    if (node.id === targetId && node.type === 'window') {
      // Create a new split with the current window and new window
      return Node.createSplit(direction, node, newWindow);
    }
  
    // If this is a split node, recursively check its children
    if (node.type === 'split') {
      // Check if target is in first child
      if (findNodeById(node.first, targetId)) {
        return {
          ...node,
          first: splitNodeById(node.first, targetId, direction, newWindow)
        };
      }
      
      // Check if target is in second child
      if (findNodeById(node.second, targetId)) {
        return {
          ...node,
          second: splitNodeById(node.second, targetId, direction, newWindow)
        };
      }
    }
  
    // If we haven't found the target node, return the original node unchanged
    return node;
  };

export const removeNodeById = (node, targetId) => {
  if (!node) return null;

  if (node.type === 'split') {
    // Only remove if the child is a window node with matching ID
    if (node.first.type === 'window' && node.first.id === targetId) {
      return node.second;
    }
    if (node.second.type === 'window' && node.second.id === targetId) {
      return node.first;
    }

    const firstResult = removeNodeById(node.first, targetId);
    if (firstResult !== node.first) {
      node.first = firstResult;
      return node;
    }

    const secondResult = removeNodeById(node.second, targetId);
    if (secondResult !== node.second) {
      node.second = secondResult;
      return node;
    }
  }

  return node;
};

export const findNodeById = (node, targetId) => {
  if (!node) return null;
  
  if (node.id === targetId && node.type === 'window') return node;
  
  if (node.type === 'split') {
    const firstResult = findNodeById(node.first, targetId);
    if (firstResult) return firstResult;
    
    const secondResult = findNodeById(node.second, targetId);
    if (secondResult) return secondResult;
  }
  
  return null;
};

export const findAllWindowIds = (node) => {
  if (!node) return [];
  if (node.type === 'window') return [node.id];
  return [...findAllWindowIds(node.first), ...findAllWindowIds(node.second)];
};

export const updateSplitRatio = (node, splitId, newRatio) => {
  if (!node) return;

  if (node.type === 'split' && node.id === splitId) {
    node.splitRatio = Math.max(0.2, Math.min(0.8, newRatio));
    return;
  }

  if (node.type === 'split') {
    updateSplitRatio(node.first, splitId, newRatio);
    updateSplitRatio(node.second, splitId, newRatio);
  }
};

/**
 * Finds the sibling window ID of a given window ID
 * Used to determine which window should be active after closing a window
 * @param {Node} node - Current node in the tree
 * @param {string} targetId - ID of the window to find the sibling of
 * @returns {string|null} ID of the sibling window, or null if not found
 */
export const findSiblingWindowId = (node, targetId) => {
  if (!node) return null;
  
  if (node.type === 'split') {
    // Check if the target is a direct child of this split
    if (node.first.type === 'window' && node.first.id === targetId) {
      // Return the ID of the first window found in the second branch
      return node.second.type === 'window' 
        ? node.second.id 
        : findFirstWindowId(node.second);
    }
    if (node.second.type === 'window' && node.second.id === targetId) {
      // Return the ID of the first window found in the first branch
      return node.first.type === 'window' 
        ? node.first.id 
        : findFirstWindowId(node.first);
    }
    
    // Otherwise, recursively check both branches
    const firstResult = findSiblingWindowId(node.first, targetId);
    if (firstResult) return firstResult;
    
    return findSiblingWindowId(node.second, targetId);
  }
  
  return null;
};

================
File: src/utils/windowSizeConstants.js
================
/**
 * Constants for window size constraints
 * These values define the minimum sizes for windows to ensure they remain usable
 */

// Minimum window dimensions in percentage of screen size
export const MIN_WINDOW_WIDTH_PERCENT = 30; // 30% of screen width
export const MIN_WINDOW_HEIGHT_PERCENT = 30; // 30% of screen height

// Minimum window dimensions in pixels (used for absolute size checks)
export const MIN_WINDOW_WIDTH_PX = 300; // 300px minimum width
export const MIN_WINDOW_HEIGHT_PX = 200; // 200px minimum height

// Maximum number of windows total (regardless of arrangement)
export const MAX_HORIZONTAL_WINDOWS = 4; // Maximum windows total
export const MAX_VERTICAL_WINDOWS = 4;   // Maximum windows total

================
File: src/utils/windowTypes.js
================
// src/utils/windowTypes.js
import { FolderOpen, Code, Terminal as TerminalIcon, Eye, MessageSquare, Shield, Layout, Dices } from 'lucide-react';
import { WINDOW_TYPES } from './constants';

// Import individually to avoid circular dependency
import { 
  EnhancedTerminalWindow,
  EnhancedExplorerWindow,
  EnhancedAudioWindow,
  EnhancedChatWindow,
  EnhancedAdminWindow
} from '../components/windows';

export { WINDOW_TYPES };

export const WINDOW_CONTENT = {
  [WINDOW_TYPES.EXPLORER]: {
    title: 'File Explorer',
    icon: FolderOpen,
    component: EnhancedExplorerWindow
  },
  [WINDOW_TYPES.TERMINAL]: {
    title: 'Terminal',
    icon: TerminalIcon,
    component: EnhancedTerminalWindow
  },
  [WINDOW_TYPES.CHAT]: {
    title: 'Chat',
    icon: MessageSquare,
    component: EnhancedChatWindow
  },
  [WINDOW_TYPES.ADMIN]: {
    title: 'Admin Panel',
    icon: Shield,
    component: EnhancedAdminWindow
  }
};

================
File: src/utils/windowUtils.js
================
/**
 * Contains utility functions for window-specific calculations and operations.
 * These functions focus on spatial relationships and window bounds rather than
 * tree structure manipulation.
 */

/**
 * Calculates the bounds of windows in the tree. Each window gets its position
 * and size as percentages of the available space.
 * 
 * @param {Node} node - The node to calculate bounds for
 * @param {Object} available - The available space in percentages
 * @returns {Array} Array of objects containing window IDs and their bounds
 */
export const getWindowBounds = (node, available = { x: 0, y: 0, width: 100, height: 100 }) => {
    if (node.type === 'window') {
      return [{
        id: node.id,
        bounds: {
          left: available.x,
          top: available.y,
          right: available.x + available.width,
          bottom: available.y + available.height,
          width: available.width,
          height: available.height,
          centerX: available.x + (available.width / 2),
          centerY: available.y + (available.height / 2)
        }
      }];
    }
  
    // For split nodes, recursively get bounds of children
    const bounds = [];
    
    if (node.direction === 'horizontal') {
      const firstHalf = {
        x: available.x,
        y: available.y,
        width: available.width * node.splitRatio,
        height: available.height
      };
      const secondHalf = {
        x: available.x + (available.width * node.splitRatio),
        y: available.y,
        width: available.width * (1 - node.splitRatio),
        height: available.height
      };
      bounds.push(...getWindowBounds(node.first, firstHalf));
      bounds.push(...getWindowBounds(node.second, secondHalf));
    } else {
      const firstHalf = {
        x: available.x,
        y: available.y,
        width: available.width,
        height: available.height * node.splitRatio
      };
      const secondHalf = {
        x: available.x,
        y: available.y + (available.height * node.splitRatio),
        width: available.width,
        height: available.height * (1 - node.splitRatio)
      };
      bounds.push(...getWindowBounds(node.first, firstHalf));
      bounds.push(...getWindowBounds(node.second, secondHalf));
    }
  
    return bounds;
  };
  
  /**
   * Determines if two windows are adjacent in a specific direction.
   * Uses a small tolerance value to account for floating-point calculations.
   * 
   * @param {Object} window1 - First window with bounds
   * @param {Object} window2 - Second window with bounds
   * @param {string} direction - Direction to check ('left', 'right', 'up', 'down')
   * @returns {boolean} Whether the windows are adjacent
   */
  export const areWindowsAdjacent = (window1, window2, direction) => {
    const tolerance = 0.01; // 1% tolerance for floating point comparisons
    
    switch (direction) {
      case 'left':
        return Math.abs(window1.bounds.left - window2.bounds.right) < tolerance &&
               !(window1.bounds.bottom < window2.bounds.top || window1.bounds.top > window2.bounds.bottom);
      case 'right':
        return Math.abs(window1.bounds.right - window2.bounds.left) < tolerance &&
               !(window1.bounds.bottom < window2.bounds.top || window1.bounds.top > window2.bounds.bottom);
      case 'up':
        return Math.abs(window1.bounds.top - window2.bounds.bottom) < tolerance &&
               !(window1.bounds.right < window2.bounds.left || window1.bounds.left > window2.bounds.right);
      case 'down':
        return Math.abs(window1.bounds.bottom - window2.bounds.top) < tolerance &&
               !(window1.bounds.right < window2.bounds.left || window1.bounds.left > window2.bounds.right);
      default:
        return false;
    }
  };
  
  /**
   * Finds the next window in a specified direction from the active window.
   * 
   * @param {Node} rootNode - The root node of the window tree
   * @param {string} activeNodeId - ID of the currently active window
   * @param {string} direction - Direction to look for the next window
   * @returns {string|null} ID of the next window, or null if none found
   */
  export const findNextWindow = (rootNode, activeNodeId, direction) => {
    const allWindows = getWindowBounds(rootNode);
    const activeWindow = allWindows.find(w => w.id === activeNodeId);
    if (!activeWindow) return null;
  
    const adjacentWindows = allWindows.filter(w => 
      w.id !== activeNodeId && areWindowsAdjacent(activeWindow, w, direction)
    );
  
    if (adjacentWindows.length === 0) return null;
  
    // Sort adjacent windows based on position and direction
    let nextWindow;
    switch (direction) {
      case 'left':
        nextWindow = adjacentWindows.sort((a, b) => 
          a.bounds.centerX !== b.bounds.centerX
            ? b.bounds.centerX - a.bounds.centerX
            : a.bounds.centerY - b.bounds.centerY
        )[0];
        break;
      case 'right':
        nextWindow = adjacentWindows.sort((a, b) => 
          a.bounds.centerX !== b.bounds.centerX
            ? a.bounds.centerX - b.bounds.centerX
            : a.bounds.centerY - b.bounds.centerY
        )[0];
        break;
      case 'up':
        nextWindow = adjacentWindows.sort((a, b) => 
          a.bounds.centerY !== b.bounds.centerY
            ? b.bounds.centerY - a.bounds.centerY
            : a.bounds.centerX - b.bounds.centerX
        )[0];
        break;
      case 'down':
        nextWindow = adjacentWindows.sort((a, b) => 
          a.bounds.centerY !== b.bounds.centerY
            ? a.bounds.centerY - b.bounds.centerY
            : a.bounds.centerX - b.bounds.centerX
        )[0];
        break;
    }
  
    return nextWindow?.id || null;
  };

================
File: vite.config.js
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import tailwindcss from '@tailwindcss/vite'
import { nodePolyfills } from 'vite-plugin-node-polyfills'


// This configuration sets up Vite with both React and Tailwind CSS support
export default defineConfig({
  // Configure dev server with proxy for API requests
  server: {
    proxy: {
      '/api': {
        target: 'http://45.45.239.125:3001',
        changeOrigin: true,
        secure: false,
        configure: (proxy, _options) => {
          proxy.on('error', (err, _req, _res) => {
            console.log('proxy error', err);
          });
          proxy.on('proxyReq', (proxyReq, req, _res) => {
            console.log('Sending Request:', req.method, req.url);
          });
          proxy.on('proxyRes', (proxyRes, req, _res) => {
            console.log('Received Response:', proxyRes.statusCode, req.url);
          });
        }
      }
    }
  },
  plugins: [
    // The React plugin enables JSX processing and Fast Refresh
    react(),
    // The Tailwind plugin handles utility class generation
    tailwindcss(),
    // Configure Node.js polyfills for SimplePeer
    nodePolyfills({
      // Whether to polyfill specific Node.js globals
      globals: {
        Buffer: true,
        global: true,
        process: true,
      },
      // Whether to polyfill Node.js builtins
      protocolImports: true,
    }),
  ],
  resolve: {
    extensions: ['.js', '.jsx', '.json'],
    alias: {
      // Provide Node.js polyfills for browser environment
      buffer: 'buffer'
    }
  },
  define: {
    // Define global variables for browser environment
    global: 'window',
    'process.env': {}
  },
  optimizeDeps: {
    // Include Node.js modules that need to be pre-bundled
    include: ['buffer', 'simple-peer']
  },
  build: {
    // Configure Rollup to handle Node.js modules
    rollupOptions: {
      output: {
        manualChunks: {
          'simple-peer': ['simple-peer']
        }
      }
    },
    // Enable content hashing in filenames for cache busting
    assetsDir: 'assets',
    sourcemap: true,
    manifest: true,
    // Use content hashing to force cache invalidation when files change
    chunkFileNames: 'assets/js/[name]-[hash].js',
    entryFileNames: 'assets/js/[name]-[hash].js',
    assetFileNames: 'assets/[ext]/[name]-[hash].[ext]'
  }
})



================================================================
End of Codebase
================================================================
